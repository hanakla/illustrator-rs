/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const kSPNoError: u32 = 0;
pub const kSPOutOfMemoryError: i32 = -108;
pub const kSPBlocksSuite: &[u8; 16] = b"SP Blocks Suite\0";
pub const kSPBlocksSuiteVersion: u32 = 2;
pub const kSPCachesSuite: &[u8; 16] = b"SP Caches Suite\0";
pub const kSPCachesSuiteVersion: u32 = 2;
pub const kSPCacheCaller: &[u8; 9] = b"SP Cache\0";
pub const kSPPluginPurgeCachesSelector: &[u8; 14] = b"Plug-in Purge\0";
pub const kSPPropertiesSuite: &[u8; 20] = b"SP Properties Suite\0";
pub const kSPPropertiesSuiteVersion2: u32 = 2;
pub const kSPPropertiesSuiteVersion: u32 = 2;
pub const kSPPropertiesSuiteVersion3: u32 = 3;
pub const kSPPropertiesCaller: &[u8; 14] = b"SP Properties\0";
pub const kSPPropertiesAcquireSelector: &[u8; 8] = b"Acquire\0";
pub const kSPPropertiesReleaseSelector: &[u8; 8] = b"Release\0";
pub const kSPAdaptersSuite: &[u8; 18] = b"SP Adapters Suite\0";
pub const kSPAdaptersSuiteVersion: u32 = 3;
pub const kSPAdaptersCaller: &[u8; 12] = b"SP Adapters\0";
pub const kSPAdaptersStartupSelector: &[u8; 9] = b"Start up\0";
pub const kSPAdaptersShutdownSelector: &[u8; 10] = b"Shut down\0";
pub const kSPAdaptersDisposeInfoSelector: &[u8; 13] = b"Dispose info\0";
pub const kSPAdaptersFlushSelector: &[u8; 6] = b"Flush\0";
pub const kSPAdaptersRegisterPluginsSelector: &[u8; 17] = b"Register plugins\0";
pub const kSPAdaptersLoadPluginSelector: &[u8; 12] = b"Load plugin\0";
pub const kSPAdaptersReleasePluginSelector: &[u8; 15] = b"Release plugin\0";
pub const kSPAdaptersSendMessageSelector: &[u8; 13] = b"Send message\0";
pub const kSPAdaptersFindPropertySelector: &[u8; 14] = b"Find property\0";
pub const kSPAdaptersAboutSelector: &[u8; 6] = b"About\0";
pub const kSPAdaptersAcquireSuiteHostSelector: &[u8; 14] = b"Acquire Suite\0";
pub const kSPAdaptersReleaseSuiteHostSelector: &[u8; 14] = b"Release Suite\0";
pub const kSPFilesSuite: &[u8; 15] = b"SP Files Suite\0";
pub const kSPFilesSuiteVersion3: u32 = 3;
pub const kSPFilesSuiteVersion: u32 = 4;
pub const kSPStringsSuite: &[u8; 17] = b"SP Strings Suite\0";
pub const kSPStringsSuiteVersion: u32 = 2;
pub const kSPPluginsSuite: &[u8; 18] = b"SP Plug-ins Suite\0";
pub const kSPPluginsSuiteVersion4: u32 = 4;
pub const kSPPluginsSuiteVersion5: u32 = 5;
pub const kSPPluginsSuiteVersion: u32 = 4;
pub const kSPAccessSuite: &[u8; 16] = b"SP Access Suite\0";
pub const kSPAccessSuiteVersion: u32 = 3;
pub const kSPAccessCaller: &[u8; 10] = b"SP Access\0";
pub const kSPAccessReloadSelector: &[u8; 7] = b"Reload\0";
pub const kSPAccessUnloadSelector: &[u8; 7] = b"Unload\0";
pub const kSPFlushAccessType: &[u8; 16] = b"SP Flush Access\0";
pub const kSPSuitesSuite: &[u8; 16] = b"SP Suites Suite\0";
pub const kSPSuitesSuiteVersion: u32 = 2;
pub const kSPLatestInternalVersion: u32 = 0;
pub const kAIAboutToLoadSuite: &[u8; 22] = b"About To Load SPSuite\0";
pub const kSPRuntimeSuite: &[u8; 17] = b"SP Runtime Suite\0";
pub const kSPRuntimeSuiteVersion6: u32 = 6;
pub const kSPRuntimeSuiteVersion: u32 = 6;
pub const kNoErr: u32 = 0;
pub const kAICharacterEncodingSuite: &[u8; 28] = b"AI Character Encoding Suite\0";
pub const kAIArtSuite: &[u8; 13] = b"AI Art Suite\0";
pub const kAIArtSelectionChangedNotifier: &[u8; 34] = b"AI Art Selection Changed Notifier\0";
pub const kAIDrawingModeChangedNotifier: &[u8; 33] = b"AI Drawing Mode Changed Notifier\0";
pub const kAIArtPropertiesChangedNotifier: &[u8; 35] = b"AI Art Properties Changed Notifier\0";
pub const kAIAlignmentKeyArtChangedNotifier: &[u8; 38] = b"AI Alignment Key Art Changed Notifier\0";
pub const kAIArtExpandedChangedNotifier: &[u8; 46] =
    b"AI Art Layers Palette Expand Changed Notifier\0";
pub const kAIArtObjectsChangedNotifier: &[u8; 32] = b"AI Art Objects Changed Notifier\0";
pub const kAILayerSuite: &[u8; 15] = b"AI Layer Suite\0";
pub const kAICurrentLayerNotifier: &[u8; 26] = b"AI Current Layer Notifier\0";
pub const kAILayerDeletionNotifier: &[u8; 27] = b"AI Layer Deletion Notifier\0";
pub const kAILayerSetNotifier: &[u8; 22] = b"AI Layer Set Notifier\0";
pub const kAILayerOptionsNotifier: &[u8; 26] = b"AI Layer Options Notifier\0";
pub const kAILayerArtStyleChangeNotifier: &[u8; 35] = b"AI Layer Art Style Change Notifier\0";
pub const kAIArtSetSuite: &[u8; 17] = b"AI Art Set Suite\0";
pub const kAICSXSExtensionSuite: &[u8; 24] = b"AI CSXS Extension Suite\0";
pub const kAICSXSExtensionUnloadNotifier: &[u8; 28] = b"Extension Unloaded Notifier\0";
pub const kAICSXSExtensionLoadNotifier: &[u8; 26] = b"Extension Loaded Notifier\0";
pub const kAICSXSPanelVisibilityChangeNotifier: &[u8; 44] =
    b"Extension Panel Visibility Changed Notifier\0";
pub const kAIRealMathSuite: &[u8; 19] = b"AI Real Math Suite\0";
pub const kAIFloatOne: f64 = 1.0;
pub const kAIFloatZero: f64 = 0.0;
pub const kAIPi: f64 = 3.141592653589793;
pub const kAIColorSuite: &[u8; 15] = b"AI Color Suite\0";
pub const kAIColorConversionSuite: &[u8; 26] = b"AI Color Conversion Suite\0";
pub const kAICustomColorSuite: &[u8; 22] = b"AI Custom Color Suite\0";
pub const kAIArtCustomColorChangedNotifier: &[u8; 37] = b"AI Art Custom Color Changed Notifier\0";
pub const kSPBasicSuite: &[u8; 15] = b"SP Basic Suite\0";
pub const kSPBasicSuiteVersion: u32 = 4;
pub const kSPInterfaceSuite: &[u8; 19] = b"SP Interface Suite\0";
pub const kSPInterfaceSuiteVersion: u32 = 2;
pub const kSPInterfaceCaller: &[u8; 13] = b"SP Interface\0";
pub const kSPInterfaceStartupSelector: &[u8; 8] = b"Startup\0";
pub const kSPInterfaceShutdownSelector: &[u8; 9] = b"Shutdown\0";
pub const kSPInterfaceAboutSelector: &[u8; 6] = b"About\0";
pub const kSPSweetPea2Adapter: &[u8; 20] = b"Sweet Pea 2 Adapter\0";
pub const kSPSweetPea2AdapterVersion: u32 = 1;
pub const kAIPluginSuite: &[u8; 16] = b"AI Plugin Suite\0";
pub const kAIAllPluginStartedNotifier: &[u8; 33] = b"AI All Plug-ins Started Notifier\0";
pub const kAIPluginStoppingNotifier: &[u8; 34] = b"AI All Plug-ins Stopping Notifier\0";
pub const kAIUnicodeStringSuite: &[u8; 24] = b"AI Unicode String Suite\0";
pub const kAIObjectSetSuite: &[u8; 19] = b"AI ObjectSet Suite\0";
pub const kAIObjectSetChangedNotifier: &[u8; 31] = b"AI Object Set Changed Notifier\0";
pub const kAIReplaceColorNotifier: &[u8; 26] = b"AI Replace Color Notifier\0";
pub const kAIEntrySuite: &[u8; 15] = b"AI Entry Suite\0";
pub const kAIDictionarySuite: &[u8; 20] = b"AI Dictionary Suite\0";
pub const kAIDictionaryIteratorSuite: &[u8; 29] = b"AI Dictionary Iterator Suite\0";
pub const kAIRasterSuite: &[u8; 16] = b"AI Raster Suite\0";
pub const kAIPlacedSuite: &[u8; 16] = b"AI Placed Suite\0";
pub const kAIArtboardRangeSuite: &[u8; 24] = b"AI Artboard Range Suite\0";
pub const kAIActionManagerSuite: &[u8; 24] = b"AI Action Manager Suite\0";
pub const kAIActionManagerPlayActionEventDoneNotifier: &[u8; 48] =
    b"AI Action Manager PlayActionEvent Done Notifier\0";
pub const kAIActionActualExecutionFinishedNotifier: &[u8; 45] =
    b"AI Action Actual Execution Finished Notifier\0";
pub const kAIFileFormatSuite: &[u8; 21] = b"AI File Format Suite\0";
pub const kAIMacFileFormatSuite: &[u8; 25] = b"AI Mac File Format Suite\0";
pub const kAIFileFormatDocumentOpenedNotifier: &[u8; 40] =
    b"AI File Format Document Opened Notifier\0";
pub const kAIFileFormatLinkUpdateNotifier: &[u8; 36] = b"AI File Format Link Update Notifier\0";
pub const kAIDocumentSuite: &[u8; 18] = b"AI Document Suite\0";
pub const kAIDocumentChangedNotifier: &[u8; 29] = b"AI Document Changed Notifier\0";
pub const kAIActiveDocumentWindowAboutToBeChangedNotifier: &[u8; 55] =
    b"AI Active Document Window About To be Changed Notifier\0";
pub const kAIDocumentAboutToCloseNotifier: &[u8; 36] = b"AI Document About To Close Notifier\0";
pub const kAIDocumentClosedNotifier: &[u8; 28] = b"AI Document Closed Notifier\0";
pub const kAIDocumentOpenedNotifier: &[u8; 28] = b"AI Document Opened Notifier\0";
pub const kAIDocumentSavedNotifier: &[u8; 27] = b"AI Document Saved Notifier\0";
pub const kAIDocumentWriteOnDiskCompleteNotifier: &[u8; 44] =
    b"AI Document Write On Disk Complete Notifier\0";
pub const kAIDocumentWriteOnDiskFailedNotifier: &[u8; 42] =
    b"AI Document Write On Disk Failed Notifier\0";
pub const kAIDocumentWriteCopyOnDiskCompleteNotifier: &[u8; 49] =
    b"AI Document Write Copy On Disk Complete Notifier\0";
pub const kAIDocumentWriteCopyOnDiskFailedNotifier: &[u8; 47] =
    b"AI Document Write Copy On Disk Failed Notifier\0";
pub const kAIDocumentNewNotifier: &[u8; 25] = b"AI Document New Notifier\0";
pub const kAIDocumentClrMdlChangedNotifier: &[u8; 41] =
    b"AI Document Color Model Changed Notifier\0";
pub const kAIDocumentProfilesChangedNotifier: &[u8; 38] =
    b"AI Document Profiles Changed Notifier\0";
pub const kAIDocumentSpotColorModeChangedNotifier: &[u8; 45] =
    b"AI Document Spot Color Mode Changed Notifier\0";
pub const kAIDocumentRulerUnitChangedNotifier: &[u8; 40] =
    b"AI Document Ruler Unit Changed Notifier\0";
pub const kAIDocumentWritePreprocessNotifier: &[u8; 38] =
    b"AI Document Write Preprocess Notifier\0";
pub const kAIDocumentWritePostprocessNotifier: &[u8; 39] =
    b"AI Document Write Postprocess Notifier\0";
pub const kAIDocumentCropAreaModifiedNotifier: &[u8; 40] =
    b"AI Document Crop Area Modified Notifier\0";
pub const kAIDocumentRulerOriginChangedNotifier: &[u8; 42] =
    b"AI Document Ruler Origin Changed Notifier\0";
pub const kAIDocumentBleedsChangedNotifier: &[u8; 41] =
    b"AI Document Bleed Value Changed Notifier\0";
pub const kAIDocumentTransparencyGridNotifier: &[u8; 39] =
    b"AI Document Transparency Grid Notifier\0";
pub const kAIDocumentScaleConversionStartedNotifier: &[u8; 46] =
    b"AI Document Scale Conversion Started Notifier\0";
pub const kAIDocumentScaleConvertedNotifier: &[u8; 37] = b"AI Document Scale Converted Notifier\0";
pub const kAIActiveDocumentScaleChangedNotifier: &[u8; 42] =
    b"AI Active Document Scale Changed Notifier\0";
pub const kAIPDFDictKeyInsertPages: &[u8; 24] = b"AIPDFDictKeyInsertPages\0";
pub const kAIPDFDictKeyInsertPagesIndex: &[u8; 29] = b"AIPDFDictKeyInsertPagesIndex\0";
pub const kAIDocumentMiPrintRecordVersion: u32 = 1;
pub const kAIHardSoftSuite: &[u8; 19] = b"AI Hard Soft Suite\0";
pub const kAICurrentCoordinateSystemChangedNotifier: &[u8; 46] =
    b"AI Current Coordinate System Changed Notifier\0";
pub const kAILegacyTextConversionSuite: &[u8; 32] = b"AI Legacy Text Conversion Suite\0";
pub const kAILayerListSuite: &[u8; 14] = b"AI Layer List\0";
pub const kAILayerListChangedNotifier: &[u8; 36] = b"AI Edit Layer List Changed Notifier\0";
pub const kAIDocumentLayerList: &[u8; 23] = b"AI Document Layer List\0";
pub const kAITransparencyMaskLayerList: &[u8; 32] = b"AI Transparency Mask Layer List\0";
pub const kAIMatchingArtSuite: &[u8; 22] = b"AI Matching Art Suite\0";
pub const kAIMdMemorySuite: &[u8; 18] = b"AI MdMemory Suite\0";
pub const kAIMenuSuite: &[u8; 14] = b"AI Menu Suite\0";
pub const kAIMenuChangedNotifier: &[u8; 25] = b"AI Menu Changed Notifier\0";
pub const kAIEditColorsSubMenuGroup: &[u8; 28] = b"AIEdit Colors SubMenu Group\0";
pub const kAIChartsMenuGroup: &[u8; 13] = b"Adobe Charts\0";
pub const kAINotifierSuite: &[u8; 18] = b"AI Notifier Suite\0";
pub const kAIRealBezierSuite: &[u8; 21] = b"AI Real Bezier Suite\0";
pub const kAIPathSuite: &[u8; 14] = b"AI Path Suite\0";
pub const kAIPathStyleSuite: &[u8; 20] = b"AI Path Style Suite\0";
pub const kAIBeginImportStylesNotifier: &[u8; 32] = b"AI Begin Import Styles Notifier\0";
pub const kAIEndImportStylesNotifier: &[u8; 30] = b"AI End Import Styles Notifier\0";
pub const kAIFixedMathSuite: &[u8; 20] = b"AI Fixed Math Suite\0";
pub const kAIPreferenceSuite: &[u8; 20] = b"AI Preference Suite\0";
pub const kAIPreferenceChangedNotifier: &[u8; 31] = b"AI Preference Changed Notifier\0";
pub const kAIPreferenceCaller: &[u8; 14] = b"AI Preference\0";
pub const kAIPreferenceInitSelector: &[u8; 22] = b"Init Preference Panel\0";
pub const kAIPreferenceOKSelector: &[u8; 21] = b"Preference Dialog OK\0";
pub const kAIPreferenceCancelSelector: &[u8; 25] = b"Preference Dialog Cancel\0";
pub const kAIPreferenceUpdateSelector: &[u8; 26] = b"Preference Dialog Upadate\0";
pub const kAIPreferenceTurnOffWarningPrefix: &[u8; 21] = b"DontShowWarningAgain\0";
pub const kAITimerSuite: &[u8; 15] = b"AI Timer Suite\0";
pub const kAIToolSuite: &[u8; 14] = b"AI Tool Suite\0";
pub const kAIEffectiveToolChangedNotifier: &[u8; 35] = b"AI Effective Tool Changed Notifier\0";
pub const kAIUserToolChangedNotifier: &[u8; 30] = b"AI User Tool Changed Notifier\0";
pub const kAIToolSelectedNotifier: &[u8; 26] = b"AI Tool Selected Notifier\0";
pub const kAIToolDeselectedNotifier: &[u8; 28] = b"AI Tool Deselected Notifier\0";
pub const kAIInvalidateByScrollNotifier: &[u8; 33] = b"AI Invalidate By Scroll Notifier\0";
pub const kAIToolClearStateNotifier: &[u8; 29] = b"AI Tool Clear State Notifier\0";
pub const kAIToolTitleChangedNotifier: &[u8; 31] = b"AI Tool Title Changed Notifier\0";
pub const kAIToolTooltipChangedNotifier: &[u8; 33] = b"AI Tool Tooltip Changed Notifier\0";
pub const kAIToolHelpIDChangedNotifier: &[u8; 33] = b"AI Tool Help ID Changed Notifier\0";
pub const kAIToolIconChangedNotifier: &[u8; 40] = b"AI Tool Icon Resources Changed Notifier\0";
pub const kAIToolChangedNotifier: &[u8; 25] = b"AI Tool Changed Notifier\0";
pub const kAIToolWindowChangedNotifier: &[u8; 32] = b"AI Tool Window Changed Notifier\0";
pub const kAIToolSuspendNotifier: &[u8; 25] = b"AI Tool Suspend Notifier\0";
pub const kAIToolResumeNotifier: &[u8; 24] = b"AI Tool Resume Notifier\0";
pub const kAIToolTabletPointerTypeChangedNotifier: &[u8; 40] =
    b"AI Tablet Pointer Type Changed Notifier\0";
pub const kAIToolModifiersChangedNotifier: &[u8; 35] = b"AI Tool Modifiers Changed Notifier\0";
pub const kAIToolSuspendedBySpacebarNotifier: &[u8; 39] =
    b"AI Tool Suspended by Spacebar Notifier\0";
pub const kAIToolResumedBySpacebarNotifier: &[u8; 37] = b"AI Tool Resumed by Spacebar Notifier\0";
pub const kAIToolSuspendedByCmdKeyNotifier: &[u8; 38] = b"AI Tool Suspended by Cmd Key Notifier\0";
pub const kAIToolResumedByCmdKeyNotifier: &[u8; 36] = b"AI Tool Resumed by Cmd Key Notifier\0";
pub const kAIEyedropperDragNotifier: &[u8; 28] = b"AI Eyedropper Drag Notifier\0";
pub const kAIFilePathSuite: &[u8; 19] = b"AI File Path Suite\0";
pub const kAIDataFilterSuite: &[u8; 21] = b"AI Data Filter Suite\0";
pub const kAIStringPoolSuite: &[u8; 21] = b"AI String Pool Suite\0";
pub const kAINameSpaceSuite: &[u8; 20] = b"AI Name Space Suite\0";
pub const kAIFontSuite: &[u8; 14] = b"AI Font Suite\0";
pub const kAIBeginImportCompFontNotifier: &[u8; 34] = b"AI Begin Import CompFont Notifier\0";
pub const kAIEndImportCompFontNotifier: &[u8; 32] = b"AI End Import CompFont Notifier\0";
pub const kAICurrentLanguageChangedNotifier: &[u8; 37] = b"AI Current Language Changed Notifier\0";
pub const kAIMEFontSuite: &[u8; 17] = b"AI ME Font Suite\0";
pub const kAIRuntimeSuite: &[u8; 17] = b"AI Runtime Suite\0";
pub const kAIApplicationStartedNotifier: &[u8; 32] = b"AI Application Started Notifier\0";
pub const kAIApplicationShutdownNotifier: &[u8; 33] = b"AI Application Shutdown Notifier\0";
pub const kAISaveUserDataNotifier: &[u8; 27] = b"AI Save User Data Notifier\0";
pub const kAIUndoSuite: &[u8; 14] = b"AI Undo Suite\0";
pub const kAIUndoNewTransaction: &[u8; 33] = b"AI Undo New Transaction Notifier\0";
pub const kAIUndoForgetFutureTransaction: &[u8; 39] = b"AI Undo Forget Last Future Transaction\0";
pub const kAIUndoClearedAllFutureTransaction: &[u8; 39] =
    b"AI Undo Cleared All Future Transaction\0";
pub const kAIUndoCommitPastTransaction: &[u8; 38] = b"AI Undo Commit First Past Transaction\0";
pub const kAIUndoStackRefresh: &[u8; 22] = b"AI Undo Stack Refresh\0";
pub const kAIDocumentViewSuite: &[u8; 23] = b"AI Document View Suite\0";
pub const kAIDocumentViewChangedNotifier: &[u8; 34] = b"AI Document View Changed Notifier\0";
pub const kAIDocumentViewInvalidRectChangedNotifier: &[u8; 47] =
    b"AI Document View Invalid Rect Changed Notifier\0";
pub const kAIDocumentViewStyleChangedNotifier: &[u8; 40] =
    b"AI Document View Style Changed Notifier\0";
pub const kAIDocumentViewActiveViewChangedNotifier: &[u8; 52] =
    b"AI Document View Style Active View Changed Notifier\0";
pub const kAIDocumentViewOPPPlateStateChangedNotifier: &[u8; 46] =
    b"AI Document View Plate State Changed Notifier\0";
pub const kAIDocumentViewEdgesVisibilityChangeNotifier: &[u8; 50] =
    b"AI Document View Edges Visibility Change Notifier\0";
pub const kAIActiveDocViewTitleChangedNotifier: &[u8; 40] =
    b"AI Document View Title Changed Notifier\0";
pub const kAIDocViewTrimViewStateChangedNotifier: &[u8; 50] =
    b"AI Document View Trim View State Changed Notifier\0";
pub const kAIDocViewRenderModeChangedNotifier: &[u8; 46] =
    b"AI Document View Render Mode Changed Notifier\0";
pub const kAIUserSuite: &[u8; 14] = b"AI User Suite\0";
pub const kAIUniversalLocaleFormat: u32 = 0;
pub const kAIResourceLocaleFormat: u32 = 1;
pub const kAISystemLocaleFormat: u32 = 2;
pub const kAIShortDateFormat: u32 = 0;
pub const kAILongDateFormat: u32 = 256;
pub const kAIAbbrevDateFormat: u32 = 512;
pub const kAIShortTimeFormat: u32 = 0;
pub const kAILongTimeFormat: u32 = 256;
pub const kAIPanelSuite: &[u8; 15] = b"AI Panel Suite\0";
pub const kAIPanelFlyoutMenuSuite: &[u8; 27] = b"AI Panel Flyout Menu Suite\0";
pub const kAIAppContextSuite: &[u8; 17] = b"AI Context Suite\0";
pub const kAIFoldersSuite: &[u8; 17] = b"AI Folders Suite\0";
pub const kAIClipboardSuite: &[u8; 19] = b"AI Clipboard Suite\0";
pub const kAIFilterSuite: &[u8; 16] = b"AI Filter Suite\0";
pub const kAIArraySuite: &[u8; 15] = b"AI Array Suite\0";
pub const kAIXMLNodeSuite: &[u8; 18] = b"AI XML Node Suite\0";
pub const kAIXMLDocumentSuite: &[u8; 22] = b"AI XML Document Suite\0";
pub const kAIXMLElementSuite: &[u8; 21] = b"AI XML Element Suite\0";
pub const kAIXMLNodeListSuite: &[u8; 23] = b"AI XML Node List Suite\0";
pub const kAIXMLNamedNodeMapSuite: &[u8; 28] = b"AI XML Named Node Map Suite\0";
pub const kAIMetadataSyncNotifier: &[u8; 26] = b"AI Metadata Sync Notifier\0";
pub const kAILiveEffectSuite: &[u8; 21] = b"AI Live Effect Suite\0";
pub const kAILiveEffectParamsExpandBeforeKey: &[u8; 35] = b"Adobe Effect Expand Before Version\0";
pub const kAILiveEffectParamsWriteAlternateVersionMajorKey: &[u8; 50] =
    b"Adobe Effect Expand Write Alternate Version Major\0";
pub const kAILiveEffectParamsWriteAlternateVersionMinorKey: &[u8; 50] =
    b"Adobe Effect Expand Write Alternate Version Minor\0";
pub const kAILiveEffectMenuSubGroup: u32 = 1;
pub const kAISwatchListSuite: &[u8; 21] = b"AI Swatch List Suite\0";
pub const kAISwatchGroupSuite: &[u8; 22] = b"AI Swatch Group Suite\0";
pub const kAISwatchLibraryDialogChangedNotifier: &[u8; 42] =
    b"AI Swatch Library Dialog Changed Notifier\0";
pub const kAISwatchListChangedNotifier: &[u8; 32] = b"AI Swatch List Changed Notifier\0";
pub const kAISwatchListChangedInternallyNotifier: &[u8; 43] =
    b"AI Swatch List Changed Internally Notifier\0";
pub const kAISwatchReplaceColorNotifier: &[u8; 33] = b"AI Swatch Replace Color Notifier\0";
pub const kAICreateNewSwatchNotifier: &[u8; 30] = b"AI Create New Swatch Notifier\0";
pub const kAIDeleteSwatchNotifier: &[u8; 35] = b"AI Delete Selected Swatch Notifier\0";
pub const kAICreateNewSwatchWithDefaultParamNotifier: &[u8; 49] =
    b"AI Create New Swatch With Default Param Notifier\0";
pub const kAIDocSwatchesSelectionChangedNotifier: &[u8; 43] =
    b"AI Doc Swatches Selection Changed Notifier\0";
pub const kAIPaintStyleSuite: &[u8; 21] = b"AI Paint Style Suite\0";
pub const kAIPaintStyleModifierCaller: &[u8; 30] = b"AI PaintStyle Modifier Caller\0";
pub const kAIUpdatePathStyleNotifier: &[u8; 29] = b"AI Update PathStyle Notifier\0";
pub const kAIPaintStyleFillStrokeChangedNotifier: &[u8; 44] =
    b"AI Paint Style Fill Stroke Changed Notifier\0";
pub const kAIPaintStyleGradientStopChangedNotifier: &[u8; 46] =
    b"AI Paint Style Gradient Stop Changed Notifier\0";
pub const kAIPaintStyleSetStrokeWidthSelector: &[u8; 41] =
    b"AI Paint Style Set Stroke Width Selector\0";
pub const kAIPaintStyleIndicatorType: &[u8; 30] = b"AI Paint Style Indicator Type\0";
pub const kAIPaintStyleIndicatorSmallType: &[u8; 36] = b"AI Paint Style Indicator Small Type\0";
pub const kAIPaintStyleColorEditorType: &[u8; 33] = b"AI Paint Style Color Editor Type\0";
pub const kAIArtStyleSuite: &[u8; 19] = b"AI Art Style Suite\0";
pub const kAINamedStyleListChangedNotifier: &[u8; 37] = b"AI Named Style List Changed Notifier\0";
pub const kAIArtStyleFocusChangedNotifier: &[u8; 36] = b"AI Art Style Focus Changed Notifier\0";
pub const kAIArtStyleEditTransparencyNotifier: &[u8; 30] = b"AI Edit Transparency Notifier\0";
pub const kAINewArtBasicAppearancePref: &[u8; 28] = b"AI New Art Basic Appearance\0";
pub const kAIContainerOverridesObjectAppearancePref: &[u8; 30] = b"AI Container Overrides Object\0";
pub const kAIBlendStyleSuite: &[u8; 21] = b"AI Blend Style Suite\0";
pub const kAIMaskSuite: &[u8; 14] = b"AI Mask Suite\0";
pub const kAIBlendModeKey: &[u8; 5] = b"Mode\0";
pub const kAIBlendOpacityKey: &[u8; 8] = b"Opacity\0";
pub const kAIBlendIsolatedKey: &[u8; 9] = b"Isolated\0";
pub const kAIBlendKnockoutKey: &[u8; 9] = b"Knockout\0";
pub const kAIBlendAlphaIsShapeKey: &[u8; 13] = b"AlphaIsShape\0";
pub const kAIPluginGroupSuite: &[u8; 22] = b"AI Plugin Group Suite\0";
pub const kAIWorkspaceSuite: &[u8; 19] = b"AI Workspace Suite\0";
pub const kAIWorkspaceRestoreFinishNotifier: &[u8; 37] = b"AI Workspace Restore Finish Notifier\0";
pub const kAIWorkspaceCaller: &[u8; 18] = b"Workspace Manager\0";
pub const kAIWSWriteSelector: &[u8; 16] = b"Write Workspace\0";
pub const kAIWSRestoreSelector: &[u8; 18] = b"Restore Workspace\0";
pub const kAIWSDefaultSelector: &[u8; 18] = b"Default Workspace\0";
pub const kAIControlBarSuite: &[u8; 21] = b"AI Control Bar Suite\0";
pub const kAIShapeConstructionSuite: &[u8; 28] = b"AI Shape Construction Suite\0";
pub const kAIGeometrySuite: &[u8; 18] = b"AI Geometry Suite\0";
pub const kAITransformArtSuite: &[u8; 23] = b"AI Transform Art Suite\0";
pub const kAIUIDPoolSuite: &[u8; 18] = b"AI UID Pool Suite\0";
pub const kAIUIDSuite: &[u8; 13] = b"AI UID Suite\0";
pub const kAIUIDREFSuite: &[u8; 16] = b"AI UIDREF Suite\0";
pub const kAIUIDUtilsSuite: &[u8; 19] = b"AI UID Utils Suite\0";
pub const kAIXMLNameChangedNotifier: &[u8; 29] = b"AI XML Name Changed Notifier\0";
pub const kAIArtboardRulerOriginChangedNotifier: &[u8; 42] =
    b"AI Artboard Ruler Origin Changed Notifier\0";
pub const kAIArtboardSuite: &[u8; 18] = b"AI Artboard Suite\0";
pub const kAIUUIDSuite: &[u8; 14] = b"AI UUID Suite\0";
pub const kAILimitsSuite: &[u8; 16] = b"AI Limits Suite\0";
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type time_t = __darwin_time_t;
pub type std___enable_if_t = u8;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std__If = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Tp> = _Tp;
pub type std___type_identity_t = std___type_identity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
pub type std___binary_function = std_binary_function;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___pointer_traits_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std___rebind_pointer_t = std_pointer_traits;
pub type std_string = std_basic_string;
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
    pub __st_: _StateT,
    pub __off_: std_streamoff,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
    pub __t_: _Iter,
    pub current: _Iter,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_value_type = std_iterator_traits;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
    pub __i_: std___wrap_iter_iterator_type<_Iter>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
pub type std___pointer_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_rebind_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_void_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_const_void_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
pub type std___rebind_alloc = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = ::std::os::raw::c_ulong;
pub type std_allocator_difference_type = ::std::os::raw::c_long;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
pub type std_streampos = std_fpos<__mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::std::os::raw::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub __data_: *const std_basic_string_view_value_type<_CharT>,
    pub __size_: std_basic_string_view_size_type,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = ::std::os::raw::c_ulong;
pub type std_basic_string_view_difference_type = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less___result_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unique_ptr_deleter_sfinae {
    pub _address: u8,
}
pub type std___unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub __ptr_: std___compressed_pair,
}
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae;
pub type std_unique_ptr__LValRefType = u8;
pub type std_unique_ptr__GoodRValRefType = u8;
pub type std_unique_ptr__BadRValRefType = u8;
pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = std___enable_if_t;
pub type std_unique_ptr__EnableIfDeleterConstructible = std___enable_if_t;
pub type std_unique_ptr__EnableIfMoveConvertible = std___enable_if_t;
pub type std_unique_ptr__EnableIfDeleterConvertible = std___enable_if_t;
pub type std_unique_ptr__EnableIfDeleterAssignable = std___enable_if_t;
#[repr(C)]
pub struct std_basic_string {
    pub __r_: std___compressed_pair,
}
pub type std_basic_string___default_allocator_type = std_allocator;
pub type std_basic_string___self = std_basic_string;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type<_CharT> = _CharT;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference<_CharT> = *mut std_basic_string_value_type<_CharT>;
pub type std_basic_string_const_reference<_CharT> = *const std_basic_string_value_type<_CharT>;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub _address: u8,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub __data_: *mut std_basic_string_value_type<_CharT>,
    pub __padding_: *mut ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl<_CharT> std_basic_string___short<_CharT> {
    #[inline]
    pub fn __size_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set___size_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn __size__raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set___size__raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn __is_long_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set___is_long_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn __is_long__raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set___is_long__raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __size_: ::std::os::raw::c_uchar,
        __is_long_: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __size_: u8 = unsafe { ::std::mem::transmute(__size_) };
            __size_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __is_long_: u8 = unsafe { ::std::mem::transmute(__is_long_) };
            __is_long_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub __lx: __BindgenUnionField<u8>,
    pub __lxx: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 = 0;
pub type std_basic_string__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1<_CharT>,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub __s: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub __l: __BindgenUnionField<u8>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 = 0;
pub type std_basic_string__bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_node_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tree_node_types {
    pub _address: u8,
}
pub type std___make_tree_node_types__NodePtr = std___rebind_pointer_t;
pub type std___make_tree_node_types_type = std___tree_node_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_node_destructor<_Allocator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Allocator>>,
    pub __na_: *mut std___tree_node_destructor_allocator_type<_Allocator>,
    pub __value_constructed: bool,
}
pub type std___tree_node_destructor_allocator_type<_Allocator> = _Allocator;
pub type std___tree_node_destructor___alloc_traits = std_allocator_traits;
pub type std___tree_node_destructor_pointer = std___tree_node_destructor___alloc_traits;
pub type std___tree_node_destructor__NodeTypes = std___tree_node_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_iterator {
    pub __ptr_: std___tree_iterator___iter_pointer,
}
pub type std___tree_iterator__NodeTypes = std___tree_node_types;
pub type std___tree_iterator___node_pointer<_NodePtr> = _NodePtr;
pub type std___tree_iterator___node_base_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___end_node_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___iter_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___pointer_traits = std_pointer_traits;
pub type std___tree_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___tree_iterator_value_type<_Tp> = _Tp;
pub type std___tree_iterator_difference_type<_DiffType> = _DiffType;
pub type std___tree_iterator_reference<_Tp> = *mut std___tree_iterator_value_type<_Tp>;
pub type std___tree_iterator_pointer = std___tree_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_const_iterator {
    pub __ptr_: std___tree_const_iterator___iter_pointer,
}
pub type std___tree_const_iterator__NodeTypes = std___tree_node_types;
pub type std___tree_const_iterator___node_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___node_base_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___end_node_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___iter_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___pointer_traits = std_pointer_traits;
pub type std___tree_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___tree_const_iterator_value_type<_Tp> = _Tp;
pub type std___tree_const_iterator_difference_type<_DiffType> = _DiffType;
pub type std___tree_const_iterator_reference<_Tp> =
    *const std___tree_const_iterator_value_type<_Tp>;
pub type std___tree_const_iterator_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___non_const_iterator = std___tree_iterator;
#[repr(C)]
pub struct std___tree {
    pub __begin_node_: std___tree___iter_pointer,
    pub __pair1_: std___compressed_pair,
    pub __pair3_: std___compressed_pair,
}
pub type std___tree_value_type<_Tp> = _Tp;
pub type std___tree_value_compare<_Compare> = _Compare;
pub type std___tree_allocator_type<_Allocator> = _Allocator;
pub type std___tree___alloc_traits = std_allocator_traits;
pub type std___tree__NodeTypes = std___make_tree_node_types;
pub type std___tree_key_type = std___tree__NodeTypes;
pub type std___tree___node_value_type = std___tree__NodeTypes;
pub type std___tree___container_value_type = std___tree__NodeTypes;
pub type std___tree_pointer = std___tree___alloc_traits;
pub type std___tree_const_pointer = std___tree___alloc_traits;
pub type std___tree_size_type = std___tree___alloc_traits;
pub type std___tree_difference_type = std___tree___alloc_traits;
pub type std___tree___void_pointer = std___tree__NodeTypes;
pub type std___tree___node = std___tree__NodeTypes;
pub type std___tree___node_pointer = std___tree__NodeTypes;
pub type std___tree___node_base = std___tree__NodeTypes;
pub type std___tree___node_base_pointer = std___tree__NodeTypes;
pub type std___tree___end_node_t = std___tree__NodeTypes;
pub type std___tree___end_node_ptr = std___tree__NodeTypes;
pub type std___tree___parent_pointer = std___tree__NodeTypes;
pub type std___tree___iter_pointer = std___tree__NodeTypes;
pub type std___tree___node_allocator = std___rebind_alloc;
pub type std___tree___node_traits = std_allocator_traits;
pub type std___tree___node_base_allocator = std___rebind_alloc;
pub type std___tree___node_base_traits = std_allocator_traits;
pub type std___tree__Dp = std___tree_node_destructor<std___tree___node_allocator>;
pub type std___tree___node_holder = std_unique_ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std___tree__DetachedTreeCache {
    pub __t_: *mut std___tree,
    pub __cache_root_: std___tree___node_pointer,
    pub __cache_elem_: std___tree___node_pointer,
}
#[repr(C)]
pub struct std_set {
    pub __tree_: std_set___base,
}
pub type std_set_key_type<_Key> = _Key;
pub type std_set_value_type<_Key> = std_set_key_type<_Key>;
pub type std_set_key_compare = std___type_identity_t;
pub type std_set_value_compare = std_set_key_compare;
pub type std_set_allocator_type = std___type_identity_t;
pub type std_set_reference<_Key> = *mut std_set_value_type<_Key>;
pub type std_set_const_reference<_Key> = *const std_set_value_type<_Key>;
pub type std_set___base = std___tree;
pub type std_set___alloc_traits = std_allocator_traits;
pub type std_set_pointer = std_set___base;
pub type std_set_const_pointer = std_set___base;
pub type std_set_size_type = std_set___base;
pub type std_set_difference_type = std_set___base;
pub type std_set_iterator = std_set___base;
pub type std_set_const_iterator = std_set___base;
pub type std_set_reverse_iterator = std_reverse_iterator<std_set_iterator>;
pub type std_set_const_reverse_iterator = std_reverse_iterator<std_set_const_iterator>;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector {
    pub __begin_: std_vector_pointer,
    pub __end_: std_vector_pointer,
    pub __end_cap_: std___compressed_pair,
}
pub type std_vector___default_allocator_type = std_allocator;
pub type std_vector___self = std_vector;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_allocator_type<_Allocator> = _Allocator;
pub type std_vector___alloc_traits = std_allocator_traits;
pub type std_vector_reference<_Tp> = *mut std_vector_value_type<_Tp>;
pub type std_vector_const_reference<_Tp> = *const std_vector_value_type<_Tp>;
pub type std_vector_size_type = std_vector___alloc_traits;
pub type std_vector_difference_type = std_vector___alloc_traits;
pub type std_vector_pointer = std_vector___alloc_traits;
pub type std_vector_const_pointer = std_vector___alloc_traits;
pub type std_vector_iterator = std___wrap_iter<std_vector_pointer>;
pub type std_vector_const_iterator = std___wrap_iter<std_vector_const_pointer>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector___destroy_vector {
    pub __vec_: *mut std_vector,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__ConstructTransaction {
    pub __v_: *mut std_vector,
    pub __pos_: std_vector_pointer,
    pub __new_end_: std_vector_const_pointer,
}
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
pub type UInt8 = ::std::os::raw::c_uchar;
pub type UInt16 = ::std::os::raw::c_ushort;
pub type SInt16 = ::std::os::raw::c_short;
pub type UInt32 = ::std::os::raw::c_uint;
pub type SInt32 = ::std::os::raw::c_int;
pub type Ptr = *mut ::std::os::raw::c_char;
pub type OSErr = SInt16;
pub type OSStatus = SInt32;
pub type ByteOffset = ::std::os::raw::c_ulong;
pub type ItemCount = ::std::os::raw::c_ulong;
pub type FourCharCode = UInt32;
pub type OSType = FourCharCode;
pub type ResType = FourCharCode;
pub type Boolean = ::std::os::raw::c_uchar;
pub type ProcPtr = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type URefCon = *mut ::std::os::raw::c_void;
pub type Str255 = [::std::os::raw::c_uchar; 256usize];
pub type ConstStr255Param = *const ::std::os::raw::c_uchar;
pub type CFIndex = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFString {
    _unused: [u8; 0],
}
pub type CFStringRef = *const __CFString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAllocator {
    _unused: [u8; 0],
}
pub type CFAllocatorRef = *const __CFAllocator;
pub type CFErrorDomain = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFError {
    _unused: [u8; 0],
}
#[doc = "@typedef CFErrorRef\nThis is the type of a reference to CFErrors.  CFErrorRef is toll-free bridged with NSError."]
pub type CFErrorRef = *mut __CFError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFURL {
    _unused: [u8; 0],
}
pub type CFURLRef = *const __CFURL;
pub const CFSocketError_kCFSocketSuccess: CFSocketError = 0;
pub const CFSocketError_kCFSocketError: CFSocketError = -1;
pub const CFSocketError_kCFSocketTimeout: CFSocketError = -2;
pub type CFSocketError = CFIndex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamError {
    pub domain: CFIndex,
    pub error: SInt32,
}
pub const CFStreamErrorDomain_kCFStreamErrorDomainCustom: CFStreamErrorDomain = -1;
pub const CFStreamErrorDomain_kCFStreamErrorDomainPOSIX: CFStreamErrorDomain = 1;
pub const CFStreamErrorDomain_kCFStreamErrorDomainMacOSStatus: CFStreamErrorDomain = 2;
pub type CFStreamErrorDomain = CFIndex;
pub const CFURLError_kCFURLUnknownError: CFURLError = -10;
pub const CFURLError_kCFURLUnknownSchemeError: CFURLError = -11;
pub const CFURLError_kCFURLResourceNotFoundError: CFURLError = -12;
pub const CFURLError_kCFURLResourceAccessViolationError: CFURLError = -13;
pub const CFURLError_kCFURLRemoteHostUnavailableError: CFURLError = -14;
pub const CFURLError_kCFURLImproperArgumentsError: CFURLError = -15;
pub const CFURLError_kCFURLUnknownPropertyKeyError: CFURLError = -16;
pub const CFURLError_kCFURLPropertyKeyUnavailableError: CFURLError = -17;
pub const CFURLError_kCFURLTimeoutError: CFURLError = -18;
pub type CFURLError = CFIndex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBundle {
    _unused: [u8; 0],
}
pub type CFBundleRef = *mut __CFBundle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFXMLParser {
    _unused: [u8; 0],
}
pub type CFXMLParserRef = *mut __CFXMLParser;
pub type CFXMLParserStatusCode = CFIndex;
pub type CFXMLParserHandleErrorCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        error: CFXMLParserStatusCode,
        info: *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type ai_int8 = i8;
pub type ai_uint8 = u8;
pub type ai_int16 = i16;
pub type ai_uint16 = u16;
pub type ai_int32 = i32;
pub type ai_uint32 = u32;
pub type ai_int64 = i64;
pub type ai_uint64 = u64;
pub type ai_sizediff_t = isize;
pub type ai_intptr = isize;
pub type ai_uintptr = usize;
pub type ai_SizeType = usize;
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai15SetUpBasicFuncsEP17SPBasicFuncStruct"]
    pub fn ai_SetUpBasicFuncs(inStruct: *mut SPBasicFuncStruct);
}
pub const ai_Quadrant_kFirstQuadrant: ai_Quadrant = 1;
pub const ai_Quadrant_kSecondQuadrant: ai_Quadrant = 2;
pub const ai_Quadrant_kThirdQuadrant: ai_Quadrant = 3;
pub const ai_Quadrant_kFourthQuadrant: ai_Quadrant = 4;
pub type ai_Quadrant = ::std::os::raw::c_uint;
pub const ai_IconType_kInvalid: ai_IconType = 0;
pub const ai_IconType_kSVG: ai_IconType = 1;
pub const ai_IconType_kPNG: ai_IconType = 2;
#[doc = "Icon Types to be given by clients."]
pub type ai_IconType = ai_uint8;
#[doc = " Exception class thrown by C++ classes"]
#[repr(C)]
#[derive(Debug)]
pub struct ai_Error {
    pub _base: std_exception,
    pub mErr: AIErr,
    pub mWhatMessage: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug)]
pub struct ai_LogicError {
    pub _base: ai_Error,
    pub mMsg: *const ::std::os::raw::c_char,
}
#[doc = " Allocator object class for the AutoBuffer template."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ai_SPAlloc {
    pub _address: u8,
}
unsafe extern "C" {
    #[doc = " Allocates a block of memory.\n@param byteCount The number of bytes, an unsigned integer.\n@return A pointer to the allocated block."]
    #[link_name = "\u{1}__ZN2ai7SPAlloc13AllocateBlockEm"]
    pub fn ai_SPAlloc_AllocateBlock(byteCount: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Frees a block of memory allocated by \\c #AllocateBlock().\n@param block A pointer to the block."]
    #[link_name = "\u{1}__ZN2ai7SPAlloc11DeleteBlockEPv"]
    pub fn ai_SPAlloc_DeleteBlock(block: *mut ::std::os::raw::c_void);
}
impl ai_SPAlloc {
    #[inline]
    pub unsafe fn AllocateBlock(byteCount: usize) -> *mut ::std::os::raw::c_void {
        ai_SPAlloc_AllocateBlock(byteCount)
    }
    #[inline]
    pub unsafe fn DeleteBlock(block: *mut ::std::os::raw::c_void) {
        ai_SPAlloc_DeleteBlock(block)
    }
}
#[doc = " An \\c AutoBuffer class object allows you to retrieve string contents\ninto a buffer, or to pass or retrieve any array of data types,\nwithout having to manage the buffer's memory."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_AutoBuffer<elem, size_type> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<elem>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<size_type>>,
    pub fCapacity: size_type,
    pub fBuffer: *mut elem,
}
pub type ai_AutoBuffer_iterator<elem> = *mut elem;
pub type ai_AutoBuffer_const_iterator<elem> = *const elem;
#[repr(C)]
pub struct ai_const_PStr__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Constant Pascal string adapter object."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_const_PStr {
    pub vtable_: *const ai_const_PStr__bindgen_vtable,
    pub fConstStr: *const ::std::os::raw::c_uchar,
}
#[doc = " Mutable Pascal string adapter object."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_PStr {
    pub _base: ai_const_PStr,
}
#[doc = " \\c UnicodeString objects provide basic string functionality for\nUnicode-based strings, similar to that provided by the standard C string library.\n\nThe contents of the string are treated as if all characters are represented\nas full 32-bit Unicode characters, which means you do not need to know the\ninternal representation of the string, or deal with surrogate pairs during\nediting or searching operations."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_UnicodeString {
    pub fImpl: *mut CAIUnicodeStringImpl,
}
#[doc = " A numeric relative offset type (signed integer)."]
pub type ai_UnicodeString_offset_type = ai_sizediff_t;
#[doc = " A numeric value type (unsigned integer)."]
pub type ai_UnicodeString_size_type = usize;
#[doc = " Value type for a UTF-32 character code."]
pub type ai_UnicodeString_UTF32TextChar = ASUInt32;
#[doc = " Value type for a UTF-16 character code."]
pub type ai_UnicodeString_UTF16Char = ASUnicode;
pub type ai_UnicodeString_value_type = ai_UnicodeString_UTF32TextChar;
#[doc = " Canonical Decomposition"]
pub const ai_UnicodeString_NormalizedForm_kForm_NFD: ai_UnicodeString_NormalizedForm = 0;
#[doc = " Canonical Decomposition, followed by Canonical Composition"]
pub const ai_UnicodeString_NormalizedForm_kForm_NFC: ai_UnicodeString_NormalizedForm = 1;
#[doc = " Compatibility Decomposition"]
pub const ai_UnicodeString_NormalizedForm_kForm_NFKD: ai_UnicodeString_NormalizedForm = 2;
#[doc = " Comparability Decomposition, followed by Canonical Composition."]
pub const ai_UnicodeString_NormalizedForm_kForm_NFKC: ai_UnicodeString_NormalizedForm = 3;
#[doc = " Do not use this"]
pub const ai_UnicodeString_NormalizedForm_kForm_DummyValue: ai_UnicodeString_NormalizedForm =
    4294967295;
#[doc = " Normalization forms for use with the \\c #normalize() method.\nSee http://www.unicode.org/reports/tr15/ for more information."]
pub type ai_UnicodeString_NormalizedForm = ::std::os::raw::c_uint;
#[doc = " TBD"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ai_UnicodeString_Collator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ai_UnicodeString_const_iterator {
    pub fIndex: ai_UnicodeString_const_iterator_size_type,
    pub fStringContainer: ai_UnicodeString_const_iterator_container_type,
}
pub type ai_UnicodeString_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type ai_UnicodeString_const_iterator_value_type = ai_UnicodeString_value_type;
pub type ai_UnicodeString_const_iterator_difference_type = isize;
pub type ai_UnicodeString_const_iterator_pointer = *mut ai_UnicodeString_value_type;
pub type ai_UnicodeString_const_iterator_reference = *mut ai_UnicodeString_value_type;
pub type ai_UnicodeString_const_iterator_size_type = ai_UnicodeString_size_type;
pub type ai_UnicodeString_const_iterator_container_type = *const ai_UnicodeString;
unsafe extern "C" {
    #[doc = " The maximum number of characters possible in a string. This also indicates a failure if used as return value."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString4nposE"]
    pub static ai_UnicodeString_npos: ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nnon-zero-terminated \\c char array whose encoding is ISO Roman/Latin.\n@param string The \\c char array.\n@param count the number of bytes (chars) in the string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString9FromRomanEPKcm"]
    pub fn ai_UnicodeString_FromRoman(
        string: *const ::std::os::raw::c_char,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nzero-terminated \\c char array whose encoding is ISO Roman/Latin.\n@param string The \\c char array.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString9FromRomanEPKc"]
    pub fn ai_UnicodeString_FromRoman1(string: *const ::std::os::raw::c_char) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\n\\c std::string whose encoding is ISO Roman/Latin.\n@param string The string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString9FromRomanERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
    pub fn ai_UnicodeString_FromRoman2(string: *const std_string) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nPascal string whose encoding is ISO Roman/Latin.\n@param pascalString The Pascal string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString9FromRomanERKNS_10const_PStrE"]
    pub fn ai_UnicodeString_FromRoman3(pascalString: *const ai_const_PStr) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nnon-zero-terminated \\c char array whose encoding is the current platform encoding.\n@param string The \\c char array.\n@param count The number of bytes (chars) in the string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString12FromPlatformEPKcm"]
    pub fn ai_UnicodeString_FromPlatform(
        string: *const ::std::os::raw::c_char,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nzero-terminated \\c char array whose encoding is the current platform encoding.\n@param string The \\c char array.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString12FromPlatformEPKc"]
    pub fn ai_UnicodeString_FromPlatform1(
        string: *const ::std::os::raw::c_char,
    ) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\n\\c std::string whose encoding is the current platform encoding.\n@param string The string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString12FromPlatformERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
    pub fn ai_UnicodeString_FromPlatform2(string: *const std_string) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nPascal string whose encoding is the current platform encoding.\n@param pascalString The Pascal string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString12FromPlatformERKNS_10const_PStrE"]
    pub fn ai_UnicodeString_FromPlatform3(pascalString: *const ai_const_PStr) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nzero-terminated \\c char array whose encoding is UTF8.\n@param string The \\c char array.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString8FromUTF8EPKc"]
    pub fn ai_UnicodeString_FromUTF8(string: *const ::std::os::raw::c_char) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\n\\c std::string whose encoding is UTF8.\n@param string The string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString8FromUTF8ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
    pub fn ai_UnicodeString_FromUTF81(string: *const std_string) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from a\nPascal string whose encoding is UTF8.\n@param pascalString The Pascal string.\n@return The Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString8FromUTF8ERKNS_10const_PStrE"]
    pub fn ai_UnicodeString_FromUTF82(pascalString: *const ai_const_PStr) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Appends a string to this string.\n@param str The string to append.\n@return A reference to this Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString6appendERKS0_"]
    pub fn ai_UnicodeString_append(
        this: *mut ai_UnicodeString,
        str_: *const ai_UnicodeString,
    ) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Appends a substring of a given string to this string.\n@param str The source string of the substring.\n@param startOffset The 0-based index of the first character in the substring.\n@param count The maximum number of characters in the substring.\n@return A reference to this Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString6appendERKS0_mm"]
    pub fn ai_UnicodeString_append1(
        this: *mut ai_UnicodeString,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Replaces the contents of this string with another string.\n@param str The new contents.\n@return A reference to this Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString6assignERKS0_"]
    pub fn ai_UnicodeString_assign(
        this: *mut ai_UnicodeString,
        str_: *const ai_UnicodeString,
    ) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the UTF32 code point (character) from a string by position index.\nRaises \\c #kUnicodeStringBadIndex exception if offset is out of range.\n@param offset The 0-based index of the character.\n@return The UTF32 value of the character."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString2atEm"]
    pub fn ai_UnicodeString_at(
        this: *const ai_UnicodeString,
        offset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_UTF32TextChar;
}
unsafe extern "C" {
    #[doc = " Erases all characters in this string. Same as <code>erase(0, npos)</code>.\nUninitialized strings remain unchanged.\n@return Nothing.\n@see \\c #erase()"]
    #[link_name = "\u{1}__ZN2ai13UnicodeString5clearEv"]
    pub fn ai_UnicodeString_clear(this: *mut ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Compares this string and another string for equality.\nUninitialized strings are equal to other uninitialized strings and\nto empty strings.Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param str The string to compare against (right side of compare)..\n@return  Zero if the two strings are equal.\n<br> Negative if this string is less than \\c str.\n<br> Positive if this string is greater than \\c str."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString7compareERKS0_"]
    pub fn ai_UnicodeString_compare(
        this: *const ai_UnicodeString,
        str_: *const ai_UnicodeString,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Compares this string and a substring of another string for equality.\nUninitialized strings are equal to other uninitialized strings and\nto empty strings.Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param pos The 0-based index of the first character of the substring.\n@param num The number of characters to compare.\n@param str The source of the substring to compare against (right side of compare)..\n@return  Zero if this string and the substring are equal.\n<br> Negative if this string is less than the substring of \\c str.\n<br> Positive if this string is greater than the substring of \\c str."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString7compareEmmRKS0_"]
    pub fn ai_UnicodeString_compare1(
        this: *const ai_UnicodeString,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Compares a substring of this string and a substring of another string for equality.\nUninitialized strings are equal to other uninitialized strings and\nto empty strings.Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param pos The 0-based index of the first character of the substring in this string.\n@param num The number of characters to compare in this string.\n@param str The source of the substring to compare against (right side of compare)..\n@param startOffset The 0-based index of the first character of the substring of \\c str.\n@param count The number of characters from \\c str to compare.\n@return  Zero if the two substrings are equal.\n<br> Negative if the substring of this string is less than the substring of \\c str.\n<br> Positive if the substring of this string is greater than the substring of \\c str."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString7compareEmmRKS0_mm"]
    pub fn ai_UnicodeString_compare2(
        this: *const ai_UnicodeString,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of characters (UTF code points) in this string.\n@return The number of UTF code points in this string."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString6lengthEv"]
    pub fn ai_UnicodeString_length(this: *const ai_UnicodeString) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Reports whether this string is an empty string.\n@return True if the string is empty."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString5emptyEv"]
    pub fn ai_UnicodeString_empty(this: *const ai_UnicodeString) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes characters (UTF code points) from this string.\n@param pos The 0-based position index of the first character to remove.\n@param count The number of characters to remove.\n@return A reference to this Unicode string object."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString5eraseEmm"]
    pub fn ai_UnicodeString_erase(
        this: *mut ai_UnicodeString,
        pos: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Searches for a character in this string.\n@param ch The character to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@return The 0-based position index of the found character, or\nthe number of characters in this string (\\c #npos)\nif the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString4findEjm"]
    pub fn ai_UnicodeString_find(
        this: *const ai_UnicodeString,
        ch: ai_UnicodeString_UTF32TextChar,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Searches for a string within a subset of this string.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@return The 0-based position index of the first character of the target\nstring within this string, if found,  or the number of\ncharacters in this string (\\c #npos)\nif the target string is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString4findERKS0_m"]
    pub fn ai_UnicodeString_find1(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Searches for a substring within a subset of this string.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in the target string to search for.\n@return The 0-based position index of the first character of the target\nsubstring within this string, if found,  or (\\c #npos)\nif the target substring is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString4findERKS0_mm"]
    pub fn ai_UnicodeString_find2(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Searches for a substring within a subset of this string, performing a caseless compare.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in the target string to search for.\n@return The 0-based position index of the first character of the target\nsubstring within this string, if found,  or  (\\c #npos)\nif the target substring is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString8caseFindERKS0_mm"]
    pub fn ai_UnicodeString_caseFind(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for a character in this string,\nmoving backward from a point in this string.\n@param ch The character to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@return The 0-based position index of the found character, or (\\c #npos)\nif the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString5rfindEjm"]
    pub fn ai_UnicodeString_rfind(
        this: *const ai_UnicodeString,
        ch: ai_UnicodeString_UTF32TextChar,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for a string within a subset of this string,\nmoving backward from a point in this string.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@return The 0-based position index of the first character of the target\nstring within this string, if found,  or (\\c #npos)\nif the target string is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString5rfindERKS0_m"]
    pub fn ai_UnicodeString_rfind1(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for a substring within a subset of this string,\nmoving backward from a point in this string.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in the target string to search for.\n@return The 0-based position index of the first character of the target\nsubstring within this string, if found,  or (\\c #npos)\nif the target substring is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString5rfindERKS0_mm"]
    pub fn ai_UnicodeString_rfind2(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for the first character of a string within a subset of this string.\n@param target The string to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in the substring to search.\n@return The 0-based position index of the first character of the target\nstring within this string, if found,  or (\\c #npos)\nif the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString13find_first_ofERKS0_mm"]
    pub fn ai_UnicodeString_find_first_of(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Searches for the last character of a string within a subset of this string.\n@param target The string containing the character to search for.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in this string in which to search.\n@return The 0-based position index of the last character of the target\nstring within this string, if found,  or (\\c #npos)\nif the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString12find_last_ofERKS0_mm"]
    pub fn ai_UnicodeString_find_last_of(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for the first occurrence in a subset of this string of a character\nthat is not in a target string.\n@param target The target string.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in this string to search.\n@return The 0-based position index of the character within this string,\nif found,  or (\\c #npos) if the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString17find_first_not_ofERKS0_mm"]
    pub fn ai_UnicodeString_find_first_not_of(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tSearches for the last occurrence in a subset of this string of a character\nthat is not in a target string.\n@param target The target string.\n@param startOffset The 0-based position index in this string at which to start the search.\n@param count The number of characters in this string to search.\n@return The 0-based position index of the character within this string,\nif found,  or (\\c #npos)\tif the character is not found."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString16find_last_not_ofERKS0_mm"]
    pub fn ai_UnicodeString_find_last_not_of(
        this: *const ai_UnicodeString,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Resizes this string, truncating it or adding characters as needed.\n@param count The new number of characters.\n@param ch The UTF code point value with which to initialize new elements,\nif the size of the string is increased.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString6resizeEmj"]
    pub fn ai_UnicodeString_resize(
        this: *mut ai_UnicodeString,
        count: ai_UnicodeString_size_type,
        ch: ai_UnicodeString_UTF32TextChar,
    );
}
unsafe extern "C" {
    #[doc = " Retrieves number of characters (UTF code points) that this string can hold without reallocation.\nThis may be the same as or more than \\c #length().\n@return The number of characters that can be held in this string without reallocation."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString8capacityEv"]
    pub fn ai_UnicodeString_capacity(this: *const ai_UnicodeString) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Request to change the capacity of this string to accommodate at least the specified number of characters.\nIf new capacity is greater than the current \\c #capacity(), new storage is allocated, and \\c #capacity()\nis made equal or greater than new capacity.\nIf new capacity is less than or equal to the current \\c #capacity(), there is no effect.\n@param count The new desired capacity of this string in number of characters.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString7reserveEm"]
    pub fn ai_UnicodeString_reserve(this: *mut ai_UnicodeString, count: ai_UnicodeString_size_type);
}
unsafe extern "C" {
    #[doc = " Creates a copy of a substring of this string.\n@param offset The 0-based position index of the first character\nto be copied to the substring.\n@param count The maximum number of characters to copy to the new substring.\n@return A \\c UnicodeString object containing the requested substring."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString6substrEmm"]
    pub fn ai_UnicodeString_substr(
        this: *const ai_UnicodeString,
        offset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Convert the characters in this to lower case following the conventions of\nthe default locale.\n@return A reference to this."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString7toLowerEv"]
    pub fn ai_UnicodeString_toLower(this: *mut ai_UnicodeString) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = "Convert the characters in this to UPPER CASE following the conventions of\nthe default locale.\n@return A reference to this."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString7toUpperEv"]
    pub fn ai_UnicodeString_toUpper(this: *mut ai_UnicodeString) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Compares a substring of this string with a substring of another string, doing a caseless\ncode-point-based comparison.\nUninitialized strings are equal to other uninitialized strings and\nempty strings. Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param pos The 0-based position index of the first character of\nthe substring of this string.\n@param num The number of characters in the substring of this string.\n@param str The comparison string (right side of compare).\n@param startOffset The 0-based position index of the first character of\nthe substring of the comparison string.\n@param count The number of characters in the substring of the comparison string.\n@return 0 if this substring and the comparison substring are equal.\n<br> Positive if this substring is greater than the comparison substring.\n<br> Negative if this substring is less than the comparison substring."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString11caseCompareEmmRKS0_mm"]
    pub fn ai_UnicodeString_caseCompare(
        this: *const ai_UnicodeString,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Compares this string with another string for canonical equivalence\nof their normalized forms (NFD or NFC).\tThis requires temporary\nallocation of memory, and can throw out-of-memory errors.\n\nUninitialized strings are equal to other uninitialized strings and\nempty strings. Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param str The comparison string (right side of compare).\n@return 0 if the strings are equal.\n<br> Positive if this string is greater than the comparison string.\n<br> Negative if this string is less than the comparison string.\n\n@note Substring comparison of non-normalized strings is not directly available.\nYou can create substrings and pass them to this method."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString16canonicalCompareERKS0_"]
    pub fn ai_UnicodeString_canonicalCompare(
        this: *const ai_UnicodeString,
        str_: *const ai_UnicodeString,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Compares this string with another string for canonical equivalence\nof their normalized forms (NFD or NFC), performing a caseless compare.\nThis requires temporary\tallocation of memory, and can throw out-of-memory errors.\n\nUninitialized strings are equal to other uninitialized strings and\nempty strings. Uninitialized and empty strings are less than initialized,\nnon-empty strings.\n@param str The comparison string (right side of compare).\n@return 0 if the strings are equal.\n<br> Positive if this string is greater than the comparison string.\n<br> Negative if this string is less than the comparison string.\n\n@note Substring comparison of non-normalized strings is not directly available.\nYou can create substrings and pass them to this method."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString20canonicalCaseCompareERKS0_"]
    pub fn ai_UnicodeString_canonicalCaseCompare(
        this: *const ai_UnicodeString,
        str_: *const ai_UnicodeString,
    ) -> ai_int32;
}
unsafe extern "C" {
    #[doc = " Normalizes this string in place into the specified form.\nNormalization may require re-allocation of the string.  If this happens,\nthe method can throw out-of-memory errors. On failure, this\nstring remains unmodified.\n@param form The form with which to normalize the string.\n@return A reference to this string."]
    #[link_name = "\u{1}__ZN2ai13UnicodeString9normalizeENS0_14NormalizedFormE"]
    pub fn ai_UnicodeString_normalize(
        this: *mut ai_UnicodeString,
        form: ai_UnicodeString_NormalizedForm,
    ) -> *mut ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Reports whether this string contains surrogate pairs.\n@return True if there are surrogate pairs in this string."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString13hasSurrogatesEv"]
    pub fn ai_UnicodeString_hasSurrogates(this: *const ai_UnicodeString) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a UTF-16 string from the contents of this string, in platform byte order.\nThis method does not allocate any memory, and returns in constant time.\n@param buffer A reference to a const pointer to \\c UTF16Char in which\nto return the contents of this string as UTF-16 code units. Can be\n0 if this string is empty.\nThis buffer pointer is only valid at most for the lifetime of this string.\nThe buffer is not guaranteed to be 0 terminated.\nUse \\c #as_ASUnicode() to guarantee a 0-terminated buffer.\n@return The number of UTF-16 characters in the returned buffer."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString6utf_16ERPKt"]
    pub fn ai_UnicodeString_utf_16(
        this: *const ai_UnicodeString,
        buffer: *mut *const ai_UnicodeString_UTF16Char,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Creates a 0-terminated UTF-16 string from the contents of this string,\nin platform byte order.\n@return The contents of this string as UTF-16 code units."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString12as_ASUnicodeEv"]
    pub fn ai_UnicodeString_as_ASUnicode(this: *const ai_UnicodeString) -> std_basic_string;
}
unsafe extern "C" {
    #[doc = "\tCopies the contents of this string to a provided buffer.  This method\nfollows the \\c strlcpy paradigm.\n@param buffer A pointer to a byte array in which to return the 0-terminated copy.\n@param bufferMax The maximum byte count to write to the buffer, including the 0 terminator,\nor \\c NULL to return the required size.\n@param encoding The encoding for the result.\n@return The size needed to write the entire string contents to a buffer,\nincluding a 0 terminator."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString11getToBufferEPcm19AICharacterEncoding"]
    pub fn ai_UnicodeString_getToBuffer(
        this: *const ai_UnicodeString,
        buffer: *mut ::std::os::raw::c_char,
        bufferMax: ai_UnicodeString_size_type,
        encoding: AICharacterEncoding,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tCopies the contents of this string to a Pascal string in a provided buffer.\n@param pascalString A pointer to a Pascal string in which to return the 0-terminated copy.\n@param bufferMax The maximum byte count to write to the buffer, including the 0 terminator,\nor \\c NULL to return the required size.\n@param encoding The encoding for the result.\n@return The size needed to write the entire string contents to a buffer,\nincluding a 0 terminator."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString11getToBufferERKNS_4PStrEm19AICharacterEncoding"]
    pub fn ai_UnicodeString_getToBuffer1(
        this: *const ai_UnicodeString,
        pascalString: *const ai_PStr,
        bufferMax: ai_UnicodeString_size_type,
        encoding: AICharacterEncoding,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = "\tCreates a \\c std::string from the contents of this string. Can throw\nan out-of-memory error.\n@param encoding The encoding for the result.\n@return The string result."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString14getInStdStringE19AICharacterEncoding"]
    pub fn ai_UnicodeString_getInStdString(
        this: *const ai_UnicodeString,
        encoding: AICharacterEncoding,
    ) -> std_string;
}
unsafe extern "C" {
    #[doc = "\tCopies the contents of this string to an \\c ai::AutoBuffer<char>.\n@param encoding The encoding for the result.\n@param b The buffer in which to return the result. The resulting\ncontents might not be 0 terminated.\n@return The number of characters (bytes) returned in the buffer."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString5getAsE19AICharacterEncodingRNS_10AutoBufferIcmNS_7SPAllocEEE"]
    pub fn ai_UnicodeString_getAs(
        this: *const ai_UnicodeString,
        encoding: AICharacterEncoding,
        b: *mut ai_AutoBuffer<::std::os::raw::c_char, ::std::os::raw::c_ulong>,
    ) -> ai_UnicodeString_size_type;
}
unsafe extern "C" {
    #[doc = " Converts the contents of this string to a Mac OS \\c CFString.\n@param alloc A valid \\c CFAllocatorRef for allocating the \\c CFString.\n@return An immutable \\c CFString object containing chars, or \\c NULL if there was a problem\ncreating the object. You must dispose of this object when it is no longer needed."]
    #[link_name = "\u{1}__ZNK2ai13UnicodeString11as_CFStringEPK13__CFAllocator"]
    pub fn ai_UnicodeString_as_CFString(
        this: *const ai_UnicodeString,
        alloc: CFAllocatorRef,
    ) -> CFStringRef;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai13UnicodeString10deleteImplEv"]
    pub fn ai_UnicodeString_deleteImpl(this: *mut ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Empty string constructor.  Creates a valid, empty string.  This method is guaranteed\nto not throw any exceptions."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1Ev"]
    pub fn ai_UnicodeString_UnicodeString(this: *mut ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString from an encoded byte array.\n@param string Array of bytes to construct from.\n@param srcByteLen Length of the array.\n@param encoding Encoding of the contents of the byte array. Default\nis the current platform encoding"]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EPKcl19AICharacterEncoding"]
    pub fn ai_UnicodeString_UnicodeString1(
        this: *mut ai_UnicodeString,
        string: *const ::std::os::raw::c_char,
        srcByteLen: ai_UnicodeString_offset_type,
        encoding: AICharacterEncoding,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a UnicodeString using a copies of a single character.\n@param count Number of characters to insert in this string.\n@param ch The UTF32 code point (character) with which to initialize the string."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1Emj"]
    pub fn ai_UnicodeString_UnicodeString2(
        this: *mut ai_UnicodeString,
        count: ai_UnicodeString_size_type,
        ch: ai_UnicodeString_UTF32TextChar,
    );
}
unsafe extern "C" {
    #[doc = " Convenience constructor from a \\c char buffer that is known to be 0 terminated.\n@param string Initial contents.\n@param encoding Encoding of the contents of the byte array."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EPKc19AICharacterEncoding"]
    pub fn ai_UnicodeString_UnicodeString3(
        this: *mut ai_UnicodeString,
        string: *const ::std::os::raw::c_char,
        encoding: AICharacterEncoding,
    );
}
unsafe extern "C" {
    #[doc = " Convenience constructor from a \\c std::string.\n@param string Initial contents.\n@param encoding Encoding of the contents of the byte array."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE19AICharacterEncoding"]
    pub fn ai_UnicodeString_UnicodeString4(
        this: *mut ai_UnicodeString,
        string: *const std_string,
        encoding: AICharacterEncoding,
    );
}
unsafe extern "C" {
    #[doc = " Constructor from 0-terminated, platform-byte-ordered, UTF-16 array.\nSurrogate pairs are okay. Exception raised if string is malformed.\n@param string Pointer to a valid 0-terminated array of UTF-16 \\c ASUnicode."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EPKt"]
    pub fn ai_UnicodeString_UnicodeString5(this: *mut ai_UnicodeString, string: *const ASUnicode);
}
unsafe extern "C" {
    #[doc = " Constructor from the ZString referred to by a ZString key.\n@param zStringKey The ZString key."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EPK10ZREFStruct"]
    pub fn ai_UnicodeString_UnicodeString6(this: *mut ai_UnicodeString, zStringKey: ZRef);
}
unsafe extern "C" {
    #[doc = " Constructor from a non-0-terminated platform-byte-ordered, UTF-16 array.\nSurrogate pairs are okay. Exception raised if string is malformed.\n@param string Pointer to an array of UTF-16 \\c ASUnicode.\n@param srcUTF16Count The number of UTF-16 code units to be read from string."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EPKtm"]
    pub fn ai_UnicodeString_UnicodeString7(
        this: *mut ai_UnicodeString,
        string: *const ASUnicode,
        srcUTF16Count: ai_UnicodeString_size_type,
    );
}
unsafe extern "C" {
    #[doc = " Constructor from a \\c std::basic_string of platform-byte-ordered \\c ASUnicode characters.\nSurrogate pairs are okay. Exception raised if string is malformed.\n@param string A \\c std::basic_string<ASUnicode>."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1ERKNSt3__112basic_stringItNS1_11char_traitsItEENS1_9allocatorItEEEE"]
    pub fn ai_UnicodeString_UnicodeString8(
        this: *mut ai_UnicodeString,
        string: *const std_basic_string,
    );
}
unsafe extern "C" {
    #[doc = " Copy Constructor, creates a copy of a string.\n@param s The string to copy."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1ERKS0_"]
    pub fn ai_UnicodeString_UnicodeString9(this: *mut ai_UnicodeString, s: *const ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Constructs a Unicode string object from a Mac OS \\c CFString.\n@param cfString The source \\c CFString."]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1ERKPK10__CFString"]
    pub fn ai_UnicodeString_UnicodeString10(
        this: *mut ai_UnicodeString,
        cfString: *const CFStringRef,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai13UnicodeStringC1EP20CAIUnicodeStringImpl"]
    pub fn ai_UnicodeString_UnicodeString11(
        this: *mut ai_UnicodeString,
        impl_: *mut CAIUnicodeStringImpl,
    );
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai13UnicodeStringD1Ev"]
    pub fn ai_UnicodeString_UnicodeString_destructor(this: *mut ai_UnicodeString);
}
impl ai_UnicodeString {
    #[inline]
    pub unsafe fn FromRoman(
        string: *const ::std::os::raw::c_char,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString {
        ai_UnicodeString_FromRoman(string, count)
    }
    #[inline]
    pub unsafe fn FromRoman1(string: *const ::std::os::raw::c_char) -> ai_UnicodeString {
        ai_UnicodeString_FromRoman1(string)
    }
    #[inline]
    pub unsafe fn FromRoman2(string: *const std_string) -> ai_UnicodeString {
        ai_UnicodeString_FromRoman2(string)
    }
    #[inline]
    pub unsafe fn FromRoman3(pascalString: *const ai_const_PStr) -> ai_UnicodeString {
        ai_UnicodeString_FromRoman3(pascalString)
    }
    #[inline]
    pub unsafe fn FromPlatform(
        string: *const ::std::os::raw::c_char,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString {
        ai_UnicodeString_FromPlatform(string, count)
    }
    #[inline]
    pub unsafe fn FromPlatform1(string: *const ::std::os::raw::c_char) -> ai_UnicodeString {
        ai_UnicodeString_FromPlatform1(string)
    }
    #[inline]
    pub unsafe fn FromPlatform2(string: *const std_string) -> ai_UnicodeString {
        ai_UnicodeString_FromPlatform2(string)
    }
    #[inline]
    pub unsafe fn FromPlatform3(pascalString: *const ai_const_PStr) -> ai_UnicodeString {
        ai_UnicodeString_FromPlatform3(pascalString)
    }
    #[inline]
    pub unsafe fn FromUTF8(string: *const ::std::os::raw::c_char) -> ai_UnicodeString {
        ai_UnicodeString_FromUTF8(string)
    }
    #[inline]
    pub unsafe fn FromUTF81(string: *const std_string) -> ai_UnicodeString {
        ai_UnicodeString_FromUTF81(string)
    }
    #[inline]
    pub unsafe fn FromUTF82(pascalString: *const ai_const_PStr) -> ai_UnicodeString {
        ai_UnicodeString_FromUTF82(pascalString)
    }
    #[inline]
    pub unsafe fn append(&mut self, str_: *const ai_UnicodeString) -> *mut ai_UnicodeString {
        ai_UnicodeString_append(self, str_)
    }
    #[inline]
    pub unsafe fn append1(
        &mut self,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> *mut ai_UnicodeString {
        ai_UnicodeString_append1(self, str_, startOffset, count)
    }
    #[inline]
    pub unsafe fn assign(&mut self, str_: *const ai_UnicodeString) -> *mut ai_UnicodeString {
        ai_UnicodeString_assign(self, str_)
    }
    #[inline]
    pub unsafe fn at(&self, offset: ai_UnicodeString_size_type) -> ai_UnicodeString_UTF32TextChar {
        ai_UnicodeString_at(self, offset)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        ai_UnicodeString_clear(self)
    }
    #[inline]
    pub unsafe fn compare(&self, str_: *const ai_UnicodeString) -> ai_int32 {
        ai_UnicodeString_compare(self, str_)
    }
    #[inline]
    pub unsafe fn compare1(
        &self,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
    ) -> ai_int32 {
        ai_UnicodeString_compare1(self, pos, num, str_)
    }
    #[inline]
    pub unsafe fn compare2(
        &self,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_int32 {
        ai_UnicodeString_compare2(self, pos, num, str_, startOffset, count)
    }
    #[inline]
    pub unsafe fn length(&self) -> ai_UnicodeString_size_type {
        ai_UnicodeString_length(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        ai_UnicodeString_empty(self)
    }
    #[inline]
    pub unsafe fn erase(
        &mut self,
        pos: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> *mut ai_UnicodeString {
        ai_UnicodeString_erase(self, pos, count)
    }
    #[inline]
    pub unsafe fn find(
        &self,
        ch: ai_UnicodeString_UTF32TextChar,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find(self, ch, startOffset)
    }
    #[inline]
    pub unsafe fn find1(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find1(self, target, startOffset)
    }
    #[inline]
    pub unsafe fn find2(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find2(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn caseFind(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_caseFind(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn rfind(
        &self,
        ch: ai_UnicodeString_UTF32TextChar,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_rfind(self, ch, startOffset)
    }
    #[inline]
    pub unsafe fn rfind1(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_rfind1(self, target, startOffset)
    }
    #[inline]
    pub unsafe fn rfind2(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_rfind2(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn find_first_of(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find_first_of(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn find_last_of(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find_last_of(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn find_first_not_of(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find_first_not_of(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn find_last_not_of(
        &self,
        target: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_find_last_not_of(self, target, startOffset, count)
    }
    #[inline]
    pub unsafe fn resize(
        &mut self,
        count: ai_UnicodeString_size_type,
        ch: ai_UnicodeString_UTF32TextChar,
    ) {
        ai_UnicodeString_resize(self, count, ch)
    }
    #[inline]
    pub unsafe fn capacity(&self) -> ai_UnicodeString_size_type {
        ai_UnicodeString_capacity(self)
    }
    #[inline]
    pub unsafe fn reserve(&mut self, count: ai_UnicodeString_size_type) {
        ai_UnicodeString_reserve(self, count)
    }
    #[inline]
    pub unsafe fn substr(
        &self,
        offset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_UnicodeString {
        ai_UnicodeString_substr(self, offset, count)
    }
    #[inline]
    pub unsafe fn toLower(&mut self) -> *mut ai_UnicodeString {
        ai_UnicodeString_toLower(self)
    }
    #[inline]
    pub unsafe fn toUpper(&mut self) -> *mut ai_UnicodeString {
        ai_UnicodeString_toUpper(self)
    }
    #[inline]
    pub unsafe fn caseCompare(
        &self,
        pos: ai_UnicodeString_size_type,
        num: ai_UnicodeString_size_type,
        str_: *const ai_UnicodeString,
        startOffset: ai_UnicodeString_size_type,
        count: ai_UnicodeString_size_type,
    ) -> ai_int32 {
        ai_UnicodeString_caseCompare(self, pos, num, str_, startOffset, count)
    }
    #[inline]
    pub unsafe fn canonicalCompare(&self, str_: *const ai_UnicodeString) -> ai_int32 {
        ai_UnicodeString_canonicalCompare(self, str_)
    }
    #[inline]
    pub unsafe fn canonicalCaseCompare(&self, str_: *const ai_UnicodeString) -> ai_int32 {
        ai_UnicodeString_canonicalCaseCompare(self, str_)
    }
    #[inline]
    pub unsafe fn normalize(
        &mut self,
        form: ai_UnicodeString_NormalizedForm,
    ) -> *mut ai_UnicodeString {
        ai_UnicodeString_normalize(self, form)
    }
    #[inline]
    pub unsafe fn hasSurrogates(&self) -> bool {
        ai_UnicodeString_hasSurrogates(self)
    }
    #[inline]
    pub unsafe fn utf_16(
        &self,
        buffer: *mut *const ai_UnicodeString_UTF16Char,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_utf_16(self, buffer)
    }
    #[inline]
    pub unsafe fn as_ASUnicode(&self) -> std_basic_string {
        ai_UnicodeString_as_ASUnicode(self)
    }
    #[inline]
    pub unsafe fn getToBuffer(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        bufferMax: ai_UnicodeString_size_type,
        encoding: AICharacterEncoding,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_getToBuffer(self, buffer, bufferMax, encoding)
    }
    #[inline]
    pub unsafe fn getToBuffer1(
        &self,
        pascalString: *const ai_PStr,
        bufferMax: ai_UnicodeString_size_type,
        encoding: AICharacterEncoding,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_getToBuffer1(self, pascalString, bufferMax, encoding)
    }
    #[inline]
    pub unsafe fn getInStdString(&self, encoding: AICharacterEncoding) -> std_string {
        ai_UnicodeString_getInStdString(self, encoding)
    }
    #[inline]
    pub unsafe fn getAs(
        &self,
        encoding: AICharacterEncoding,
        b: *mut ai_AutoBuffer<::std::os::raw::c_char, ::std::os::raw::c_ulong>,
    ) -> ai_UnicodeString_size_type {
        ai_UnicodeString_getAs(self, encoding, b)
    }
    #[inline]
    pub unsafe fn as_CFString(&self, alloc: CFAllocatorRef) -> CFStringRef {
        ai_UnicodeString_as_CFString(self, alloc)
    }
    #[inline]
    pub unsafe fn deleteImpl(&mut self) {
        ai_UnicodeString_deleteImpl(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        string: *const ::std::os::raw::c_char,
        srcByteLen: ai_UnicodeString_offset_type,
        encoding: AICharacterEncoding,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString1(__bindgen_tmp.as_mut_ptr(), string, srcByteLen, encoding);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        count: ai_UnicodeString_size_type,
        ch: ai_UnicodeString_UTF32TextChar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString2(__bindgen_tmp.as_mut_ptr(), count, ch);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        string: *const ::std::os::raw::c_char,
        encoding: AICharacterEncoding,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString3(__bindgen_tmp.as_mut_ptr(), string, encoding);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(string: *const std_string, encoding: AICharacterEncoding) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString4(__bindgen_tmp.as_mut_ptr(), string, encoding);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(string: *const ASUnicode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString5(__bindgen_tmp.as_mut_ptr(), string);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(zStringKey: ZRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString6(__bindgen_tmp.as_mut_ptr(), zStringKey);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(
        string: *const ASUnicode,
        srcUTF16Count: ai_UnicodeString_size_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString7(__bindgen_tmp.as_mut_ptr(), string, srcUTF16Count);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(string: *const std_basic_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString8(__bindgen_tmp.as_mut_ptr(), string);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new9(s: *const ai_UnicodeString) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString9(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new10(cfString: *const CFStringRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString10(__bindgen_tmp.as_mut_ptr(), cfString);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new11(impl_: *mut CAIUnicodeStringImpl) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_UnicodeString_UnicodeString11(__bindgen_tmp.as_mut_ptr(), impl_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_UnicodeString_UnicodeString_destructor(self)
    }
}
#[doc = " struct to keep list of the UUIDs of inserted, removed, and modified objects"]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtObjectsChangedData {
    pub insertedObjList: ai_AutoBuffer<ai_uuid, ::std::os::raw::c_ulong>,
    pub removedObjList: ai_AutoBuffer<ai_uuid, ::std::os::raw::c_ulong>,
    pub modifiedObjList: ai_AutoBuffer<ai_uuid, ::std::os::raw::c_ulong>,
}
#[doc = " struct for notification data of <b>kAIArtObjectsChangedNotifier</b>"]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtObjectsChangedNotifierData {
    pub artObjsChangedData: ai_ArtObjectsChangedData,
    pub refStamp: usize,
}
#[doc = " This class represents an Illustrator color space."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ColorSpace {
    pub fImpl: *mut CAIColorSpaceImpl,
}
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyUnknown: ai_ColorSpace_Family = 0;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyGray: ai_ColorSpace_Family = 1;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyRGB: ai_ColorSpace_Family = 2;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyLab: ai_ColorSpace_Family = 3;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyCMYK: ai_ColorSpace_Family = 4;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilySeparation: ai_ColorSpace_Family = 5;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyNChannel: ai_ColorSpace_Family = 6;
pub const ai_ColorSpace_Family_kAIColorSpaceFamilyIndexed: ai_ColorSpace_Family = 7;
pub type ai_ColorSpace_Family = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Reports whether this color space is valid.\n@return True if the color space is valid, false otherwise."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace7IsValidEv"]
    pub fn ai_ColorSpace_IsValid(this: *const ai_ColorSpace) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves the family of this color space.\n@return The color space family constant."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace9GetFamilyEv"]
    pub fn ai_ColorSpace_GetFamily(this: *const ai_ColorSpace) -> ai_ColorSpace_Family;
}
unsafe extern "C" {
    #[doc = " Reports whether this color space has an alpha channel.\nAn indexed color space has an alpha channel if and only if\nits base color space has an alpha channel.\n@return True if the color space has an alpha channel, false otherwise."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace8HasAlphaEv"]
    pub fn ai_ColorSpace_HasAlpha(this: *const ai_ColorSpace) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of components in this color space, including the alpha channel\nif present. An indexed color space has only one component in addition to the\npossible alpha component (not the number of color components in the base color space).\n@return The number of components."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace13NumComponentsEv"]
    pub fn ai_ColorSpace_NumComponents(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of color components in this color space, excluding the alpha channel\nif present. For an indexed color space, this is the number of color components\nin its base color space.\n@return The number of color components."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace18NumColorComponentsEv"]
    pub fn ai_ColorSpace_NumColorComponents(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of spot components in this color space. Ignores\nthe alpha channel, if present.\n@return 0 for CMYK, RGB, Gray, Lab, and process separations.\n<br> 1 for  spot separations\n<br> For an Indexed color space, the number of spot color components in its base color space."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace17NumSpotComponentsEv"]
    pub fn ai_ColorSpace_NumSpotComponents(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of process components in this color space,\nwhich is the number of color components, minus the number of spot components.\n@return The number of process components."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace20NumProcessComponentsEv"]
    pub fn ai_ColorSpace_NumProcessComponents(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the base color space for this indexed color space, or\nthe alternate color space for this separation or n-channel color space.\n@return The base or alternate color space, or, for a standard\ncolor space, this color space itself."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace14BaseColorSpaceEv"]
    pub fn ai_ColorSpace_BaseColorSpace(this: *const ai_ColorSpace) -> ai_ColorSpace;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of components in the index color table of this\nindexed color space.\nThrows bad-parameter error for non-indexed color spaces.\n@return The number of color table components."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace20IndexedNumComponentsEv"]
    pub fn ai_ColorSpace_IndexedNumComponents(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of entries in the index color table of this\nindexed color space.\nThrows bad-parameter error for non-indexed color spaces.\n@return The number of color table entries."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace17IndexedNumEntriesEv"]
    pub fn ai_ColorSpace_IndexedNumEntries(this: *const ai_ColorSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the color table of this indexed color space.\nThrows bad-parameter error for non-indexed color spaces.\n@return A pointer to the color table."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace12IndexedTableEv"]
    pub fn ai_ColorSpace_IndexedTable(this: *const ai_ColorSpace) -> *const ASUInt8;
}
unsafe extern "C" {
    #[doc = " Retrieves an entry from the color table of this indexed color space.\n@param index The 0-based index position of the entry.\n@return A pointer to the entry, or \\c NULL if the index is out of range."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace13IndexedColorsEh"]
    pub fn ai_ColorSpace_IndexedColors(
        this: *const ai_ColorSpace,
        index: ASUInt8,
    ) -> *const ASUInt8;
}
unsafe extern "C" {
    #[doc = "\tRetrieves the alternate color values in the alternate color space\nfor this separation color space.\nThrows bad-parameter error for non-separation color spaces.\n@return A pointer to the array of color values."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace19SeparationAltColorsEv"]
    pub fn ai_ColorSpace_SeparationAltColors(this: *const ai_ColorSpace) -> *const AIFloat;
}
unsafe extern "C" {
    #[doc = " Retrieves the fully-specified color space list for this color space.\nThrows bad-parameter error if this is an indexed color space.\n@return The color space list object."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace17GetColorSpaceListEv"]
    pub fn ai_ColorSpace_GetColorSpaceList(this: *const ai_ColorSpace) -> ai_ColorSpaceList;
}
unsafe extern "C" {
    #[doc = " Retrieves the name of a colorant for this color space.\nThrows bad-parameter error if index is out of range.\n@param n The 0-based index of the colorant, less than \\c NumColorComponents().\n@return  \"Gray\" for Gray color spaces.\n<br> \"Red\",\"Green\", or \"Blue\" for RGB color spaces.\n<br> \"Cyan\",\"Magenta\",\"Yellow\", or \"Black\" for CMYK color spaces.\n<br> Empty strings for LAB color spaces."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace11NthColorantEi"]
    pub fn ai_ColorSpace_NthColorant(this: *const ai_ColorSpace, n: ai_int32) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Reports whether this color space has all process components.\n@return True if the color space has all process components\n<br> False if the color space has no process components, or\nfor  spot, separation, or process separation color spaces."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace29HasFullSetOfProcessComponentsEv"]
    pub fn ai_ColorSpace_HasFullSetOfProcessComponents(this: *const ai_ColorSpace) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves the name of a family for this color space as a string.\n@return kBadParameterErr if the color space is undefined.\n@param familyStr This is updated with \"Grayscale\", \"RGB\", \"CMYK\", \"Lab\", \"Separation\", \"DeviceN\", \"Indexed\" based on the family."]
    #[link_name = "\u{1}__ZNK2ai10ColorSpace14GetFamilyAsStrERNS_13UnicodeStringE"]
    pub fn ai_ColorSpace_GetFamilyAsStr(
        this: *const ai_ColorSpace,
        familyStr: *mut ai_UnicodeString,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai10ColorSpace10deleteImplEv"]
    pub fn ai_ColorSpace_deleteImpl(this: *mut ai_ColorSpace);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai10ColorSpace7getImplEv"]
    pub fn ai_ColorSpace_getImpl(this: *const ai_ColorSpace) -> *const CAIColorSpaceImpl;
}
unsafe extern "C" {
    #[doc = " Constructs an empty, invalid color space object. Throws no exceptions."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1Ev"]
    pub fn ai_ColorSpace_ColorSpace(this: *mut ai_ColorSpace);
}
unsafe extern "C" {
    #[doc = " Constructs a standard color space object.\n@param family The color space family (Gray, RGB, CMYK, or LAB).\n@param hasAlpha True if alpha channel is present.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1ENS0_6FamilyEb"]
    pub fn ai_ColorSpace_ColorSpace1(
        this: *mut ai_ColorSpace,
        family: ai_ColorSpace_Family,
        hasAlpha: bool,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a process separation color space.\n@param separationNum Process-separation plate number of the base CMYK color space.\n<br>0: Cyan\n<br>1: Magenta\n<br>2: Yellow\n<br>3: Black\n@param hasAlpha True if alpha channel is present.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1Eib"]
    pub fn ai_ColorSpace_ColorSpace2(
        this: *mut ai_ColorSpace,
        separationNum: ::std::os::raw::c_int,
        hasAlpha: bool,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a color space based on the global custom color.\n@param customColor The global custom color object.\n@param hasAlpha True if alpha channel is present.\n@return The new global process color space object, or, if the custom color is a spot color,\na spot separation color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1EPvb"]
    pub fn ai_ColorSpace_ColorSpace3(
        this: *mut ai_ColorSpace,
        customColor: AICustomColorHandle,
        hasAlpha: bool,
    );
}
unsafe extern "C" {
    #[doc = " Constructs an n-channel color space using a fully specified color space list.\n@param csList The list of component color spaces, which must conform to all\nrequirements of an n-channel color space, including at most one process\ncolor space and no duplicate channels, with all RGB or Lab channels present\nand in order.\n@param hasAlpha True if alpha channel is present.\n@param promoteToProcess True to construct an equivalent process color space instead\nof a NChannel color space if it is possible. For example, if the input color\nspace list contains the full process components and has no spot components,\nan equivalent process color space representation exists and is returned.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1ERKNS_14ColorSpaceListEbb"]
    pub fn ai_ColorSpace_ColorSpace4(
        this: *mut ai_ColorSpace,
        csList: *const ai_ColorSpaceList,
        hasAlpha: bool,
        promoteToProcess: bool,
    );
}
unsafe extern "C" {
    #[doc = " Constructs an indexed color space.\n@param baseCs The base color space of the indexed color space.\n@param numComponents The number of components in the color lookup table.\nFor an RGB indexed table, can be 3 or 4.\n@param numEntries number of entries in the color lookup table.\n@param lookup The color lookup table, \\c numComponents rows by\n\\c numEntries columns.  A 4-component RGB table must\nbe in 0RGB byte order.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1ERKS0_iiPKh"]
    pub fn ai_ColorSpace_ColorSpace5(
        this: *mut ai_ColorSpace,
        baseCs: *const ai_ColorSpace,
        numComponents: ::std::os::raw::c_int,
        numEntries: ::std::os::raw::c_int,
        lookup: *const ASUInt8,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a color space based on another color space. The alpha channel, if present,\nis ignored in constructing the new color space.\n@param baseCs The input color space.\n@param hasAlpha True if alpha channel is to be present in the new color space.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1ERKS0_b"]
    pub fn ai_ColorSpace_ColorSpace6(
        this: *mut ai_ColorSpace,
        baseCs: *const ai_ColorSpace,
        hasAlpha: bool,
    );
}
unsafe extern "C" {
    #[doc = " Copy constructor.\n@param cs the color space to copy.\n@return The new color space object."]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1ERKS0_"]
    pub fn ai_ColorSpace_ColorSpace7(this: *mut ai_ColorSpace, cs: *const ai_ColorSpace);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai10ColorSpaceC1EP17CAIColorSpaceImpl"]
    pub fn ai_ColorSpace_ColorSpace8(this: *mut ai_ColorSpace, impl_: *mut CAIColorSpaceImpl);
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai10ColorSpaceD1Ev"]
    pub fn ai_ColorSpace_ColorSpace_destructor(this: *mut ai_ColorSpace);
}
impl ai_ColorSpace {
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        ai_ColorSpace_IsValid(self)
    }
    #[inline]
    pub unsafe fn GetFamily(&self) -> ai_ColorSpace_Family {
        ai_ColorSpace_GetFamily(self)
    }
    #[inline]
    pub unsafe fn HasAlpha(&self) -> bool {
        ai_ColorSpace_HasAlpha(self)
    }
    #[inline]
    pub unsafe fn NumComponents(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_NumComponents(self)
    }
    #[inline]
    pub unsafe fn NumColorComponents(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_NumColorComponents(self)
    }
    #[inline]
    pub unsafe fn NumSpotComponents(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_NumSpotComponents(self)
    }
    #[inline]
    pub unsafe fn NumProcessComponents(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_NumProcessComponents(self)
    }
    #[inline]
    pub unsafe fn BaseColorSpace(&self) -> ai_ColorSpace {
        ai_ColorSpace_BaseColorSpace(self)
    }
    #[inline]
    pub unsafe fn IndexedNumComponents(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_IndexedNumComponents(self)
    }
    #[inline]
    pub unsafe fn IndexedNumEntries(&self) -> ::std::os::raw::c_int {
        ai_ColorSpace_IndexedNumEntries(self)
    }
    #[inline]
    pub unsafe fn IndexedTable(&self) -> *const ASUInt8 {
        ai_ColorSpace_IndexedTable(self)
    }
    #[inline]
    pub unsafe fn IndexedColors(&self, index: ASUInt8) -> *const ASUInt8 {
        ai_ColorSpace_IndexedColors(self, index)
    }
    #[inline]
    pub unsafe fn SeparationAltColors(&self) -> *const AIFloat {
        ai_ColorSpace_SeparationAltColors(self)
    }
    #[inline]
    pub unsafe fn GetColorSpaceList(&self) -> ai_ColorSpaceList {
        ai_ColorSpace_GetColorSpaceList(self)
    }
    #[inline]
    pub unsafe fn NthColorant(&self, n: ai_int32) -> ai_UnicodeString {
        ai_ColorSpace_NthColorant(self, n)
    }
    #[inline]
    pub unsafe fn HasFullSetOfProcessComponents(&self) -> bool {
        ai_ColorSpace_HasFullSetOfProcessComponents(self)
    }
    #[inline]
    pub unsafe fn GetFamilyAsStr(&self, familyStr: *mut ai_UnicodeString) -> ASErr {
        ai_ColorSpace_GetFamilyAsStr(self, familyStr)
    }
    #[inline]
    pub unsafe fn deleteImpl(&mut self) {
        ai_ColorSpace_deleteImpl(self)
    }
    #[inline]
    pub unsafe fn getImpl(&self) -> *const CAIColorSpaceImpl {
        ai_ColorSpace_getImpl(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(family: ai_ColorSpace_Family, hasAlpha: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace1(__bindgen_tmp.as_mut_ptr(), family, hasAlpha);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(separationNum: ::std::os::raw::c_int, hasAlpha: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace2(__bindgen_tmp.as_mut_ptr(), separationNum, hasAlpha);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(customColor: AICustomColorHandle, hasAlpha: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace3(__bindgen_tmp.as_mut_ptr(), customColor, hasAlpha);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        csList: *const ai_ColorSpaceList,
        hasAlpha: bool,
        promoteToProcess: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace4(
            __bindgen_tmp.as_mut_ptr(),
            csList,
            hasAlpha,
            promoteToProcess,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        baseCs: *const ai_ColorSpace,
        numComponents: ::std::os::raw::c_int,
        numEntries: ::std::os::raw::c_int,
        lookup: *const ASUInt8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace5(
            __bindgen_tmp.as_mut_ptr(),
            baseCs,
            numComponents,
            numEntries,
            lookup,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(baseCs: *const ai_ColorSpace, hasAlpha: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace6(__bindgen_tmp.as_mut_ptr(), baseCs, hasAlpha);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(cs: *const ai_ColorSpace) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace7(__bindgen_tmp.as_mut_ptr(), cs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(impl_: *mut CAIColorSpaceImpl) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpace_ColorSpace8(__bindgen_tmp.as_mut_ptr(), impl_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_ColorSpace_ColorSpace_destructor(self)
    }
}
#[doc = "\tThis class represents a list of color spaces for Illustrator."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ColorSpaceList {
    pub fImpl: *mut CAIColorSpaceListImpl,
}
unsafe extern "C" {
    #[doc = " Reports whether this color-space list is valid.\n@return True if the list is valid."]
    #[link_name = "\u{1}__ZNK2ai14ColorSpaceList7IsValidEv"]
    pub fn ai_ColorSpaceList_IsValid(this: *const ai_ColorSpaceList) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a color-space entry to this color-space list.\n@param cs The color-space list object to add.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceList13AddColorSpaceERKNS_10ColorSpaceE"]
    pub fn ai_ColorSpaceList_AddColorSpace(this: *mut ai_ColorSpaceList, cs: *const ai_ColorSpace);
}
unsafe extern "C" {
    #[doc = " Reports the number of color-space entries in this list.\n@return The number of entries."]
    #[link_name = "\u{1}__ZNK2ai14ColorSpaceList14NumColorSpacesEv"]
    pub fn ai_ColorSpaceList_NumColorSpaces(
        this: *const ai_ColorSpaceList,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves a color space from this list.\nThrows bad-parameter error if index is out of range.\n@param n The 0-based index of the color-space entry.\n@return The color-space object."]
    #[link_name = "\u{1}__ZNK2ai14ColorSpaceList13NthColorSpaceEi"]
    pub fn ai_ColorSpaceList_NthColorSpace(
        this: *const ai_ColorSpaceList,
        n: ::std::os::raw::c_int,
    ) -> ai_ColorSpace;
}
unsafe extern "C" {
    #[doc = " Normalizes this color-space list by flattening any n-channel color-spaces,\nremoving duplicates, compacting 4-process separation color spaces\ninto a single CMYK process color space, and sorting the color spaces.\nThe order of the spot-separation color spaces is preserved.\n@param docColorModel The document color model, an \\c #AIDocumentColorModelValue.\n@param convertGrayToFullProcess Optional. When false (the default), if the document\ncolor model is CMYK, a gray color space is converted to separation Black.\nOtherwise, a gray color space is converted to the full process color in the\ndocument color space.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceList9NormalizeEsb"]
    pub fn ai_ColorSpaceList_Normalize(
        this: *mut ai_ColorSpaceList,
        docColorModel: ::std::os::raw::c_short,
        convertGrayToFullProcess: bool,
    );
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceList10deleteImplEv"]
    pub fn ai_ColorSpaceList_deleteImpl(this: *mut ai_ColorSpaceList);
}
unsafe extern "C" {
    #[doc = " Default color space list constructor.\nCreates an invalid color space list.\nThrows no exceptions.\n@return The new list object."]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceListC1Ev"]
    pub fn ai_ColorSpaceList_ColorSpaceList(this: *mut ai_ColorSpaceList);
}
unsafe extern "C" {
    #[doc = " Creates a color space list containing an initial color space entry.\n@param cs The initial color space object.\n@return The new list object."]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceListC1ERKNS_10ColorSpaceE"]
    pub fn ai_ColorSpaceList_ColorSpaceList1(
        this: *mut ai_ColorSpaceList,
        cs: *const ai_ColorSpace,
    );
}
unsafe extern "C" {
    #[doc = " Copy constructor.\n@param csList The color-space list object to copy.\n@return The new list object."]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceListC1ERKS0_"]
    pub fn ai_ColorSpaceList_ColorSpaceList2(
        this: *mut ai_ColorSpaceList,
        csList: *const ai_ColorSpaceList,
    );
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai14ColorSpaceListD1Ev"]
    pub fn ai_ColorSpaceList_ColorSpaceList_destructor(this: *mut ai_ColorSpaceList);
}
impl ai_ColorSpaceList {
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        ai_ColorSpaceList_IsValid(self)
    }
    #[inline]
    pub unsafe fn AddColorSpace(&mut self, cs: *const ai_ColorSpace) {
        ai_ColorSpaceList_AddColorSpace(self, cs)
    }
    #[inline]
    pub unsafe fn NumColorSpaces(&self) -> ::std::os::raw::c_int {
        ai_ColorSpaceList_NumColorSpaces(self)
    }
    #[inline]
    pub unsafe fn NthColorSpace(&self, n: ::std::os::raw::c_int) -> ai_ColorSpace {
        ai_ColorSpaceList_NthColorSpace(self, n)
    }
    #[inline]
    pub unsafe fn Normalize(
        &mut self,
        docColorModel: ::std::os::raw::c_short,
        convertGrayToFullProcess: bool,
    ) {
        ai_ColorSpaceList_Normalize(self, docColorModel, convertGrayToFullProcess)
    }
    #[inline]
    pub unsafe fn deleteImpl(&mut self) {
        ai_ColorSpaceList_deleteImpl(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpaceList_ColorSpaceList(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cs: *const ai_ColorSpace) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpaceList_ColorSpaceList1(__bindgen_tmp.as_mut_ptr(), cs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(csList: *const ai_ColorSpaceList) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ColorSpaceList_ColorSpaceList2(__bindgen_tmp.as_mut_ptr(), csList);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_ColorSpaceList_ColorSpaceList_destructor(self)
    }
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai19SPBasicAcquireSuiteEPKciPPKv"]
    pub fn ai_SPBasicAcquireSuite(
        name: *const ::std::os::raw::c_char,
        version: ai_int32,
        suite: *mut *const ::std::os::raw::c_void,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai19SPBasicReleaseSuiteEPKci"]
    pub fn ai_SPBasicReleaseSuite(name: *const ::std::os::raw::c_char, version: ai_int32) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai14SPBasicIsEqualEPKcS1_"]
    pub fn ai_SPBasicIsEqual(
        token1: *const ::std::os::raw::c_char,
        token2: *const ::std::os::raw::c_char,
    ) -> SPBoolean;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai20SPBasicAllocateBlockEmPPv"]
    pub fn ai_SPBasicAllocateBlock(size: usize, block: *mut *mut ::std::os::raw::c_void) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai16SPBasicFreeBlockEPv"]
    pub fn ai_SPBasicFreeBlock(block: *mut ::std::os::raw::c_void) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai22SPBasicReallocateBlockEPvmPS0_"]
    pub fn ai_SPBasicReallocateBlock(
        block: *mut ::std::os::raw::c_void,
        newSize: usize,
        newblock: *mut *mut ::std::os::raw::c_void,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai16SPBasicUndefinedEv"]
    pub fn ai_SPBasicUndefined() -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai18SPSubAllocateBlockEmPPv"]
    pub fn ai_SPSubAllocateBlock(size: usize, block: *mut *mut ::std::os::raw::c_void) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai14SPSubFreeBlockEPv"]
    pub fn ai_SPSubFreeBlock(block: *mut ::std::os::raw::c_void) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    #[link_name = "\u{1}__ZN2ai20SPSubReallocateBlockEPvmPS0_"]
    pub fn ai_SPSubReallocateBlock(
        block: *mut ::std::os::raw::c_void,
        newSize: usize,
        newblock: *mut *mut ::std::os::raw::c_void,
    ) -> SPErr;
}
#[repr(C)]
#[derive(Debug)]
pub struct ai_FilePath {
    pub impl_: *mut FilePathImpl,
}
unsafe extern "C" {
    #[doc = " Resets cached information about volumes, used to increase\nthe efficiency of filesystem operations.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath16ResetVolumeCacheEv"]
    pub fn ai_FilePath_ResetVolumeCache();
}
unsafe extern "C" {
    #[doc = " Reports whether a file-path object is empty.\n@return True if the object is empty."]
    #[link_name = "\u{1}__ZNK2ai8FilePath7IsEmptyEv"]
    pub fn ai_FilePath_IsEmpty(this: *const ai_FilePath) -> bool;
}
unsafe extern "C" {
    #[doc = " Sets the referenced path of this object to a \\c NULL path.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath9MakeEmptyEv"]
    pub fn ai_FilePath_MakeEmpty(this: *mut ai_FilePath);
}
unsafe extern "C" {
    #[doc = " Compares this file path to another for equality.\n@param filePath The path object to compare to this one\n@param resolveLinks\tOptional. True to resolve links, aliases, and/or shortcuts\nif the paths are not identical. Default is false.\n@return True if the paths are identical, whether or not the file exists,\nor if links are resolved and the two paths refer to the same file.\n<br> False if the paths are not identical and \\c resolveLinks is false."]
    #[link_name = "\u{1}__ZNK2ai8FilePath5EqualERKS0_b"]
    pub fn ai_FilePath_Equal(
        this: *const ai_FilePath,
        filePath: *const ai_FilePath,
        resolveLinks: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Reports whether this path starts with a delimiter, and\nis therefore an absolute, not relative, path.\n@return True if the path starts with a delimiter"]
    #[link_name = "\u{1}__ZNK2ai8FilePath19StartsWithDelimiterEv"]
    pub fn ai_FilePath_StartsWithDelimiter(this: *const ai_FilePath) -> bool;
}
unsafe extern "C" {
    #[doc = " Reports whether this path ends with a delimiter, and\ntherefore references a folder or directory, rather than a file.\n@return True if the path ends with a delimiter"]
    #[link_name = "\u{1}__ZNK2ai8FilePath17EndsWithDelimiterEv"]
    pub fn ai_FilePath_EndsWithDelimiter(this: *const ai_FilePath) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a component to this path. Adds or ignores appropriate delimiters\nas needed. Does not add delimiters to the end of a path unless explicitly\nrequested by sending an empty addend.\n@param addend [in/out] A Unicode string containing the component to\nadd, in which to return the lengthened path string.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath12AddComponentERKNS_13UnicodeStringE"]
    pub fn ai_FilePath_AddComponent(this: *mut ai_FilePath, addend: *const ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Removes the end component from this path.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath15RemoveComponentEv"]
    pub fn ai_FilePath_RemoveComponent(this: *mut ai_FilePath);
}
unsafe extern "C" {
    #[doc = " Adds a file extension to this path. Adds or ignores dots as needed so\nthat only one dot appears before the extension.\n@param ext The extension text in a Unicode string.\n@return Nothing"]
    #[link_name = "\u{1}__ZN2ai8FilePath12AddExtensionERKNS_13UnicodeStringE"]
    pub fn ai_FilePath_AddExtension(this: *mut ai_FilePath, ext: *const ai_UnicodeString);
}
unsafe extern "C" {
    #[doc = " Removes the file extension, if any, from this path.\n@return Nothing"]
    #[link_name = "\u{1}__ZN2ai8FilePath15RemoveExtensionEv"]
    pub fn ai_FilePath_RemoveExtension(this: *mut ai_FilePath);
}
unsafe extern "C" {
    #[doc = " Reports whether this file or directory exists after querying the file system.\n@param resolveLinks True to resolve links, aliases, and shortcuts for the\nfull path returned in \\c longPath.\n@param longPath\t[out] Optional. A buffer in which to return a full long,\nUnicode version of the path, if the file or directory is found.\nReturn value undefined if function returns false. Can be \\c NULL.\n@param isFile [out] Optional. A buffer in which to return true if a\nfile is found, false if a directory is found. Return value undefined\nif function returns false.Can be \\c NULL.\n@return True if the file or directory exists, false otherwise."]
    #[link_name = "\u{1}__ZNK2ai8FilePath6ExistsEbPNS_13UnicodeStringEPb"]
    pub fn ai_FilePath_Exists(
        this: *const ai_FilePath,
        resolveLinks: bool,
        longPath: *mut ai_UnicodeString,
        isFile: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "\tResolves any alias or shortcut for this path by querying file system,\nand alters the object to point directly to the target file.\nThe target file or directory must exist.  <<or what happens?>>\n@return Nothing"]
    #[link_name = "\u{1}__ZN2ai8FilePath7ResolveEv"]
    pub fn ai_FilePath_Resolve(this: *mut ai_FilePath);
}
unsafe extern "C" {
    #[doc = "\tSets this file path from a Unicode string containing a path native to\nWindows, Unix, or Mac OS, or a URL.\n@param path Path of file.\n@param expandName When true, the function attempts to expand the\nprovided path string into a full name (for example, for\ta short,\ntruncated name in Windows).\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath3SetERKNS_13UnicodeStringEbb"]
    pub fn ai_FilePath_Set(
        this: *mut ai_FilePath,
        path: *const ai_UnicodeString,
        expandName: bool,
        dontStripTrailingSpace: bool,
    );
}
unsafe extern "C" {
    #[doc = " Internal. Sets this file path from an \\c MiFile. (Illustrator core only.)\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath13SetFromMiFileERK6MiFile"]
    pub fn ai_FilePath_SetFromMiFile(this: *mut ai_FilePath, arg1: *const MiFile);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai8FilePath16SetFromSPFileRefERK23SPPlatformFileReference"]
    pub fn ai_FilePath_SetFromSPFileRef(
        this: *mut ai_FilePath,
        arg1: *const SPPlatformFileReference,
    );
}
unsafe extern "C" {
    #[doc = " Sets this file path from an \\c CFStringRef file specification in Mac OS.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath15SetFromCFStringEPK10__CFString"]
    pub fn ai_FilePath_SetFromCFString(this: *mut ai_FilePath, arg1: CFStringRef);
}
unsafe extern "C" {
    #[doc = " Sets this file path from an \\c CFURLRef URL specification in Mac OS.\n@return Nothing."]
    #[link_name = "\u{1}__ZN2ai8FilePath12SetFromCFURLEPK7__CFURL"]
    pub fn ai_FilePath_SetFromCFURL(this: *mut ai_FilePath, arg1: CFURLRef);
}
unsafe extern "C" {
    #[doc = " Retrieves the file name including an extension, if applicable, but without the path.\n@param displayName True to get the display name.\n@return The file name string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath11GetFileNameEb"]
    pub fn ai_FilePath_GetFileName(this: *const ai_FilePath, displayName: bool)
        -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the file name without the extension and path.\n@return The file name string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath16GetFileNameNoExtEv"]
    pub fn ai_FilePath_GetFileNameNoExt(this: *const ai_FilePath) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the file extension, without the dot, or \\c NULL if the\nfile name ends with a dot.\n@return The extension string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath16GetFileExtensionEv"]
    pub fn ai_FilePath_GetFileExtension(this: *const ai_FilePath) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the full path in notation native to the current platform.\n@param displayName True to get the display name.\n@return The path string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath11GetFullPathEb"]
    pub fn ai_FilePath_GetFullPath(this: *const ai_FilePath, displayName: bool)
        -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the directory name, ending with a delimiter, without the filename,\nin notation native to the current platform.\nIf path represents a directory, the result is the same as \\c GetFullPath().\n@param displayName True to get the display name.\n@return The directory path string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath12GetDirectoryEb"]
    pub fn ai_FilePath_GetDirectory(
        this: *const ai_FilePath,
        displayName: bool,
    ) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves an operating-system-specific short version of the path.\nThe file or folder must exist. Accesses the file system.\n\\li In Windows, conforms to 8.3 format.\n\\li In Mac OS X, the name may be truncated and a file ID appended.\nIf the file ID is required, the path is not valid across processes.\n@return The path string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath12GetShortPathEv"]
    pub fn ai_FilePath_GetShortPath(this: *const ai_FilePath) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[doc = " Retrieves the parent of the object represented by this path.\n\\li If this path is a directory, gets the parent directory.\n\\li If this path is a top-level volume, gets an empty path.\n\nDoes not access the file system, and does not guarantee that\nthe referenced file or directory exists.\n@return The file-path object for the parent."]
    #[link_name = "\u{1}__ZNK2ai8FilePath9GetParentEv"]
    pub fn ai_FilePath_GetParent(this: *const ai_FilePath) -> ai_FilePath;
}
unsafe extern "C" {
    #[doc = " Retrieves the path component delimiter for the current platform.\n@return The delimiter character."]
    #[link_name = "\u{1}__ZN2ai8FilePath12GetDelimiterEv"]
    pub fn ai_FilePath_GetDelimiter() -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieves the creator and type of this file or directory (4-character codes)\nin Mac OS.\n@param creator [out] A buffer in which to return the creator, a 4-character code.\n@param type [out] A buffer in which to return the type, a 4-character code.\n@return An error code, \\c #kNoErr on success."]
    #[link_name = "\u{1}__ZNK2ai8FilePath17GetCreatorAndTypeEPjS1_"]
    pub fn ai_FilePath_GetCreatorAndType(
        this: *const ai_FilePath,
        creator: *mut ai_uint32,
        type_: *mut ai_uint32,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves this path as a Uniform Resource Locator (URL), which\ncontains only ASCII characters; any special\tcharacters are\nescaped with URL percent (\\%) encoding.\n@param displayName True to get the display name.\n@return The URL string."]
    #[link_name = "\u{1}__ZNK2ai8FilePath8GetAsURLEb"]
    pub fn ai_FilePath_GetAsURL(this: *const ai_FilePath, displayName: bool) -> ai_UnicodeString;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai8FilePath22GetAsSPPlatformFileRefER23SPPlatformFileReference"]
    pub fn ai_FilePath_GetAsSPPlatformFileRef(
        this: *const ai_FilePath,
        arg1: *mut SPPlatformFileReference,
    );
}
unsafe extern "C" {
    #[doc = " Internal. Fills in the existing \\c MiFile from this path (Illustrator core only)."]
    #[link_name = "\u{1}__ZNK2ai8FilePath11GetAsMiFileER6MiFile"]
    pub fn ai_FilePath_GetAsMiFile(this: *const ai_FilePath, arg1: *mut MiFile) -> AIErr;
}
unsafe extern "C" {
    #[doc = "  Internal. Creates an \\c MiFile based on this path (Illustrator core only)."]
    #[link_name = "\u{1}__ZNK2ai8FilePath11GetAsMiFileERP6MiFile"]
    pub fn ai_FilePath_GetAsMiFile1(this: *const ai_FilePath, arg1: *mut *mut MiFile) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai8FilePath11IsOnNetworkEv"]
    pub fn ai_FilePath_IsOnNetwork(this: *const ai_FilePath) -> AIBoolean;
}
unsafe extern "C" {
    #[doc = " Creates a \\c CFString from this file path in Mac OS.\n@return The file specification object."]
    #[link_name = "\u{1}__ZNK2ai8FilePath13GetAsCFStringEv"]
    pub fn ai_FilePath_GetAsCFString(this: *const ai_FilePath) -> CFStringRef;
}
unsafe extern "C" {
    #[doc = " Creates a \\c CFURL from this file path in Mac OS.\n@return The URL specification object."]
    #[link_name = "\u{1}__ZNK2ai8FilePath10GetAsCFURLEv"]
    pub fn ai_FilePath_GetAsCFURL(this: *const ai_FilePath) -> CFURLRef;
}
unsafe extern "C" {
    #[doc = " Default constructor. Creates an empty file-path object."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1Ev"]
    pub fn ai_FilePath_FilePath(this: *mut ai_FilePath);
}
unsafe extern "C" {
    #[doc = " Copies a file-path object."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1ERKS0_"]
    pub fn ai_FilePath_FilePath1(this: *mut ai_FilePath, arg1: *const ai_FilePath);
}
unsafe extern "C" {
    #[doc = "\tCreates an initialized file-path object from a Unicode string\ncontaining a path native to Windows, Unix, or Mac OS, or a URL.\n@param path The new path.\n@param expandName When true, the function attempts to expand the\nprovided path string into a full name (for example, for\ta short,\ntruncated name in Windows).\n@param dontStripTrailingSpace When true, the function will not strip any\ntrailing whitespace in the provided path unicode string.\n@return The new object."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1ERKNS_13UnicodeStringEbb"]
    pub fn ai_FilePath_FilePath2(
        this: *mut ai_FilePath,
        path: *const ai_UnicodeString,
        expandName: bool,
        dontStripTrailingSpace: bool,
    );
}
unsafe extern "C" {
    #[doc = " Internal. Creates an initialized file-path object from\na \\c MiFile (Illustrator core only)."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1ERK6MiFile"]
    pub fn ai_FilePath_FilePath3(this: *mut ai_FilePath, arg1: *const MiFile);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai8FilePathC1ERK23SPPlatformFileReference"]
    pub fn ai_FilePath_FilePath4(this: *mut ai_FilePath, arg1: *const SPPlatformFileReference);
}
unsafe extern "C" {
    #[doc = " Creates an initialized file-path object from a \\c CFString\nfile specification  in Mac OS.\n@return The new object."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1EPK10__CFString"]
    pub fn ai_FilePath_FilePath5(this: *mut ai_FilePath, arg1: CFStringRef);
}
unsafe extern "C" {
    #[doc = " Creates an initialized file-path object from a \\c CFURLRef\nURL specification  in Mac OS.\n@return The new object."]
    #[link_name = "\u{1}__ZN2ai8FilePathC1EPK7__CFURL"]
    pub fn ai_FilePath_FilePath6(this: *mut ai_FilePath, arg1: CFURLRef);
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai8FilePathD1Ev"]
    pub fn ai_FilePath_FilePath_destructor(this: *mut ai_FilePath);
}
impl ai_FilePath {
    #[inline]
    pub unsafe fn ResetVolumeCache() {
        ai_FilePath_ResetVolumeCache()
    }
    #[inline]
    pub unsafe fn IsEmpty(&self) -> bool {
        ai_FilePath_IsEmpty(self)
    }
    #[inline]
    pub unsafe fn MakeEmpty(&mut self) {
        ai_FilePath_MakeEmpty(self)
    }
    #[inline]
    pub unsafe fn Equal(&self, filePath: *const ai_FilePath, resolveLinks: bool) -> bool {
        ai_FilePath_Equal(self, filePath, resolveLinks)
    }
    #[inline]
    pub unsafe fn StartsWithDelimiter(&self) -> bool {
        ai_FilePath_StartsWithDelimiter(self)
    }
    #[inline]
    pub unsafe fn EndsWithDelimiter(&self) -> bool {
        ai_FilePath_EndsWithDelimiter(self)
    }
    #[inline]
    pub unsafe fn AddComponent(&mut self, addend: *const ai_UnicodeString) {
        ai_FilePath_AddComponent(self, addend)
    }
    #[inline]
    pub unsafe fn RemoveComponent(&mut self) {
        ai_FilePath_RemoveComponent(self)
    }
    #[inline]
    pub unsafe fn AddExtension(&mut self, ext: *const ai_UnicodeString) {
        ai_FilePath_AddExtension(self, ext)
    }
    #[inline]
    pub unsafe fn RemoveExtension(&mut self) {
        ai_FilePath_RemoveExtension(self)
    }
    #[inline]
    pub unsafe fn Exists(
        &self,
        resolveLinks: bool,
        longPath: *mut ai_UnicodeString,
        isFile: *mut bool,
    ) -> bool {
        ai_FilePath_Exists(self, resolveLinks, longPath, isFile)
    }
    #[inline]
    pub unsafe fn Resolve(&mut self) {
        ai_FilePath_Resolve(self)
    }
    #[inline]
    pub unsafe fn Set(
        &mut self,
        path: *const ai_UnicodeString,
        expandName: bool,
        dontStripTrailingSpace: bool,
    ) {
        ai_FilePath_Set(self, path, expandName, dontStripTrailingSpace)
    }
    #[inline]
    pub unsafe fn SetFromMiFile(&mut self, arg1: *const MiFile) {
        ai_FilePath_SetFromMiFile(self, arg1)
    }
    #[inline]
    pub unsafe fn SetFromSPFileRef(&mut self, arg1: *const SPPlatformFileReference) {
        ai_FilePath_SetFromSPFileRef(self, arg1)
    }
    #[inline]
    pub unsafe fn SetFromCFString(&mut self, arg1: CFStringRef) {
        ai_FilePath_SetFromCFString(self, arg1)
    }
    #[inline]
    pub unsafe fn SetFromCFURL(&mut self, arg1: CFURLRef) {
        ai_FilePath_SetFromCFURL(self, arg1)
    }
    #[inline]
    pub unsafe fn GetFileName(&self, displayName: bool) -> ai_UnicodeString {
        ai_FilePath_GetFileName(self, displayName)
    }
    #[inline]
    pub unsafe fn GetFileNameNoExt(&self) -> ai_UnicodeString {
        ai_FilePath_GetFileNameNoExt(self)
    }
    #[inline]
    pub unsafe fn GetFileExtension(&self) -> ai_UnicodeString {
        ai_FilePath_GetFileExtension(self)
    }
    #[inline]
    pub unsafe fn GetFullPath(&self, displayName: bool) -> ai_UnicodeString {
        ai_FilePath_GetFullPath(self, displayName)
    }
    #[inline]
    pub unsafe fn GetDirectory(&self, displayName: bool) -> ai_UnicodeString {
        ai_FilePath_GetDirectory(self, displayName)
    }
    #[inline]
    pub unsafe fn GetShortPath(&self) -> ai_UnicodeString {
        ai_FilePath_GetShortPath(self)
    }
    #[inline]
    pub unsafe fn GetParent(&self) -> ai_FilePath {
        ai_FilePath_GetParent(self)
    }
    #[inline]
    pub unsafe fn GetDelimiter() -> ::std::os::raw::c_char {
        ai_FilePath_GetDelimiter()
    }
    #[inline]
    pub unsafe fn GetCreatorAndType(
        &self,
        creator: *mut ai_uint32,
        type_: *mut ai_uint32,
    ) -> AIErr {
        ai_FilePath_GetCreatorAndType(self, creator, type_)
    }
    #[inline]
    pub unsafe fn GetAsURL(&self, displayName: bool) -> ai_UnicodeString {
        ai_FilePath_GetAsURL(self, displayName)
    }
    #[inline]
    pub unsafe fn GetAsSPPlatformFileRef(&self, arg1: *mut SPPlatformFileReference) {
        ai_FilePath_GetAsSPPlatformFileRef(self, arg1)
    }
    #[inline]
    pub unsafe fn GetAsMiFile(&self, arg1: *mut MiFile) -> AIErr {
        ai_FilePath_GetAsMiFile(self, arg1)
    }
    #[inline]
    pub unsafe fn GetAsMiFile1(&self, arg1: *mut *mut MiFile) -> AIErr {
        ai_FilePath_GetAsMiFile1(self, arg1)
    }
    #[inline]
    pub unsafe fn IsOnNetwork(&self) -> AIBoolean {
        ai_FilePath_IsOnNetwork(self)
    }
    #[inline]
    pub unsafe fn GetAsCFString(&self) -> CFStringRef {
        ai_FilePath_GetAsCFString(self)
    }
    #[inline]
    pub unsafe fn GetAsCFURL(&self) -> CFURLRef {
        ai_FilePath_GetAsCFURL(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ai_FilePath) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        path: *const ai_UnicodeString,
        expandName: bool,
        dontStripTrailingSpace: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath2(
            __bindgen_tmp.as_mut_ptr(),
            path,
            expandName,
            dontStripTrailingSpace,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const MiFile) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *const SPPlatformFileReference) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(arg1: CFStringRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath5(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(arg1: CFURLRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_FilePath_FilePath6(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_FilePath_FilePath_destructor(self)
    }
}
#[doc = " Flag indicating that the color model has an alpha channel. The alpha\ncomponent appears after the color components."]
pub const ai_RasterColorSpace_kColorSpaceHasAlpha: ai_RasterColorSpace = 16;
#[doc = " Each pixel value for a gray color space has a single component\ndescribing a grayscale value. The gray color space is additive so the minimum\nvalue represents black and the maximum represents white."]
pub const ai_RasterColorSpace_kGrayColorSpace: ai_RasterColorSpace = 0;
#[doc = " Each pixel value for a RGB color space has three components which\nrepresent red, green and blue respectively. The RGB color space is additive."]
pub const ai_RasterColorSpace_kRGBColorSpace: ai_RasterColorSpace = 1;
#[doc = " Each pixel value for a CMYK color space has four components which\nrepresent cyan, magenta, yellow and black respectively. The CMYK color space\nis subtractive."]
pub const ai_RasterColorSpace_kCMYKColorSpace: ai_RasterColorSpace = 2;
#[doc = " Not valid as an image type; can occur only in placed linked\nfiles. See \\c #AIPlacedSuite::GetRasterInfo()."]
pub const ai_RasterColorSpace_kLabColorSpace: ai_RasterColorSpace = 3;
#[doc = " Each pixel value for a separation color space has a single component\ndescribing a tint value. The separation color space is subtractive so the minimum\nvalue represents white and the maximum represents black."]
pub const ai_RasterColorSpace_kSeparationColorSpace: ai_RasterColorSpace = 4;
#[doc = " Each pixel value for an NChannel color space has of a variable number of\ncomponents which represent individual channels in the NChannel color space.\nThe process components of the color space could be either additive or subtractive.\nThe spot components of the color space are subtractive."]
pub const ai_RasterColorSpace_kNChannelColorSpace: ai_RasterColorSpace = 5;
#[doc = " Each pixel value for an indexed color space has a single component\ndescribing an index value into a color lookup table. The number of components\nin the color lookup table depends on the base color space of the indexed\ncolor space."]
pub const ai_RasterColorSpace_kIndexedColorSpace: ai_RasterColorSpace = 6;
#[doc = " A gray color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaGrayColorSpace: ai_RasterColorSpace = 16;
#[doc = " An RGB color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaRGBColorSpace: ai_RasterColorSpace = 17;
#[doc = " A CMYK color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaCMYKColorSpace: ai_RasterColorSpace = 18;
#[doc = " A LAB color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaLabColorSpace: ai_RasterColorSpace = 19;
#[doc = " A separation color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaSeparationColorSpace: ai_RasterColorSpace = 20;
#[doc = " An NChannel color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaNChannelColorSpace: ai_RasterColorSpace = 21;
#[doc = " An indexed color space with an alpha channel."]
pub const ai_RasterColorSpace_kAlphaIndexedColorSpace: ai_RasterColorSpace = 22;
#[doc = " An indexed color space with an alpha channel."]
pub const ai_RasterColorSpace_kInvalidColorSpace: ai_RasterColorSpace = 255;
#[doc = " Color models for raster data"]
pub type ai_RasterColorSpace = ::std::os::raw::c_uint;
#[doc = " No data is available for the image (for example, when a\ndocument is opened and the linked file cannot be found)."]
pub const ai_RasterDataState_kAIRasterNoData: ai_RasterDataState = 0;
#[doc = " Data is available and is the same data that was read from\nthe linked file (that is, it has not been modified since being read)."]
pub const ai_RasterDataState_kAIRasterLinkData: ai_RasterDataState = 1;
#[doc = " Data is available and it has been modified since it was read from\nthe file (for example, a Photoshop filter might have been run on the image)."]
pub const ai_RasterDataState_kAIRasterEditedData: ai_RasterDataState = 2;
#[doc = " Data states for \\c #AIRasterLink::datastate. Direct linking of images is deprecated\n(although still supported). Create linked objects using the \\c #AIPlacedSuite."]
pub type ai_RasterDataState = ::std::os::raw::c_uint;
#[doc = " Preserve original dimensions regardless of bounding box size and transformations."]
pub const ai_PlaceMethod_kAsIs: ai_PlaceMethod = 0;
#[doc = " Fill bounding box while preserving proportions. Can overlap edges in one dimension."]
pub const ai_PlaceMethod_kFill: ai_PlaceMethod = 1;
#[doc = " Fit fully inside bounding box while preserving proportions."]
pub const ai_PlaceMethod_kFit: ai_PlaceMethod = 2;
#[doc = " Fit to bounding box; replaced file preserves bounds but not proportions."]
pub const ai_PlaceMethod_kConform: ai_PlaceMethod = 3;
#[doc = " Fit to bounding box; replaced file preserves transformations and tries to preserve size.\nDefault."]
pub const ai_PlaceMethod_kReconform: ai_PlaceMethod = 4;
#[doc = " Methods for positioning and sizing a linked object.\n@see \\c #AIPlacedSuite::SetPlaceOptions(), \\c #AIPlacedSuite::GetPlaceOptions()"]
pub type ai_PlaceMethod = ::std::os::raw::c_uint;
pub const ai_PlaceAlignment_kTopLeft: ai_PlaceAlignment = 0;
pub const ai_PlaceAlignment_kMidLeft: ai_PlaceAlignment = 1;
pub const ai_PlaceAlignment_kBotLeft: ai_PlaceAlignment = 2;
pub const ai_PlaceAlignment_kTopMid: ai_PlaceAlignment = 3;
pub const ai_PlaceAlignment_kMidMid: ai_PlaceAlignment = 4;
pub const ai_PlaceAlignment_kBotMid: ai_PlaceAlignment = 5;
pub const ai_PlaceAlignment_kTopRight: ai_PlaceAlignment = 6;
pub const ai_PlaceAlignment_kMidRight: ai_PlaceAlignment = 7;
pub const ai_PlaceAlignment_kBotRight: ai_PlaceAlignment = 8;
#[doc = " Alignment options for positioning a linked object.\n@see \\c #AIPlacedSuite::SetPlaceOptions(), \\c #AIPlacedSuite::GetPlaceOptions()"]
pub type ai_PlaceAlignment = ::std::os::raw::c_uint;
#[doc = "This class represents a predefined set of locales\nused in Illustrator, with a unique identifying code\nand associated descriptive string for the language and region.\nThe methods allow you to access the current locale setting\nof the operating system or of the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ai_Locale {
    pub _address: u8,
}
#[doc = " Invalid locale"]
pub const ai_Locale_ID_kUndefined: ai_Locale_ID = -1;
#[doc = " Implies the default language behavior for a particular context.\nFor example, in the \\c ai::NumberFormat class, implies the system\nsetting for number formats"]
pub const ai_Locale_ID_kDefault: ai_Locale_ID = 0;
#[doc = " The operating-system locale"]
pub const ai_Locale_ID_kSystem: ai_Locale_ID = 1;
#[doc = " The application locale"]
pub const ai_Locale_ID_kApplication: ai_Locale_ID = 2;
#[doc = " US English (en_US)"]
pub const ai_Locale_ID_kUS: ai_Locale_ID = 3;
#[doc = " English (en_GB)"]
pub const ai_Locale_ID_kBritain: ai_Locale_ID = 4;
#[doc = " German (de_DE)"]
pub const ai_Locale_ID_kGermany: ai_Locale_ID = 5;
#[doc = " French (fr_FR)"]
pub const ai_Locale_ID_kFrance: ai_Locale_ID = 6;
#[doc = " Italian (it_IT)"]
pub const ai_Locale_ID_kItaly: ai_Locale_ID = 7;
#[doc = " Japanese (ja_JP)"]
pub const ai_Locale_ID_kJapan: ai_Locale_ID = 8;
#[doc = "  Chinese (Simplified - zh_CN)"]
pub const ai_Locale_ID_kChina: ai_Locale_ID = 9;
#[doc = " Chinese (Traditional - zh_TW)"]
pub const ai_Locale_ID_kTaiwan: ai_Locale_ID = 10;
#[doc = " Korean (Korea - ko_KR)"]
pub const ai_Locale_ID_kKorea: ai_Locale_ID = 11;
#[doc = " Arabic (ar_AE)"]
pub const ai_Locale_ID_kArabia: ai_Locale_ID = 12;
#[doc = " English (en_CA)"]
pub const ai_Locale_ID_kCanadaComma: ai_Locale_ID = 13;
#[doc = " French (fr_CA)"]
pub const ai_Locale_ID_kFrCanada: ai_Locale_ID = 14;
#[doc = " Spanish (es_ES)"]
pub const ai_Locale_ID_kSpain: ai_Locale_ID = 15;
#[doc = " Swedish (sv_SE)"]
pub const ai_Locale_ID_kSweden: ai_Locale_ID = 16;
#[doc = " Portuguese (pt_PT)"]
pub const ai_Locale_ID_kPortugal: ai_Locale_ID = 17;
#[doc = " Portuguese (pt_BR)"]
pub const ai_Locale_ID_kBrazil: ai_Locale_ID = 18;
#[doc = " Polish (pl_PL)"]
pub const ai_Locale_ID_kPoland: ai_Locale_ID = 19;
#[doc = " Dutch (nl_NL)"]
pub const ai_Locale_ID_kNetherlands: ai_Locale_ID = 20;
#[doc = " Danish (da_DK)"]
pub const ai_Locale_ID_kDenmark: ai_Locale_ID = 21;
#[doc = " German (de_CH)"]
pub const ai_Locale_ID_kGrSwiss: ai_Locale_ID = 22;
#[doc = " Norwegian (nb_NO)"]
pub const ai_Locale_ID_kNorway: ai_Locale_ID = 23;
#[doc = " Nynorsk (nn_NO)"]
pub const ai_Locale_ID_kNynorskNorway: ai_Locale_ID = 24;
#[doc = " Finnish (fi_FI)"]
pub const ai_Locale_ID_kFinland: ai_Locale_ID = 25;
#[doc = " Czech (cs_CZ)"]
pub const ai_Locale_ID_kCzech: ai_Locale_ID = 26;
#[doc = " Hungarian (hu_HU)"]
pub const ai_Locale_ID_kHungary: ai_Locale_ID = 27;
#[doc = " Greek (el_GR)"]
pub const ai_Locale_ID_kGreece: ai_Locale_ID = 28;
#[doc = " Russian (ru_RU)"]
pub const ai_Locale_ID_kRussia: ai_Locale_ID = 29;
#[doc = " Romanian (ro_RO)"]
pub const ai_Locale_ID_kRomania: ai_Locale_ID = 30;
#[doc = " Turkish (tr_TR)"]
pub const ai_Locale_ID_kTurkey: ai_Locale_ID = 31;
#[doc = " Thai (th_TH)"]
pub const ai_Locale_ID_kThailand: ai_Locale_ID = 32;
#[doc = " Vietnamese (vi_VN)"]
pub const ai_Locale_ID_kVietnam: ai_Locale_ID = 33;
#[doc = " Bulgarian (bg_BG)"]
pub const ai_Locale_ID_kBulgaria: ai_Locale_ID = 34;
#[doc = " Hebrew (he_IL)"]
pub const ai_Locale_ID_kIsrael: ai_Locale_ID = 35;
#[doc = " Ukrainian (uk_UA)"]
pub const ai_Locale_ID_kUkraine: ai_Locale_ID = 36;
#[doc = " Mexican Spanish (es_MX)"]
pub const ai_Locale_ID_kSpMexican: ai_Locale_ID = 37;
#[doc = " Iranian Farsi (fa_IR)"]
pub const ai_Locale_ID_kFarsi: ai_Locale_ID = 38;
#[doc = " Arabic with English UI (en_AE)"]
pub const ai_Locale_ID_kEnArabia: ai_Locale_ID = 39;
#[doc = " Hebrew with English UI  (en_IL)"]
pub const ai_Locale_ID_kEnHebrew: ai_Locale_ID = 40;
#[doc = " North African French  (fr_MA)"]
pub const ai_Locale_ID_kFrNorthAfrica: ai_Locale_ID = 41;
pub const ai_Locale_ID_kAIDummyLocale: ai_Locale_ID = 4294967295;
#[doc = " Locale type constants, mapped to a descriptive string\nthat contains the language name and region code."]
pub type ai_Locale_ID = ::std::os::raw::c_long;
unsafe extern "C" {
    #[doc = " Retrieves the language and region code string for a locale.\n@param\tid The locale identifier constant.\n@return\tThe language and region code string ."]
    #[link_name = "\u{1}__ZN2ai6Locale9getLocaleENS0_2IDE"]
    pub fn ai_Locale_getLocale(id: ai_Locale_ID) -> std_string;
}
unsafe extern "C" {
    #[doc = " Retrieves the current system locale as a locale identifier.\n@return\tThe locale ID constant."]
    #[link_name = "\u{1}__ZN2ai6Locale17getSystemLocaleIDEv"]
    pub fn ai_Locale_getSystemLocaleID() -> ai_Locale_ID;
}
unsafe extern "C" {
    #[doc = " Retrieves the current application locale as a locale identifier.\n@return\tThe locale ID constant."]
    #[link_name = "\u{1}__ZN2ai6Locale22getApplicationLocaleIDEv"]
    pub fn ai_Locale_getApplicationLocaleID() -> ai_Locale_ID;
}
unsafe extern "C" {
    #[doc = "\tRetrieves the locale identifier for a language and region code string.\n@param locale\tlanguage and region code string\n@return\tThe locale ID constant or \\c ai::Locale::kUndefined if the string\ndoes not map to a valid type."]
    #[link_name = "\u{1}__ZN2ai6Locale5getIDERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"]
    pub fn ai_Locale_getID(locale: *const std_string) -> ai_Locale_ID;
}
impl ai_Locale {
    #[inline]
    pub unsafe fn getLocale(id: ai_Locale_ID) -> std_string {
        ai_Locale_getLocale(id)
    }
    #[inline]
    pub unsafe fn getSystemLocaleID() -> ai_Locale_ID {
        ai_Locale_getSystemLocaleID()
    }
    #[inline]
    pub unsafe fn getApplicationLocaleID() -> ai_Locale_ID {
        ai_Locale_getApplicationLocaleID()
    }
    #[inline]
    pub unsafe fn getID(locale: *const std_string) -> ai_Locale_ID {
        ai_Locale_getID(locale)
    }
}
#[doc = " Locale unique identifying code."]
pub use self::ai_Locale_ID as ai_LocaleID;
#[doc = " Artboard identifier."]
pub type ai_ArtboardID = ai_int32;
#[doc = " Artboard object."]
pub type ai_ArtboardRef = *mut CAIArtboardProperties;
#[doc = " Artboard list object."]
pub type ai_ArtboardListRef = *mut CAIArtboardList;
#[doc = " The \\c ArtboardProperties object encapsulates all the attributes associated with\nan artboard. These are not live objects but a snapshot at any given time.\nTo update an object, you must call \\c ai::ArtboardList::Update."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtboardProperties {
    pub fImpl: ai_ArtboardRef,
}
pub const ai_ArtboardProperties_DisplayMarkType_kNone: ai_ArtboardProperties_DisplayMarkType = 0;
pub const ai_ArtboardProperties_DisplayMarkType_kCenter: ai_ArtboardProperties_DisplayMarkType = 1;
pub const ai_ArtboardProperties_DisplayMarkType_kCrossHair: ai_ArtboardProperties_DisplayMarkType =
    2;
pub const ai_ArtboardProperties_DisplayMarkType_kSafeAreas: ai_ArtboardProperties_DisplayMarkType =
    4;
#[doc = " Types of artboard display marks and annotations."]
pub type ai_ArtboardProperties_DisplayMarkType = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Retrieves the position and bounds of this artboard.\n@param value [out] A buffer in which to return the value."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties11GetPositionER12AIDoubleRect"]
    pub fn ai_ArtboardProperties_GetPosition(
        this: *const ai_ArtboardProperties,
        value: *mut AIRealRect,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Modifies the position and bounds of this artboard. Call \\c ai::ArtboardList::Update()\nwith this object to make the change.\n@param value The new position and bounds value."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties11SetPositionE12AIDoubleRect"]
    pub fn ai_ArtboardProperties_SetPosition(
        this: *mut ai_ArtboardProperties,
        value: AIRealRect,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the pixel aspect ratio of the artboard ruler.\n@param value [out] A buffer in which to return the value."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties6GetPARERd"]
    pub fn ai_ArtboardProperties_GetPAR(
        this: *const ai_ArtboardProperties,
        value: *mut AIReal,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Modifies the pixel aspect ratio of the artboard ruler. Call \\c ai::ArtboardList::Update()\nwith this object to make the change in the artboard\n@param value The new value."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties6SetPAREd"]
    pub fn ai_ArtboardProperties_SetPAR(this: *mut ai_ArtboardProperties, value: AIReal) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Reports whether a particular type of annotation is shown or hidden.\n@param mark The type of annotation.\n@param show [out] A buffer in which to return true if the mark is shown, false if hidden."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties18GetShowDisplayMarkENS0_15DisplayMarkTypeERb"]
    pub fn ai_ArtboardProperties_GetShowDisplayMark(
        this: *const ai_ArtboardProperties,
        mark: ai_ArtboardProperties_DisplayMarkType,
        show: *mut bool,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Shows or hides a particular type of annotation.\n@param mark The type of annotation.\n@param show True to show, false to hide."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties18SetShowDisplayMarkENS0_15DisplayMarkTypeEb"]
    pub fn ai_ArtboardProperties_SetShowDisplayMark(
        this: *mut ai_ArtboardProperties,
        mark: ai_ArtboardProperties_DisplayMarkType,
        show: bool,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the name associated with this artboard.\n@param name [out] A buffer in which to return the name."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties7GetNameERNS_13UnicodeStringE"]
    pub fn ai_ArtboardProperties_GetName(
        this: *const ai_ArtboardProperties,
        name: *mut ai_UnicodeString,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Sets the name associated with this artboard.\n@param name The new name."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties7SetNameERKNS_13UnicodeStringE"]
    pub fn ai_ArtboardProperties_SetName(
        this: *mut ai_ArtboardProperties,
        name: *const ai_UnicodeString,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the ruler origin of the artboard.\tRuler origin is relative to left-bottom corner of the artboard\n@param rulerOrigin [out] A buffer in which to return the ruler origin."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties14GetRulerOriginER14_t_AIRealPoint"]
    pub fn ai_ArtboardProperties_GetRulerOrigin(
        this: *const ai_ArtboardProperties,
        rulerOrigin: *mut AIRealPoint,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Sets the ruler origin of the artboard. Ruler origin is relative to left-bottom corner of the artboard\n@param rulerOrigin The new ruler origin."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties14SetRulerOriginERK14_t_AIRealPoint"]
    pub fn ai_ArtboardProperties_SetRulerOrigin(
        this: *mut ai_ArtboardProperties,
        rulerOrigin: *const AIRealPoint,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Reports whether this artboard has an application-generated name.  This affects the file name of the artboard if it is saved\nas part of an export-to-JPEG operation.\n@param isDefault [out] A buffer in which to return true if the name is generated, false if it has been explicitly set."]
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties13IsDefaultNameERh"]
    pub fn ai_ArtboardProperties_IsDefaultName(
        this: *const ai_ArtboardProperties,
        isDefault: *mut AIBoolean,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Internal. Do not use."]
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties16SetIsDefaultNameERKh"]
    pub fn ai_ArtboardProperties_SetIsDefaultName(
        this: *mut ai_ArtboardProperties,
        isDefault: *const AIBoolean,
    ) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties10IsSelectedERh"]
    pub fn ai_ArtboardProperties_IsSelected(
        this: *const ai_ArtboardProperties,
        isSelected: *mut AIBoolean,
    ) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai18ArtboardProperties15GetUUIDAsStringERNS_13UnicodeStringE"]
    pub fn ai_ArtboardProperties_GetUUIDAsString(
        this: *const ai_ArtboardProperties,
        uuid: *mut ai_UnicodeString,
    ) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai18ArtboardProperties10deleteImplEv"]
    pub fn ai_ArtboardProperties_deleteImpl(this: *mut ai_ArtboardProperties);
}
unsafe extern "C" {
    #[doc = " Default constructor"]
    #[link_name = "\u{1}__ZN2ai18ArtboardPropertiesC1Ev"]
    pub fn ai_ArtboardProperties_ArtboardProperties(this: *mut ai_ArtboardProperties);
}
unsafe extern "C" {
    #[doc = " Copy Constructor"]
    #[link_name = "\u{1}__ZN2ai18ArtboardPropertiesC1ERKS0_"]
    pub fn ai_ArtboardProperties_ArtboardProperties1(
        this: *mut ai_ArtboardProperties,
        arg1: *const ai_ArtboardProperties,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai18ArtboardPropertiesC1EP21CAIArtboardProperties"]
    pub fn ai_ArtboardProperties_ArtboardProperties2(
        this: *mut ai_ArtboardProperties,
        ref_: ai_ArtboardRef,
    );
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai18ArtboardPropertiesD1Ev"]
    pub fn ai_ArtboardProperties_ArtboardProperties_destructor(this: *mut ai_ArtboardProperties);
}
impl ai_ArtboardProperties {
    #[inline]
    pub unsafe fn GetPosition(&self, value: *mut AIRealRect) -> AIErr {
        ai_ArtboardProperties_GetPosition(self, value)
    }
    #[inline]
    pub unsafe fn SetPosition(&mut self, value: AIRealRect) -> AIErr {
        ai_ArtboardProperties_SetPosition(self, value)
    }
    #[inline]
    pub unsafe fn GetPAR(&self, value: *mut AIReal) -> AIErr {
        ai_ArtboardProperties_GetPAR(self, value)
    }
    #[inline]
    pub unsafe fn SetPAR(&mut self, value: AIReal) -> AIErr {
        ai_ArtboardProperties_SetPAR(self, value)
    }
    #[inline]
    pub unsafe fn GetShowDisplayMark(
        &self,
        mark: ai_ArtboardProperties_DisplayMarkType,
        show: *mut bool,
    ) -> AIErr {
        ai_ArtboardProperties_GetShowDisplayMark(self, mark, show)
    }
    #[inline]
    pub unsafe fn SetShowDisplayMark(
        &mut self,
        mark: ai_ArtboardProperties_DisplayMarkType,
        show: bool,
    ) -> AIErr {
        ai_ArtboardProperties_SetShowDisplayMark(self, mark, show)
    }
    #[inline]
    pub unsafe fn GetName(&self, name: *mut ai_UnicodeString) -> AIErr {
        ai_ArtboardProperties_GetName(self, name)
    }
    #[inline]
    pub unsafe fn SetName(&mut self, name: *const ai_UnicodeString) -> AIErr {
        ai_ArtboardProperties_SetName(self, name)
    }
    #[inline]
    pub unsafe fn GetRulerOrigin(&self, rulerOrigin: *mut AIRealPoint) -> AIErr {
        ai_ArtboardProperties_GetRulerOrigin(self, rulerOrigin)
    }
    #[inline]
    pub unsafe fn SetRulerOrigin(&mut self, rulerOrigin: *const AIRealPoint) -> AIErr {
        ai_ArtboardProperties_SetRulerOrigin(self, rulerOrigin)
    }
    #[inline]
    pub unsafe fn IsDefaultName(&self, isDefault: *mut AIBoolean) -> AIErr {
        ai_ArtboardProperties_IsDefaultName(self, isDefault)
    }
    #[inline]
    pub unsafe fn SetIsDefaultName(&mut self, isDefault: *const AIBoolean) -> AIErr {
        ai_ArtboardProperties_SetIsDefaultName(self, isDefault)
    }
    #[inline]
    pub unsafe fn IsSelected(&self, isSelected: *mut AIBoolean) -> AIErr {
        ai_ArtboardProperties_IsSelected(self, isSelected)
    }
    #[inline]
    pub unsafe fn GetUUIDAsString(&self, uuid: *mut ai_UnicodeString) -> AIErr {
        ai_ArtboardProperties_GetUUIDAsString(self, uuid)
    }
    #[inline]
    pub unsafe fn deleteImpl(&mut self) {
        ai_ArtboardProperties_deleteImpl(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardProperties_ArtboardProperties(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ai_ArtboardProperties) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardProperties_ArtboardProperties1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(ref_: ai_ArtboardRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardProperties_ArtboardProperties2(__bindgen_tmp.as_mut_ptr(), ref_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_ArtboardProperties_ArtboardProperties_destructor(self)
    }
}
#[doc = " The \\c ArtboardList object is the interface to the set of artboards associated\nwith a document. It encapsulate all artboard operations."]
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtboardList {
    pub fImpl: ai_ArtboardListRef,
}
pub type ai_ArtboardList_value_type = ai_ArtboardList_Artboard;
unsafe extern "C" {
    #[doc = " Adds a new artboard to the document and reports its index position in this artboard list.\n@param newArtboard The new artboard's properties.\n@param index [out] A buffer in which to return the 0-based index position of the new artboard.\n@return The error \\c #kAIExceededMaxArtboardLimitErr if the number of artboards exceeds  \\c #kAIMAX_ARTBOARD_LIMIT."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList6AddNewERNS_18ArtboardPropertiesERi"]
    pub fn ai_ArtboardList_AddNew(
        this: *mut ai_ArtboardList,
        newArtboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Inserts a new artboard to the document at the specified location.\n@param artboard The new artboard's properties.\n@param index 0-based index position of the new artboard.\n@return The error \\c #kAIExceededMaxArtboardLimitErr if the number of artboards exceeds  \\c #kAIMAX_ARTBOARD_LIMIT.\nNote : It will override the UUID in artboardProperties. In case you want to preserve the UUID in artboard properties use \\c #InsertUsingArtboardPropertiesUUID()"]
    #[link_name = "\u{1}__ZN2ai12ArtboardList6InsertERNS_18ArtboardPropertiesERi"]
    pub fn ai_ArtboardList_Insert(
        this: *mut ai_ArtboardList,
        artboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Inserts a new artboard to the document at the specified location using the UUID in artboard properties.\n@param artboard The new artboard's properties.\n@param index 0-based index position of the new artboard.\n@return The error \\c #kAIExceededMaxArtboardLimitErr if the number of artboards exceeds  \\c #kAIMAX_ARTBOARD_LIMIT."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList33InsertUsingArtboardPropertiesUUIDERNS_18ArtboardPropertiesERi"]
    pub fn ai_ArtboardList_InsertUsingArtboardPropertiesUUID(
        this: *mut ai_ArtboardList,
        artboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Deletes an artboard from the document list, makes the next one in the list active.\n@param index The 0-based index position of the artboard to delete.\n@return The error \\c #kAICantDeleteLastArtboardErr if this is the last artboard in the list."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList6DeleteEi"]
    pub fn ai_ArtboardList_Delete(this: *mut ai_ArtboardList, index: ai_ArtboardID) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList6DeleteERKNSt3__16vectorIiNS1_9allocatorIiEEEE"]
    pub fn ai_ArtboardList_Delete1(
        this: *mut ai_ArtboardList,
        artboardIDs: *const std_vector,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of artboards defined in the artboard list.\n@param count [out] A buffer in which to return the number of artboards."]
    #[link_name = "\u{1}__ZNK2ai12ArtboardList8GetCountERi"]
    pub fn ai_ArtboardList_GetCount(
        this: *const ai_ArtboardList,
        count: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the properties of an artboard. Use with \\c #GetCount() and \\c #Update()\nto modify an artboard without changing which artboard is active in the document.\n@param index The 0-based index position of the artboard in the artboard list..\n@return The artboard properties object. On error returns an invalid object."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList21GetArtboardPropertiesEi"]
    pub fn ai_ArtboardList_GetArtboardProperties(
        this: *mut ai_ArtboardList,
        index: ai_ArtboardID,
    ) -> ai_ArtboardProperties;
}
unsafe extern "C" {
    #[doc = " Updates the properties of an artboard. Use with \\c #GetCount() and \\c #GetArtboardProperties()\nto modify an artboard without changing which artboard is active in the document.\n@param index The 0-based index position of the artboard in the document list.\n@param artboard The object containing the new artboard properties."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList6UpdateEiRKNS_18ArtboardPropertiesE"]
    pub fn ai_ArtboardList_Update(
        this: *mut ai_ArtboardList,
        index: ai_ArtboardID,
        artboard: *const ai_ArtboardProperties,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the index position of the active artboard in the document's list.\n@param index [out] A buffer in which to return the 0-based index, or -1 if there are\nno artboards in the current document."]
    #[link_name = "\u{1}__ZNK2ai12ArtboardList9GetActiveERi"]
    pub fn ai_ArtboardList_GetActive(
        this: *const ai_ArtboardList,
        index: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Makes a specific artboard active, and makes it current in the iteration order.\n@param index The 0-based index position of the artboard in the document list."]
    #[link_name = "\u{1}__ZN2ai12ArtboardList9SetActiveEi"]
    pub fn ai_ArtboardList_SetActive(this: *mut ai_ArtboardList, index: ai_ArtboardID) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList6SelectEib"]
    pub fn ai_ArtboardList_Select(
        this: *mut ai_ArtboardList,
        artboardID: ai_ArtboardID,
        exclusively: bool,
    ) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList6SelectERKNSt3__16vectorIiNS1_9allocatorIiEEEEb"]
    pub fn ai_ArtboardList_Select1(
        this: *mut ai_ArtboardList,
        artboardIDs: *const std_vector,
        exclusively: bool,
    ) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList9SelectAllEv"]
    pub fn ai_ArtboardList_SelectAll(this: *mut ai_ArtboardList) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList8DeselectEi"]
    pub fn ai_ArtboardList_Deselect(this: *mut ai_ArtboardList, artboardID: ai_ArtboardID)
        -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList11DeselectAllEv"]
    pub fn ai_ArtboardList_DeselectAll(this: *mut ai_ArtboardList) -> AIErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList10deleteImplEv"]
    pub fn ai_ArtboardList_deleteImpl(this: *mut ai_ArtboardList);
}
unsafe extern "C" {
    #[doc = "//Range loop support\nai::ArtboardList artboardList;\nfor (const auto& artboard: artboardList)\n{\nauto artboardID = artboard.GetID();\nauto& props = artboard.GetProps();\n}"]
    #[link_name = "\u{1}__ZN2ai12ArtboardList5beginEv"]
    pub fn ai_ArtboardList_begin(this: *mut ai_ArtboardList) -> ai_ArtboardList_iterator;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList3endEv"]
    pub fn ai_ArtboardList_end(this: *mut ai_ArtboardList) -> ai_ArtboardList_iterator;
}
unsafe extern "C" {
    #[doc = "Index-based accessor method.\n\nUsage Example:\nai::ArtboardList artboardList;\nauto artboard = artboardList.at(0);\n\nAIRealRect artboardPos{};\nartboard.GetProps().GetPosition(artboardPos);\n\nartboardPos.left += 100.0;\nartboardPos.right += 100.0;\nartboard.GetProps().SetPosition(artboardPos);\n\nartboard.Update():"]
    #[link_name = "\u{1}__ZN2ai12ArtboardList2atEi"]
    pub fn ai_ArtboardList_at(
        this: *mut ai_ArtboardList,
        artboardID: ai_ArtboardID,
    ) -> ai_ArtboardList_value_type;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZNK2ai12ArtboardList4sizeEv"]
    pub fn ai_ArtboardList_size(this: *const ai_ArtboardList) -> ai_ArtboardID;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardListC1Ev"]
    pub fn ai_ArtboardList_ArtboardList(this: *mut ai_ArtboardList);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardListC1ERKS0_"]
    pub fn ai_ArtboardList_ArtboardList1(this: *mut ai_ArtboardList, arg1: *const ai_ArtboardList);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardListC1EP15CAIArtboardList"]
    pub fn ai_ArtboardList_ArtboardList2(this: *mut ai_ArtboardList, arg1: ai_ArtboardListRef);
}
unsafe extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}__ZN2ai12ArtboardListD1Ev"]
    pub fn ai_ArtboardList_ArtboardList_destructor(this: *mut ai_ArtboardList);
}
impl ai_ArtboardList {
    #[inline]
    pub unsafe fn AddNew(
        &mut self,
        newArtboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr {
        ai_ArtboardList_AddNew(self, newArtboard, index)
    }
    #[inline]
    pub unsafe fn Insert(
        &mut self,
        artboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr {
        ai_ArtboardList_Insert(self, artboard, index)
    }
    #[inline]
    pub unsafe fn InsertUsingArtboardPropertiesUUID(
        &mut self,
        artboard: *mut ai_ArtboardProperties,
        index: *mut ai_ArtboardID,
    ) -> AIErr {
        ai_ArtboardList_InsertUsingArtboardPropertiesUUID(self, artboard, index)
    }
    #[inline]
    pub unsafe fn Delete(&mut self, index: ai_ArtboardID) -> AIErr {
        ai_ArtboardList_Delete(self, index)
    }
    #[inline]
    pub unsafe fn Delete1(&mut self, artboardIDs: *const std_vector) -> AIErr {
        ai_ArtboardList_Delete1(self, artboardIDs)
    }
    #[inline]
    pub unsafe fn GetCount(&self, count: *mut ai_ArtboardID) -> AIErr {
        ai_ArtboardList_GetCount(self, count)
    }
    #[inline]
    pub unsafe fn GetArtboardProperties(&mut self, index: ai_ArtboardID) -> ai_ArtboardProperties {
        ai_ArtboardList_GetArtboardProperties(self, index)
    }
    #[inline]
    pub unsafe fn Update(
        &mut self,
        index: ai_ArtboardID,
        artboard: *const ai_ArtboardProperties,
    ) -> AIErr {
        ai_ArtboardList_Update(self, index, artboard)
    }
    #[inline]
    pub unsafe fn GetActive(&self, index: *mut ai_ArtboardID) -> AIErr {
        ai_ArtboardList_GetActive(self, index)
    }
    #[inline]
    pub unsafe fn SetActive(&mut self, index: ai_ArtboardID) -> AIErr {
        ai_ArtboardList_SetActive(self, index)
    }
    #[inline]
    pub unsafe fn Select(&mut self, artboardID: ai_ArtboardID, exclusively: bool) -> AIErr {
        ai_ArtboardList_Select(self, artboardID, exclusively)
    }
    #[inline]
    pub unsafe fn Select1(&mut self, artboardIDs: *const std_vector, exclusively: bool) -> AIErr {
        ai_ArtboardList_Select1(self, artboardIDs, exclusively)
    }
    #[inline]
    pub unsafe fn SelectAll(&mut self) -> AIErr {
        ai_ArtboardList_SelectAll(self)
    }
    #[inline]
    pub unsafe fn Deselect(&mut self, artboardID: ai_ArtboardID) -> AIErr {
        ai_ArtboardList_Deselect(self, artboardID)
    }
    #[inline]
    pub unsafe fn DeselectAll(&mut self) -> AIErr {
        ai_ArtboardList_DeselectAll(self)
    }
    #[inline]
    pub unsafe fn deleteImpl(&mut self) {
        ai_ArtboardList_deleteImpl(self)
    }
    #[inline]
    pub unsafe fn begin(&mut self) -> ai_ArtboardList_iterator {
        ai_ArtboardList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&mut self) -> ai_ArtboardList_iterator {
        ai_ArtboardList_end(self)
    }
    #[inline]
    pub unsafe fn at(&mut self, artboardID: ai_ArtboardID) -> ai_ArtboardList_value_type {
        ai_ArtboardList_at(self, artboardID)
    }
    #[inline]
    pub unsafe fn size(&self) -> ai_ArtboardID {
        ai_ArtboardList_size(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardList_ArtboardList(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ai_ArtboardList) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardList_ArtboardList1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: ai_ArtboardListRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardList_ArtboardList2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ai_ArtboardList_ArtboardList_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtboardList_Artboard {
    pub mArtboardID: ai_ArtboardID,
    pub mProps: ai_ArtboardProperties,
    pub mArtboardListPtr: ai_ArtboardList_Artboard_container_type,
}
pub type ai_ArtboardList_Artboard_container_type = *mut ai_ArtboardList;
unsafe extern "C" {
    #[doc = " Update the current value of the properties for an artboard in document\n#ArtboardList::Update"]
    #[link_name = "\u{1}__ZN2ai12ArtboardList8Artboard6UpdateEv"]
    pub fn ai_ArtboardList_Artboard_Update(this: *mut ai_ArtboardList_Artboard) -> AIErr;
}
unsafe extern "C" {
    #[doc = "Create an artboard object"]
    #[link_name = "\u{1}__ZN2ai12ArtboardList8ArtboardC1EiPS0_"]
    pub fn ai_ArtboardList_Artboard_Artboard(
        this: *mut ai_ArtboardList_Artboard,
        artboardID: ai_ArtboardID,
        artboardListPtr: ai_ArtboardList_Artboard_container_type,
    );
}
impl ai_ArtboardList_Artboard {
    #[inline]
    pub unsafe fn Update(&mut self) -> AIErr {
        ai_ArtboardList_Artboard_Update(self)
    }
    #[inline]
    pub unsafe fn new(
        artboardID: ai_ArtboardID,
        artboardListPtr: ai_ArtboardList_Artboard_container_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardList_Artboard_Artboard(__bindgen_tmp.as_mut_ptr(), artboardID, artboardListPtr);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ai_ArtboardList_iterator {
    pub mValue: ai_ArtboardList_iterator_value_type,
    pub mArtboardListPtr: ai_ArtboardList_iterator_container_type,
    pub mArtboardCount: ai_ArtboardList_iterator_size_type,
}
pub type ai_ArtboardList_iterator_value_type = ai_ArtboardList_Artboard;
pub type ai_ArtboardList_iterator_container_type = *mut ai_ArtboardList;
pub type ai_ArtboardList_iterator_size_type = ai_ArtboardID;
unsafe extern "C" {
    #[link_name = "\u{1}__ZN2ai12ArtboardList8iteratorC1EiPS0_"]
    pub fn ai_ArtboardList_iterator_iterator(
        this: *mut ai_ArtboardList_iterator,
        index: ai_ArtboardList_iterator_size_type,
        artboardListPtr: ai_ArtboardList_iterator_container_type,
    );
}
impl ai_ArtboardList_iterator {
    #[inline]
    pub unsafe fn new(
        index: ai_ArtboardList_iterator_size_type,
        artboardListPtr: ai_ArtboardList_iterator_container_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ai_ArtboardList_iterator_iterator(__bindgen_tmp.as_mut_ptr(), index, artboardListPtr);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " Retrieves the name of the specified artboard.\n@param name [out] A buffer in which to return the name.\n@param isDefault [out] True if the name is the default name.\n@param index [in] The 0-based position index of the artboard, or -1 to get the active artboard."]
    #[link_name = "\u{1}__ZN2ai13ArtboardUtils15GetArtboardNameERNS_13UnicodeStringERbi"]
    pub fn ai_ArtboardUtils_GetArtboardName(
        name: *mut ai_UnicodeString,
        isDefault: *mut bool,
        index: ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the index of the artboard with specified name\n@param name [in] The name of the Artboard.\n@param index [out] The artboard index ."]
    #[link_name = "\u{1}__ZN2ai13ArtboardUtils22GetArtboardIndexByNameERKNS_13UnicodeStringERi"]
    pub fn ai_ArtboardUtils_GetArtboardIndexByName(
        name: *const ai_UnicodeString,
        index: *mut ai_ArtboardID,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Tells if there is any overlap between the artboards in the artboard list"]
    #[link_name = "\u{1}__ZN2ai13ArtboardUtils26AreAnyArtboardsOverlappingERNS_12ArtboardListERh"]
    pub fn ai_ArtboardUtils_AreAnyArtboardsOverlapping(
        artboardList: *mut ai_ArtboardList,
        isOverlapping: *mut AIBoolean,
    ) -> AIErr;
}
unsafe extern "C" {
    #[doc = " Retrieves the number of selected artboards in the current document\n@param count [out] A buffer in which to return the number of selected artboards."]
    #[link_name = "\u{1}__ZN2ai13ArtboardUtils23GetNumSelectedArtboardsERi"]
    pub fn ai_ArtboardUtils_GetNumSelectedArtboards(count: *mut ai_ArtboardID) -> AIErr;
}
#[doc = " Class to keep the data of UUID associated with an art object.\nEach art object keeps a unique id which remain same through out\nthe life of the object in single session.\nUtility functions to interact with UUID are provided in suite #AIUUIDSuite\n@see \\c #AIUUIDSuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ai_uuid {
    pub mData: [ai_uint8; 16usize],
}
pub type AIReal = f64;
pub type AIFloat = f32;
#[doc = " Double-byte numeric value"]
pub type AIDouble = f64;
#[doc = " Rectangle specified with \\c #AIDouble coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDoubleRect {
    pub left: AIDouble,
    pub top: AIDouble,
    pub right: AIDouble,
    pub bottom: AIDouble,
}
#[doc = " Rectangle specified with \\c #AIDouble coordinates."]
pub type AIRealRect = AIDoubleRect;
pub type AIRealRectPtr = *mut AIRealRect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIFloatRect {
    pub left: AIFloat,
    pub top: AIFloat,
    pub right: AIFloat,
    pub bottom: AIFloat,
}
pub type AIFloatRect = _t_AIFloatRect;
pub type AIFloatRectPtr = *mut _t_AIFloatRect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIRealMatrix {
    pub a: AIReal,
    pub b: AIReal,
    pub c: AIReal,
    pub d: AIReal,
    pub tx: AIReal,
    pub ty: AIReal,
}
pub type AIRealMatrix = _t_AIRealMatrix;
pub type AIRealMatrixPtr = *mut _t_AIRealMatrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIRealPoint {
    pub h: AIReal,
    pub v: AIReal,
}
pub type AIRealPoint = _t_AIRealPoint;
pub type AIRealPointPtr = *mut _t_AIRealPoint;
#[doc = " Rectangle value in Windows (same as \\c RECT)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIRect {
    #[doc = " Coordinate values"]
    pub left: ai_int32,
    #[doc = " Coordinate values"]
    pub top: ai_int32,
    #[doc = " Coordinate values"]
    pub right: ai_int32,
    #[doc = " Coordinate values"]
    pub bottom: ai_int32,
}
#[doc = " Rectangle value in Windows (same as \\c RECT)"]
pub type AIRect = _t_AIRect;
#[doc = " Point value in Windows (same as \\c Point)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIPoint {
    #[doc = " Coordinate values"]
    pub h: ai_int32,
    #[doc = " Coordinate values"]
    pub v: ai_int32,
}
#[doc = " Point value in Windows (same as \\c Point)"]
pub type AIPoint = _t_AIPoint;
#[doc = " Mac OS only. the same as Mac OS \\c Boolean."]
pub type AIBoolean = ::std::os::raw::c_uchar;
#[doc = " On Mac OS, \\c SPBoolean is \\c Boolean."]
pub type SPBoolean = ::std::os::raw::c_uchar;
#[doc = " PICA error codes are C strings, except for the no-error code, which\nis \\c NULL (and \\c #kSPOutOfMemoryError). Compare errors first with\n\\c #kSPNoError, to text for success. On failure, compare with\npredefined error constants in \\c SPErrorCodes.h.\n\nFor example:\n@code\nSPErr error = kSPNoError;\nblock = SPAllocateBlock( size, debug, &error );\nif ( error != kSPNoError ) {\nif ( strcmp( error, kSPOutOfMemoryError ) == 0 )\nFailOutOfMemory();\n...\n}\n@endcode"]
pub type SPErr = ai_int32;
#[doc = "\tSuite\n\n/\n/** @ingroup Suites\nThis suite provides basic memory management for PICA (the Adobe plug-in manager),\nwith debugging capability for the development version of the application.\n\nUnlike other suites, this suite is available during plug-in load and unload operations.\nYou can acquire it in response to a PICA access (\\c #kSPAccessCaller) or property\n(\\c #kSPPropertiesCaller) message, and use it to allocate and free memory\nfor the plug-in you are loading or unloading.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPBlocksSuite and \\c #kSPBlocksSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPBlocksSuite {
    #[doc = " Allocates a block of memory.\n@param size The number of bytes.\n@param debug Optional. A tag for the block, available in the\ndevelopment version of the application. Otherwise ignored.\nSee \\c #SPBlockDebugSuite::GetBlockDebug().\n@param block [out] A buffer in which to return the block pointer.\n@see \\c #SPBasicSuite::AllocateBlock()"]
    pub AllocateBlock: ::std::option::Option<
        unsafe extern "C" fn(
            size: usize,
            debug: *const ::std::os::raw::c_char,
            block: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Frees a block of memory allocated with \\c #AllocateBlock().\n@param block The block pointer.\n@see \\c #SPBasicSuite::FreeBlock()"]
    pub FreeBlock:
        ::std::option::Option<unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> SPErr>,
    #[doc = " Reallocates a block previously allocated with \\c #AllocateBlock().\nIncreases the size without changing the location, if possible.\n@param block The block pointer.\n@param newSize The new number of bytes.\n@param debug Optional. A tag for the block, available in the\ndevelopment version of the application. Otherwise ignored.\nSee \\c #SPBlockDebugSuite::GetBlockDebug().\n@param newblock [out] A buffer in which to return the new block pointer.\n@see \\c #SPBasicSuite::ReallocateBlock()"]
    pub ReallocateBlock: ::std::option::Option<
        unsafe extern "C" fn(
            block: *mut ::std::os::raw::c_void,
            newSize: usize,
            debug: *const ::std::os::raw::c_char,
            rblock: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
}
#[doc = " Basic suite-access information provided with every call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPMessageData {
    #[doc = " \\c #kSPValidSPMessageData if this is a valid PICA message."]
    pub SPCheck: ai_int32,
    #[doc = " This plug-in, an \\c #SPPluginRef."]
    pub self_: *mut SPPlugin,
    #[doc = " An array of application-wide global variables."]
    pub globals: *mut ::std::os::raw::c_void,
    #[doc = " A pointer to the basic PICA suite, which you use to obtain all other suites."]
    pub basic: *mut SPBasicSuite,
}
#[doc = "\tTypes\n\n/\n/** Prototype for the cache-flushing procedure an adapter calls in response to the\n\\c #kSPAdaptersDisposeInfoSelector, to determine which plug-ins to unload,\nand inform the caller of whether its managed plug-in have been unloaded.\n@param type The plug-in type, as set by the adapter. For PICA plug-ins, this type\nis \\c #kSPFlushAccessType.\n@param data A pointer to the adapter-defined plug-in data. For PICA plug-ins, this\ndata is an \\c #SPAccessRef.\n@param flushed [out] A buffer in which to return the result,\nthe number of plug-ins actually unloaded."]
pub type SPFlushCachesProc = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        flushed: *mut ai_int32,
    ) -> SPErr,
>;
#[doc = " Message passed with the \\c #kSPPluginPurgeCachesSelector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPurgeCachesMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
}
#[doc = "\tSuite\n\n/\n/** @ingroup Suites\nThis suite allows you to manage PICA cache memory.\n\nPICA plug-ins are intended to move in and out of memory (cache) as necessary,\nto allow a small memory footprint. By default, PICA keeps loaded plug-ins in\ncache until the application heap has been filled, and then unloads them.\nBeyond this simple strategy, the application and plug-ins can use this\nfunction to unload plug-ins when needed. Plug-ins do not typically need\nto do this.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPCachesSuite and \\c #kSPCachesSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPCachesSuite {
    #[doc = " Sends a message to all plug-in adapters telling them to unload any\nunused plug-ins from memory.\n@param flushProc The procedure the adapter uses to determine which\nplug-ins to unload.\n@param flushed [out] A buffer in which to return the result of the\nprocedure calls, the total number of plug-ins actually unloaded."]
    pub SPFlushCaches: ::std::option::Option<
        unsafe extern "C" fn(flushProc: SPFlushCachesProc, flushed: *mut ai_int32) -> SPErr,
    >,
}
#[doc = " Data type for plug-in property key and vendor ID. See \\c #PIProperty."]
pub type PIType = ai_uint32;
#[doc = " Plug-in property. Properties contain information about\nplug-in resource files, such as their type and location."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PIProperty {
    #[doc = " Vendor-specific identifier."]
    pub vendorID: PIType,
    #[doc = " Identification key for this resource type."]
    pub propertyKey: PIType,
    #[doc = " 0-based index of this resource within its type.\nMust be unique for properties of a given type within\na property list."]
    pub propertyID: ai_int32,
    #[doc = " Number of characters in the data array. Rounded to a multiple of 4."]
    pub propertyLength: ai_int32,
    #[doc = " The property data array that contains the property value, a string of 4 characters."]
    pub propertyData: [::std::os::raw::c_char; 1usize],
}
#[doc = " Plug-in property list. Provides the version number of the plug-in\nproperty mechanism itself, and properties for the associated plug-in."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PIPropertyList {
    #[doc = " Version number for the \\c #PIProperty structure."]
    pub version: ai_int32,
    #[doc = " Number of properties in the list."]
    pub count: ai_int32,
    #[doc = " The properties array."]
    pub properties: [PIProperty; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPProperty {
    _unused: [u8; 0],
}
#[doc = " Types\n\n/\n/** An opaque reference to a plug-in property. Access with the \\c #SPPropertiesSuite."]
pub type SPPropertyRef = *mut SPProperty;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPropertyList {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a plug-in property list. Create and access with the \\c #SPPropertiesSuite."]
pub type SPPropertyListRef = *mut SPPropertyList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPropertyListIterator {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to an iterator for a plug-in property list. Create and access with the \\c #SPPropertiesSuite."]
pub type SPPropertyListIteratorRef = *mut SPPropertyListIterator;
#[doc = " Message passed with the \\c #kSPPropertiesCaller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPropertiesMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " Unique identifier for the vendor defining this property type. This allows\nyou to define your own properties in a way that\ndoes not conflict with either Adobe or other vendors.\nUse a registered application creator code to ensure uniqueness.\nAll PICA properties use \\c #PIAdobeVendorID."]
    pub vendorID: PIType,
    #[doc = " The property type key code, typically identifies a resource type."]
    pub propertyKey: PIType,
    #[doc = " The unique property identifier, for multiple resources of a given\ntype. Normally, there is only one, and the ID value is 0."]
    pub propertyID: ai_int32,
    #[doc = " A structure containing the property data, or value."]
    pub property: *mut ::std::os::raw::c_void,
    #[doc = " Reference count. Increment when a property is acquired, decrement\nwhen it is released."]
    pub refCon: ai_int32,
    #[doc = " True (non-zero) if this property does not change between sessions\nand can be cached by the application in the start-up preferences\nfile, false (0) otherwise. Typically true."]
    pub cacheable: ai_int32,
}
#[doc = " Suite\n\n/\n/** @ingroup Suites\nUse these functions to create, access, and manage plug-in property lists\nassociated with a specific plug-in. Plug-in properties provide the\napplication with resource information for the plug-in, such as the types\nand locations of code files, and the plug-in version.\n\nA plug-in can be associated with multiple properties lists.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPPropertiesSuite and \\c #kSPPropertiesSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPropertiesSuite {
    #[doc = " Creates a new plug-in property list.\n@param stringPool The string pool in which to keep plug-in names.\n@param propertyList [out] A buffer in which to return the new list object."]
    pub AllocatePropertyList:
        ::std::option::Option<unsafe extern "C" fn(propertyList: *mut SPPropertyListRef) -> SPErr>,
    #[doc = " Frees a list of plug-in properties allocated with \\c #AllocatePropertyList(), and\nalso frees any entries in the list. If the list is one of a chain, frees the\nentire chain.\n@param propertyList The plug-in properties list object.\n@see \\c #SPHasMultiplePropertyLists()"]
    pub FreePropertyList:
        ::std::option::Option<unsafe extern "C" fn(propertyList: SPPropertyListRef) -> SPErr>,
    #[doc = " Adds a set of properties to a plug-in properties list. This set is typically\nread from a resource file.Creates an \\c #SPPropertyRef for each property,\nbut does not return these objects.\n@param propertyList The plug-in properties list object.\n@param pList A pointer to the low-level structure for the set of properties to add.\n@param refCon The initial reference count for properties in the set.\n@param cacheable True (non-zero) if these properties do not change between sessions\nand can be cached by the application in the start-up preferences\nfile, false (0) otherwise. Typically true.\n@see \\c #AddProperty()"]
    pub AddProperties: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            pList: *mut PIPropertyList,
            refCon: ai_int32,
            cacheable: ai_int32,
        ) -> SPErr,
    >,
    #[doc = " Creates a new individual property and adds it to a plug-in properties list.\nTypically called to install a property returned from an \\c #kSPPropertiesAcquireSelector message.\n@param propertyList The plug-in properties list object.\n@param vendorID\tThe vendor identifier for the new property.\n@param propertyKey The type key code for the new property.\n@param propertyID The unique identifier for the individual property (normally 0).\n@param p A pointer to the property value structure.\n@param refCon The initial reference count for property.\n@param cacheable True (non-zero) if this property does not change between sessions\nand can be cached by the application in the start-up preferences\nfile, false (0) otherwise. Typically true.\n@param property [out] A buffer in which to return the new property object.\n@see \\c #AllocatePropertyList(), \\c #AddProperties()"]
    pub AddProperty: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            vendorID: PIType,
            propertyKey: PIType,
            propertyID: ai_int32,
            p: *mut PIProperty,
            refCon: ai_int32,
            cacheable: ai_int32,
            property: *mut SPPropertyRef,
        ) -> SPErr,
    >,
    #[doc = "\tRetrieves a property from a plug-in properties list, or from any list in its chain.\n@param propertyList The plug-in properties list object.\n@param vendorID\tThe vendor identifier for the new property.\n@param propertyKey The type key code for the new property.\n@param propertyID The unique identifier for the individual property (normally 0).\n@param property [out] A buffer in which to return the property object, or \\c NULL if a\nmatching property is not found.\n@param \\c #FindPropertyLocal()"]
    pub FindProperty: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            vendorID: PIType,
            propertyKey: PIType,
            propertyID: ai_int32,
            property: *mut SPPropertyRef,
        ) -> SPErr,
    >,
    #[doc = " Creates an iterator object with which to traverse a plug-in properties list.\nThe iterator is initially set to the first property in the list.\n@param propertyList The plug-in properties list object.\n@param iter [out] A buffer in which to return the new iterator object.\n@see \\c #NextProperty(), \\c #DeletePropertyListIterator()"]
    pub NewPropertyListIterator: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            iter: *mut SPPropertyListIteratorRef,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the current property and advances a plug-in properties list iterator\nto the next property in the list.\n@param iter The plug-in properties list iterator object.\n@param property [out] A buffer in which to return the current property object, \\c NULL\nif the end of the list has been reached.\n@see \\c #NewPropertyListIterator(),"]
    pub NextProperty: ::std::option::Option<
        unsafe extern "C" fn(
            iter: SPPropertyListIteratorRef,
            property: *mut SPPropertyRef,
        ) -> SPErr,
    >,
    #[doc = " Frees a plug-in properties list iterator that is no longer needed.\n@param iter The plug-in properties list iterator object.\n@see \\c #NewPropertyListIterator(),"]
    pub DeletePropertyListIterator:
        ::std::option::Option<unsafe extern "C" fn(iter: SPPropertyListIteratorRef) -> SPErr>,
    #[doc = "\tRetrieves the low-level property structure of a property object.\n@param property The property object.\n@param p [out] A buffer in which to return a pointer to the property structure."]
    pub GetPropertyPIProperty: ::std::option::Option<
        unsafe extern "C" fn(property: SPPropertyRef, p: *mut *mut PIProperty) -> SPErr,
    >,
    #[doc = "\tRetrieves the current reference count of a property.\n@param property The property object.\n@param refCon [out] A buffer in which to return the reference count."]
    pub GetPropertyRefCon: ::std::option::Option<
        unsafe extern "C" fn(property: SPPropertyRef, refCon: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tReports whether a property is cacheable.\n@param property The property object.\n@param cacheable [out] A buffer in which to return true (non-zero)\nif this property does not change between sessions\nand can be cached by the application in the start-up preferences\nfile, false (0) otherwise."]
    pub GetPropertyCacheable: ::std::option::Option<
        unsafe extern "C" fn(property: SPPropertyRef, cacheable: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tReports whether a property was allocated by the plug-in that contains it.\n@param property The property object.\n@param allocatedByPlugin [out] A buffer in which to return true (non-zero)\nif this property was created after being acquired from a\n\\c #kSPPropertiesAcquireSelector message, false (0) if the\nproperty was read from a resource file.\n@see \\c #AddProperty(), \\c #AddProperties()"]
    pub GetPropertyAllocatedByPlugin: ::std::option::Option<
        unsafe extern "C" fn(property: SPPropertyRef, allocatedByPlugin: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tReports whether a plug-in properties list is one of a chain of properties lists for its plug-in.\n(Note that this function returns a boolean value, not an error code.)\n@param propertyList The plug-in properties list object.\n@return True (non-zero) if the list is one of a chain, false (0) otherwise.\n@see \\c #GetNextPropertyList()"]
    pub SPHasMultiplePropertyLists:
        ::std::option::Option<unsafe extern "C" fn(propertyList: SPPropertyListRef) -> SPBoolean>,
    #[doc = "\tRetrieves the next plug-in properties list in a properties-list chain.\n@param propertyList The current plug-in properties list object.\n@param nextPropertyList [out] A buffer in which to return the next properties list object,\nor \\c NULL if the end of the chain has been reached."]
    pub GetNextPropertyList: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            nextPropertyList: *mut SPPropertyListRef,
        ) -> SPErr,
    >,
    #[doc = "\tRetrieves a property from a plug-in properties list, but does not search in other\nlists in the chain.\n@param propertyList The plug-in properties list object.\n@param vendorID\tThe vendor identifier for the new property.\n@param propertyKey The type key code for the new property.\n@param propertyID The unique identifier for the individual property (normally 0).\n@param property [out] A buffer in which to return the property object, or \\c NULL if a\nmatching property is not found.\n@see \\c #FindProperty()"]
    pub FindPropertyLocal: ::std::option::Option<
        unsafe extern "C" fn(
            propertyList: SPPropertyListRef,
            vendorID: PIType,
            propertyKey: PIType,
            propertyID: ai_int32,
            property: *mut SPPropertyRef,
        ) -> SPErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAdapter {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to an adapter object. Access using the \\c #SPAdaptersSuite."]
pub type SPAdapterRef = *mut SPAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAdapterList {
    _unused: [u8; 0],
}
#[doc = " A list of adapter objects. Create with\n\\c #SPAdaptersSuite::AllocateAdapterList(), or use\nthe global list, \\c #kSPRuntimeAdapterList."]
pub type SPAdapterListRef = *mut SPAdapterList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAdapterListIterator {
    _unused: [u8; 0],
}
#[doc = " An iterator object for examining an adapter list.\nSee \\c #SPAdaptersSuite::NewAdapterListIterator()."]
pub type SPAdapterListIteratorRef = *mut SPAdapterListIterator;
#[doc = " The message passed with all \\c #kSPAdaptersCaller calls.\nFields are used by specific selectors as indicated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAdaptersMessage {
    #[doc = " The message data. All selectors."]
    pub d: SPMessageData,
    #[doc = " The adapter object. All selectors. If you add more than\none adapter for a plug-in, use this to determine which handler to use."]
    pub adapter: SPAdapterRef,
    #[doc = " For \\c #kSPAdaptersAboutSelector, \\c #kSPAdaptersLoadPluginSelector, \\c #kSPAdaptersReleasePluginSelector,\n\\c #kSPAdaptersSendMessageSelector, \\c #kSPAdaptersFindPropertySelector, the plug-in object which to\nact upon (display information, load, release, send a message to, or find properties for)."]
    pub targetPlugin: *mut SPPlugin,
    #[doc = " For all selectors, the target result of the handler, if any."]
    pub targetResult: SPErr,
    #[doc = " For \\c #kSPAdaptersFindPropertySelector.\nNo longer used."]
    pub vendorID: PIType,
    #[doc = " For \\c #kSPAdaptersFindPropertySelector.\nNo longer used."]
    pub propertyKey: PIType,
    #[doc = " For \\c #kSPAdaptersFindPropertySelector.\nNo longer used."]
    pub propertyID: ai_int32,
    #[doc = " For \\c #kSPAdaptersFindPropertySelector.\nNo longer used."]
    pub property: *mut ::std::os::raw::c_void,
    #[doc = " For \\c #kSPAdaptersFlushSelector. The procedure with which to flush caches,\npassed from the call to \\c #SPCachesSuite::SPFlushCaches().\nThe adapter should call this to determine which plug-ins are being removed from\nmemory, and unload them."]
    pub flushProc: SPFlushCachesProc,
    #[doc = " For \\c #kSPAdaptersFlushSelector. Return the result of the flush procedure,\nthe number of plug-ins removed."]
    pub flushed: ai_int32,
    #[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
    pub suiteList: *mut SPSuiteList,
    #[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
    pub suite: *mut SPSuite,
    #[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
    pub host: *mut SPPlugin,
    #[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
    pub suiteProcs: *const ::std::os::raw::c_void,
    #[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
    pub acquired: ai_int32,
    #[doc = " For \\c #kSPAdaptersSendMessageSelector.\nThe caller to pass to the adapted plug-in."]
    pub plugin_caller: *const ::std::os::raw::c_char,
    #[doc = " For \\c #kSPAdaptersSendMessageSelector.\nThe selector to pass to the adapted plug-in."]
    pub plugin_selector: *const ::std::os::raw::c_char,
    #[doc = " For \\c #kSPAdaptersSendMessageSelector.\nThe message to pass to the adapted plug-in."]
    pub plugin_message: *mut ::std::os::raw::c_void,
}
#[doc = " A string pool structure. See \\c #SPStringsSuite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPStringPool {
    _unused: [u8; 0],
}
#[doc = " Suite\n\n/\n/** @ingroup Suites\nAn adapter is an interface between the PICA plug-in manager and\nan individual plug-in. PICA and application plug-ins are hosted by\ninternal PICA adapters. Plug-ins can add other adapters to PICA's\n\\e adapter \\e list, allowing non-PICA plug-ins to run under the PICA API.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPAdaptersSuite and \\c #kSPAdaptersSuiteVersion.\n\nAn adapter searches the PICA \\e file \\e list (\\c #kSPRuntimeFileList)\nfor plug-ins types that it supports, and adds them to the \\e plug-in \\e list\n(\\c #kSPRuntimePluginList). When notified by PICA to do so, the adapter is\nresponsible for loading and calling the plug-ins it adds, and must\ndo any conversion of messages, data structures or other API elements.\nAn adapter can be used to update\n\nThere are always at least two adapters, the internal adapters for PICA\nand for the application, in the  global adapter list (\\c #kSPRuntimeAdapterList).\nThe internal adapters translate any legacy function calls into those\ncurrently supported by PICA and the application.\n\nYou can provide an adapter for backward compatibility with older\nversions of your own plug-ins, or to interpret your own file types.\nTo make an adapter available for your plug-in, add it in response to the\n\\c #kSPAdaptersRegisterPluginsSelector when your plug-in is loaded.\n\nYou can also use this suite to create and maintain your own adapter list,\nin addition to the global list.\n\nUse the adapter to load and call the adapted plug-in. For example, to\nverify that a message could be sent to a plug-in:\n@code\nSPErr error;\nSPPluginRef pluginToCall;\nSPAdapterRef pluginsAdapter;\nchar *adapterName;\nlong adapterVersion;\n\nerror = sSPPlugins->GetPluginAdapter( pluginToCall, &pluginsAdapter );\nerror = sSPAdapters->GetAdapterName( pluginsAdapter, &adapterName );\nif ( strcmp( adapterName, kSPSweetPea2Adapter ) == 0 ) {\n// it is a PICA plug-in, call it as such with sSPInterface.\n} else if ( strcmp( adapterName, \"MYAPP Legacy Plug-in Adapter\" ) == 0 ) {\n// it is an adapted plug-in, call it with the adapter�s\n// interface suite\nerror = sSPAdapters->GetAdapterVersion( pluginsAdapter, &adapterVersion );\nif ( adapterVersion == 1 ) {\n// use one hypothetical interface suite\n} else if ( adapterVersion == 2) {\n// use another hypothetical interface suite\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAdaptersSuite {
    #[doc = " Allocates a new list of adapters. You can keep your own list,\nor obtain the global list with \\c #SPRuntimeSuite::GetRuntimeAdapterList().\n@param stringPool The string pool in which to keep adapter names.\n@param adapterList [out] A buffer in which to return the new list object."]
    pub AllocateAdapterList: ::std::option::Option<
        unsafe extern "C" fn(
            stringPool: *mut SPStringPool,
            adapterList: *mut SPAdapterListRef,
        ) -> SPErr,
    >,
    #[doc = " Frees a list of adapters allocated with \\c #AllocateAdapterList(), and\nalso frees any entries in the list. Do not free the global list (\\c #kSPRuntimeAdapterList).\n@param adapterList The adapter list object."]
    pub FreeAdapterList:
        ::std::option::Option<unsafe extern "C" fn(adapterList: SPAdapterListRef) -> SPErr>,
    #[doc = " Creates a new adapter object and adds it to an adapter list. Do this in\nresponse to the \\c #kSPAdaptersRegisterPluginsSelector message.\n@param adapterList The adapter list object, or \\c NULL to use the\nglobal list.\n@param host\tThis plug-in object, for which the adapter is responsible.\n@param name The unique, identifying name of the adapter.\n@param version The version number of the adapter. Only the latest version\nof any adapter is used to start up plug-ins.\n@param adapter [out] A buffer in which to return the new adapter object, or\n\\c NULL if you add only one adapter. If you add more than one adapter,\ncompare this to \\c #SPAdaptersMessage::adapter to determine which handler to use.\n@see \\c #AllocateAdapterList()"]
    pub AddAdapter: ::std::option::Option<
        unsafe extern "C" fn(
            adapterList: SPAdapterListRef,
            host: *mut SPPlugin,
            name: *const ::std::os::raw::c_char,
            version: ai_int32,
            adapter: *mut SPAdapterRef,
        ) -> SPErr,
    >,
    #[doc = " Retrieves an adapter by name.\n@param adapterList The adapter list object, or \\c NULL to use the\nglobal list.\n@param name The unique, identifying name of the adapter.\n@param adapter [out] A buffer in which to return the adapter object."]
    pub SPFindAdapter: ::std::option::Option<
        unsafe extern "C" fn(
            adapterList: SPAdapterListRef,
            name: *const ::std::os::raw::c_char,
            adapter: *mut SPAdapterRef,
        ) -> SPErr,
    >,
    #[doc = " Creates an iterator object with which to traverse an adapter list.\nThe iterator is initially set to the first adapter in the list.\n@param adapterList The adapter list object, or \\c NULL to use the\nglobal list.\n@param iter [out] A buffer in which to return the new iterator object.\n@see \\c #NextAdapter(), \\c #DeleteAdapterListIterator()"]
    pub NewAdapterListIterator: ::std::option::Option<
        unsafe extern "C" fn(
            adapterList: SPAdapterListRef,
            iter: *mut SPAdapterListIteratorRef,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the current adapter and advances an adapter-list iterator to the\nnext adapter in the list.\n@param iter The adapter-list iterator object.\n@param adapter [out] A buffer in which to return the current adapter object, \\c NULL\nif the end of the list has been reached.\n@see \\c #NewAdapterListIterator(),"]
    pub NextAdapter: ::std::option::Option<
        unsafe extern "C" fn(iter: SPAdapterListIteratorRef, adapter: *mut SPAdapterRef) -> SPErr,
    >,
    #[doc = " Frees an adapter-list iterator that is no longer needed.\n@param iter The adapter-list iterator object.\n@see \\c #NewAdapterListIterator(),"]
    pub DeleteAdapterListIterator:
        ::std::option::Option<unsafe extern "C" fn(iter: SPAdapterListIteratorRef) -> SPErr>,
    #[doc = " Retrieves the plug-in that an adapter manages.\n@param adapter The adapter object.\n@param plug-in [out] A buffer in which to return the plug-in object."]
    pub GetAdapterHost: ::std::option::Option<
        unsafe extern "C" fn(adapter: SPAdapterRef, plugin: *mut *mut SPPlugin) -> SPErr,
    >,
    #[doc = " Retrieves the unique, identifying name of an adapter.\n@param adapter The adapter object.\n@param name [out] A buffer in which to return the name string."]
    pub GetAdapterName: ::std::option::Option<
        unsafe extern "C" fn(
            adapter: SPAdapterRef,
            name: *mut *const ::std::os::raw::c_char,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the version of an adapter.\n@param adapter The adapter object.\n@param version [out] A buffer in which to return the version number."]
    pub GetAdapterVersion: ::std::option::Option<
        unsafe extern "C" fn(adapter: SPAdapterRef, version: *mut ai_int32) -> SPErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPFile {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a file. Access with the \\c #SPFilesSuite."]
pub type SPFileRef = *mut SPFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPFileList {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a file list. Access with the \\c #SPFilesSuite."]
pub type SPFileListRef = *mut SPFileList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPFileListIterator {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a file-list iterator. Access with the \\c #SPFilesSuite."]
pub type SPFileListIteratorRef = *mut SPFileListIterator;
#[doc = " A file specification In Mac OS.It is the same as \\c FSSpec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlatformFileSpecification {
    #[doc = " The version number (Mac OS)."]
    pub vRefNum: ::std::os::raw::c_short,
    #[doc = " The unique identifier (Mac OS)."]
    pub parID: ai_int32,
    #[doc = " The file name string (Mac OS)."]
    pub name: [::std::os::raw::c_uchar; 64usize],
}
#[doc = " A file reference in terms of a string. This path should be POSIX style path with UTF-8 encoding.\nFSRefMakePath can be used to make a path from FSRef and FSPathMakeRef can be used to make FSRef from a POSIX style path."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlatformFileReference {
    pub path: [::std::os::raw::c_uchar; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlatformFileInfoLight {
    #[doc = " Date file was created (Mac OS)."]
    pub creationDate: ai_uint32,
    #[doc = " Data file was last modified (Mac OS)."]
    pub modificationDate: ai_uint32,
    pub extension: [::std::os::raw::c_char; 32usize],
}
#[doc = " Platform-specific file metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlatformFileInfo {
    #[doc = " Not used."]
    pub attributes: ai_uint32,
    #[doc = " Date file was created (Mac OS)."]
    pub creationDate: ai_uint32,
    #[doc = " Data file was last modified (Mac OS)."]
    pub modificationDate: ai_uint32,
    #[doc = " Type of file for Finder (Mac OS)."]
    pub finderType: ai_uint32,
    #[doc = " File creator (Mac OS)."]
    pub finderCreator: ai_uint32,
    #[doc = " File flags for Finder (Mac OS); see Mac OS documentation."]
    pub finderFlags: ai_uint16,
}
#[doc = " Suite\n\n/\n/** @ingroup Suites\nThis suite allows you to access the PICA files list. This list, created at startup,\ncontains references to every file in the application's plug-in folder, including\nany resolved file and folder aliases. PICA maintains this list, and uses it to find plug-ins.\n\nUse this suite to access the plug-in file list, in order to avoid redundant directory\nscans. Adapters looking for their own plug-ins and PICA plug-ins looking for\nsupport files should scan the list to locate relevant files rather than walking\nplatform directory  structures on their own.\n\nSimilarly, you can use this suite to create, maintain, and access your own lists\nof files in a platform-independent and efficient manner.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPFilesSuite and \\c #kSPFilesSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPFilesSuite {
    #[doc = " Creates a new file list. Typically, you use the main PICA file list to access\nplug-in files, available through \\c #SPRuntimeSuite::GetRuntimeFileList().\nYou can use this to track other file collections. If you create a new list, you\nmust free it when it is no longer needed, using \\c #FreeFileList().\n@param fileList [out] A buffer in which to return the new file list object."]
    pub AllocateFileList:
        ::std::option::Option<unsafe extern "C" fn(fileList: *mut SPFileListRef) -> SPErr>,
    #[doc = " Frees a file list created with \\c #AllocateFileList(), and any entries in the list.\n@param fileList The file list object."]
    pub FreeFileList: ::std::option::Option<unsafe extern "C" fn(fileList: SPFileListRef) -> SPErr>,
    #[doc = " Adds a file or all files in a directory to a file list. Searches a directory\nrecursively for contained files.\n@param fileList The file list object.\n@param file The file or directory specification."]
    pub AddFiles: ::std::option::Option<
        unsafe extern "C" fn(
            fileList: SPFileListRef,
            file: *const SPPlatformFileReference,
        ) -> SPErr,
    >,
    #[doc = " Creates a file-list iterator object to use with \\c #NextFile() for iterating\nthrough a file list. The iterator is initially set to the first file in the list.\nWhen the iterator is no longer needed, free it with \\c #DeleteFileListIterator().\n@param fileList The file list object.\n@param iter [out] A buffer in which to return the new iterator object."]
    pub NewFileListIterator: ::std::option::Option<
        unsafe extern "C" fn(fileList: SPFileListRef, iter: *mut SPFileListIteratorRef) -> SPErr,
    >,
    #[doc = " Retrieves the current file from a file list iterator, and advances the iterator.\n@param iter The iterator object.\n@param file [out] A buffer in which to return the current file object, or \\c NULL\nif the end of the list has been reached."]
    pub NextFile: ::std::option::Option<
        unsafe extern "C" fn(iter: SPFileListIteratorRef, file: *mut SPFileRef) -> SPErr,
    >,
    #[doc = " Frees a file-list iterator created with /c #NewFileListIterator().\n@param iter The iterator object."]
    pub DeleteFileListIterator:
        ::std::option::Option<unsafe extern "C" fn(iter: SPFileListIteratorRef) -> SPErr>,
    pub GetFileReference: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, fileSpec: *mut SPPlatformFileReference) -> SPErr,
    >,
    #[doc = " Retrieves the  metadata for a file.\n@param file The file object.\n@param info [out] A buffer in which to return the file information."]
    pub GetFileInfo: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, info: *mut SPPlatformFileInfo) -> SPErr,
    >,
    #[doc = " Reports whether a file in a file list is a plug-in.\n@param file The file object.\n@param isAPlugin [out] A buffer in which to return true if the file is a plug-in."]
    pub GetIsAPlugin: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, isAPlugin: *mut SPBoolean) -> SPErr,
    >,
    #[doc = " Sets whether a file in a file list is a plug-in.\n@param file The file object.\n@param isAPlugin True to mark the file as a plug-in, false to mark it as not a plug-in."]
    pub SetIsAPlugin:
        ::std::option::Option<unsafe extern "C" fn(file: SPFileRef, isAPlugin: SPBoolean) -> SPErr>,
    #[doc = " Retrieves the property list for a file.\n@param file The file object.\n@param propertList [out] A buffer in which to return the property list,\nor \\c #kFileDoesNotHavePiPL if the file does not have a property list,\nor \\c #kFileHasMulitplePiPLs if the file has multiple property lists.\n@see \\c SPPiPL.h"]
    pub GetFilePropertyList: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, propertList: *mut SPPropertyListRef) -> SPErr,
    >,
    #[doc = " Sets the property list for a file.\n@param file The file object.\n@param propertList The new property list."]
    pub SetFilePropertyList: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, propertList: SPPropertyListRef) -> SPErr,
    >,
    pub GetFileInfoLight: ::std::option::Option<
        unsafe extern "C" fn(file: SPFileRef, info: *mut SPPlatformFileInfoLight) -> SPErr,
    >,
}
#[doc = " Opaque reference to a string pool. Access with the \\c #SPStringsSuite."]
pub type SPStringPoolRef = *mut SPStringPool;
#[doc = " @ingroup Suites\nThis suite allows you to work with the PICA string pool.\n\nPICA manages a string pool, which provides an efficient central\nstorage space for C strings. When a string is placed in the pool, PICA\nchecks whether it already exists in the pool, and if so, returns a\npointer to the existing string. If not, it copies the string into the pool,\nand returns a pointer to the copy.\n\nThis mechanisms atomizes the strings. Because each string exists in\nonly one place, strings can be compared by address, rather than character\nby character, and string searches are made much more efficient.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPStringsSuite and \\c #kSPStringsSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPStringsSuite {
    #[doc = " Creates a new string pool and allocates an initial block of memory for\nits strings. You can also access PICA's global string pool,\nusing \\c #SPRuntimeSuite::GetRuntimeStringPool().\n@param stringPool [out] A buffer in which to return the new string pool reference."]
    pub AllocateStringPool:
        ::std::option::Option<unsafe extern "C" fn(stringPool: *mut SPStringPoolRef) -> SPErr>,
    #[doc = " Frees the memory used for a string pool created with \\c #AllocateStringPool().\nDo not free the global string pool (\\c #kSPRuntimeStringPool).\n@param stringPool The string pool reference."]
    pub FreeStringPool:
        ::std::option::Option<unsafe extern "C" fn(stringPool: SPStringPoolRef) -> SPErr>,
    #[doc = " Adds a string to a string pool, or, if the string has already been added\nto the pool, retrieves a reference to the pooled string.\n@param stringPool The string pool reference.\n@param string The string.\n@param wString [out] A buffer in which to return the address of\nthe atomized string in the pool."]
    pub MakeWString: ::std::option::Option<
        unsafe extern "C" fn(
            stringPool: SPStringPoolRef,
            string: *const ::std::os::raw::c_char,
            wString: *mut *const ::std::os::raw::c_char,
        ) -> SPErr,
    >,
}
#[doc = " Opaque reference to a plug-in object. Access with the \\c #SPPluginsSuite."]
pub type SPPluginRef = *mut SPPlugin;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPluginList {
    _unused: [u8; 0],
}
#[doc = " A list of plug-in objects. Create with\n\\c #SPPluginsSuite::AllocatePluginList(), or use\nthe global list, \\c #kSPRuntimePluginList."]
pub type SPPluginListRef = *mut SPPluginList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPluginListIterator {
    _unused: [u8; 0],
}
#[doc = " An iterator object for examining a plug-in list.\nSee \\c #SPPluginsSuite::NewPluginListIterator()."]
pub type SPPluginListIteratorRef = *mut SPPluginListIterator;
#[doc = " PICA file-access error"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SPErrorData {
    #[doc = " The file for which the error occurred."]
    pub mErrorFile: SPPlatformFileReference,
    #[doc = " Error code, see @ref Errors."]
    pub mErrorCode: SPErr,
    pub mPluginRef: SPPluginRef,
}
#[doc = " PICA file-access error"]
pub type SPErrorData = _SPErrorData;
#[doc = " PICA file-access error"]
pub type SPErrorDataPtr = *mut _SPErrorData;
pub type SPPluginEntryFunc = ::std::option::Option<
    unsafe extern "C" fn(
        caller: *const ::std::os::raw::c_char,
        selector: *const ::std::os::raw::c_char,
        message: *mut ::std::os::raw::c_void,
    ) -> SPErr,
>;
#[doc = " This suite allows you to access and manipulate the plug-in object for your own\nand those of other plug-ins managed by the Adobe plug-in manager (PICA).\nYou can access both plug-ins provided with the application (\\e host plug-ins),\nand external plug-ins.You can query and set plug-in states,\nincluding the \"broken\" state, which indicates that a plug-in has\nbecome unavailable due to an error condition.\n\nYou can also use this suite to create and use your own lists of plug-ins,\nin addition to the global list kept by the application.\n\nFor higher-level access to plug-ins, see \\c #AIPluginSuite.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPPluginsSuite and \\c #kSPPluginsSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPluginsSuite {
    #[doc = " Creates a new plug-in list. You can also access PICA's global plug-in list,\nusing \\c #SPRuntimeSuite::GetRuntimePluginList().\n@param stringPool The string pool in which to keep plug-in names.\n@param pluginList [out] A buffer in which to return the new list object."]
    pub AllocatePluginList: ::std::option::Option<
        unsafe extern "C" fn(strings: SPStringPoolRef, pluginList: *mut SPPluginListRef) -> SPErr,
    >,
    #[doc = " Frees a list of plug-ins allocated with \\c #AllocatePluginList(), and\nalso frees any entries in the list. Do not free the global list (\\c #kSPRuntimePluginList).\n@param pluginList The plug-in list object."]
    pub FreePluginList:
        ::std::option::Option<unsafe extern "C" fn(pluginList: SPPluginListRef) -> SPErr>,
    #[doc = " Creates a new plug-in object and adds it to a plug-in list.\n@param pluginList The plug-in list object, or \\c NULL to use the\nglobal list.\n@param fileSpec The file specification for the plug-in code and resources.\n@param PiPL The structure containing the plug-in properties.\n@param adapterName The unique identifying name of the adapter for the new plug-in.\n@param adapterInfo A pointer to the adapter-defined structure that stores needed\ninformation about this plug-in.\n@param plugin [out] A buffer in which to return the new plug-in object.\n@see \\c #AllocatePluginList(), \\c #SPAdaptersSuite"]
    pub AddPlugin: ::std::option::Option<
        unsafe extern "C" fn(
            pluginList: SPPluginListRef,
            fileSpec: *const SPPlatformFileReference,
            PiPL: *mut PIPropertyList,
            adapterName: *const ::std::os::raw::c_char,
            adapterInfo: *mut ::std::os::raw::c_void,
            plugin: *mut SPPluginRef,
        ) -> SPErr,
    >,
    #[doc = " Creates an iterator object with which to traverse a plug-in list.\nThe iterator is initially set to the first plug-in in the list.\n@param pluginList The plug-in list object, or \\c NULL to use the\nglobal list.\n@param iter [out] A buffer in which to return the new iterator object.\n@see \\c #NextPlugin(), \\c #DeletePluginListIterator()"]
    pub NewPluginListIterator: ::std::option::Option<
        unsafe extern "C" fn(
            pluginList: SPPluginListRef,
            iter: *mut SPPluginListIteratorRef,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the current plug-in and advances a plug-in-list iterator to the next plug-in in the list.\n@param iter The plug-in-list iterator object.\n@param plugin [out] A buffer in which to return the current plug-in object, \\c NULL\nif the end of the list has been reached.\n@see \\c #NewPluginListIterator(),"]
    pub NextPlugin: ::std::option::Option<
        unsafe extern "C" fn(iter: SPPluginListIteratorRef, plugin: *mut SPPluginRef) -> SPErr,
    >,
    #[doc = " Frees a plug-in-list iterator that is no longer needed.\n@param iter The plug-in-list iterator object.\n@see \\c #NewPluginListIterator(),"]
    pub DeletePluginListIterator:
        ::std::option::Option<unsafe extern "C" fn(iter: SPPluginListIteratorRef) -> SPErr>,
    #[doc = "\tReports whether a plug-in that is needed is available in a plug-in list.\n@param pluginList The plug-in list object, or \\c NULL to use the global list.\n@param available [out] A buffer in which to return true if the plug-in\nis found in the list.\n@see \\c #SPInterfaceSuite::StartupExport()"]
    pub GetPluginListNeededSuiteAvailable: ::std::option::Option<
        unsafe extern "C" fn(pluginList: SPPluginListRef, available: *mut SPBoolean) -> SPErr,
    >,
    #[doc = "\tRetrieves the callback structure provided by the host application for a plug-in.\n@param plugin The plug-in object.\n@param host A buffer in which to return the callback procedure."]
    pub GetPluginHostEntry: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, host: *mut SPPluginEntryFunc) -> SPErr,
    >,
    #[doc = "\tRetrieves the code and resources file of a plug-in.\n@param plugin The plug-in object.\n@param fileSpec [out] A buffer in which to return the file specification.\n@see \\c #SPFilesSuite"]
    pub GetPluginFileReference: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, fileSpec: *mut SPPlatformFileReference) -> SPErr,
    >,
    #[doc = "\tRetrieves the property list of a plug-in.\n@param plugin The plug-in object.\n@param propertList [out] A buffer in which to return the property list object.\n@see \\c #SPPropertiesSuite"]
    pub GetPluginPropertyList: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, propertList: *mut SPPropertyListRef) -> SPErr,
    >,
    #[doc = "\tRetrieves the global variables of a plug-in. This is the same value passed in messages\nto the plug-in, which PICA stores when the plug-in is unloaded.\n@param plugin The plug-in object.\n@param globals [out] A buffer in which to return a pointer to the global variable array."]
    pub GetPluginGlobals: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            globals: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = "\tSets the global variables for a plug-in. This is the same value passed in messages\nto the plug-in, which PICA stores when the plug-in is unloaded.\n@param plugin The plug-in object.\n@param globals The new global variable array."]
    pub SetPluginGlobals: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, globals: *mut ::std::os::raw::c_void) -> SPErr,
    >,
    #[doc = "\tReports whether a plug-in has received and returned from the interface start-up message.\n@param plugin The plug-in object.\n@param started [out] A buffer in which to return true (non-zero) if the plug-in has been started,\nfalse (0) otherwise."]
    pub GetPluginStarted: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, started: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tSets whether a plug-in has received and returned from the interface start-up message.\n@param plugin The plug-in object.\n@param started True (non-zero) if the plug-in has been started, false (0) otherwise."]
    pub SetPluginStarted: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, started: ai_int32) -> SPErr,
    >,
    #[doc = "\tReports whether a plug-in is instructed to skip the start-up message.\n@param plugin The plug-in object.\n@param skipShutdown [out] A buffer in which to return true (non-zero) if the plug-in skips\nthe start-up message, false (0) otherwise."]
    pub GetPluginSkipShutdown: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, skipShutdown: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tInstructs a plug-in to respond or not to respond to the start-up message.\n@param plugin The plug-in object.\n@param skipShutdown True (non-zero) to skip\tthe start-up message, false (0)\nto respond normally to the start-up message."]
    pub SetPluginSkipShutdown: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, skipShutdown: ai_int32) -> SPErr,
    >,
    #[doc = "\tReports whether a plug-in has reported an error condition that makes it unavailable.\n@param plugin The plug-in object.\n@param broken [out] A buffer in which to return true (non-zero) if\nthe plug-in is marked as broken, false (0) otherwise."]
    pub GetPluginBroken: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, broken: *mut ai_int32) -> SPErr,
    >,
    #[doc = "\tSets or clears the broken flag that marks a plug-in as unavailable due to an\nerror condition.\n@param plugin The plug-in object.\n@param broken True (non-zero) to mark the plug-in as broken, false (0)\nto clear the broken flag."]
    pub SetPluginBroken:
        ::std::option::Option<unsafe extern "C" fn(plugin: SPPluginRef, broken: ai_int32) -> SPErr>,
    #[doc = "\tRetrieves the adapter for a plug-in.\n@param plugin The plug-in object.\n@param adapter [out] A buffer in which to return the adapter object.\n@see \\c #SPAdaptersSuite"]
    pub GetPluginAdapter: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, adapter: *mut SPAdapterRef) -> SPErr,
    >,
    #[doc = "\tRetrieves the adapter-specific information for a plug-in.  Typically\nused only by the adapter that defined the information. Other plug-ins\nshould use \\c #AIPluginSuite::GetPluginOptions().\n@param plugin The plug-in object.\n@param adapterInfo [out] A buffer in which to return a pointer to the adapter-defined\ninformation structure.\n@see \\c #SPAdaptersSuite"]
    pub GetPluginAdapterInfo: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            adapterInfo: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = "\tSets the adapter-specific information for a plug-in. Typically\nused only by the adapter that defined the information. Other plug-ins\nshould use \\c #AIPluginSuite::SetPluginOptions().\n@param plugin The plug-in object.\n@param adapterInfo The adapter-defined information structure.\n@see \\c #SPAdaptersSuite"]
    pub SetPluginAdapterInfo: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            adapterInfo: *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = "\tRetrieves a specific property from the property list for a plug-in.\tIf\nthe property is not found in the list, sends the plug-in the\n\\c #kSPPropertiesAcquireSelector message. The plug-in can ignore the\nmessage, or it can create and return the requested property. In either\ncase, this function adds the (possibly \\c NULL) property to the list\nand returns it.\n@param plugin The plug-in object.\n@param vendorID The property vendor ID code.\n@param propetyKey The property type key code.\n@param propertyID The specific property identifier.\n@param p [out] A buffer in which to return a pointer to the property object.\n@see \\c #SPPropertiesSuite"]
    pub FindPluginProperty: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            vendorID: PIType,
            propertyKey: PIType,
            propertyID: ai_int32,
            p: *mut *mut PIProperty,
        ) -> SPErr,
    >,
    #[doc = "\tRetrieves the name of a plug-in.\n@param plugin The plug-in object.\n@param name [out] A buffer in which to return the name string."]
    pub GetPluginName: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            name: *mut *const ::std::os::raw::c_char,
        ) -> SPErr,
    >,
    #[doc = "\tSets the name of a plug-in.\n@param plugin The plug-in object.\n@param name The new name string."]
    pub SetPluginName: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, name: *const ::std::os::raw::c_char) -> SPErr,
    >,
    #[doc = "\tRetrieves a plug-in by name.\n@param name The name string.\n@param plugin [out] A buffer in which to return the plug-in object."]
    pub GetNamedPlugin: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            plugin: *mut SPPluginRef,
        ) -> SPErr,
    >,
    #[doc = "\tSets the property list for a plug-in.\n@param plugin The plug-in object.\n@param file The file containing the property list."]
    pub SetPluginPropertyList:
        ::std::option::Option<unsafe extern "C" fn(plugin: SPPluginRef, file: SPFileRef) -> SPErr>,
    #[doc = "\tRetrieves host information for a plug-in.\n@param plugin The plug-in object.\n@param hostInfo [out] A buffer in which to return a pointer to the\nhost information structure."]
    pub GetPluginHostInfo: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            hostInfo: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = "\tSets host information for a plug-in.\n@param plugin The plug-in object.\n@param hostInfo The new host information structure."]
    pub SetPluginHostInfo: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, hostInfo: *mut ::std::os::raw::c_void) -> SPErr,
    >,
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetPluginListNeededSuiteAvailable(
        pluginList: SPPluginListRef,
        available: *mut SPBoolean,
    ) -> SPErr;
}
pub const kFMIterationCompleted: _bindgen_ty_143 = -980;
pub const kFMInvalidFontFamilyErr: _bindgen_ty_143 = -981;
pub const kFMInvalidFontErr: _bindgen_ty_143 = -982;
pub const kFMIterationScopeModifiedErr: _bindgen_ty_143 = -983;
pub const kFMFontTableAccessErr: _bindgen_ty_143 = -984;
pub const kFMFontContainerAccessErr: _bindgen_ty_143 = -985;
pub type _bindgen_ty_143 = ::std::os::raw::c_int;
pub const kernelIncompleteErr: _bindgen_ty_158 = -2401;
pub const kernelCanceledErr: _bindgen_ty_158 = -2402;
pub const kernelOptionsErr: _bindgen_ty_158 = -2403;
pub const kernelPrivilegeErr: _bindgen_ty_158 = -2404;
pub const kernelUnsupportedErr: _bindgen_ty_158 = -2405;
pub const kernelObjectExistsErr: _bindgen_ty_158 = -2406;
pub const kernelWritePermissionErr: _bindgen_ty_158 = -2407;
pub const kernelReadPermissionErr: _bindgen_ty_158 = -2408;
pub const kernelExecutePermissionErr: _bindgen_ty_158 = -2409;
pub const kernelDeletePermissionErr: _bindgen_ty_158 = -2410;
pub const kernelExecutionLevelErr: _bindgen_ty_158 = -2411;
pub const kernelAttributeErr: _bindgen_ty_158 = -2412;
pub const kernelAsyncSendLimitErr: _bindgen_ty_158 = -2413;
pub const kernelAsyncReceiveLimitErr: _bindgen_ty_158 = -2414;
pub const kernelTimeoutErr: _bindgen_ty_158 = -2415;
pub const kernelInUseErr: _bindgen_ty_158 = -2416;
pub const kernelTerminatedErr: _bindgen_ty_158 = -2417;
pub const kernelExceptionErr: _bindgen_ty_158 = -2418;
pub const kernelIDErr: _bindgen_ty_158 = -2419;
pub const kernelAlreadyFreeErr: _bindgen_ty_158 = -2421;
pub const kernelReturnValueErr: _bindgen_ty_158 = -2422;
pub const kernelUnrecoverableErr: _bindgen_ty_158 = -2499;
pub type _bindgen_ty_158 = ::std::os::raw::c_int;
pub const kOTNoError: _bindgen_ty_171 = 0;
pub const kOTOutOfMemoryErr: _bindgen_ty_171 = -3211;
pub const kOTNotFoundErr: _bindgen_ty_171 = -3201;
pub const kOTDuplicateFoundErr: _bindgen_ty_171 = -3216;
pub const kOTBadAddressErr: _bindgen_ty_171 = -3150;
pub const kOTBadOptionErr: _bindgen_ty_171 = -3151;
pub const kOTAccessErr: _bindgen_ty_171 = -3152;
pub const kOTBadReferenceErr: _bindgen_ty_171 = -3153;
pub const kOTNoAddressErr: _bindgen_ty_171 = -3154;
pub const kOTOutStateErr: _bindgen_ty_171 = -3155;
pub const kOTBadSequenceErr: _bindgen_ty_171 = -3156;
pub const kOTSysErrorErr: _bindgen_ty_171 = -3157;
pub const kOTLookErr: _bindgen_ty_171 = -3158;
pub const kOTBadDataErr: _bindgen_ty_171 = -3159;
pub const kOTBufferOverflowErr: _bindgen_ty_171 = -3160;
pub const kOTFlowErr: _bindgen_ty_171 = -3161;
pub const kOTNoDataErr: _bindgen_ty_171 = -3162;
pub const kOTNoDisconnectErr: _bindgen_ty_171 = -3163;
pub const kOTNoUDErrErr: _bindgen_ty_171 = -3164;
pub const kOTBadFlagErr: _bindgen_ty_171 = -3165;
pub const kOTNoReleaseErr: _bindgen_ty_171 = -3166;
pub const kOTNotSupportedErr: _bindgen_ty_171 = -3167;
pub const kOTStateChangeErr: _bindgen_ty_171 = -3168;
pub const kOTNoStructureTypeErr: _bindgen_ty_171 = -3169;
pub const kOTBadNameErr: _bindgen_ty_171 = -3170;
pub const kOTBadQLenErr: _bindgen_ty_171 = -3171;
pub const kOTAddressBusyErr: _bindgen_ty_171 = -3172;
pub const kOTIndOutErr: _bindgen_ty_171 = -3173;
pub const kOTProviderMismatchErr: _bindgen_ty_171 = -3174;
pub const kOTResQLenErr: _bindgen_ty_171 = -3175;
pub const kOTResAddressErr: _bindgen_ty_171 = -3176;
pub const kOTQFullErr: _bindgen_ty_171 = -3177;
pub const kOTProtocolErr: _bindgen_ty_171 = -3178;
pub const kOTBadSyncErr: _bindgen_ty_171 = -3179;
pub const kOTCanceledErr: _bindgen_ty_171 = -3180;
pub const kEPERMErr: _bindgen_ty_171 = -3200;
pub const kENOENTErr: _bindgen_ty_171 = -3201;
pub const kENORSRCErr: _bindgen_ty_171 = -3202;
pub const kEINTRErr: _bindgen_ty_171 = -3203;
pub const kEIOErr: _bindgen_ty_171 = -3204;
pub const kENXIOErr: _bindgen_ty_171 = -3205;
pub const kEBADFErr: _bindgen_ty_171 = -3208;
pub const kEAGAINErr: _bindgen_ty_171 = -3210;
pub const kENOMEMErr: _bindgen_ty_171 = -3211;
pub const kEACCESErr: _bindgen_ty_171 = -3212;
pub const kEFAULTErr: _bindgen_ty_171 = -3213;
pub const kEBUSYErr: _bindgen_ty_171 = -3215;
pub const kEEXISTErr: _bindgen_ty_171 = -3216;
pub const kENODEVErr: _bindgen_ty_171 = -3218;
pub const kEINVALErr: _bindgen_ty_171 = -3221;
pub const kENOTTYErr: _bindgen_ty_171 = -3224;
pub const kEPIPEErr: _bindgen_ty_171 = -3231;
pub const kERANGEErr: _bindgen_ty_171 = -3233;
pub const kEWOULDBLOCKErr: _bindgen_ty_171 = -3234;
pub const kEDEADLKErr: _bindgen_ty_171 = -3234;
pub const kEALREADYErr: _bindgen_ty_171 = -3236;
pub const kENOTSOCKErr: _bindgen_ty_171 = -3237;
pub const kEDESTADDRREQErr: _bindgen_ty_171 = -3238;
pub const kEMSGSIZEErr: _bindgen_ty_171 = -3239;
pub const kEPROTOTYPEErr: _bindgen_ty_171 = -3240;
pub const kENOPROTOOPTErr: _bindgen_ty_171 = -3241;
pub const kEPROTONOSUPPORTErr: _bindgen_ty_171 = -3242;
pub const kESOCKTNOSUPPORTErr: _bindgen_ty_171 = -3243;
pub const kEOPNOTSUPPErr: _bindgen_ty_171 = -3244;
pub const kEADDRINUSEErr: _bindgen_ty_171 = -3247;
pub const kEADDRNOTAVAILErr: _bindgen_ty_171 = -3248;
pub const kENETDOWNErr: _bindgen_ty_171 = -3249;
pub const kENETUNREACHErr: _bindgen_ty_171 = -3250;
pub const kENETRESETErr: _bindgen_ty_171 = -3251;
pub const kECONNABORTEDErr: _bindgen_ty_171 = -3252;
pub const kECONNRESETErr: _bindgen_ty_171 = -3253;
pub const kENOBUFSErr: _bindgen_ty_171 = -3254;
pub const kEISCONNErr: _bindgen_ty_171 = -3255;
pub const kENOTCONNErr: _bindgen_ty_171 = -3256;
pub const kESHUTDOWNErr: _bindgen_ty_171 = -3257;
pub const kETOOMANYREFSErr: _bindgen_ty_171 = -3258;
pub const kETIMEDOUTErr: _bindgen_ty_171 = -3259;
pub const kECONNREFUSEDErr: _bindgen_ty_171 = -3260;
pub const kEHOSTDOWNErr: _bindgen_ty_171 = -3263;
pub const kEHOSTUNREACHErr: _bindgen_ty_171 = -3264;
pub const kEPROTOErr: _bindgen_ty_171 = -3269;
pub const kETIMEErr: _bindgen_ty_171 = -3270;
pub const kENOSRErr: _bindgen_ty_171 = -3271;
pub const kEBADMSGErr: _bindgen_ty_171 = -3272;
pub const kECANCELErr: _bindgen_ty_171 = -3273;
pub const kENOSTRErr: _bindgen_ty_171 = -3274;
pub const kENODATAErr: _bindgen_ty_171 = -3275;
pub const kEINPROGRESSErr: _bindgen_ty_171 = -3276;
pub const kESRCHErr: _bindgen_ty_171 = -3277;
pub const kENOMSGErr: _bindgen_ty_171 = -3278;
pub const kOTClientNotInittedErr: _bindgen_ty_171 = -3279;
pub const kOTPortHasDiedErr: _bindgen_ty_171 = -3280;
pub const kOTPortWasEjectedErr: _bindgen_ty_171 = -3281;
pub const kOTBadConfigurationErr: _bindgen_ty_171 = -3282;
pub const kOTConfigurationChangedErr: _bindgen_ty_171 = -3283;
pub const kOTUserRequestedErr: _bindgen_ty_171 = -3284;
pub const kOTPortLostConnection: _bindgen_ty_171 = -3285;
pub type _bindgen_ty_171 = ::std::os::raw::c_int;
pub const kQDNoPalette: _bindgen_ty_172 = -3950;
pub const kQDNoColorHWCursorSupport: _bindgen_ty_172 = -3951;
pub const kQDCursorAlreadyRegistered: _bindgen_ty_172 = -3952;
pub const kQDCursorNotRegistered: _bindgen_ty_172 = -3953;
pub const kQDCorruptPICTDataErr: _bindgen_ty_172 = -3954;
pub type _bindgen_ty_172 = ::std::os::raw::c_int;
pub const kNSL68kContextNotSupported: _bindgen_ty_174 = -4170;
pub const kNSLSchedulerError: _bindgen_ty_174 = -4171;
pub const kNSLBadURLSyntax: _bindgen_ty_174 = -4172;
pub const kNSLNoCarbonLib: _bindgen_ty_174 = -4173;
pub const kNSLUILibraryNotAvailable: _bindgen_ty_174 = -4174;
pub const kNSLNotImplementedYet: _bindgen_ty_174 = -4175;
pub const kNSLErrNullPtrError: _bindgen_ty_174 = -4176;
pub const kNSLSomePluginsFailedToLoad: _bindgen_ty_174 = -4177;
pub const kNSLNullNeighborhoodPtr: _bindgen_ty_174 = -4178;
pub const kNSLNoPluginsForSearch: _bindgen_ty_174 = -4179;
pub const kNSLSearchAlreadyInProgress: _bindgen_ty_174 = -4180;
pub const kNSLNoPluginsFound: _bindgen_ty_174 = -4181;
pub const kNSLPluginLoadFailed: _bindgen_ty_174 = -4182;
pub const kNSLBadProtocolTypeErr: _bindgen_ty_174 = -4183;
pub const kNSLNullListPtr: _bindgen_ty_174 = -4184;
pub const kNSLBadClientInfoPtr: _bindgen_ty_174 = -4185;
pub const kNSLCannotContinueLookup: _bindgen_ty_174 = -4186;
pub const kNSLBufferTooSmallForData: _bindgen_ty_174 = -4187;
pub const kNSLNoContextAvailable: _bindgen_ty_174 = -4188;
pub const kNSLRequestBufferAlreadyInList: _bindgen_ty_174 = -4189;
pub const kNSLInvalidPluginSpec: _bindgen_ty_174 = -4190;
pub const kNSLNoSupportForService: _bindgen_ty_174 = -4191;
pub const kNSLBadNetConnection: _bindgen_ty_174 = -4192;
pub const kNSLBadDataTypeErr: _bindgen_ty_174 = -4193;
pub const kNSLBadServiceTypeErr: _bindgen_ty_174 = -4194;
pub const kNSLBadReferenceErr: _bindgen_ty_174 = -4195;
pub const kNSLNoElementsInList: _bindgen_ty_174 = -4196;
pub const kNSLInsufficientOTVer: _bindgen_ty_174 = -4197;
pub const kNSLInsufficientSysVer: _bindgen_ty_174 = -4198;
pub const kNSLNotInitialized: _bindgen_ty_174 = -4199;
pub const kNSLInitializationFailed: _bindgen_ty_174 = -4200;
pub type _bindgen_ty_174 = ::std::os::raw::c_int;
pub const kDTPHoldJobErr: _bindgen_ty_175 = -4200;
pub const kDTPStopQueueErr: _bindgen_ty_175 = -4201;
pub const kDTPTryAgainErr: _bindgen_ty_175 = -4202;
pub const kDTPAbortJobErr: _bindgen_ty_175 = 128;
pub type _bindgen_ty_175 = ::std::os::raw::c_int;
pub const kNavWrongDialogStateErr: _bindgen_ty_193 = -5694;
pub const kNavWrongDialogClassErr: _bindgen_ty_193 = -5695;
pub const kNavInvalidSystemConfigErr: _bindgen_ty_193 = -5696;
pub const kNavCustomControlMessageFailedErr: _bindgen_ty_193 = -5697;
pub const kNavInvalidCustomControlMessageErr: _bindgen_ty_193 = -5698;
pub const kNavMissingKindStringErr: _bindgen_ty_193 = -5699;
pub type _bindgen_ty_193 = ::std::os::raw::c_int;
pub const kQTSSUnknownErr: _bindgen_ty_195 = -6150;
pub type _bindgen_ty_195 = ::std::os::raw::c_int;
pub const kDMGenErr: _bindgen_ty_196 = -6220;
pub const kDMMirroringOnAlready: _bindgen_ty_196 = -6221;
pub const kDMWrongNumberOfDisplays: _bindgen_ty_196 = -6222;
pub const kDMMirroringBlocked: _bindgen_ty_196 = -6223;
pub const kDMCantBlock: _bindgen_ty_196 = -6224;
pub const kDMMirroringNotOn: _bindgen_ty_196 = -6225;
pub const kSysSWTooOld: _bindgen_ty_196 = -6226;
pub const kDMSWNotInitializedErr: _bindgen_ty_196 = -6227;
pub const kDMDriverNotDisplayMgrAwareErr: _bindgen_ty_196 = -6228;
pub const kDMDisplayNotFoundErr: _bindgen_ty_196 = -6229;
pub const kDMNotFoundErr: _bindgen_ty_196 = -6229;
pub const kDMDisplayAlreadyInstalledErr: _bindgen_ty_196 = -6230;
pub const kDMMainDisplayCannotMoveErr: _bindgen_ty_196 = -6231;
pub const kDMNoDeviceTableclothErr: _bindgen_ty_196 = -6231;
pub const kDMFoundErr: _bindgen_ty_196 = -6232;
pub type _bindgen_ty_196 = ::std::os::raw::c_int;
pub const kUSBNoErr: _bindgen_ty_198 = 0;
pub const kUSBNoTran: _bindgen_ty_198 = 0;
pub const kUSBNoDelay: _bindgen_ty_198 = 0;
pub const kUSBPending: _bindgen_ty_198 = 1;
pub type _bindgen_ty_198 = ::std::os::raw::c_uint;
pub const kUSBNotSent2Err: _bindgen_ty_199 = -6901;
pub const kUSBNotSent1Err: _bindgen_ty_199 = -6902;
pub const kUSBBufUnderRunErr: _bindgen_ty_199 = -6903;
pub const kUSBBufOvrRunErr: _bindgen_ty_199 = -6904;
pub const kUSBRes2Err: _bindgen_ty_199 = -6905;
pub const kUSBRes1Err: _bindgen_ty_199 = -6906;
pub const kUSBUnderRunErr: _bindgen_ty_199 = -6907;
pub const kUSBOverRunErr: _bindgen_ty_199 = -6908;
pub const kUSBWrongPIDErr: _bindgen_ty_199 = -6909;
pub const kUSBPIDCheckErr: _bindgen_ty_199 = -6910;
pub const kUSBNotRespondingErr: _bindgen_ty_199 = -6911;
pub const kUSBEndpointStallErr: _bindgen_ty_199 = -6912;
pub const kUSBDataToggleErr: _bindgen_ty_199 = -6913;
pub const kUSBBitstufErr: _bindgen_ty_199 = -6914;
pub const kUSBCRCErr: _bindgen_ty_199 = -6915;
pub const kUSBLinkErr: _bindgen_ty_199 = -6916;
pub type _bindgen_ty_199 = ::std::os::raw::c_int;
pub const kUSBPortDisabled: _bindgen_ty_202 = -6969;
pub const kUSBQueueAborted: _bindgen_ty_202 = -6970;
pub const kUSBTimedOut: _bindgen_ty_202 = -6971;
pub const kUSBDeviceDisconnected: _bindgen_ty_202 = -6972;
pub const kUSBDeviceNotSuspended: _bindgen_ty_202 = -6973;
pub const kUSBDeviceSuspended: _bindgen_ty_202 = -6974;
pub const kUSBInvalidBuffer: _bindgen_ty_202 = -6975;
pub const kUSBDevicePowerProblem: _bindgen_ty_202 = -6976;
pub const kUSBDeviceBusy: _bindgen_ty_202 = -6977;
pub const kUSBUnknownInterfaceErr: _bindgen_ty_202 = -6978;
pub const kUSBPipeStalledError: _bindgen_ty_202 = -6979;
pub const kUSBPipeIdleError: _bindgen_ty_202 = -6980;
pub const kUSBNoBandwidthError: _bindgen_ty_202 = -6981;
pub const kUSBAbortedError: _bindgen_ty_202 = -6982;
pub const kUSBFlagsError: _bindgen_ty_202 = -6983;
pub const kUSBCompletionError: _bindgen_ty_202 = -6984;
pub const kUSBPBLengthError: _bindgen_ty_202 = -6985;
pub const kUSBPBVersionError: _bindgen_ty_202 = -6986;
pub const kUSBNotFound: _bindgen_ty_202 = -6987;
pub const kUSBOutOfMemoryErr: _bindgen_ty_202 = -6988;
pub const kUSBDeviceErr: _bindgen_ty_202 = -6989;
pub const kUSBNoDeviceErr: _bindgen_ty_202 = -6990;
pub const kUSBAlreadyOpenErr: _bindgen_ty_202 = -6991;
pub const kUSBTooManyTransactionsErr: _bindgen_ty_202 = -6992;
pub const kUSBUnknownRequestErr: _bindgen_ty_202 = -6993;
pub const kUSBRqErr: _bindgen_ty_202 = -6994;
pub const kUSBIncorrectTypeErr: _bindgen_ty_202 = -6995;
pub const kUSBTooManyPipesErr: _bindgen_ty_202 = -6996;
pub const kUSBUnknownPipeErr: _bindgen_ty_202 = -6997;
pub const kUSBUnknownDeviceErr: _bindgen_ty_202 = -6998;
pub const kUSBInternalErr: _bindgen_ty_202 = -6999;
pub type _bindgen_ty_202 = ::std::os::raw::c_int;
pub const kRAInvalidParameter: _bindgen_ty_204 = -7100;
pub const kRAInvalidPort: _bindgen_ty_204 = -7101;
pub const kRAStartupFailed: _bindgen_ty_204 = -7102;
pub const kRAPortSetupFailed: _bindgen_ty_204 = -7103;
pub const kRAOutOfMemory: _bindgen_ty_204 = -7104;
pub const kRANotSupported: _bindgen_ty_204 = -7105;
pub const kRAMissingResources: _bindgen_ty_204 = -7106;
pub const kRAIncompatiblePrefs: _bindgen_ty_204 = -7107;
pub const kRANotConnected: _bindgen_ty_204 = -7108;
pub const kRAConnectionCanceled: _bindgen_ty_204 = -7109;
pub const kRAUnknownUser: _bindgen_ty_204 = -7110;
pub const kRAInvalidPassword: _bindgen_ty_204 = -7111;
pub const kRAInternalError: _bindgen_ty_204 = -7112;
pub const kRAInstallationDamaged: _bindgen_ty_204 = -7113;
pub const kRAPortBusy: _bindgen_ty_204 = -7114;
pub const kRAUnknownPortState: _bindgen_ty_204 = -7115;
pub const kRAInvalidPortState: _bindgen_ty_204 = -7116;
pub const kRAInvalidSerialProtocol: _bindgen_ty_204 = -7117;
pub const kRAUserLoginDisabled: _bindgen_ty_204 = -7118;
pub const kRAUserPwdChangeRequired: _bindgen_ty_204 = -7119;
pub const kRAUserPwdEntryRequired: _bindgen_ty_204 = -7120;
pub const kRAUserInteractionRequired: _bindgen_ty_204 = -7121;
pub const kRAInitOpenTransportFailed: _bindgen_ty_204 = -7122;
pub const kRARemoteAccessNotReady: _bindgen_ty_204 = -7123;
pub const kRATCPIPInactive: _bindgen_ty_204 = -7124;
pub const kRATCPIPNotConfigured: _bindgen_ty_204 = -7125;
pub const kRANotPrimaryInterface: _bindgen_ty_204 = -7126;
pub const kRAConfigurationDBInitErr: _bindgen_ty_204 = -7127;
pub const kRAPPPProtocolRejected: _bindgen_ty_204 = -7128;
pub const kRAPPPAuthenticationFailed: _bindgen_ty_204 = -7129;
pub const kRAPPPNegotiationFailed: _bindgen_ty_204 = -7130;
pub const kRAPPPUserDisconnected: _bindgen_ty_204 = -7131;
pub const kRAPPPPeerDisconnected: _bindgen_ty_204 = -7132;
pub const kRAPeerNotResponding: _bindgen_ty_204 = -7133;
pub const kRAATalkInactive: _bindgen_ty_204 = -7134;
pub const kRAExtAuthenticationFailed: _bindgen_ty_204 = -7135;
pub const kRANCPRejectedbyPeer: _bindgen_ty_204 = -7136;
pub const kRADuplicateIPAddr: _bindgen_ty_204 = -7137;
pub const kRACallBackFailed: _bindgen_ty_204 = -7138;
pub const kRANotEnabled: _bindgen_ty_204 = -7139;
pub type _bindgen_ty_204 = ::std::os::raw::c_int;
pub const kATSUInvalidTextLayoutErr: _bindgen_ty_205 = -8790;
pub const kATSUInvalidStyleErr: _bindgen_ty_205 = -8791;
pub const kATSUInvalidTextRangeErr: _bindgen_ty_205 = -8792;
pub const kATSUFontsMatched: _bindgen_ty_205 = -8793;
pub const kATSUFontsNotMatched: _bindgen_ty_205 = -8794;
pub const kATSUNoCorrespondingFontErr: _bindgen_ty_205 = -8795;
pub const kATSUInvalidFontErr: _bindgen_ty_205 = -8796;
pub const kATSUInvalidAttributeValueErr: _bindgen_ty_205 = -8797;
pub const kATSUInvalidAttributeSizeErr: _bindgen_ty_205 = -8798;
pub const kATSUInvalidAttributeTagErr: _bindgen_ty_205 = -8799;
pub const kATSUInvalidCacheErr: _bindgen_ty_205 = -8800;
pub const kATSUNotSetErr: _bindgen_ty_205 = -8801;
pub const kATSUNoStyleRunsAssignedErr: _bindgen_ty_205 = -8802;
pub const kATSUQuickDrawTextErr: _bindgen_ty_205 = -8803;
pub const kATSULowLevelErr: _bindgen_ty_205 = -8804;
pub const kATSUNoFontCmapAvailableErr: _bindgen_ty_205 = -8805;
pub const kATSUNoFontScalerAvailableErr: _bindgen_ty_205 = -8806;
pub const kATSUCoordinateOverflowErr: _bindgen_ty_205 = -8807;
pub const kATSULineBreakInWord: _bindgen_ty_205 = -8808;
pub const kATSUBusyObjectErr: _bindgen_ty_205 = -8809;
pub type _bindgen_ty_205 = ::std::os::raw::c_int;
pub const kTextUnsupportedEncodingErr: _bindgen_ty_206 = -8738;
pub const kTextMalformedInputErr: _bindgen_ty_206 = -8739;
pub const kTextUndefinedElementErr: _bindgen_ty_206 = -8740;
pub const kTECMissingTableErr: _bindgen_ty_206 = -8745;
pub const kTECTableChecksumErr: _bindgen_ty_206 = -8746;
pub const kTECTableFormatErr: _bindgen_ty_206 = -8747;
pub const kTECCorruptConverterErr: _bindgen_ty_206 = -8748;
pub const kTECNoConversionPathErr: _bindgen_ty_206 = -8749;
pub const kTECBufferBelowMinimumSizeErr: _bindgen_ty_206 = -8750;
pub const kTECArrayFullErr: _bindgen_ty_206 = -8751;
pub const kTECBadTextRunErr: _bindgen_ty_206 = -8752;
pub const kTECPartialCharErr: _bindgen_ty_206 = -8753;
pub const kTECUnmappableElementErr: _bindgen_ty_206 = -8754;
pub const kTECIncompleteElementErr: _bindgen_ty_206 = -8755;
pub const kTECDirectionErr: _bindgen_ty_206 = -8756;
pub const kTECGlobalsUnavailableErr: _bindgen_ty_206 = -8770;
pub const kTECItemUnavailableErr: _bindgen_ty_206 = -8771;
pub const kTECUsedFallbacksStatus: _bindgen_ty_206 = -8783;
pub const kTECNeedFlushStatus: _bindgen_ty_206 = -8784;
pub const kTECOutputBufferFullStatus: _bindgen_ty_206 = -8785;
pub const unicodeChecksumErr: _bindgen_ty_206 = -8769;
pub const unicodeNoTableErr: _bindgen_ty_206 = -8768;
pub const unicodeVariantErr: _bindgen_ty_206 = -8767;
pub const unicodeFallbacksErr: _bindgen_ty_206 = -8766;
pub const unicodePartConvertErr: _bindgen_ty_206 = -8765;
pub const unicodeBufErr: _bindgen_ty_206 = -8764;
pub const unicodeCharErr: _bindgen_ty_206 = -8763;
pub const unicodeElementErr: _bindgen_ty_206 = -8762;
pub const unicodeNotFoundErr: _bindgen_ty_206 = -8761;
pub const unicodeTableFormatErr: _bindgen_ty_206 = -8760;
pub const unicodeDirectionErr: _bindgen_ty_206 = -8759;
pub const unicodeContextualErr: _bindgen_ty_206 = -8758;
pub const unicodeTextEncodingDataErr: _bindgen_ty_206 = -8757;
pub type _bindgen_ty_206 = ::std::os::raw::c_int;
pub const kUTCUnderflowErr: _bindgen_ty_207 = -8850;
pub const kUTCOverflowErr: _bindgen_ty_207 = -8851;
pub const kIllegalClockValueErr: _bindgen_ty_207 = -8852;
pub type _bindgen_ty_207 = ::std::os::raw::c_int;
pub const kATSUInvalidFontFallbacksErr: _bindgen_ty_208 = -8900;
pub const kATSUUnsupportedStreamFormatErr: _bindgen_ty_208 = -8901;
pub const kATSUBadStreamErr: _bindgen_ty_208 = -8902;
pub const kATSUOutputBufferTooSmallErr: _bindgen_ty_208 = -8903;
pub const kATSUInvalidCallInsideCallbackErr: _bindgen_ty_208 = -8904;
pub const kATSUNoFontNameErr: _bindgen_ty_208 = -8905;
pub const kATSULastErr: _bindgen_ty_208 = -8959;
pub type _bindgen_ty_208 = ::std::os::raw::c_int;
pub const kBadAdapterErr: _bindgen_ty_210 = -9050;
pub const kBadAttributeErr: _bindgen_ty_210 = -9051;
pub const kBadBaseErr: _bindgen_ty_210 = -9052;
pub const kBadEDCErr: _bindgen_ty_210 = -9053;
pub const kBadIRQErr: _bindgen_ty_210 = -9054;
pub const kBadOffsetErr: _bindgen_ty_210 = -9055;
pub const kBadPageErr: _bindgen_ty_210 = -9056;
pub const kBadSizeErr: _bindgen_ty_210 = -9057;
pub const kBadSocketErr: _bindgen_ty_210 = -9058;
pub const kBadTypeErr: _bindgen_ty_210 = -9059;
pub const kBadVccErr: _bindgen_ty_210 = -9060;
pub const kBadVppErr: _bindgen_ty_210 = -9061;
pub const kBadWindowErr: _bindgen_ty_210 = -9062;
pub const kBadArgLengthErr: _bindgen_ty_210 = -9063;
pub const kBadArgsErr: _bindgen_ty_210 = -9064;
pub const kBadHandleErr: _bindgen_ty_210 = -9065;
pub const kBadCISErr: _bindgen_ty_210 = -9066;
pub const kBadSpeedErr: _bindgen_ty_210 = -9067;
pub const kReadFailureErr: _bindgen_ty_210 = -9068;
pub const kWriteFailureErr: _bindgen_ty_210 = -9069;
pub const kGeneralFailureErr: _bindgen_ty_210 = -9070;
pub const kNoCardErr: _bindgen_ty_210 = -9071;
pub const kUnsupportedFunctionErr: _bindgen_ty_210 = -9072;
pub const kUnsupportedModeErr: _bindgen_ty_210 = -9073;
pub const kBusyErr: _bindgen_ty_210 = -9074;
pub const kWriteProtectedErr: _bindgen_ty_210 = -9075;
pub const kConfigurationLockedErr: _bindgen_ty_210 = -9076;
pub const kInUseErr: _bindgen_ty_210 = -9077;
pub const kNoMoreItemsErr: _bindgen_ty_210 = -9078;
pub const kOutOfResourceErr: _bindgen_ty_210 = -9079;
pub const kNoCardSevicesSocketsErr: _bindgen_ty_210 = -9080;
pub const kInvalidRegEntryErr: _bindgen_ty_210 = -9081;
pub const kBadLinkErr: _bindgen_ty_210 = -9082;
pub const kBadDeviceErr: _bindgen_ty_210 = -9083;
pub const k16BitCardErr: _bindgen_ty_210 = -9084;
pub const kCardBusCardErr: _bindgen_ty_210 = -9085;
pub const kPassCallToChainErr: _bindgen_ty_210 = -9086;
pub const kCantConfigureCardErr: _bindgen_ty_210 = -9087;
pub const kPostCardEventErr: _bindgen_ty_210 = -9088;
pub const kInvalidDeviceNumber: _bindgen_ty_210 = -9089;
pub const kUnsupportedVsErr: _bindgen_ty_210 = -9090;
pub const kInvalidCSClientErr: _bindgen_ty_210 = -9091;
pub const kBadTupleDataErr: _bindgen_ty_210 = -9092;
pub const kBadCustomIFIDErr: _bindgen_ty_210 = -9093;
pub const kNoIOWindowRequestedErr: _bindgen_ty_210 = -9094;
pub const kNoMoreTimerClientsErr: _bindgen_ty_210 = -9095;
pub const kNoMoreInterruptSlotsErr: _bindgen_ty_210 = -9096;
pub const kNoClientTableErr: _bindgen_ty_210 = -9097;
pub const kUnsupportedCardErr: _bindgen_ty_210 = -9098;
pub const kNoCardEnablersFoundErr: _bindgen_ty_210 = -9099;
pub const kNoEnablerForCardErr: _bindgen_ty_210 = -9100;
pub const kNoCompatibleNameErr: _bindgen_ty_210 = -9101;
pub const kClientRequestDenied: _bindgen_ty_210 = -9102;
pub const kNotReadyErr: _bindgen_ty_210 = -9103;
pub const kTooManyIOWindowsErr: _bindgen_ty_210 = -9104;
pub const kAlreadySavedStateErr: _bindgen_ty_210 = -9105;
pub const kAttemptDupCardEntryErr: _bindgen_ty_210 = -9106;
pub const kCardPowerOffErr: _bindgen_ty_210 = -9107;
pub const kNotZVCapableErr: _bindgen_ty_210 = -9108;
pub const kNoCardBusCISErr: _bindgen_ty_210 = -9109;
pub type _bindgen_ty_210 = ::std::os::raw::c_int;
pub const kPowerHandlerExistsForDeviceErr: _bindgen_ty_216 = -13006;
pub const kPowerHandlerNotFoundForDeviceErr: _bindgen_ty_216 = -13007;
pub const kPowerHandlerNotFoundForProcErr: _bindgen_ty_216 = -13008;
pub const kPowerMgtMessageNotHandled: _bindgen_ty_216 = -13009;
pub const kPowerMgtRequestDenied: _bindgen_ty_216 = -13010;
pub const kCantReportProcessorTemperatureErr: _bindgen_ty_216 = -13013;
pub const kProcessorTempRoutineRequiresMPLib2: _bindgen_ty_216 = -13014;
pub const kNoSuchPowerSource: _bindgen_ty_216 = -13020;
pub const kBridgeSoftwareRunningCantSleep: _bindgen_ty_216 = -13038;
pub type _bindgen_ty_216 = ::std::os::raw::c_int;
pub const kHIDVersionIncompatibleErr: _bindgen_ty_218 = -13909;
pub const kHIDDeviceNotReady: _bindgen_ty_218 = -13910;
pub type _bindgen_ty_218 = ::std::os::raw::c_int;
pub const kHIDSuccess: _bindgen_ty_219 = 0;
pub const kHIDInvalidRangePageErr: _bindgen_ty_219 = -13923;
pub const kHIDReportIDZeroErr: _bindgen_ty_219 = -13924;
pub const kHIDReportCountZeroErr: _bindgen_ty_219 = -13925;
pub const kHIDReportSizeZeroErr: _bindgen_ty_219 = -13926;
pub const kHIDUnmatchedDesignatorRangeErr: _bindgen_ty_219 = -13927;
pub const kHIDUnmatchedStringRangeErr: _bindgen_ty_219 = -13928;
pub const kHIDInvertedUsageRangeErr: _bindgen_ty_219 = -13929;
pub const kHIDUnmatchedUsageRangeErr: _bindgen_ty_219 = -13930;
pub const kHIDInvertedPhysicalRangeErr: _bindgen_ty_219 = -13931;
pub const kHIDInvertedLogicalRangeErr: _bindgen_ty_219 = -13932;
pub const kHIDBadLogicalMaximumErr: _bindgen_ty_219 = -13933;
pub const kHIDBadLogicalMinimumErr: _bindgen_ty_219 = -13934;
pub const kHIDUsagePageZeroErr: _bindgen_ty_219 = -13935;
pub const kHIDEndOfDescriptorErr: _bindgen_ty_219 = -13936;
pub const kHIDNotEnoughMemoryErr: _bindgen_ty_219 = -13937;
pub const kHIDBadParameterErr: _bindgen_ty_219 = -13938;
pub const kHIDNullPointerErr: _bindgen_ty_219 = -13939;
pub const kHIDInvalidReportLengthErr: _bindgen_ty_219 = -13940;
pub const kHIDInvalidReportTypeErr: _bindgen_ty_219 = -13941;
pub const kHIDBadLogPhysValuesErr: _bindgen_ty_219 = -13942;
pub const kHIDIncompatibleReportErr: _bindgen_ty_219 = -13943;
pub const kHIDInvalidPreparsedDataErr: _bindgen_ty_219 = -13944;
pub const kHIDNotValueArrayErr: _bindgen_ty_219 = -13945;
pub const kHIDUsageNotFoundErr: _bindgen_ty_219 = -13946;
pub const kHIDValueOutOfRangeErr: _bindgen_ty_219 = -13947;
pub const kHIDBufferTooSmallErr: _bindgen_ty_219 = -13948;
pub const kHIDNullStateErr: _bindgen_ty_219 = -13949;
pub const kHIDBaseError: _bindgen_ty_219 = -13950;
pub type _bindgen_ty_219 = ::std::os::raw::c_int;
pub const kTXNEndIterationErr: _bindgen_ty_221 = -22000;
pub const kTXNCannotAddFrameErr: _bindgen_ty_221 = -22001;
pub const kTXNInvalidFrameIDErr: _bindgen_ty_221 = -22002;
pub const kTXNIllegalToCrossDataBoundariesErr: _bindgen_ty_221 = -22003;
pub const kTXNUserCanceledOperationErr: _bindgen_ty_221 = -22004;
pub const kTXNBadDefaultFileTypeWarning: _bindgen_ty_221 = -22005;
pub const kTXNCannotSetAutoIndentErr: _bindgen_ty_221 = -22006;
pub const kTXNRunIndexOutofBoundsErr: _bindgen_ty_221 = -22007;
pub const kTXNNoMatchErr: _bindgen_ty_221 = -22008;
pub const kTXNAttributeTagInvalidForRunErr: _bindgen_ty_221 = -22009;
pub const kTXNSomeOrAllTagsInvalidForRunErr: _bindgen_ty_221 = -22010;
pub const kTXNInvalidRunIndex: _bindgen_ty_221 = -22011;
pub const kTXNAlreadyInitializedErr: _bindgen_ty_221 = -22012;
pub const kTXNCannotTurnTSMOffWhenUsingUnicodeErr: _bindgen_ty_221 = -22013;
pub const kTXNCopyNotAllowedInEchoModeErr: _bindgen_ty_221 = -22014;
pub const kTXNDataTypeNotAllowedErr: _bindgen_ty_221 = -22015;
pub const kTXNATSUIIsNotInstalledErr: _bindgen_ty_221 = -22016;
pub const kTXNOutsideOfLineErr: _bindgen_ty_221 = -22017;
pub const kTXNOutsideOfFrameErr: _bindgen_ty_221 = -22018;
pub type _bindgen_ty_221 = ::std::os::raw::c_int;
pub const kUCTSNoKeysAddedToObjectErr: _bindgen_ty_225 = -25342;
pub const kUCTSSearchListErr: _bindgen_ty_225 = -25343;
pub type _bindgen_ty_225 = ::std::os::raw::c_int;
pub const kMPIterationEndErr: _bindgen_ty_227 = -29275;
pub const kMPPrivilegedErr: _bindgen_ty_227 = -29276;
pub const kMPProcessCreatedErr: _bindgen_ty_227 = -29288;
pub const kMPProcessTerminatedErr: _bindgen_ty_227 = -29289;
pub const kMPTaskCreatedErr: _bindgen_ty_227 = -29290;
pub const kMPTaskBlockedErr: _bindgen_ty_227 = -29291;
pub const kMPTaskStoppedErr: _bindgen_ty_227 = -29292;
pub const kMPBlueBlockingErr: _bindgen_ty_227 = -29293;
pub const kMPDeletedErr: _bindgen_ty_227 = -29295;
pub const kMPTimeoutErr: _bindgen_ty_227 = -29296;
pub const kMPTaskAbortedErr: _bindgen_ty_227 = -29297;
pub const kMPInsufficientResourcesErr: _bindgen_ty_227 = -29298;
pub const kMPInvalidIDErr: _bindgen_ty_227 = -29299;
pub type _bindgen_ty_227 = ::std::os::raw::c_int;
pub const kMPNanokernelNeedsMemoryErr: _bindgen_ty_228 = -29294;
pub type _bindgen_ty_228 = ::std::os::raw::c_int;
pub const kCollateAttributesNotFoundErr: _bindgen_ty_229 = -29500;
pub const kCollateInvalidOptions: _bindgen_ty_229 = -29501;
pub const kCollateMissingUnicodeTableErr: _bindgen_ty_229 = -29502;
pub const kCollateUnicodeConvertFailedErr: _bindgen_ty_229 = -29503;
pub const kCollatePatternNotFoundErr: _bindgen_ty_229 = -29504;
pub const kCollateInvalidChar: _bindgen_ty_229 = -29505;
pub const kCollateBufferTooSmall: _bindgen_ty_229 = -29506;
pub const kCollateInvalidCollationRef: _bindgen_ty_229 = -29507;
pub type _bindgen_ty_229 = ::std::os::raw::c_int;
pub const kFNSInvalidReferenceErr: _bindgen_ty_230 = -29580;
pub const kFNSBadReferenceVersionErr: _bindgen_ty_230 = -29581;
pub const kFNSInvalidProfileErr: _bindgen_ty_230 = -29582;
pub const kFNSBadProfileVersionErr: _bindgen_ty_230 = -29583;
pub const kFNSDuplicateReferenceErr: _bindgen_ty_230 = -29584;
pub const kFNSMismatchErr: _bindgen_ty_230 = -29585;
pub const kFNSInsufficientDataErr: _bindgen_ty_230 = -29586;
pub const kFNSBadFlattenedSizeErr: _bindgen_ty_230 = -29587;
pub const kFNSNameNotFoundErr: _bindgen_ty_230 = -29589;
pub type _bindgen_ty_230 = ::std::os::raw::c_int;
pub const kLocalesBufferTooSmallErr: _bindgen_ty_231 = -30001;
pub const kLocalesTableFormatErr: _bindgen_ty_231 = -30002;
pub const kLocalesDefaultDisplayStatus: _bindgen_ty_231 = -30029;
pub type _bindgen_ty_231 = ::std::os::raw::c_int;
pub const kALMInternalErr: _bindgen_ty_232 = -30049;
pub const kALMGroupNotFoundErr: _bindgen_ty_232 = -30048;
pub const kALMNoSuchModuleErr: _bindgen_ty_232 = -30047;
pub const kALMModuleCommunicationErr: _bindgen_ty_232 = -30046;
pub const kALMDuplicateModuleErr: _bindgen_ty_232 = -30045;
pub const kALMInstallationErr: _bindgen_ty_232 = -30044;
pub const kALMDeferSwitchErr: _bindgen_ty_232 = -30043;
pub const kALMRebootFlagsLevelErr: _bindgen_ty_232 = -30042;
pub type _bindgen_ty_232 = ::std::os::raw::c_int;
pub const kALMLocationNotFoundErr: _bindgen_ty_233 = -30048;
pub type _bindgen_ty_233 = ::std::os::raw::c_int;
pub const kSSpInternalErr: _bindgen_ty_234 = -30340;
pub const kSSpVersionErr: _bindgen_ty_234 = -30341;
pub const kSSpCantInstallErr: _bindgen_ty_234 = -30342;
pub const kSSpParallelUpVectorErr: _bindgen_ty_234 = -30343;
pub const kSSpScaleToZeroErr: _bindgen_ty_234 = -30344;
pub type _bindgen_ty_234 = ::std::os::raw::c_int;
pub const kNSpInitializationFailedErr: _bindgen_ty_235 = -30360;
pub const kNSpAlreadyInitializedErr: _bindgen_ty_235 = -30361;
pub const kNSpTopologyNotSupportedErr: _bindgen_ty_235 = -30362;
pub const kNSpPipeFullErr: _bindgen_ty_235 = -30364;
pub const kNSpHostFailedErr: _bindgen_ty_235 = -30365;
pub const kNSpProtocolNotAvailableErr: _bindgen_ty_235 = -30366;
pub const kNSpInvalidGameRefErr: _bindgen_ty_235 = -30367;
pub const kNSpInvalidParameterErr: _bindgen_ty_235 = -30369;
pub const kNSpOTNotPresentErr: _bindgen_ty_235 = -30370;
pub const kNSpOTVersionTooOldErr: _bindgen_ty_235 = -30371;
pub const kNSpMemAllocationErr: _bindgen_ty_235 = -30373;
pub const kNSpAlreadyAdvertisingErr: _bindgen_ty_235 = -30374;
pub const kNSpNotAdvertisingErr: _bindgen_ty_235 = -30376;
pub const kNSpInvalidAddressErr: _bindgen_ty_235 = -30377;
pub const kNSpFreeQExhaustedErr: _bindgen_ty_235 = -30378;
pub const kNSpRemovePlayerFailedErr: _bindgen_ty_235 = -30379;
pub const kNSpAddressInUseErr: _bindgen_ty_235 = -30380;
pub const kNSpFeatureNotImplementedErr: _bindgen_ty_235 = -30381;
pub const kNSpNameRequiredErr: _bindgen_ty_235 = -30382;
pub const kNSpInvalidPlayerIDErr: _bindgen_ty_235 = -30383;
pub const kNSpInvalidGroupIDErr: _bindgen_ty_235 = -30384;
pub const kNSpNoPlayersErr: _bindgen_ty_235 = -30385;
pub const kNSpNoGroupsErr: _bindgen_ty_235 = -30386;
pub const kNSpNoHostVolunteersErr: _bindgen_ty_235 = -30387;
pub const kNSpCreateGroupFailedErr: _bindgen_ty_235 = -30388;
pub const kNSpAddPlayerFailedErr: _bindgen_ty_235 = -30389;
pub const kNSpInvalidDefinitionErr: _bindgen_ty_235 = -30390;
pub const kNSpInvalidProtocolRefErr: _bindgen_ty_235 = -30391;
pub const kNSpInvalidProtocolListErr: _bindgen_ty_235 = -30392;
pub const kNSpTimeoutErr: _bindgen_ty_235 = -30393;
pub const kNSpGameTerminatedErr: _bindgen_ty_235 = -30394;
pub const kNSpConnectFailedErr: _bindgen_ty_235 = -30395;
pub const kNSpSendFailedErr: _bindgen_ty_235 = -30396;
pub const kNSpMessageTooBigErr: _bindgen_ty_235 = -30397;
pub const kNSpCantBlockErr: _bindgen_ty_235 = -30398;
pub const kNSpJoinFailedErr: _bindgen_ty_235 = -30399;
pub type _bindgen_ty_235 = ::std::os::raw::c_int;
pub const kISpInternalErr: _bindgen_ty_236 = -30420;
pub const kISpSystemListErr: _bindgen_ty_236 = -30421;
pub const kISpBufferToSmallErr: _bindgen_ty_236 = -30422;
pub const kISpElementInListErr: _bindgen_ty_236 = -30423;
pub const kISpElementNotInListErr: _bindgen_ty_236 = -30424;
pub const kISpSystemInactiveErr: _bindgen_ty_236 = -30425;
pub const kISpDeviceInactiveErr: _bindgen_ty_236 = -30426;
pub const kISpSystemActiveErr: _bindgen_ty_236 = -30427;
pub const kISpDeviceActiveErr: _bindgen_ty_236 = -30428;
pub const kISpListBusyErr: _bindgen_ty_236 = -30429;
pub type _bindgen_ty_236 = ::std::os::raw::c_int;
pub const kDSpNotInitializedErr: _bindgen_ty_237 = -30440;
pub const kDSpSystemSWTooOldErr: _bindgen_ty_237 = -30441;
pub const kDSpInvalidContextErr: _bindgen_ty_237 = -30442;
pub const kDSpInvalidAttributesErr: _bindgen_ty_237 = -30443;
pub const kDSpContextAlreadyReservedErr: _bindgen_ty_237 = -30444;
pub const kDSpContextNotReservedErr: _bindgen_ty_237 = -30445;
pub const kDSpContextNotFoundErr: _bindgen_ty_237 = -30446;
pub const kDSpFrameRateNotReadyErr: _bindgen_ty_237 = -30447;
pub const kDSpConfirmSwitchWarning: _bindgen_ty_237 = -30448;
pub const kDSpInternalErr: _bindgen_ty_237 = -30449;
pub const kDSpStereoContextErr: _bindgen_ty_237 = -30450;
pub type _bindgen_ty_237 = ::std::os::raw::c_int;
pub const kFBCvTwinExceptionErr: _bindgen_ty_238 = -30500;
pub const kFBCnoIndexesFound: _bindgen_ty_238 = -30501;
pub const kFBCallocFailed: _bindgen_ty_238 = -30502;
pub const kFBCbadParam: _bindgen_ty_238 = -30503;
pub const kFBCfileNotIndexed: _bindgen_ty_238 = -30504;
pub const kFBCbadIndexFile: _bindgen_ty_238 = -30505;
pub const kFBCcompactionFailed: _bindgen_ty_238 = -30506;
pub const kFBCvalidationFailed: _bindgen_ty_238 = -30507;
pub const kFBCindexingFailed: _bindgen_ty_238 = -30508;
pub const kFBCcommitFailed: _bindgen_ty_238 = -30509;
pub const kFBCdeletionFailed: _bindgen_ty_238 = -30510;
pub const kFBCmoveFailed: _bindgen_ty_238 = -30511;
pub const kFBCtokenizationFailed: _bindgen_ty_238 = -30512;
pub const kFBCmergingFailed: _bindgen_ty_238 = -30513;
pub const kFBCindexCreationFailed: _bindgen_ty_238 = -30514;
pub const kFBCaccessorStoreFailed: _bindgen_ty_238 = -30515;
pub const kFBCaddDocFailed: _bindgen_ty_238 = -30516;
pub const kFBCflushFailed: _bindgen_ty_238 = -30517;
pub const kFBCindexNotFound: _bindgen_ty_238 = -30518;
pub const kFBCnoSearchSession: _bindgen_ty_238 = -30519;
pub const kFBCindexingCanceled: _bindgen_ty_238 = -30520;
pub const kFBCaccessCanceled: _bindgen_ty_238 = -30521;
pub const kFBCindexFileDestroyed: _bindgen_ty_238 = -30522;
pub const kFBCindexNotAvailable: _bindgen_ty_238 = -30523;
pub const kFBCsearchFailed: _bindgen_ty_238 = -30524;
pub const kFBCsomeFilesNotIndexed: _bindgen_ty_238 = -30525;
pub const kFBCillegalSessionChange: _bindgen_ty_238 = -30526;
pub const kFBCanalysisNotAvailable: _bindgen_ty_238 = -30527;
pub const kFBCbadIndexFileVersion: _bindgen_ty_238 = -30528;
pub const kFBCsummarizationCanceled: _bindgen_ty_238 = -30529;
pub const kFBCindexDiskIOFailed: _bindgen_ty_238 = -30530;
pub const kFBCbadSearchSession: _bindgen_ty_238 = -30531;
pub const kFBCnoSuchHit: _bindgen_ty_238 = -30532;
pub type _bindgen_ty_238 = ::std::os::raw::c_int;
pub type TextEncoding = UInt32;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct TextEncodingRun {
    pub offset: ByteOffset,
    pub textEncoding: TextEncoding,
}
pub type TextEncodingRunPtr = *mut TextEncodingRun;
pub type ConstTextEncodingRunPtr = *const TextEncodingRun;
pub type TextPtr = *mut UInt8;
pub type ConstTextPtr = *const UInt8;
pub type FSIORefNum = ::std::os::raw::c_int;
pub type ResErrProcPtr = ::std::option::Option<unsafe extern "C" fn(thErr: OSErr)>;
pub type ResErrUPP = ResErrProcPtr;
pub type TECPluginSignature = OSType;
pub type TECPluginVersion = UInt32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueTECObjectRef {
    _unused: [u8; 0],
}
pub type TECObjectRef = *mut OpaqueTECObjectRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueTECSnifferObjectRef {
    _unused: [u8; 0],
}
pub type TECSnifferObjectRef = *mut OpaqueTECSnifferObjectRef;
pub type TECPluginSig = OSType;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct TECConversionInfo {
    pub sourceEncoding: TextEncoding,
    pub destinationEncoding: TextEncoding,
    pub reserved1: UInt16,
    pub reserved2: UInt16,
}
pub type MarkerIdType = SInt16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFFLoop {
    pub playMode: SInt16,
    pub beginLoop: MarkerIdType,
    pub endLoop: MarkerIdType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TECBufferContextRec {
    pub textInputBuffer: ConstTextPtr,
    pub textInputBufferEnd: ConstTextPtr,
    pub textOutputBuffer: TextPtr,
    pub textOutputBufferEnd: TextPtr,
    pub encodingInputBuffer: ConstTextEncodingRunPtr,
    pub encodingInputBufferEnd: ConstTextEncodingRunPtr,
    pub encodingOutputBuffer: TextEncodingRunPtr,
    pub encodingOutputBufferEnd: TextEncodingRunPtr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TECPluginStateRec {
    pub state1: UInt8,
    pub state2: UInt8,
    pub state3: UInt8,
    pub state4: UInt8,
    pub longState1: UInt32,
    pub longState2: UInt32,
    pub longState3: UInt32,
    pub longState4: UInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TECConverterContextRec {
    pub pluginRec: Ptr,
    pub sourceEncoding: TextEncoding,
    pub destEncoding: TextEncoding,
    pub reserved1: UInt32,
    pub reserved2: UInt32,
    pub bufferContext: TECBufferContextRec,
    pub contextRefCon: URefCon,
    pub conversionProc: ProcPtr,
    pub flushProc: ProcPtr,
    pub clearContextInfoProc: ProcPtr,
    pub options1: UInt32,
    pub options2: UInt32,
    pub pluginState: TECPluginStateRec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TECSnifferContextRec {
    pub pluginRec: Ptr,
    pub encoding: TextEncoding,
    pub maxErrors: ItemCount,
    pub maxFeatures: ItemCount,
    pub textInputBuffer: ConstTextPtr,
    pub textInputBufferEnd: ConstTextPtr,
    pub numFeatures: ItemCount,
    pub numErrors: ItemCount,
    pub contextRefCon: URefCon,
    pub sniffProc: ProcPtr,
    pub clearContextInfoProc: ProcPtr,
    pub pluginState: TECPluginStateRec,
}
pub type TECPluginNewEncodingConverterPtr = ::std::option::Option<
    unsafe extern "C" fn(
        newEncodingConverter: *mut TECObjectRef,
        plugContext: *mut TECConverterContextRec,
        inputEncoding: TextEncoding,
        outputEncoding: TextEncoding,
    ) -> OSStatus,
>;
pub type TECPluginClearContextInfoPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingConverter: TECObjectRef,
        plugContext: *mut TECConverterContextRec,
    ) -> OSStatus,
>;
pub type TECPluginConvertTextEncodingPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingConverter: TECObjectRef,
        plugContext: *mut TECConverterContextRec,
    ) -> OSStatus,
>;
pub type TECPluginFlushConversionPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingConverter: TECObjectRef,
        plugContext: *mut TECConverterContextRec,
    ) -> OSStatus,
>;
pub type TECPluginDisposeEncodingConverterPtr = ::std::option::Option<
    unsafe extern "C" fn(
        newEncodingConverter: TECObjectRef,
        plugContext: *mut TECConverterContextRec,
    ) -> OSStatus,
>;
pub type TECPluginNewEncodingSnifferPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingSniffer: *mut TECSnifferObjectRef,
        snifContext: *mut TECSnifferContextRec,
        inputEncoding: TextEncoding,
    ) -> OSStatus,
>;
pub type TECPluginClearSnifferContextInfoPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingSniffer: TECSnifferObjectRef,
        snifContext: *mut TECSnifferContextRec,
    ) -> OSStatus,
>;
pub type TECPluginSniffTextEncodingPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingSniffer: TECSnifferObjectRef,
        snifContext: *mut TECSnifferContextRec,
    ) -> OSStatus,
>;
pub type TECPluginDisposeEncodingSnifferPtr = ::std::option::Option<
    unsafe extern "C" fn(
        encodingSniffer: TECSnifferObjectRef,
        snifContext: *mut TECSnifferContextRec,
    ) -> OSStatus,
>;
pub type TECPluginGetCountAvailableTextEncodingsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        availableEncodings: *mut TextEncoding,
        maxAvailableEncodings: ItemCount,
        actualAvailableEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetCountAvailableTextEncodingPairsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        availableEncodings: *mut TECConversionInfo,
        maxAvailableEncodings: ItemCount,
        actualAvailableEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetCountDestinationTextEncodingsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        inputEncoding: TextEncoding,
        destinationEncodings: *mut TextEncoding,
        maxDestinationEncodings: ItemCount,
        actualDestinationEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetCountSubTextEncodingsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        inputEncoding: TextEncoding,
        subEncodings: *mut TextEncoding,
        maxSubEncodings: ItemCount,
        actualSubEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetCountAvailableSniffersPtr = ::std::option::Option<
    unsafe extern "C" fn(
        availableEncodings: *mut TextEncoding,
        maxAvailableEncodings: ItemCount,
        actualAvailableEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetTextEncodingInternetNamePtr = ::std::option::Option<
    unsafe extern "C" fn(
        textEncoding: TextEncoding,
        encodingName: *mut ::std::os::raw::c_uchar,
    ) -> OSStatus,
>;
pub type TECPluginGetTextEncodingFromInternetNamePtr = ::std::option::Option<
    unsafe extern "C" fn(
        textEncoding: *mut TextEncoding,
        encodingName: ConstStr255Param,
    ) -> OSStatus,
>;
pub type TECPluginGetCountWebEncodingsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        availableEncodings: *mut TextEncoding,
        maxAvailableEncodings: ItemCount,
        actualAvailableEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
pub type TECPluginGetCountMailEncodingsPtr = ::std::option::Option<
    unsafe extern "C" fn(
        availableEncodings: *mut TextEncoding,
        maxAvailableEncodings: ItemCount,
        actualAvailableEncodings: *mut ItemCount,
    ) -> OSStatus,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TECPluginDispatchTable {
    pub version: TECPluginVersion,
    pub compatibleVersion: TECPluginVersion,
    pub PluginID: TECPluginSignature,
    pub PluginNewEncodingConverter: TECPluginNewEncodingConverterPtr,
    pub PluginClearContextInfo: TECPluginClearContextInfoPtr,
    pub PluginConvertTextEncoding: TECPluginConvertTextEncodingPtr,
    pub PluginFlushConversion: TECPluginFlushConversionPtr,
    pub PluginDisposeEncodingConverter: TECPluginDisposeEncodingConverterPtr,
    pub PluginNewEncodingSniffer: TECPluginNewEncodingSnifferPtr,
    pub PluginClearSnifferContextInfo: TECPluginClearSnifferContextInfoPtr,
    pub PluginSniffTextEncoding: TECPluginSniffTextEncodingPtr,
    pub PluginDisposeEncodingSniffer: TECPluginDisposeEncodingSnifferPtr,
    pub PluginGetCountAvailableTextEncodings: TECPluginGetCountAvailableTextEncodingsPtr,
    pub PluginGetCountAvailableTextEncodingPairs: TECPluginGetCountAvailableTextEncodingPairsPtr,
    pub PluginGetCountDestinationTextEncodings: TECPluginGetCountDestinationTextEncodingsPtr,
    pub PluginGetCountSubTextEncodings: TECPluginGetCountSubTextEncodingsPtr,
    pub PluginGetCountAvailableSniffers: TECPluginGetCountAvailableSniffersPtr,
    pub PluginGetCountWebTextEncodings: TECPluginGetCountWebEncodingsPtr,
    pub PluginGetCountMailTextEncodings: TECPluginGetCountMailEncodingsPtr,
    pub PluginGetTextEncodingInternetName: TECPluginGetTextEncodingInternetNamePtr,
    pub PluginGetTextEncodingFromInternetName: TECPluginGetTextEncodingFromInternetNamePtr,
}
pub type TECPluginGetPluginDispatchTablePtr =
    ::std::option::Option<unsafe extern "C" fn() -> *mut TECPluginDispatchTable>;
pub type DescType = ResType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueAEDataStorageType {
    _unused: [u8; 0],
}
pub type AEDataStorageType = *mut OpaqueAEDataStorageType;
pub type AEDataStorage = *mut AEDataStorageType;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct AEDesc {
    pub descriptorType: DescType,
    pub dataHandle: AEDataStorage,
}
pub type OSLGetErrDescProcPtr =
    ::std::option::Option<unsafe extern "C" fn(appDescPtr: *mut *mut AEDesc) -> OSErr>;
pub type OSLGetErrDescUPP = OSLGetErrDescProcPtr;
pub type AEBuildErrorCode = UInt32;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct AEBuildError {
    pub fError: AEBuildErrorCode,
    pub fErrorPos: UInt32,
}
pub const CFNetworkErrors_kCFHostErrorHostNotFound: CFNetworkErrors = 1;
pub const CFNetworkErrors_kCFHostErrorUnknown: CFNetworkErrors = 2;
pub const CFNetworkErrors_kCFSOCKSErrorUnknownClientVersion: CFNetworkErrors = 100;
pub const CFNetworkErrors_kCFSOCKSErrorUnsupportedServerVersion: CFNetworkErrors = 101;
pub const CFNetworkErrors_kCFSOCKS4ErrorRequestFailed: CFNetworkErrors = 110;
pub const CFNetworkErrors_kCFSOCKS4ErrorIdentdFailed: CFNetworkErrors = 111;
pub const CFNetworkErrors_kCFSOCKS4ErrorIdConflict: CFNetworkErrors = 112;
pub const CFNetworkErrors_kCFSOCKS4ErrorUnknownStatusCode: CFNetworkErrors = 113;
pub const CFNetworkErrors_kCFSOCKS5ErrorBadState: CFNetworkErrors = 120;
pub const CFNetworkErrors_kCFSOCKS5ErrorBadResponseAddr: CFNetworkErrors = 121;
pub const CFNetworkErrors_kCFSOCKS5ErrorBadCredentials: CFNetworkErrors = 122;
pub const CFNetworkErrors_kCFSOCKS5ErrorUnsupportedNegotiationMethod: CFNetworkErrors = 123;
pub const CFNetworkErrors_kCFSOCKS5ErrorNoAcceptableMethod: CFNetworkErrors = 124;
pub const CFNetworkErrors_kCFFTPErrorUnexpectedStatusCode: CFNetworkErrors = 200;
pub const CFNetworkErrors_kCFErrorHTTPAuthenticationTypeUnsupported: CFNetworkErrors = 300;
pub const CFNetworkErrors_kCFErrorHTTPBadCredentials: CFNetworkErrors = 301;
pub const CFNetworkErrors_kCFErrorHTTPConnectionLost: CFNetworkErrors = 302;
pub const CFNetworkErrors_kCFErrorHTTPParseFailure: CFNetworkErrors = 303;
pub const CFNetworkErrors_kCFErrorHTTPRedirectionLoopDetected: CFNetworkErrors = 304;
pub const CFNetworkErrors_kCFErrorHTTPBadURL: CFNetworkErrors = 305;
pub const CFNetworkErrors_kCFErrorHTTPProxyConnectionFailure: CFNetworkErrors = 306;
pub const CFNetworkErrors_kCFErrorHTTPBadProxyCredentials: CFNetworkErrors = 307;
pub const CFNetworkErrors_kCFErrorPACFileError: CFNetworkErrors = 308;
pub const CFNetworkErrors_kCFErrorPACFileAuth: CFNetworkErrors = 309;
pub const CFNetworkErrors_kCFErrorHTTPSProxyConnectionFailure: CFNetworkErrors = 310;
pub const CFNetworkErrors_kCFStreamErrorHTTPSProxyFailureUnexpectedResponseToCONNECTMethod:
    CFNetworkErrors = 311;
pub const CFNetworkErrors_kCFURLErrorBackgroundSessionInUseByAnotherProcess: CFNetworkErrors = -996;
pub const CFNetworkErrors_kCFURLErrorBackgroundSessionWasDisconnected: CFNetworkErrors = -997;
pub const CFNetworkErrors_kCFURLErrorUnknown: CFNetworkErrors = -998;
pub const CFNetworkErrors_kCFURLErrorCancelled: CFNetworkErrors = -999;
pub const CFNetworkErrors_kCFURLErrorBadURL: CFNetworkErrors = -1000;
pub const CFNetworkErrors_kCFURLErrorTimedOut: CFNetworkErrors = -1001;
pub const CFNetworkErrors_kCFURLErrorUnsupportedURL: CFNetworkErrors = -1002;
pub const CFNetworkErrors_kCFURLErrorCannotFindHost: CFNetworkErrors = -1003;
pub const CFNetworkErrors_kCFURLErrorCannotConnectToHost: CFNetworkErrors = -1004;
pub const CFNetworkErrors_kCFURLErrorNetworkConnectionLost: CFNetworkErrors = -1005;
pub const CFNetworkErrors_kCFURLErrorDNSLookupFailed: CFNetworkErrors = -1006;
pub const CFNetworkErrors_kCFURLErrorHTTPTooManyRedirects: CFNetworkErrors = -1007;
pub const CFNetworkErrors_kCFURLErrorResourceUnavailable: CFNetworkErrors = -1008;
pub const CFNetworkErrors_kCFURLErrorNotConnectedToInternet: CFNetworkErrors = -1009;
pub const CFNetworkErrors_kCFURLErrorRedirectToNonExistentLocation: CFNetworkErrors = -1010;
pub const CFNetworkErrors_kCFURLErrorBadServerResponse: CFNetworkErrors = -1011;
pub const CFNetworkErrors_kCFURLErrorUserCancelledAuthentication: CFNetworkErrors = -1012;
pub const CFNetworkErrors_kCFURLErrorUserAuthenticationRequired: CFNetworkErrors = -1013;
pub const CFNetworkErrors_kCFURLErrorZeroByteResource: CFNetworkErrors = -1014;
pub const CFNetworkErrors_kCFURLErrorCannotDecodeRawData: CFNetworkErrors = -1015;
pub const CFNetworkErrors_kCFURLErrorCannotDecodeContentData: CFNetworkErrors = -1016;
pub const CFNetworkErrors_kCFURLErrorCannotParseResponse: CFNetworkErrors = -1017;
pub const CFNetworkErrors_kCFURLErrorInternationalRoamingOff: CFNetworkErrors = -1018;
pub const CFNetworkErrors_kCFURLErrorCallIsActive: CFNetworkErrors = -1019;
pub const CFNetworkErrors_kCFURLErrorDataNotAllowed: CFNetworkErrors = -1020;
pub const CFNetworkErrors_kCFURLErrorRequestBodyStreamExhausted: CFNetworkErrors = -1021;
pub const CFNetworkErrors_kCFURLErrorAppTransportSecurityRequiresSecureConnection: CFNetworkErrors =
    -1022;
pub const CFNetworkErrors_kCFURLErrorFileDoesNotExist: CFNetworkErrors = -1100;
pub const CFNetworkErrors_kCFURLErrorFileIsDirectory: CFNetworkErrors = -1101;
pub const CFNetworkErrors_kCFURLErrorNoPermissionsToReadFile: CFNetworkErrors = -1102;
pub const CFNetworkErrors_kCFURLErrorDataLengthExceedsMaximum: CFNetworkErrors = -1103;
pub const CFNetworkErrors_kCFURLErrorFileOutsideSafeArea: CFNetworkErrors = -1104;
pub const CFNetworkErrors_kCFURLErrorSecureConnectionFailed: CFNetworkErrors = -1200;
pub const CFNetworkErrors_kCFURLErrorServerCertificateHasBadDate: CFNetworkErrors = -1201;
pub const CFNetworkErrors_kCFURLErrorServerCertificateUntrusted: CFNetworkErrors = -1202;
pub const CFNetworkErrors_kCFURLErrorServerCertificateHasUnknownRoot: CFNetworkErrors = -1203;
pub const CFNetworkErrors_kCFURLErrorServerCertificateNotYetValid: CFNetworkErrors = -1204;
pub const CFNetworkErrors_kCFURLErrorClientCertificateRejected: CFNetworkErrors = -1205;
pub const CFNetworkErrors_kCFURLErrorClientCertificateRequired: CFNetworkErrors = -1206;
pub const CFNetworkErrors_kCFURLErrorCannotLoadFromNetwork: CFNetworkErrors = -2000;
pub const CFNetworkErrors_kCFURLErrorCannotCreateFile: CFNetworkErrors = -3000;
pub const CFNetworkErrors_kCFURLErrorCannotOpenFile: CFNetworkErrors = -3001;
pub const CFNetworkErrors_kCFURLErrorCannotCloseFile: CFNetworkErrors = -3002;
pub const CFNetworkErrors_kCFURLErrorCannotWriteToFile: CFNetworkErrors = -3003;
pub const CFNetworkErrors_kCFURLErrorCannotRemoveFile: CFNetworkErrors = -3004;
pub const CFNetworkErrors_kCFURLErrorCannotMoveFile: CFNetworkErrors = -3005;
pub const CFNetworkErrors_kCFURLErrorDownloadDecodingFailedMidStream: CFNetworkErrors = -3006;
pub const CFNetworkErrors_kCFURLErrorDownloadDecodingFailedToComplete: CFNetworkErrors = -3007;
pub const CFNetworkErrors_kCFHTTPCookieCannotParseCookieFile: CFNetworkErrors = -4000;
pub const CFNetworkErrors_kCFNetServiceErrorUnknown: CFNetworkErrors = -72000;
pub const CFNetworkErrors_kCFNetServiceErrorCollision: CFNetworkErrors = -72001;
pub const CFNetworkErrors_kCFNetServiceErrorNotFound: CFNetworkErrors = -72002;
pub const CFNetworkErrors_kCFNetServiceErrorInProgress: CFNetworkErrors = -72003;
pub const CFNetworkErrors_kCFNetServiceErrorBadArgument: CFNetworkErrors = -72004;
pub const CFNetworkErrors_kCFNetServiceErrorCancel: CFNetworkErrors = -72005;
pub const CFNetworkErrors_kCFNetServiceErrorInvalid: CFNetworkErrors = -72006;
pub const CFNetworkErrors_kCFNetServiceErrorTimeout: CFNetworkErrors = -72007;
pub const CFNetworkErrors_kCFNetServiceErrorDNSServiceFailure: CFNetworkErrors = -73000;
pub type CFNetworkErrors = ::std::os::raw::c_int;
pub const CFNetServicesError_kCFNetServicesErrorUnknown: CFNetServicesError = -72000;
pub const CFNetServicesError_kCFNetServicesErrorCollision: CFNetServicesError = -72001;
pub const CFNetServicesError_kCFNetServicesErrorNotFound: CFNetServicesError = -72002;
pub const CFNetServicesError_kCFNetServicesErrorInProgress: CFNetServicesError = -72003;
pub const CFNetServicesError_kCFNetServicesErrorBadArgument: CFNetServicesError = -72004;
pub const CFNetServicesError_kCFNetServicesErrorCancel: CFNetServicesError = -72005;
pub const CFNetServicesError_kCFNetServicesErrorInvalid: CFNetServicesError = -72006;
pub const CFNetServicesError_kCFNetServicesErrorTimeout: CFNetServicesError = -72007;
pub const CFNetServicesError_kCFNetServicesErrorMissingRequiredConfiguration: CFNetServicesError =
    -72008;
pub type CFNetServicesError = ::std::os::raw::c_int;
pub const CFStreamErrorHTTP_kCFStreamErrorHTTPParseFailure: CFStreamErrorHTTP = -1;
pub const CFStreamErrorHTTP_kCFStreamErrorHTTPRedirectionLoop: CFStreamErrorHTTP = -2;
pub const CFStreamErrorHTTP_kCFStreamErrorHTTPBadURL: CFStreamErrorHTTP = -3;
pub type CFStreamErrorHTTP = ::std::os::raw::c_int;
pub const CFStreamErrorHTTPAuthentication_kCFStreamErrorHTTPAuthenticationTypeUnsupported:
    CFStreamErrorHTTPAuthentication = -1000;
pub const CFStreamErrorHTTPAuthentication_kCFStreamErrorHTTPAuthenticationBadUserName:
    CFStreamErrorHTTPAuthentication = -1001;
pub const CFStreamErrorHTTPAuthentication_kCFStreamErrorHTTPAuthenticationBadPassword:
    CFStreamErrorHTTPAuthentication = -1002;
pub type CFStreamErrorHTTPAuthentication = ::std::os::raw::c_int;
pub const kCSIdentityUnknownAuthorityErr: _bindgen_ty_899 = -1;
pub const kCSIdentityAuthorityNotAccessibleErr: _bindgen_ty_899 = -2;
pub const kCSIdentityPermissionErr: _bindgen_ty_899 = -3;
pub const kCSIdentityDeletedErr: _bindgen_ty_899 = -4;
pub const kCSIdentityInvalidFullNameErr: _bindgen_ty_899 = -5;
pub const kCSIdentityDuplicateFullNameErr: _bindgen_ty_899 = -6;
pub const kCSIdentityInvalidPosixNameErr: _bindgen_ty_899 = -7;
pub const kCSIdentityDuplicatePosixNameErr: _bindgen_ty_899 = -8;
pub type _bindgen_ty_899 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __SecTrust {
    _unused: [u8; 0],
}
#[doc = "@typedef SecTrustRef\n@abstract CFType used for performing X.509 certificate trust evaluations."]
pub type SecTrustRef = *mut __SecTrust;
#[doc = "@typedef SecTrustWithErrorCallback\n@abstract Delivers the result from an asynchronous trust evaluation.\n@param trustRef A reference to the trust object which has been evaluated.\n@param result A boolean value indicating whether the certificate is trusted.\n@param error An error if the trust evaluation failed."]
pub type SecTrustWithErrorCallback = *mut ::std::os::raw::c_void;
pub const kLSNo32BitEnvironmentErr: _bindgen_ty_1133 = -10386;
pub const kLSMalformedLocErr: _bindgen_ty_1133 = -10400;
pub const kLSAppInTrashErr: _bindgen_ty_1133 = -10660;
pub const kLSExecutableIncorrectFormat: _bindgen_ty_1133 = -10661;
pub const kLSAttributeNotFoundErr: _bindgen_ty_1133 = -10662;
pub const kLSAttributeNotSettableErr: _bindgen_ty_1133 = -10663;
pub const kLSIncompatibleApplicationVersionErr: _bindgen_ty_1133 = -10664;
pub const kLSNoRosettaEnvironmentErr: _bindgen_ty_1133 = -10665;
pub const kLSGarbageCollectionUnsupportedErr: _bindgen_ty_1133 = -10666;
pub const kLSUnknownErr: _bindgen_ty_1133 = -10810;
pub const kLSNotAnApplicationErr: _bindgen_ty_1133 = -10811;
pub const kLSNotInitializedErr: _bindgen_ty_1133 = -10812;
pub const kLSDataUnavailableErr: _bindgen_ty_1133 = -10813;
pub const kLSApplicationNotFoundErr: _bindgen_ty_1133 = -10814;
pub const kLSUnknownTypeErr: _bindgen_ty_1133 = -10815;
pub const kLSDataTooOldErr: _bindgen_ty_1133 = -10816;
pub const kLSDataErr: _bindgen_ty_1133 = -10817;
pub const kLSLaunchInProgressErr: _bindgen_ty_1133 = -10818;
pub const kLSNotRegisteredErr: _bindgen_ty_1133 = -10819;
pub const kLSAppDoesNotClaimTypeErr: _bindgen_ty_1133 = -10820;
pub const kLSAppDoesNotSupportSchemeWarning: _bindgen_ty_1133 = -10821;
pub const kLSServerCommunicationErr: _bindgen_ty_1133 = -10822;
pub const kLSCannotSetInfoErr: _bindgen_ty_1133 = -10823;
pub const kLSNoRegistrationInfoErr: _bindgen_ty_1133 = -10824;
pub const kLSIncompatibleSystemVersionErr: _bindgen_ty_1133 = -10825;
pub const kLSNoLaunchPermissionErr: _bindgen_ty_1133 = -10826;
pub const kLSNoExecutableErr: _bindgen_ty_1133 = -10827;
pub const kLSNoClassicEnvironmentErr: _bindgen_ty_1133 = -10828;
pub const kLSMultipleSessionsNotSupportedErr: _bindgen_ty_1133 = -10829;
pub type _bindgen_ty_1133 = OSStatus;
#[doc = " Prototype for a plug-in entry point, which receives messages from\nthe application or other plug-ins.\n@param caller The caller, which identifies what suite or subsystem\nmade the call. See @ref Callers.\n@param selector The specific event that triggered the call. See @ref Selectors.\n@param message The message data, whose type depends on the specific event."]
pub type SPEntry = ::std::option::Option<
    unsafe extern "C" fn(
        caller: *const ::std::os::raw::c_char,
        selector: *const ::std::os::raw::c_char,
        message: *mut ::std::os::raw::c_void,
    ) -> SPErr,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAccess {
    _unused: [u8; 0],
}
#[doc = " A plug-in access object, used with the \\c #SPAccessSuite to make calls\nto a plug-in. These objects are reference counted. The count is\nincremented when you acquire the object using \\c #SPAccessSuite::AcquirePlugin()\nand decremented when you release it with \\c #SPAccessSuite::ReleasePlugin(),\nso you must be careful to balance these calls. The object is automatically\ncreated and the plug-in loaded if necessary, and the object is destroyed\nand the plug-in unloaded when the reference count is 0."]
pub type SPAccessRef = *mut SPAccess;
#[doc = " Resource chain access information on Mac OS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPMacResChain {
    #[doc = " File reference number"]
    pub fileRefNum: FSIORefNum,
    #[doc = " CF bundle"]
    pub bundleRef: CFBundleRef,
}
#[doc = " Resource chain access information on Mac OS"]
pub type SPPlatformAccessRef = *mut SPMacResChain;
#[doc = " Access  information for the resource chain on Mac OS, or library information on Windows.\nSee \\c #SPAccessSuite::GetAccessInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlatformAccessInfo {
    #[doc = " File access for entry and resources, when resource-access has not been set."]
    pub defaultAccess: SPPlatformAccessRef,
    #[doc = " File access for entry and resources, when resource-access\nhas been set using \\c #SPAccessSuite::SetPluginResourceAccess().\nOtherwise \\c NULL."]
    pub resourceAccess: SPPlatformAccessRef,
    #[doc = " The time since the last access operation, in clock-ticks (1/60th second)."]
    pub lastAccessTicks: ai_uint32,
}
#[doc = " The receiving plug-in has been loaded at application startup, and not yet initialized.\nSent with the \\c #kSPAccessReloadSelector."]
pub const SPAccessPoint_kStartup: SPAccessPoint = 0;
#[doc = " The receiving plug-in has been loaded programmatically while the application\nis running, and has already been initialized.\nSent with the \\c #kSPAccessReloadSelector and the \\c #kSPAccessUnloadSelector."]
pub const SPAccessPoint_kRuntime: SPAccessPoint = 1;
#[doc = " The receiving plug-in is about to be unloaded after being shut down.\nSent with the \\c #kSPAccessUnloadSelector."]
pub const SPAccessPoint_kShutdown: SPAccessPoint = 2;
#[doc = " The receiving plug-in has a non-zero access count and the application is shutting down.\nSent with the \\c #kSPAccessUnloadSelector.\nIf the plug-in has acquired itself in order to remain in memory,\nit should not free any resources  and not acquire others when this\ncall is received."]
pub const SPAccessPoint_kTerminal: SPAccessPoint = 3;
#[doc = " Sent in the \\c #SPAccessMessage to identify when an access call was made.\nUse to distinguish a start-up load from a run-time load or reload,\nand a run-time unload from a shut-down unload."]
pub type SPAccessPoint = ::std::os::raw::c_uint;
#[doc = " Message sent with the \\c #kSPAccessCaller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAccessMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " When the access occurred."]
    pub when: SPAccessPoint,
}
#[doc = " @ingroup Suites\nThis suite is used to load and unload plug-ins. The functions allow\nyou to send messages directly to another plug-in. For example:\n@code\nSPErr SendMessage( SPPluginRef plugin, const char *caller, const char *selector, void *message, SPErr *error ) {\n\nSPErr result;\nSPAccessRef access;\n\naccess = sAccess->AcquirePlugin( plugin, error );\nfail( error );\n\nresult = sAccess->CallPlugin( access, caller, selector, message, error );\nfail( error );\n\nsAccess->ReleasePlugin( access, error );\nfail( error );\n\nreturn result;\n}\n@endcode\nStandard PICA plug-ins rarely call one another directly. Usually program\ncontrol flows from plug-in to plug-in through higher-level suites.\nPlug-in adapters, which provide protocol conversion to non-PICA plug-ins,\ncan add their own access suites to provide access to their foreign plug-ins.\n\n@see \\c #SPInterfaceSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPAccessSuite and \\c #kSPAccessSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPAccessSuite {
    #[doc = " Loads a plug-in if necessary, and prepares it to be called. Creates\nan accessor object if necessary, or increments the reference count\nof the existing accessor. Use \\c #ReleasePlugin() to decrement\nthe count when you not longer need the accessor.\n\nA plug-in can acquire itself in order to remain in memory, even if\nnot referenced by any other plug-in.\n@param plugin The plug-in object.\n@param access [out] A buffer in which to return the new access object."]
    pub AcquirePlugin: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, access: *mut SPAccessRef) -> SPErr,
    >,
    #[doc = " Decrements the reference count of an accessor object.\nWhen the reference count reaches 0, frees the accessor object\nand allows the associated plug-in to be unloaded.\n@param access The access object."]
    pub ReleasePlugin: ::std::option::Option<unsafe extern "C" fn(access: SPAccessRef) -> SPErr>,
    #[doc = " Retrieves the accessor object for a plug-in.\nYou can use this to get the accessor for your own plug-in, in order\nto access the resource chain or library information.\n\nUsed by plug-ins that export suites to manually establish a\nresource context within any of the suite procedures, so that\nthey can access resources. Not needed when a plug-in is called\nthrough its entry point. \\c #SPAccessSuite::CallPlugin()\nsets up the resource context for you.\n\n@param plugin The plug-in object.\n@param access [out] A buffer in which to return the access object,\nor \\c NULL if the plug-in is not loaded."]
    pub GetPluginAccess: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, access: *mut SPAccessRef) -> SPErr,
    >,
    #[doc = " Retrieves the plug-in for an accessor.\n@param access The access object.\n@param plugin [out] A buffer in which to return the plug-in object,\nregardless of whether the plug-in is actually loaded into memory."]
    pub GetAccessPlugin: ::std::option::Option<
        unsafe extern "C" fn(access: SPAccessRef, plugin: *mut SPPluginRef) -> SPErr,
    >,
    #[doc = " Retrieves the entry point of a plug-in accessor. This is the point to\nwhich \\c #CallPlugin() jumps. Before accessing the entry point directly,\nuse \\c #SetCurrentPlugin() to make the plug-in current.\n@param access The access object.\n@param entry [out] A buffer in which to return the entry point structure."]
    pub GetAccessEntry: ::std::option::Option<
        unsafe extern "C" fn(access: SPAccessRef, entry: *mut SPEntry) -> SPErr,
    >,
    #[doc = " Retrieves the current reference count of an accessor object.\n@param access The access object.\n@param count [out] A buffer in which to return the count."]
    pub GetAccessCount: ::std::option::Option<
        unsafe extern "C" fn(access: SPAccessRef, count: *mut ai_int32) -> SPErr,
    >,
    #[doc = " Retrieves the platform-specific resource access information of a plug-in accessor.\nThis is for the resource-chain in Mac OS, or the plug-in library in Windows.\n@param access The access object.\n@param info [out] A buffer in which to return the information structure."]
    pub GetAccessInfo: ::std::option::Option<
        unsafe extern "C" fn(access: SPAccessRef, info: *mut SPPlatformAccessInfo) -> SPErr,
    >,
    #[doc = " Retrieves the platform-specific resource access information of a plug-in accessor.\nThis is for the resource-chain in Mac OS, or the plug-in library in Windows.\n@param access The access object.\n@param info [out] A buffer in which to return the information structure.\nThis differs from \\c #SPAccessSuite::GetAccessInfo(), which takes an \\c #SPAccessRef\nand returns the \\c #SPPlatformAccessInfo."]
    pub GetPluginResourceAccess: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            resourceAccess: *mut SPPlatformAccessRef,
        ) -> SPErr,
    >,
    #[doc = " Sets the the platform-specific resource access information for a plug-in.\n@param plugin The plug-in object.\n@param resourceAccess The new resource-access information."]
    pub SetPluginResourceAccess: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, resourceAccess: SPPlatformAccessRef) -> SPErr,
    >,
    #[doc = " Sends a message to a plug-in, using an accessor object.\n@param access The access object.\n@param caller The caller.\n@param slector The selector.\n@param message The message, as required for the selector.\n@param result [out] A buffer in which to return the result of the call,\nreturned by the called plug-in."]
    pub CallPlugin: ::std::option::Option<
        unsafe extern "C" fn(
            access: SPAccessRef,
            caller: *const ::std::os::raw::c_char,
            selector: *const ::std::os::raw::c_char,
            message: *mut ::std::os::raw::c_void,
            result: *mut SPErr,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the current plug-in, whose access information is the current\nresource context. This is typically the last plug-in to\nreceive a call, but can be set by a plug-in adapter, or by\n\\c #SetCurrentPlugin().\n@param plugin [out] A buffer in which to return the plug-in object,"]
    pub GetCurrentPlugin:
        ::std::option::Option<unsafe extern "C" fn(plugin: *mut SPPluginRef) -> SPErr>,
    #[doc = " Makes a plug-in and its resource context current. An adapter can use\nthis to set the resource context before making a call to a plug-in.\nBefore making this call, you should save the reference for the current\nplug-in, and restore it when this plug-in no longer needs to be current.\n@param plugin The plug-in object,"]
    pub SetCurrentPlugin: ::std::option::Option<unsafe extern "C" fn(plugin: SPPluginRef) -> SPErr>,
}
#[doc = " Opaque reference to a suite object. Access with the \\c #SPSuitesSuite."]
pub type SPSuiteRef = *mut SPSuite;
#[doc = " A list of suite objects. Create with\n\\c #SPSuitesSuite::AllocateSuiteList(), or use\nthe global list, \\c #kSPRuntimeSuiteList."]
pub type SPSuiteListRef = *mut SPSuiteList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPSuiteListIterator {
    _unused: [u8; 0],
}
#[doc = " An iterator object for examining a suite list.\nSee \\c #SPSuitesSuite::NewSuiteListIterator()."]
pub type SPSuiteListIteratorRef = *mut SPSuiteListIterator;
#[doc = " @ingroup Suites\nThis suite allows you to create, manage, and access PICA function suites.\n\nA suite associates a name and version number with a pointer to an array of\nfunction pointers. The functions generally haves some common purpose, such as\naccessing a data type, and are used by plug-ins to interact with PICA, with\nthe application, and with each other.\n\nIn order to use a function in a suite, you must first \\e acquire it.\nThis suite provides the low-level function \\c #AcquireSuite(),\nbut a plug-in more typically uses the \\c #SPBasicSuite, which is provided\nwith every message to a plug-in.\n\nPICA creates a global suite list at application startup, which contains\nreferences to every suite added by PICA, the application, or other plug-ins.\nYou can use this suite to create and manage additional suite lists.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPSuitesSuite and \\c #kSPSuitesSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPSuitesSuite {
    #[doc = " Creates a new suite list. You can also access PICA's global suite list,\nusing \\c #SPRuntimeSuite::GetRuntimeSuiteList().\n@param stringPool The string pool in which to keep suite names.\n@param plugins A set of plug-in objects.\n@param suiteList [out] A buffer in which to return the new list object."]
    pub AllocateSuiteList: ::std::option::Option<
        unsafe extern "C" fn(
            stringPool: SPStringPoolRef,
            plugins: SPPluginListRef,
            suiteList: *mut SPSuiteListRef,
        ) -> SPErr,
    >,
    #[doc = " Frees a list of suites allocated with \\c #AllocateSuiteList(), and\nalso frees any entries in the list. Do not free the global list (\\c #kSPRuntimeSuiteList).\n@param suiteList The suite list object."]
    pub FreeSuiteList:
        ::std::option::Option<unsafe extern "C" fn(suiteList: SPSuiteListRef) -> SPErr>,
    #[doc = " Creates a new plug-in function suite and adds it to a suite list.\nIdentifying constants for the suite name and version must be made\navailable in a public header file.\n@param suiteList The suite list object, or \\c NULL to use the\nglobal list.\n@param host The plug-in object providing the suite.\n@param name The unique name of the suite.\n@param apiVersion The public version number of the suite.\n@param internalVersion The internal version number of the suite.\n@param suiteProcs A pointer to a structure containing the function pointers\nfor the suite.\n@param suite [out] A buffer in which to return the new suite object."]
    pub AddSuite: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            host: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
            suiteProcs: *const ::std::os::raw::c_void,
            suite: *mut SPSuiteRef,
        ) -> SPErr,
    >,
    #[doc = " Acquires a function suite from a suite list. Loads the suite if necessary,\nand increments its reference count. This function differs from\n\\c #SPBasicSuite::AcquireSuite() in that you can specify a suite list\nand internal version number.\n@param suiteList The suite list object, or \\c NULL to use the\nglobal list.\n@param name The suite name.\n@param version The public suite version number.\n@param internalVersion The internal suite version number.\n@param suiteProcs [out] A buffer in which to return a pointer to the\nsuite function pointer array."]
    pub AcquireSuite: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
            suiteProcs: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Decrements the reference count of a suite in a suite list and unloads it when the\nreference count reaches 0.\n@param suiteList The suite list object, or \\c NULL to use the\nglobal list.\n@param name The suite name.\n@param version The public suite version number.\n@param internalVersion The internal suite version number."]
    pub ReleaseSuite: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
        ) -> SPErr,
    >,
    #[doc = " Retrieves a suite from a suite list.\n@param suiteList The suite list object, or \\c NULL to use the\nglobal list.\n@param name The suite name.\n@param version The public suite version number.\n@param internalVersion The internal suite version number.\n@param suiteProcs [out] A buffer in which to return the suite object, or\n\\c NULL if no matching suite is found in the list."]
    pub FindSuite: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
            suite: *mut SPSuiteRef,
        ) -> SPErr,
    >,
    #[doc = " Creates an iterator object with which to traverse a suite list.\nThe iterator is initially set to the first suite in the list.\n@param suiteList The suite list object, or \\c NULL to use the\nglobal list.\n@param iter [out] A buffer in which to return the new iterator object.\n@see \\c #NextSuite(), \\c #DeleteSuiteListIterator()"]
    pub NewSuiteListIterator: ::std::option::Option<
        unsafe extern "C" fn(suiteList: SPSuiteListRef, iter: *mut SPSuiteListIteratorRef) -> SPErr,
    >,
    #[doc = " Retrieves the current suite and advances a suite-list iterator to the next suite in the list.\n@param iter The suite-list iterator object.\n@param suite [out] A buffer in which to return the current suite object, \\c NULL\nif the end of the list has been reached.\n@see \\c #NewSuiteListIterator(),"]
    pub NextSuite: ::std::option::Option<
        unsafe extern "C" fn(iter: SPSuiteListIteratorRef, suite: *mut SPSuiteRef) -> SPErr,
    >,
    #[doc = " Frees a suite-list iterator that is no longer needed.\n@param iter The suite-list iterator object.\n@see \\c #NewSuiteListIterator(),"]
    pub DeleteSuiteListIterator:
        ::std::option::Option<unsafe extern "C" fn(iter: SPSuiteListIteratorRef) -> SPErr>,
    #[doc = " Retrieves the plug-in that provides a suite.\n@param suite The suite object.\n@param plugin [out] A buffer in which to return the plug-in object."]
    pub GetSuiteHost: ::std::option::Option<
        unsafe extern "C" fn(suite: SPSuiteRef, plugin: *mut SPPluginRef) -> SPErr,
    >,
    #[doc = " Retrieves the unique name of a suite.\n@param suite The suite object.\n@param name [out] A buffer in which to return the name string."]
    pub GetSuiteName: ::std::option::Option<
        unsafe extern "C" fn(suite: SPSuiteRef, name: *mut *const ::std::os::raw::c_char) -> SPErr,
    >,
    #[doc = " Retrieves the public version number of a suite.\n@param suite The suite object.\n@param version [out] A buffer in which to return the public version number."]
    pub GetSuiteAPIVersion: ::std::option::Option<
        unsafe extern "C" fn(suite: SPSuiteRef, version: *mut ai_int32) -> SPErr,
    >,
    #[doc = " Retrieves the internal version number of a suite.\n@param suite The suite object.\n@param version [out] A buffer in which to return the internal version number."]
    pub GetSuiteInternalVersion: ::std::option::Option<
        unsafe extern "C" fn(suite: SPSuiteRef, version: *mut ai_int32) -> SPErr,
    >,
    #[doc = " Retrieves the function pointer array of a suite.\n@param suite The suite object.\n@param suiteProcs [out] A buffer in which to return a pointer\nto the function pointer array."]
    pub GetSuiteProcs: ::std::option::Option<
        unsafe extern "C" fn(
            suite: SPSuiteRef,
            suiteProcs: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Retrieves the current reference count of a suite.\n@param suite The suite object.\n@param count [out] A buffer in which to return the reference count."]
    pub GetSuiteAcquireCount: ::std::option::Option<
        unsafe extern "C" fn(suite: SPSuiteRef, count: *mut ai_int32) -> SPErr,
    >,
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPAllocateSuiteList(
        stringPool: SPStringPoolRef,
        plugins: SPPluginListRef,
        suiteList: *mut SPSuiteListRef,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPFreeSuiteList(suiteList: SPSuiteListRef) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPAddSuite(
        suiteList: SPSuiteListRef,
        host: SPPluginRef,
        name: *const ::std::os::raw::c_char,
        apiVersion: ai_int32,
        internalVersion: ai_int32,
        suiteProcs: *const ::std::os::raw::c_void,
        suite: *mut SPSuiteRef,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPRemoveSuite(suiteList: SPSuiteListRef, suite: SPSuiteRef) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPRemoveSuiteEx(
        suiteList: SPSuiteListRef,
        name: *const ::std::os::raw::c_char,
        apiVersion: ai_int32,
        internalVersion: ai_int32,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPAcquireSuite(
        suiteList: SPSuiteListRef,
        name: *const ::std::os::raw::c_char,
        apiVersion: ai_int32,
        internalVersion: ai_int32,
        suiteProcs: *mut *const ::std::os::raw::c_void,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPReleaseSuite(
        suiteList: SPSuiteListRef,
        name: *const ::std::os::raw::c_char,
        apiVersion: ai_int32,
        internalVersion: ai_int32,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPFindSuite(
        suiteList: SPSuiteListRef,
        name: *const ::std::os::raw::c_char,
        apiVersion: ai_int32,
        internalVersion: ai_int32,
        suite: *mut SPSuiteRef,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPNewSuiteListIterator(
        suiteList: SPSuiteListRef,
        iter: *mut SPSuiteListIteratorRef,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPNextSuite(iter: SPSuiteListIteratorRef, suite: *mut SPSuiteRef) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPDeleteSuiteListIterator(iter: SPSuiteListIteratorRef) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteHost(suite: SPSuiteRef, plugin: *mut SPPluginRef) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteName(suite: SPSuiteRef, name: *mut *const ::std::os::raw::c_char) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteAPIVersion(suite: SPSuiteRef, version: *mut ai_int32) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteInternalVersion(suite: SPSuiteRef, version: *mut ai_int32) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteProcs(
        suite: SPSuiteRef,
        suiteProcs: *mut *const ::std::os::raw::c_void,
    ) -> SPErr;
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetSuiteAcquireCount(suite: SPSuiteRef, count: *mut ai_int32) -> SPErr;
}
#[repr(C)]
pub struct SuiteNameVersion {
    pub mName: std_string,
    pub mAPIVersion: ai_int32,
    pub mPluginName: std_string,
}
unsafe extern "C" {
    #[link_name = "\u{1}__Z24SPGetAcquireFailedSuitesv"]
    pub fn SPGetAcquireFailedSuites() -> std_set;
}
#[doc = " Sent to the \\c #SPStartupNotifyProc after a file has been added as a plug-in.\nThe \\c notifyData value is the plug-in object, an \\c #SPPluginRef."]
pub const NotifyEvent_kAddFile: NotifyEvent = 0;
#[doc = " Sent to the \\c #SPStartupNotifyProc after a plug-in has been added.\nThe \\c notifyData value is the plug-in object, an \\c #SPPluginRef."]
pub const NotifyEvent_kAddPlugin: NotifyEvent = 1;
#[doc = " Sent to the \\c #SPStartupNotifyProc to specify a general message for the application splash screen.\nThe \\c notifyData value is a pointer to a C string, <code>char**</code>."]
pub const NotifyEvent_kSetMessage: NotifyEvent = 2;
#[doc = " Internal"]
pub const NotifyEvent_kSuitesAvailable: NotifyEvent = 3;
#[doc = " Internal"]
pub const NotifyEvent_kError: NotifyEvent = 4;
#[doc = " Sent to the \\c #SPStartupNotifyProc after the plug-in is started.\nThe \\c notifyData value is the plug-in object, an \\c #SPPluginRef."]
pub const NotifyEvent_kStartingupPlugin: NotifyEvent = 5;
#[doc = " Sent to the \\c #SPShutdownNotifyProc just before a plug-in is shutdown.\nThe \\c notifyData value is the plug-in object, an \\c #SPPluginRef."]
pub const NotifyEvent_kPreShutdownPlugin: NotifyEvent = 6;
#[doc = " Sent to the \\c #SPShutdownNotifyProc after the plug-in is shutdown.\nThe \\c notifyData value is the plug-in object, an \\c #SPPluginRef."]
pub const NotifyEvent_kPostShutdownPlugin: NotifyEvent = 7;
#[doc = " Internal"]
pub const NotifyEvent_kNoEvent: NotifyEvent = 4294967295;
#[doc = " A notification event type, that an adapter passes to the \\c #SPStartupNotifyProc\nand \\c #SPShutdownNotifyProc when the associated plug-in is loaded or unloaded."]
pub type NotifyEvent = ::std::os::raw::c_uint;
#[doc = " Internal"]
pub type SPAllocateProc = ::std::option::Option<
    unsafe extern "C" fn(
        size: usize,
        hostData: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Internal"]
pub type SPFreeProc = ::std::option::Option<
    unsafe extern "C" fn(block: *mut ::std::os::raw::c_void, hostData: *mut ::std::os::raw::c_void),
>;
#[doc = " Internal"]
pub type SPReallocateProc = ::std::option::Option<
    unsafe extern "C" fn(
        block: *mut ::std::os::raw::c_void,
        newSize: usize,
        hostData: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Called by an adapter to inform the application that a plug-in is being started up.\nThe application uses this information to track the start-up process; for example,\nto display a list of plug-ins being loaded.\n@param event The notification event constant that identifies which event occurred.\n@param notifyData A pointer to plug-in-defined initialization data.\n@param hostData\tA pointer to application-defined initialization data.\n@return Nothing."]
pub type SPStartupNotifyProc = ::std::option::Option<
    unsafe extern "C" fn(
        event: NotifyEvent,
        notifyData: *mut ::std::os::raw::c_void,
        hostData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Called by an adapter to inform the application that a plug-in is being shut down.\nThe application uses this information to track the shut-down process.\n@param event The notification event.\n@param notifyData A pointer to plug-in-defined termination data.\n@param hostData\tA pointer to application-defined termination data.\n@return Nothing."]
pub type SPShutdownNotifyProc = ::std::option::Option<
    unsafe extern "C" fn(
        event: NotifyEvent,
        notifyData: *mut ::std::os::raw::c_void,
        hostData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Internal"]
pub type SPAssertTrapProc = ::std::option::Option<
    unsafe extern "C" fn(
        failMessage: *const ::std::os::raw::c_char,
        hostData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Internal"]
pub type SPThrowTrapProc = ::std::option::Option<
    unsafe extern "C" fn(error: SPErr, hostData: *mut ::std::os::raw::c_void),
>;
#[doc = " Internal"]
pub type SPDebugTrapProc = ::std::option::Option<
    unsafe extern "C" fn(
        debugMessage: *const ::std::os::raw::c_char,
        hostData: *mut ::std::os::raw::c_void,
    ),
>;
pub type SPWarningProc = ::std::option::Option<
    unsafe extern "C" fn(
        warningMessage: *const ::std::os::raw::c_char,
        hostData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Internal"]
pub type SPAllocateStringPoolProc =
    ::std::option::Option<unsafe extern "C" fn(pool: *mut SPStringPoolRef) -> SPErr>;
#[doc = " Internal"]
pub type SPFreeStringPoolProc =
    ::std::option::Option<unsafe extern "C" fn(stringPool: SPStringPoolRef) -> SPErr>;
#[doc = " Internal"]
pub type SPMakeWStringProc = ::std::option::Option<
    unsafe extern "C" fn(
        stringPool: SPStringPoolRef,
        string: *const ::std::os::raw::c_char,
        wString: *mut *const ::std::os::raw::c_char,
    ) -> SPErr,
>;
#[doc = " Internal"]
pub type SPFilterEventProc = ::std::option::Option<
    unsafe extern "C" fn(event: NotifyEvent, eventData: *const ::std::os::raw::c_void) -> SPBoolean,
>;
#[doc = " Internal"]
pub type SPAddPluginsProc = ::std::option::Option<unsafe extern "C" fn() -> SPErr>;
#[doc = " Internal"]
pub type SPOverrideStartupProc =
    ::std::option::Option<unsafe extern "C" fn(currentPlugin: SPPluginRef) -> SPBoolean>;
pub type SPWideCharToPlatform = ::std::option::Option<
    unsafe extern "C" fn(
        destination: *mut ::std::os::raw::c_char,
        dstSizeBytes: usize,
        src: *const ai_uint16,
        srcWcharCount: usize,
    ) -> SPErr,
>;
pub type SPPlatformToWideChar = ::std::option::Option<
    unsafe extern "C" fn(
        destination: *mut ai_uint16,
        dstCharCount: usize,
        src: *const ::std::os::raw::c_char,
        srcSizeBytes: usize,
    ) -> SPErr,
>;
#[doc = " Internal"]
pub type GetNativePluginAccessProc = ::std::option::Option<
    unsafe extern "C" fn(plugin: SPPluginRef, access: *mut SPAccessRef) -> SPErr,
>;
#[doc = " Internal"]
pub type MemoryIsCriticalProc = ::std::option::Option<unsafe extern "C" fn() -> SPBoolean>;
pub type SPPerfLogTimerStart = ::std::option::Option<
    unsafe extern "C" fn(hostLogData: *mut *mut ::std::os::raw::c_void, pauseAtStart: SPBoolean),
>;
pub type SPPerfLogTimerPause =
    ::std::option::Option<unsafe extern "C" fn(hostLogData: *mut ::std::os::raw::c_void)>;
pub type SPPerfLogTimerPlay =
    ::std::option::Option<unsafe extern "C" fn(hostLogData: *mut ::std::os::raw::c_void)>;
pub type SPPerfLogPut = ::std::option::Option<
    unsafe extern "C" fn(
        hostLogData: *mut ::std::os::raw::c_void,
        logString1: *const ::std::os::raw::c_char,
        logString2: *const ::std::os::raw::c_char,
    ),
>;
pub type SPPerfLogPutWithGivenTime = ::std::option::Option<
    unsafe extern "C" fn(
        givenTime: ai_int64,
        logString1: *const ::std::os::raw::c_char,
        logString2: *const ::std::os::raw::c_char,
    ),
>;
pub type SPGetElapsedMicroSeconds = ::std::option::Option<
    unsafe extern "C" fn(hostLogData: *mut ::std::os::raw::c_void) -> ai_int64,
>;
pub type SPPerfLogTimerDestroy =
    ::std::option::Option<unsafe extern "C" fn(hostLogData: *mut ::std::os::raw::c_void)>;
#[doc = " Callback procedures provided to PICA by the application.\nPlug-ins do not use these, except for adapters, which\ncall the initialization and termination procedures.\n@see \\c #SPRuntimeSuite::GetRuntimeHostFileSpec()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPHostProcs {
    pub hostData: *mut ::std::os::raw::c_void,
    pub extAllocate: SPAllocateProc,
    pub extFree: SPFreeProc,
    pub extReallocate: SPReallocateProc,
    pub intAllocate: SPAllocateProc,
    pub intFree: SPFreeProc,
    pub intReallocate: SPReallocateProc,
    #[doc = " Plug-in initialization procedure"]
    pub startupNotify: SPStartupNotifyProc,
    #[doc = " Plug-in termination procedure"]
    pub shutdownNotify: SPShutdownNotifyProc,
    pub assertTrap: SPAssertTrapProc,
    pub throwTrap: SPThrowTrapProc,
    pub debugTrap: SPDebugTrapProc,
    pub warningProc: SPWarningProc,
    pub allocateStringPool: SPAllocateStringPoolProc,
    pub freeStringPool: SPFreeStringPoolProc,
    pub makeWString: SPMakeWStringProc,
    pub appStringPool: SPStringPoolRef,
    pub filterEvent: SPFilterEventProc,
    pub overrideAddPlugins: SPAddPluginsProc,
    pub overridePluginStartup: SPOverrideStartupProc,
    pub getPluginAccess: GetNativePluginAccessProc,
    pub memoryIsCritical: MemoryIsCriticalProc,
    pub extSubAllocate: SPAllocateProc,
    pub extSubFree: SPFreeProc,
    pub extSubReallocate: SPReallocateProc,
    pub wideCharToPlatform: SPWideCharToPlatform,
    pub platformToWideChar: SPPlatformToWideChar,
    pub startPerflog: SPPerfLogTimerStart,
    pub pausePerfLogTimer: SPPerfLogTimerPause,
    pub playPerfLogTimer: SPPerfLogTimerPlay,
    pub putPerfLog: SPPerfLogPut,
    pub putPerfLogWithGivenTime: SPPerfLogPutWithGivenTime,
    pub getElapsedMicroSeconds: SPGetElapsedMicroSeconds,
    pub clearHostLogData: SPPerfLogTimerDestroy,
}
#[doc = "\tSuite\n\n/\n/** @ingroup Suites\nThis suite allows you to obtain specific references to the\nPICA global lists and string pool.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPRuntimeSuite and \\c #kSPRuntimeSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPRuntimeSuite {
    #[doc = " Retrieves the PICA global string pool.\n@param stringPool [out] A buffer in which to return the string-pool object.\n@see \\c #SPStringsSuite"]
    pub GetRuntimeStringPool:
        ::std::option::Option<unsafe extern "C" fn(stringPool: *mut SPStringPoolRef) -> SPErr>,
    #[doc = " Retrieves the PICA global suite list.\n@param suiteList [out] A buffer in which to return the list object.\n@see \\c #SPSuitesSuite"]
    pub GetRuntimeSuiteList:
        ::std::option::Option<unsafe extern "C" fn(suiteList: *mut SPSuiteListRef) -> SPErr>,
    #[doc = " Retrieves the PICA global file list.\n@param fileList [out] A buffer in which to return the list object.\n@see \\c #SPFilesSuite"]
    pub GetRuntimeFileList:
        ::std::option::Option<unsafe extern "C" fn(fileList: *mut SPFileListRef) -> SPErr>,
    #[doc = " Retrieves the PICA global plug-in list.\n@param pluginList [out] A buffer in which to return the list object.\n@see \\c #SPPluginsSuite"]
    pub GetRuntimePluginList:
        ::std::option::Option<unsafe extern "C" fn(pluginList: *mut SPPluginListRef) -> SPErr>,
    #[doc = " Retrieves the PICA global adapter list.\n@param adapterList [out] A buffer in which to return the list object.\n@see \\c #SPAdaptersSuite"]
    pub GetRuntimeAdapterList:
        ::std::option::Option<unsafe extern "C" fn(adapterList: *mut SPAdapterListRef) -> SPErr>,
    #[doc = " Retrieves the block of function pointers supplied to PICA by the\napplication, which contains memory management routines, notification routines,\nexception handling, and string pool routines.\n\nA plug-in does not normally call the host functions directly; you\ncan use the PICA suite functions for most operations. An adapter, however,\nuses the host functions for start-up and shut-down notification.\n@param hostProcs [out] A buffer in which to return a pointer to the\nblock of function pointers."]
    pub GetRuntimeHostProcs:
        ::std::option::Option<unsafe extern "C" fn(hostProcs: *mut *mut SPHostProcs) -> SPErr>,
    #[doc = " Retrieves the location of the application's plug-in folder.\n@param pluginFolder [out] A buffer in which to return the\nfile specification for the directory that contains plug-ins."]
    pub GetRuntimePluginsFolder: ::std::option::Option<
        unsafe extern "C" fn(pluginFolder: *mut SPPlatformFileReference) -> SPErr,
    >,
    #[doc = " Retrieves the location of the application's executable file.\n@param hostFileSpec [out] A buffer in which to return the\nfile specification for the application's executable file."]
    pub GetRuntimeHostFileRef: ::std::option::Option<
        unsafe extern "C" fn(hostFileSpec: *mut SPPlatformFileReference) -> SPErr,
    >,
}
unsafe extern "C" {
    #[doc = " Internal"]
    pub fn SPGetRuntimeSuiteList(suiteList: *mut SPSuiteListRef) -> SPErr;
}
#[doc = " Internal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPBasicFuncStruct {
    pub SPAcquireSuiteFunc: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
            suiteProcs: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    pub SPReleaseSuiteFunc: ::std::option::Option<
        unsafe extern "C" fn(
            suiteList: SPSuiteListRef,
            name: *const ::std::os::raw::c_char,
            apiVersion: ai_int32,
            internalVersion: ai_int32,
        ) -> SPErr,
    >,
    pub spAllocateBlockFunc: ::std::option::Option<
        unsafe extern "C" fn(
            allocateProc: SPAllocateProc,
            size: usize,
            debug: *const ::std::os::raw::c_char,
            block: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    pub spFreeBlockFunc: ::std::option::Option<
        unsafe extern "C" fn(freeProc: SPFreeProc, block: *mut ::std::os::raw::c_void) -> SPErr,
    >,
    pub spReallocateBlockFunc: ::std::option::Option<
        unsafe extern "C" fn(
            reallocateProc: SPReallocateProc,
            block: *mut ::std::os::raw::c_void,
            newSize: usize,
            debug: *const ::std::os::raw::c_char,
            newblock: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    pub gProcs: *mut SPHostProcs,
}
pub const AIErrorCode_kAICoreErrorRangeStart: AIErrorCode = 1;
pub const AIErrorCode_kAICoreCanceledError: AIErrorCode = 129;
pub const AIErrorCode_kAICoreErrorRangeEnd: AIErrorCode = 2048;
pub const AIErrorCode_kAICommonErrorRangeStart: AIErrorCode = 2049;
pub const AIErrorCode_kAIAlreadyExportingSameDocument: AIErrorCode = 2050;
pub const AIErrorCode_kAIOriginalNetworkPathDoesNotExist: AIErrorCode = 2051;
pub const AIErrorCode_kAIScratchFolderNotAvailable: AIErrorCode = 2052;
pub const AIErrorCode_kAISufficientScratchDiskSpaceNotAvailable: AIErrorCode = 2053;
pub const AIErrorCode_kAIMultipleArtboardInASingleArtboardWorkflow: AIErrorCode = 2054;
pub const AIErrorCode_kAIPreConditionNotMet: AIErrorCode = 2055;
pub const AIErrorCode_kAIFeatureNotOptedIn: AIErrorCode = 2056;
pub const AIErrorCode_kAIFeatureNotEnabled: AIErrorCode = 2057;
pub const AIErrorCode_kAIFileCopyToNetworkLocationFailed: AIErrorCode = 2058;
pub const AIErrorCode_kAIJSONParsingFailed: AIErrorCode = 2059;
pub const AIErrorCode_kAIVerificationFailedErr: AIErrorCode = 2060;
pub const AIErrorCode_kAIFileReadError: AIErrorCode = 2061;
pub const AIErrorCode_kAIFileRenameError: AIErrorCode = 2062;
pub const AIErrorCode_kAICorruptLinkErr: AIErrorCode = 2063;
pub const AIErrorCode_kAICantCutAllArtboardsErr: AIErrorCode = 2064;
pub const AIErrorCode_kAINoSpaceToPasteArtboardErr: AIErrorCode = 2065;
pub const AIErrorCode_kAIHTTPErr: AIErrorCode = 2066;
pub const AIErrorCode_kAIDXFDWGSDKErr: AIErrorCode = 2067;
pub const AIErrorCode_kAILiveEditTimeExceededErr: AIErrorCode = 2068;
pub const AIErrorCode_kAIJsonValueNotAMapErr: AIErrorCode = 2069;
pub const AIErrorCode_kAIFileNotFoundErr: AIErrorCode = 2070;
pub const AIErrorCode_kAIFileGenratedByForegroundSaveNotFoundErr: AIErrorCode = 2071;
pub const AIErrorCode_kAINotACloudDocumentErr: AIErrorCode = 2072;
pub const AIErrorCode_kAINotALocalDocumentErr: AIErrorCode = 2073;
pub const AIErrorCode_kCloudDocumentAlreadyOpeningErr: AIErrorCode = 2074;
pub const AIErrorCode_kAINotOnMainThreadError: AIErrorCode = 2075;
pub const AIErrorCode_kAINoFeatureFound: AIErrorCode = 2076;
pub const AIErrorCode_kAISignatureNotValid: AIErrorCode = 2077;
pub const AIErrorCode_kAIUserNotRegisteredWithCloudErr: AIErrorCode = 2078;
pub const AIErrorCode_kAIInvalidToolBoxDrawerTileViewErr: AIErrorCode = 2079;
pub const AIErrorCode_kAIRepeatArtIsolationModeNotActiveErr: AIErrorCode = 2080;
pub const AIErrorCode_kAIFileDeleteError: AIErrorCode = 2081;
pub const AIErrorCode_kAIDirectoryDeleteError: AIErrorCode = 2082;
pub const AIErrorCode_kAIFastExportFailedErr: AIErrorCode = 2083;
pub const AIErrorCode_kAICantHibernateInvalidDocType: AIErrorCode = 2084;
pub const AIErrorCode_kAICantHibernatePreferenceOff: AIErrorCode = 2085;
pub const AIErrorCode_kAIInvalidHibernateInfoFile: AIErrorCode = 2086;
pub const AIErrorCode_kAIFileFormatNotFoundErr: AIErrorCode = 2087;
pub const AIErrorCode_kAITaskCantBeScheduledErr: AIErrorCode = 2088;
pub const AIErrorCode_kAILiveEffectNotFoundErr: AIErrorCode = 2089;
pub const AIErrorCode_kAIUserNotLoggedInToCCErr: AIErrorCode = 2090;
pub const AIErrorCode_kAILiveEffectParamsNotFoundErr: AIErrorCode = 2091;
pub const AIErrorCode_kAILiveEffectVisibilityHiddenErr: AIErrorCode = 2092;
pub const AIErrorCode_kAIFileCopyErr: AIErrorCode = 2093;
pub const AIErrorCode_kUITaskGroupExistsError: AIErrorCode = 2094;
pub const AIErrorCode_kUITaskGroupDoesNotExistError: AIErrorCode = 2095;
pub const AIErrorCode_kUITaskGroupInvalidHandle: AIErrorCode = 2096;
pub const AIErrorCode_kAIUnsupportedSkiaFeatureErr: AIErrorCode = 2097;
pub const AIErrorCode_kAIUnsupportedAGMGPUFeatureErr: AIErrorCode = 2098;
pub const AIErrorCode_kAISkipEffectExecutionErr: AIErrorCode = 2099;
pub const AIErrorCode_kAICodecNotAvailableErr: AIErrorCode = 2100;
pub const AIErrorCode_kAIPDFFormatUnknownErr: AIErrorCode = 2101;
pub const AIErrorCode_kAICantErr: AIErrorCode = 2102;
pub const AIErrorCode_kAINotEnoughRAMErr: AIErrorCode = 2103;
pub const AIErrorCode_kAIBrokenJPEGErr: AIErrorCode = 2104;
pub const AIErrorCode_kAIPluginLoadingErr: AIErrorCode = 2105;
pub const AIErrorCode_kAIFileReadWriteErr: AIErrorCode = 2106;
pub const AIErrorCode_kAIInvalidObjectsIgnoredErr: AIErrorCode = 2107;
pub const AIErrorCode_kAISufficientDiskSpaceNotAvailable: AIErrorCode = 2108;
pub const AIErrorCode_kAITextResourceLoadingFailed: AIErrorCode = 2109;
pub const AIErrorCode_kAINotEntitledErr: AIErrorCode = 2110;
pub const AIErrorCode_kAIInvalidVMStreamErr: AIErrorCode = 2111;
pub const AIErrorCode_kAIImageSizeTooSmallForMockupErr: AIErrorCode = 2112;
pub const AIErrorCode_kUnSupportedLanguageError: AIErrorCode = 2113;
pub const AIErrorCode_kBlockedContentError: AIErrorCode = 2114;
pub const AIErrorCode_kInternetDisconnectedError: AIErrorCode = 2115;
pub const AIErrorCode_kAIFFQuotaExhaustedError: AIErrorCode = 2116;
pub const AIErrorCode_kAIFFBlockByAdminError: AIErrorCode = 2117;
pub const AIErrorCode_kAIFFBlockDueToViolationError: AIErrorCode = 2118;
pub const AIErrorCode_kAIFFNotEntitledError: AIErrorCode = 2119;
pub const AIErrorCode_kAIFFProfileDeniedError: AIErrorCode = 2120;
pub const AIErrorCode_kAIFFInvalidScopeError: AIErrorCode = 2121;
pub const AIErrorCode_kAIFFThrottledError: AIErrorCode = 2122;
pub const AIErrorCode_kAIFFUnauthorizedError: AIErrorCode = 2123;
pub const AIErrorCode_kAIFFGeoBlockError: AIErrorCode = 2124;
pub const AIErrorCode_kNotEnoughSpaceAvailableErr: AIErrorCode = 2125;
pub const AIErrorCode_kAINoVectorToFormMockupErr: AIErrorCode = 2126;
pub const AIErrorCode_kAINoGPUToFormMockupErr: AIErrorCode = 2127;
pub const AIErrorCode_kAIOnDemandModuleNotFoundErr: AIErrorCode = 2128;
pub const AIErrorCode_kBlockedArtistContentError: AIErrorCode = 2129;
pub const AIErrorCode_kAIFFBlockDueToInvalidSubscription: AIErrorCode = 2130;
pub const AIErrorCode_kAIFFValidationError: AIErrorCode = 2131;
pub const AIErrorCode_kAIImageContainsPSConstructsErr: AIErrorCode = 2132;
pub const AIErrorCode_kAIUnsupportedColorSpaceErr: AIErrorCode = 2133;
pub const AIErrorCode_kAIPreloadPluginNotFoundErr: AIErrorCode = 2134;
pub const AIErrorCode_kAINotFoundError: AIErrorCode = 2135;
pub const AIErrorCode_kEmptyArtBoundsErr: AIErrorCode = 2136;
pub const AIErrorCode_kAIPSDMissingCompositeErr: AIErrorCode = 2137;
pub const AIErrorCode_kAINeedUserInputErr: AIErrorCode = 2138;
pub const AIErrorCode_kPreloadNotReadyErr: AIErrorCode = 2139;
pub const AIErrorCode_kSentinelErrorCodeStarted: AIErrorCode = 2199;
pub const AIErrorCode_kAIInvalidSHMStreamErr: AIErrorCode = 2200;
pub const AIErrorCode_kAIInvalidRecoveryInfo: AIErrorCode = 2201;
pub const AIErrorCode_kAIMonitorNotLaunched: AIErrorCode = 2202;
pub const AIErrorCode_kAISHMLoadError: AIErrorCode = 2203;
pub const AIErrorCode_kAISentinelDirectoryErr: AIErrorCode = 2204;
pub const AIErrorCode_kAISentinelTempDirErr: AIErrorCode = 2205;
pub const AIErrorCode_kAISentinelSerializeIPCCacheMapErr: AIErrorCode = 2206;
pub const AIErrorCode_kAISentinelSerializeIPCStreamErr: AIErrorCode = 2207;
pub const AIErrorCode_kAISentinelRenametoOldErr: AIErrorCode = 2208;
pub const AIErrorCode_kAISentinelRenameTemptoSentinelErr: AIErrorCode = 2209;
pub const AIErrorCode_kAISentinelSerializeImageArrayErr: AIErrorCode = 2210;
pub const AIErrorCode_kAIRobinErrorCodeStarted: AIErrorCode = 3149;
pub const AIErrorCode_kAIRobinClientNotRegisteredWithVulcanErr: AIErrorCode = 3150;
pub const AIErrorCode_kAIRobinServiceIsDownErr: AIErrorCode = 3151;
pub const AIErrorCode_kAIRobinCommunicationBrokenErr: AIErrorCode = 3152;
pub const AIErrorCode_kAIRobinServiceFailedToOpenFileErr: AIErrorCode = 3153;
pub const AIErrorCode_kAIRobinJobFailedUptoMaxTimesErr: AIErrorCode = 3154;
pub const AIErrorCode_kAIRobinNoErrorCodeInFailedResponseMsgErr: AIErrorCode = 3155;
pub const AIErrorCode_kAIRobinAckOfMessageNotReceivedErr: AIErrorCode = 3156;
pub const AIErrorCode_kAIRobinFallbackAllAsServiceInactiveErr: AIErrorCode = 3157;
pub const AIErrorCode_kAIRobinFallbackAllAsServiceNotRunningErr: AIErrorCode = 3158;
pub const AIErrorCode_kAIRobinCommandFallbackNotImplementedErr: AIErrorCode = 3159;
pub const AIErrorCode_kAIRobinCrashedWhileExecutingJobErr: AIErrorCode = 3160;
pub const AIErrorCode_kAIRobinRealErrorConvertedToCancelErr: AIErrorCode = 3161;
pub const AIErrorCode_kAIRobinServiceStartTimedOutErr: AIErrorCode = 3162;
pub const AIErrorCode_kAIRobinErrorCodeEnded: AIErrorCode = 3249;
pub const AIErrorCode_kIllustratorDiagnosysErrorCodeStarted: AIErrorCode = 3349;
pub const AIErrorCode_kIllustratorDiagnosysNotLaunched: AIErrorCode = 3350;
pub const AIErrorCode_kIllustratorDiagnosysErrorCodeEnded: AIErrorCode = 3449;
pub const AIErrorCode_kAICommonErrorRangeEnd: AIErrorCode = 65535;
pub const AIErrorCode_kAIThirdPartySDKErrorRangeStart: AIErrorCode = 65536;
pub const AIErrorCode_kAIThirdPartySDKErrorRangeEnd: AIErrorCode = 131071;
pub type AIErrorCode = ai_int32;
#[doc = " 8-bit integer"]
pub type ASInt8 = ::std::os::raw::c_schar;
#[doc = " 16-bit integer"]
pub type ASInt16 = ::std::os::raw::c_short;
#[doc = " 32-bit integer"]
pub type ASInt32 = ai_int32;
#[doc = " 8-bit integer"]
pub type ASUInt8 = ::std::os::raw::c_uchar;
#[doc = " 16-bit integer"]
pub type ASUInt16 = ::std::os::raw::c_ushort;
#[doc = " 32-bit integer"]
pub type ASUInt32 = ai_uint32;
#[doc = " Error code"]
pub type ASErr = ai_int32;
pub type ASByte = ::std::os::raw::c_uchar;
pub type ASBytePtr = *mut ASByte;
#[doc = " Unicode double-byte character"]
pub type ASUnicode = ASUInt16;
#[doc = " Void pointer"]
pub type ASPtr = *mut ::std::os::raw::c_void;
#[doc = " Opaque reference"]
pub type ASHandle = *mut *mut ::std::os::raw::c_void;
#[doc = " Numeric value (long) used for fixed-math fractional values, as \\c #AIFract. Obsolete."]
pub type ASFract = ASInt32;
#[doc = " Numeric value (floating-point)"]
pub type ASReal = f32;
#[doc = " Fixed numeric value - obsolete, use \\c #ASReal"]
pub type ASFixed = ASInt32;
#[doc = " Point specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealPoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASFixedPoint {
    pub h: ASFixed,
    pub v: ASFixed,
}
#[doc = " Point specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealPoint"]
pub type ASFixedPoint = _t_ASFixedPoint;
#[doc = " Point specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealPoint"]
pub type ASFixedPointP = *mut _t_ASFixedPoint;
#[doc = " Rectangle specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASFixedRect {
    pub left: ASFixed,
    pub top: ASFixed,
    pub right: ASFixed,
    pub bottom: ASFixed,
}
#[doc = " Rectangle specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealRect"]
pub type ASFixedRect = _t_ASFixedRect;
#[doc = " Rectangle specified with \\c #ASFixed coordinates - obsolete, use \\c #ASRealRect"]
pub type ASFixedRectP = *mut _t_ASFixedRect;
#[doc = " Transformation matrix specified with \\c #ASFixed values - obsolete, use \\c #ASRealMatrix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASFixedMatrix {
    pub a: ASFixed,
    pub b: ASFixed,
    pub c: ASFixed,
    pub d: ASFixed,
    pub tx: ASFixed,
    pub ty: ASFixed,
}
#[doc = " Transformation matrix specified with \\c #ASFixed values - obsolete, use \\c #ASRealMatrix"]
pub type ASFixedMatrix = _t_ASFixedMatrix;
#[doc = " Transformation matrix specified with \\c #ASFixed values - obsolete, use \\c #ASRealMatrix"]
pub type ASFixedMatrixP = *mut _t_ASFixedMatrix;
#[doc = " Point specified with \\c #ASReal coordinates"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASRealPoint {
    pub h: ASReal,
    pub v: ASReal,
}
#[doc = " Point specified with \\c #ASReal coordinates"]
pub type ASRealPoint = _t_ASRealPoint;
#[doc = " Rectangle specified with \\c #ASReal coordinates"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASRealRect {
    pub left: ASReal,
    pub top: ASReal,
    pub right: ASReal,
    pub bottom: ASReal,
}
#[doc = " Rectangle specified with \\c #ASReal coordinates"]
pub type ASRealRect = _t_ASRealRect;
#[doc = " Transformation matrix specified with \\c #ASReal values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_ASRealMatrix {
    pub a: ASReal,
    pub b: ASReal,
    pub c: ASReal,
    pub d: ASReal,
    pub tx: ASReal,
    pub ty: ASReal,
}
#[doc = " Transformation matrix specified with \\c #ASReal values"]
pub type ASRealMatrix = _t_ASRealMatrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASAccess {
    _unused: [u8; 0],
}
#[doc = " Generic reference to a resource (plug-in) file.\nGenerally equivalent to an \\c #SPPluginRef"]
pub type ASAccessRef = *mut ASAccess;
#[doc = " Mac OS only. Size type for Mac OS \\c Rect and \\c Point."]
pub type ASSize = ::std::os::raw::c_short;
#[doc = " Mac OS only. the same as Mac OS \\c Boolean."]
pub type ASBoolean = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MacPort_t {
    _unused: [u8; 0],
}
#[doc = " Port reference, Mac OS only, same as Mac OS \\c CGrafPtr."]
pub type AIPortRef = *mut MacPort_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MacWindow_t {
    _unused: [u8; 0],
}
#[doc = " Window reference, Mac OS only, same as Mac OS \\c WindowPtr."]
pub type AIWindowRef = *mut MacWindow_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MacDialog_t {
    _unused: [u8; 0],
}
#[doc = " Dialog reference, Mac OS only, same as Mac OS \\c DialogPtr."]
pub type AIDialogRef = *mut MacDialog_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArtObject {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an art object. Access using \\c #AIArtSuite."]
pub type AIArtHandle = *mut ArtObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AISafeArtOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an Safe Art Handle. Access using \\c #AIArtSuite"]
pub type AISafeArtHandle = *mut _t_AISafeArtOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AILayerOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a layer. Access using \\c #AILayerSuite."]
pub type AILayerHandle = *mut _t_AILayerOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIDocument {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a document. Access using \\c #AIDocumentSuite."]
pub type AIDocumentHandle = *mut _t_AIDocument;
#[doc = " Fixed number (obsolete) See \\c #AIFixedMathSuite."]
pub type AIFixed = ASFixed;
#[doc = " A fractional number greater than -2 and less than 2. Obsolete, use \\c AIReal."]
pub type AIFract = ASFract;
#[doc = " An unsigned fractional number greater than 0 and less than 4. Obsolete, use \\c AIReal."]
pub type AIUFract = ai_uint32;
pub type AIRealPtr = *mut AIReal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIStreamOpaque {
    _unused: [u8; 0],
}
#[doc = " Data stream"]
pub type AIStream = *mut _t_AIStreamOpaque;
#[doc = " Rectangle specified with \\c #AIFixed coordinates. Obsolete, use \\c #AIRealRect."]
pub type AIFixedRect = ASFixedRect;
#[doc = " Point specified with \\c #AIFixed coordinates. Obsolete, use \\c #AIRealPoint."]
pub type AIFixedPoint = ASFixedPoint;
#[doc = " Transformation matrix specified with \\c #AIFixed values. Obsolete, use \\c #AIRealMatrix."]
pub type AIFixedMatrix = ASFixedMatrix;
#[doc = " Transformation matrix specified with \\c #ASReal values"]
pub type AIFloatMatrix = ASRealMatrix;
#[doc = " Point specified with \\c #ASReal coordinates"]
pub type AIFloatPoint = ASRealPoint;
#[doc = " 1-byte boolean value, true (1) or false (0)"]
pub type AIBool8 = ASByte;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIPlatformViewOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a Platform View, NSView* on Mac and HWND on Windows ."]
pub type AIPlatformViewRef = *mut _t_AIPlatformViewOpaque;
#[doc = " RGB color record"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRGBColor {
    #[doc = " Color values"]
    pub red: ai_uint16,
    pub green: ai_uint16,
    pub blue: ai_uint16,
}
#[doc = " Event information structure, used by \\c #AIToolSuite, \\c #AICursorSnapSuite.\nAIEvent is the same as Macintosh EventRecord on Macintosh and Windows. */\n/** Event record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIEvent {
    #[doc = " The type of event"]
    pub what: ::std::os::raw::c_ushort,
    #[doc = " The event message"]
    pub message: ::std::os::raw::c_ulong,
    #[doc = " The time when the event occurred"]
    pub when: ::std::os::raw::c_ulong,
    #[doc = " The location of the event"]
    pub where_: AIPoint,
    #[doc = " Event modifiers (other simultaneous events or conditions).\nA logical OR of \\c #AIEventModifersValue bit flag values."]
    pub modifiers: ::std::os::raw::c_ushort,
}
#[doc = " Event information structure, used by \\c #AIToolSuite, \\c #AICursorSnapSuite.\nAIEvent is the same as Macintosh EventRecord on Macintosh and Windows. */\n/** Event record."]
pub type AIEvent = _t_AIEvent;
#[doc = " Opaque error, returned by most suite functions. See @ref Errors"]
pub type AIErr = ASErr;
#[doc = " Use the \\c #AIColorProfile type instead of an \\c ACEProfile*"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACEProfile {
    _unused: [u8; 0],
}
#[doc = " Opaque color profile. See \\c #AIColorConversionSuite."]
pub type AIColorProfile = *mut ACEProfile;
#[doc = " An Illustrator menu command identifier. See \\c #AICommandManagerSuite."]
pub type AICommandID = ai_uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZREFStruct {
    _unused: [u8; 0],
}
#[doc = " A ZString (localizable string) reference.\nEnforces the passing of ZStrings.\nA ZStrings is a \\c char* with a conventional format,\nso it is easy to pass a non-ZString by accident. When this\ntype is specified, the function expects a ZString.\nYou can cast it back to a \\c char* if you need to look inside it."]
pub type ZRef = *const ZREFStruct;
#[doc = " Default value"]
pub const AIPaintOrder_kPlaceDefault: AIPaintOrder = 0;
#[doc = " Place above the prepositional object"]
pub const AIPaintOrder_kPlaceAbove: AIPaintOrder = 1;
#[doc = " Place below the prepositional object"]
pub const AIPaintOrder_kPlaceBelow: AIPaintOrder = 2;
#[doc = " Place within and at the top of the prepositional container"]
pub const AIPaintOrder_kPlaceInsideOnTop: AIPaintOrder = 3;
#[doc = " Place within and at the bottom of the prepositional container"]
pub const AIPaintOrder_kPlaceInsideOnBottom: AIPaintOrder = 4;
#[doc = " Place at the top of the paint order, ignoring prepositional object"]
pub const AIPaintOrder_kPlaceAboveAll: AIPaintOrder = 5;
#[doc = " Place at the bottom of the paint order, ignoring prepositional object"]
pub const AIPaintOrder_kPlaceBelowAll: AIPaintOrder = 6;
#[doc = " The position of an art object, which determines how it is drawn relative to another,\noverlapping art object, known as the prep (prepositional) object,\nand also whether a path is inside a compound path or group.\n\\li If the paint order is \\c kPlaceAbove or \\c kPlaceBelow, the object is drawn above or below the prep object\nwhen the boundaries overlap.\n\\li If the paint order is \\c kPlaceInsideOnTop or \\c kPlaceInsideOnBottom,the object is inside the prep object,\nwhich must be a container.\n\\li If the paint order is \\c kPlaceAboveAll or \\c kPlaceBelowAll,\nthe prep object is ignored and the object is placed on top of or at the bottom of the entire document\n(that is, inside-on-top the topmost group or inside-on-bottom the bottommost group).\n\nThe paint order is the back-to-front ordering of art objects, also called the occlusion order or Z-order.\nIt determines which objects obscure others when their bounds overlap. If objects do not overlap,\nthe paint order is irrelevant to rendering.\n\nPaint order values are used, for example, when creating art objects with \\c #AIArtSuite::NewArt(), copying\nor moving art objects, or specifying insertion points for art."]
pub type AIPaintOrder = ::std::os::raw::c_uint;
pub const AIPaintUsage_kAINotUsed: AIPaintUsage = 0;
#[doc = " Paint is applied to fills."]
pub const AIPaintUsage_kAIUsedOnFill: AIPaintUsage = 1;
#[doc = " Paint is applied to strokes."]
pub const AIPaintUsage_kAIUsedOnStroke: AIPaintUsage = 2;
#[doc = " Paint is applied to both fills and strokes."]
pub const AIPaintUsage_kAIUsedOnBoth: AIPaintUsage = 3;
#[doc = " How paint is applied--to fills, strokes, or both."]
pub type AIPaintUsage = ::std::os::raw::c_uint;
pub const AIVersion_kAIVersion1: AIVersion = 1;
pub const AIVersion_kAIVersion88: AIVersion = 2;
pub const AIVersion_kAIVersion3: AIVersion = 3;
pub const AIVersion_kAIVersion4: AIVersion = 4;
pub const AIVersion_kAIVersion5: AIVersion = 5;
pub const AIVersion_kAIVersion6: AIVersion = 6;
pub const AIVersion_kAIVersion7: AIVersion = 7;
pub const AIVersion_kAIVersion8: AIVersion = 8;
pub const AIVersion_kAIVersion9: AIVersion = 9;
pub const AIVersion_kAIVersion10: AIVersion = 10;
pub const AIVersion_kAIVersion11: AIVersion = 11;
pub const AIVersion_kAIVersion12: AIVersion = 12;
pub const AIVersion_kAIVersion13: AIVersion = 13;
pub const AIVersion_kAIVersion14: AIVersion = 14;
pub const AIVersion_kAIVersion15: AIVersion = 15;
pub const AIVersion_kAIVersion16: AIVersion = 16;
pub const AIVersion_kAIVersion17: AIVersion = 17;
pub const AIVersion_kAIVersion18: AIVersion = 18;
pub const AIVersion_kAIVersion19: AIVersion = 19;
pub const AIVersion_kAIVersion20: AIVersion = 20;
pub const AIVersion_kAIVersion21: AIVersion = 21;
pub const AIVersion_kAIVersion22: AIVersion = 22;
pub const AIVersion_kAIVersion23: AIVersion = 23;
pub const AIVersion_kAIVersion24: AIVersion = 24;
pub const AIVersion_kAIVersion25: AIVersion = 25;
pub const AIVersion_kAIVersion26: AIVersion = 26;
pub const AIVersion_kAIVersion27: AIVersion = 27;
pub const AIVersion_kAIVersion28: AIVersion = 28;
pub const AIVersion_kAIVersion29: AIVersion = 29;
pub const AIVersion_kAIVersionLatest: AIVersion = 29;
#[doc = " These constants identify the various shipping versions of Illustrator."]
pub type AIVersion = ::std::os::raw::c_uint;
#[doc = " None"]
pub const AIUnits_kAINoUnits: AIUnits = 0;
#[doc = " Points"]
pub const AIUnits_kAIPointUnits: AIUnits = 1;
#[doc = " Inches"]
pub const AIUnits_kAIInchUnits: AIUnits = 2;
#[doc = " Millimeters"]
pub const AIUnits_kAIMillimeterUnits: AIUnits = 3;
#[doc = " Centimeters"]
pub const AIUnits_kAICentimeterUnits: AIUnits = 4;
#[doc = " Picas"]
pub const AIUnits_kAIPicaUnits: AIUnits = 5;
#[doc = " Percentage"]
pub const AIUnits_kAIPercentUnits: AIUnits = 6;
#[doc = " Degrees"]
pub const AIUnits_kAIDegreeUnits: AIUnits = 7;
#[doc = " Q units"]
pub const AIUnits_kAIQUnits: AIUnits = 8;
#[doc = " Hexadecimal units"]
pub const AIUnits_kAIBase16Units: AIUnits = 9;
#[doc = " Pixels"]
pub const AIUnits_kAIPixelUnits: AIUnits = 10;
#[doc = " Time"]
pub const AIUnits_kAITimeUnits: AIUnits = 11;
#[doc = " Feets units"]
pub const AIUnits_kAIFeetUnits: AIUnits = 12;
#[doc = " Ha"]
pub const AIUnits_kAIHaUnits: AIUnits = 13;
#[doc = " Feet Inch"]
pub const AIUnits_kAIFeetInchUnits: AIUnits = 14;
#[doc = " Meter"]
pub const AIUnits_kAIMeterUnits: AIUnits = 15;
#[doc = " Yards"]
pub const AIUnits_kAIYardUnits: AIUnits = 16;
#[doc = " Minimum default"]
pub const AIUnits_kAIMinNormalUnits: AIUnits = 1;
#[doc = " Maximum default"]
pub const AIUnits_kAIMaxNormalUnits: AIUnits = 16;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits1: AIUnits = 101;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits2: AIUnits = 102;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits3: AIUnits = 103;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits4: AIUnits = 104;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits5: AIUnits = 105;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits6: AIUnits = 106;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits7: AIUnits = 107;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits8: AIUnits = 108;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits9: AIUnits = 109;
#[doc = " App constant"]
pub const AIUnits_kAIAppUnits10: AIUnits = 110;
#[doc = " App constant"]
pub const AIUnits_kAIMaxAppUnits: AIUnits = 110;
#[doc = " internal use"]
pub const AIUnits_kAIDummyUnits: AIUnits = 4294967295;
#[doc = " These constants identify the various units used in Illustrator."]
pub type AIUnits = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AISize {
    pub width: AIReal,
    pub height: AIReal,
}
#[doc = " The character set currently supported by the system."]
pub const AICharacterEncoding_kAIPlatformCharacterEncoding: AICharacterEncoding = 0;
#[doc = " UTF8 encoding"]
pub const AICharacterEncoding_kAIUTF8CharacterEncoding: AICharacterEncoding = 1;
#[doc = " UTF16 encoding (formerly \\c kAIUCS2CharacterEncoding)"]
pub const AICharacterEncoding_kAIUTF16CharacterEncoding: AICharacterEncoding = 2;
#[doc = " Roman"]
pub const AICharacterEncoding_kAIRomanCharacterEncoding: AICharacterEncoding = 16;
#[doc = " Japanese, encoded using Shift-JIS"]
pub const AICharacterEncoding_kAIJapaneseCharacterEncoding: AICharacterEncoding = 17;
#[doc = " Traditional Chinese"]
pub const AICharacterEncoding_kAITraditionalChineseCharacterEncoding: AICharacterEncoding = 18;
#[doc = " Simplified Chinese"]
pub const AICharacterEncoding_kAISimplifiedChineseCharacterEncoding: AICharacterEncoding = 19;
#[doc = " Korean"]
pub const AICharacterEncoding_kAIKoreanCharacterEncoding: AICharacterEncoding = 20;
#[doc = " Arabic"]
pub const AICharacterEncoding_kAIArabicCharacterEncoding: AICharacterEncoding = 21;
#[doc = " Hebrew"]
pub const AICharacterEncoding_kAIHebrewCharacterEncoding: AICharacterEncoding = 22;
#[doc = " Greek"]
pub const AICharacterEncoding_kAIGreekCharacterEncoding: AICharacterEncoding = 23;
#[doc = " Cyrillic"]
pub const AICharacterEncoding_kAICyrillicCharacterEncoding: AICharacterEncoding = 24;
#[doc = " Central European Roman (also known as Eastern European Roman)"]
pub const AICharacterEncoding_kAICentralEuroRomanCharacterEncoding: AICharacterEncoding = 25;
#[doc = " Turkish"]
pub const AICharacterEncoding_kAITurkishCharacterEncoding: AICharacterEncoding = 26;
#[doc = " Baltic"]
pub const AICharacterEncoding_kAIBalticCharacterEncoding: AICharacterEncoding = 27;
#[doc = " Romanian"]
pub const AICharacterEncoding_kAIRomanianCharacterEncoding: AICharacterEncoding = 28;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIUkrainianCharacterEncoding: AICharacterEncoding = 29;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAICentralEuropeanRomanCharacterEncoding: AICharacterEncoding = 25;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIIcelandicCharacterEncoding: AICharacterEncoding = 28;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAICroatianCharacterEncoding: AICharacterEncoding = 29;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacRomanCharacterEncoding: AICharacterEncoding = 30;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinRomanCharacterEncoding: AICharacterEncoding = 31;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacArabicCharacterEncoding: AICharacterEncoding = 32;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinArabicCharacterEncoding: AICharacterEncoding = 33;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacHebrewCharacterEncoding: AICharacterEncoding = 34;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinHebrewCharacterEncoding: AICharacterEncoding = 35;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacGreekCharacterEncoding: AICharacterEncoding = 36;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinGreekCharacterEncoding: AICharacterEncoding = 37;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacCyrillicCharacterEncoding: AICharacterEncoding = 38;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinCyrillicCharacterEncoding: AICharacterEncoding = 39;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacCentralEuroRomanCharacterEncoding: AICharacterEncoding = 40;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacCentralEuropeanRomanCharacterEncoding: AICharacterEncoding = 40;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinCentralEuroRomanCharacterEncoding: AICharacterEncoding = 41;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinCentralEuropeanRomanCharacterEncoding: AICharacterEncoding = 41;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacIcelandicCharacterEncoding: AICharacterEncoding = 42;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinIcelandicCharacterEncoding: AICharacterEncoding = 43;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacTurkishCharacterEncoding: AICharacterEncoding = 44;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinTurkishCharacterEncoding: AICharacterEncoding = 45;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacCroatianCharacterEncoding: AICharacterEncoding = 46;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinCroatianCharacterEncoding: AICharacterEncoding = 47;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacRomanianCharacterEncoding: AICharacterEncoding = 48;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinRomanianCharacterEncoding: AICharacterEncoding = 49;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacUkrainianCharacterEncoding: AICharacterEncoding = 50;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinUkrainianCharacterEncoding: AICharacterEncoding = 51;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIMacBalticCharacterEncoding: AICharacterEncoding = 52;
#[doc = " Ukrainian"]
pub const AICharacterEncoding_kAIWinBalticCharacterEncoding: AICharacterEncoding = 53;
#[doc = " Japanese, JISX0213:2000 + JISX0208:1997, using Shift-JIS"]
pub const AICharacterEncoding_kAIJapaneseX0213CharacterEncoding: AICharacterEncoding = 256;
#[doc = " Chinese, GB 18030-2000"]
pub const AICharacterEncoding_kAIChineseGB18030CharacterEncoding: AICharacterEncoding = 257;
#[doc = " Chinese, HKSCS"]
pub const AICharacterEncoding_kAIChineseHKSCSCharacterEncoding: AICharacterEncoding = 258;
#[doc = " SymbolEnCoding"]
pub const AICharacterEncoding_kAISymbolCharacterEncoding: AICharacterEncoding = 259;
#[doc = " SymbolEnCoding"]
pub const AICharacterEncoding_kAIDummyCharacterEncoding: AICharacterEncoding = 4294967295;
#[doc = " Constant values for the various character encodings supported by this suite.\nThe character sets for the specific language encodings (Roman, Japanese, and so on)\nare\tplatform specific. The character sets for the specific East Asian encodings\n(GB, JISX0213, and so on) are standard.\nSee \\c #AICharacterEncodingSuite::ConvertBuffer()."]
pub type AICharacterEncoding = ::std::os::raw::c_uint;
#[doc = "  Shift-JIS"]
pub const AIJapaneseEncoding_kAISJISEncoding: AIJapaneseEncoding = 0;
#[doc = " JISX0208:1997"]
pub const AIJapaneseEncoding_kAIJISEncoding: AIJapaneseEncoding = 1;
#[doc = " Kuten"]
pub const AIJapaneseEncoding_kAIKutenEncoding: AIJapaneseEncoding = 2;
#[doc = " Kuten"]
pub const AIJapaneseEncoding_kAIDummyJapaneseEncoding: AIJapaneseEncoding = 4294967295;
#[doc = " Constant values for ways to encode characters in the JIS character set.\nSee \\c #AICharacterEncodingSuite::ConvertJapaneseChar()."]
pub type AIJapaneseEncoding = ::std::os::raw::c_uint;
#[doc = "\t@ingroup Suites\nThe character encoding suite provides facilities for translating between different\nencodings of textual data. See also \\c ai::EncodedString, which provides a C++ class\nfor translating between platform encoding, UTF8, and UTF16.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAICharacterEncodingSuite and \\c #kAICharacterEncodingVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICharacterEncodingSuite {
    #[doc = " Converts text from one encoding to another.\n\nUnicode 3 values are always used as the intermediate representation\nduring the translation between the source and the destination encodings.\nByte order of UTF16 Unicode values are dictated by the current platform\n(big-endian in Mac OS, little-endian in Windows).\n\nIf some characters do not map exactly, a loose or fallback mapping is used.\nIf some characters cannot be mapped, the source characters are dropped from\nthe destination buffer.\n@param srcBuffer The buffer containing the text.\n@param srcBytes The number of bytes in \\c srcBuffer.\n@param srcEncoding The encoding used by the text in \\c srcBuffer.\n@param dstBuffer [out] A buffer in which to return the converted text.\n@param dstBytes The number of bytes in \\c dstBuffer.\n@param dstEncoding The encoding to which to convert the text.\n@param dstLength [out] A buffer in which to return the number of bytes\nwritten to \\c dstBuffer.\n@param errIfCantMap When true, return error codes when characters do not\nmap exactly."]
    pub ConvertBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            srcBuffer: *const ::std::os::raw::c_void,
            srcBytes: usize,
            srcEncoding: AICharacterEncoding,
            dstBuffer: *mut ::std::os::raw::c_void,
            dstBytes: usize,
            dstEncoding: AICharacterEncoding,
            dstLength: *mut usize,
            errIfCantMap: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Converts a Japanese character  from one Japanese encoding to another.\n@param srcEncoding The encoding currently used for \\c ch.\n@param dstEncoding The encoding to which to convert the character.\n@param ch [in, out] A pointer to the Japanese character, represented as an unsigned short.\n@return The error \\c #kBadParameterErr if \\c ch is not within a valid range for \\c srcEncoding.\n<br> The error \\c #kBadParameterErr if \\c ch is a single-byte Shift-JIS character\n(used to represent ASCII and half-width katakana characters). Such characters cannot be\nconverted to JIS X 0208 or Kuten."]
    pub ConvertJapaneseChar: ::std::option::Option<
        unsafe extern "C" fn(
            srcEncoding: AIJapaneseEncoding,
            dstEncoding: AIJapaneseEncoding,
            ch: *mut ai_uint16,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a given Unicode (UTF16) character is categorized as a punctuation\ncharacter. Only supports characters in the BMP (Basic Multilingual Plane).\n(Note that this function returns a Boolean value, not an error code)\n@param inChar The character.\n@return True if the character is punctuation."]
    pub IsPunct: ::std::option::Option<unsafe extern "C" fn(inChar: ASUnicode) -> AIBool8>,
    #[doc = " Reports whether a given Unicode (UTF16) character is categorized as a spacing\ncharacter. Only supports characters in the BMP (Basic Multilingual Plane).\n(Note that this function returns a Boolean value, not an error code)\n@param inChar The character.\n@return True if the character is spacing."]
    pub IsSpace: ::std::option::Option<unsafe extern "C" fn(inChar: ASUnicode) -> AIBool8>,
    #[doc = " Finds the preferred encoding for a given Unicode String.\n@param inUnicodeText The Unicode String.\n@param inDefaultEncoding The default encoding\n@param outMBCSEncoding [out] A buffer in which to return the most suitable encoding."]
    pub GetCheckedPreferredEncoding: ::std::option::Option<
        unsafe extern "C" fn(
            inUnicodeText: *const ASUnicode,
            inDefaultEncoding: AICharacterEncoding,
            outMBCSEncoding: *mut AICharacterEncoding,
        ) -> AIErr,
    >,
}
#[doc = " @file IAIUnicodeString.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAIUnicodeStringImpl {
    _unused: [u8; 0],
}
pub const AIDrawingMode_kAIDrawNormalMode: AIDrawingMode = 0;
pub const AIDrawingMode_kAIDrawBehindMode: AIDrawingMode = 1;
pub const AIDrawingMode_kAIDrawInsideMode: AIDrawingMode = 2;
#[doc = " Type constants for drawing modes."]
pub type AIDrawingMode = ::std::os::raw::c_uint;
#[doc = " Special type never returned as an art object type, but used\nas a parameter to the Matching Art suite function \\c #AIMatchingArtSuite::GetMatchingArt()."]
pub const AIArtType_kAnyArt: AIArtType = -1;
#[doc = " Reserved for objects that are not supported in the plug-in interface.\nYou should anticipate unknown art objects and ignore them gracefully.\nIf a plug-in written for an earlier version of the plug-in API calls\n\\c #AIArtSuite::GetArtType() with an art object of a type unknown in its version,\nthe function maps the type to either an appropriate type or to \\c kUnknownArt."]
pub const AIArtType_kUnknownArt: AIArtType = 0;
#[doc = "  Art group"]
pub const AIArtType_kGroupArt: AIArtType = 1;
#[doc = "  Path art"]
pub const AIArtType_kPathArt: AIArtType = 2;
#[doc = "  Compound path art"]
pub const AIArtType_kCompoundPathArt: AIArtType = 3;
#[doc = " Pre-AI11 text art type; no longer supported but remains as a place holder so\nthat the values for other art types remain the same."]
pub const AIArtType_kTextArtUnsupported: AIArtType = 4;
#[doc = " Pre-AI11 text art type; no longer supported but remains as a place holder so\nthat the values for other art types remain the same."]
pub const AIArtType_kTextPathArtUnsupported: AIArtType = 5;
#[doc = " Pre-AI11 text art type; no longer supported but remains as a place holder so\nthat the values for other art types remain the same."]
pub const AIArtType_kTextRunArtUnsupported: AIArtType = 6;
#[doc = "  Placed art"]
pub const AIArtType_kPlacedArt: AIArtType = 7;
#[doc = " Never returned as an art object type, it is\nan obsolete parameter to \\c #AIMatchingArtSuite::GetMatchingArt().\nIt was used to match paths inside text objects without matching the text objects themselves.\nIn AI11 and later, use the \\c kMatchTextPaths flag to return text paths."]
pub const AIArtType_kMysteryPathArt: AIArtType = 8;
#[doc = "  Raster art"]
pub const AIArtType_kRasterArt: AIArtType = 9;
#[doc = "  Plug-in art"]
pub const AIArtType_kPluginArt: AIArtType = 10;
#[doc = "  Mesh art"]
pub const AIArtType_kMeshArt: AIArtType = 11;
#[doc = "  Text Frame art"]
pub const AIArtType_kTextFrameArt: AIArtType = 12;
#[doc = "  Symbol art"]
pub const AIArtType_kSymbolArt: AIArtType = 13;
#[doc = " A foreign object, which is a \"black box\" containing drawing commands, constructed with\n\\c #AIForeignObjectSuite::New() rather than \\c #AIArtSuite::NewArt()."]
pub const AIArtType_kForeignArt: AIArtType = 14;
#[doc = " A text object read from a legacy file (AI10 or earlier)"]
pub const AIArtType_kLegacyTextArt: AIArtType = 15;
#[doc = " Chart Art (Deprecated)"]
pub const AIArtType_kChartArt: AIArtType = 16;
#[doc = " Radial Repeat Art"]
pub const AIArtType_kRadialRepeatArt: AIArtType = 17;
#[doc = " Grid Repeat Art"]
pub const AIArtType_kGridRepeatArt: AIArtType = 18;
#[doc = " Symmetry Art"]
pub const AIArtType_kSymmetryArt: AIArtType = 19;
#[doc = " Concentric Repeat Art"]
pub const AIArtType_kConcentricRepeatArt: AIArtType = 20;
#[doc = " Concentric Repeat Art"]
pub const AIArtType_kLastArtType: AIArtType = 20;
#[doc = " Type constants for art objects. Some values are only for use in matching and are never\nreturned from \\c #AIArtSuite::GetArtType()."]
pub type AIArtType = ::std::os::raw::c_int;
#[doc = " null value"]
pub const AIArtOrder_kUnknownOrder: AIArtOrder = 0;
#[doc = " art1 is before art2"]
pub const AIArtOrder_kFirstBeforeSecond: AIArtOrder = 1;
#[doc = " art2 is after art1 (an alias for \\c kFirstBeforeSecond)."]
pub const AIArtOrder_kSecondAfterFirst: AIArtOrder = 1;
#[doc = " art1 is after art2"]
pub const AIArtOrder_kFirstAfterSecond: AIArtOrder = 2;
#[doc = " art2 is before art1 (an alias for \\c kFirstAfterSecond)."]
pub const AIArtOrder_kSecondBeforeFirst: AIArtOrder = 2;
#[doc = " art1 is contained in art2"]
pub const AIArtOrder_kFirstInsideSecond: AIArtOrder = 3;
#[doc = " art2 is contained in art1"]
pub const AIArtOrder_kSecondInsideFirst: AIArtOrder = 4;
#[doc = " Return values from \\c #AIArtSuite::GetArtOrder(). The order in which art objects\nare encountered in a \\c #AIArtSuite::GetArtSibling() tree traversal.\n\"Before\" means above or in front in the paint order,\nand \"After\" means behind or below in the paint order."]
pub type AIArtOrder = ::std::os::raw::c_uint;
#[doc = " Object is selected; see also \\c kArtFullySelected."]
pub const AIArtUserAttr_kArtSelected: AIArtUserAttr = 1;
#[doc = " Object is locked"]
pub const AIArtUserAttr_kArtLocked: AIArtUserAttr = 2;
#[doc = " Object is hidden"]
pub const AIArtUserAttr_kArtHidden: AIArtUserAttr = 4;
#[doc = " AI7 and later, distinguishes a container, such as a text path, that is fully selected from one\nwhere some contained parts are selected, but the container is not - for example, the path is\nselected but the text is not. In both cases, \\c kArtSelected is on for both the container and the\ncontained object, but if the text is not selected, this flag is off for the container.\nPass either flag to \\c #AIArtSuite::SetArtUserAttr() to fully select any object, including a container."]
pub const AIArtUserAttr_kArtFullySelected: AIArtUserAttr = 8;
#[doc = "  The contents of the object are expanded in the layers palette; valid only for groups and plug-in groups."]
pub const AIArtUserAttr_kArtExpanded: AIArtUserAttr = 16;
#[doc = " Object is part of a targeted set; see \\c #AIArtSuite::ModifyTargetedArtSet()"]
pub const AIArtUserAttr_kArtTargeted: AIArtUserAttr = 32;
#[doc = " Object defines a clip mask; this can only be set on paths, compound paths, and\ntext frame objects, and only if the object is already contained within a clip group."]
pub const AIArtUserAttr_kArtIsClipMask: AIArtUserAttr = 4096;
#[doc = " Text wraps around the object. Cannot be set on an object that is part of compound group (returns \\c kBadParameterErr).\nSet for the ancestor compound group instead."]
pub const AIArtUserAttr_kArtIsTextWrap: AIArtUserAttr = 65536;
#[doc = " Matches only fully selected top level objects and not their children; valid only for matching."]
pub const AIArtUserAttr_kArtSelectedTopLevelGroups: AIArtUserAttr = 64;
#[doc = " Matches only leaf selected objects and not their containers; valid only for matching; see also \\c kArtSelectedTopLevelGroups"]
pub const AIArtUserAttr_kArtSelectedLeaves: AIArtUserAttr = 128;
#[doc = " Matches only top level selected objects that have a stroke or fill; valid only for matching; see also \\c kArtSelectedTopLevelGroups"]
pub const AIArtUserAttr_kArtSelectedTopLevelWithPaint: AIArtUserAttr = 256;
#[doc = " Object has a simple style.\nValid only for \\c #AIArtSuite::GetArtUserAttr() and \\c #AIMatchingArtSuite::GetMatchingArt().\nCauses an error in \\c #AIArtSuite::SetArtUserAttr()."]
pub const AIArtUserAttr_kArtHasSimpleStyle: AIArtUserAttr = 512;
#[doc = "  True if the art object has an active style.\nValid only for \\c #AIArtSuite::GetArtUserAttr() and \\c #AIMatchingArtSuite::GetMatchingArt().\nCauses an error in \\c #AIArtSuite::SetArtUserAttr()."]
pub const AIArtUserAttr_kArtHasActiveStyle: AIArtUserAttr = 1024;
#[doc = " Object is a part of a compound path.\nValid only for \\c #AIArtSuite::GetArtUserAttr() and \\c #AIMatchingArtSuite::GetMatchingArt().\nCauses an error in \\c #AIArtSuite::SetArtUserAttr()."]
pub const AIArtUserAttr_kArtPartOfCompound: AIArtUserAttr = 2048;
#[doc = " Art object dictionaries are included in the search for matching art; valid only for matching."]
pub const AIArtUserAttr_kMatchDictionaryArt: AIArtUserAttr = 8192;
#[doc = " Contents of graph objects are included in the search for matching art, valid only for matching."]
pub const AIArtUserAttr_kMatchArtInGraphs: AIArtUserAttr = 16384;
#[doc = " Result art of plug-in groups is included in the search for matching art; valid only for matching."]
pub const AIArtUserAttr_kMatchArtInResultGroups: AIArtUserAttr = 32768;
#[doc = " Defining paths of text frame objects are included in the search for matching art; valid only for matching."]
pub const AIArtUserAttr_kMatchTextPaths: AIArtUserAttr = 131072;
#[doc = " In \\c #AIArtSuite::GetArtUserAttr(), reports whether the object has an art style that is pending re-execution.\nIn \\c #AIArtSuite::SetArtUserAttr(), marks the art style dirty without making any other changes to the art\nor to the style."]
pub const AIArtUserAttr_kArtStyleIsDirty: AIArtUserAttr = 262144;
#[doc = " Neither Edit Art Nor Result art of plug-in groups is included in the search for matching art; valid only for matching."]
pub const AIArtUserAttr_kMatchArtNotIntoPluginGroups: AIArtUserAttr = 524288;
#[doc = " Contents of graph objects are included in the search for matching art, valid only for matching."]
pub const AIArtUserAttr_kMatchArtInCharts: AIArtUserAttr = 1048576;
#[doc = "  Primary arts of repeat objects are included in the search for matching art, valid only for matching."]
pub const AIArtUserAttr_kMatchArtIntoRepeats: AIArtUserAttr = 2097152;
#[doc = " State selectors for \\c #AIArtSuite::GetArtUserAttr() and \\c #AIArtSuite::SetArtUserAttr(),\nand \\c #AIMatchingArtSuite functions such as \\c #AIMatchingArtSuite::GetMatchingArt().\n\nUse for both \\c whichAttr and \\c attr parameters; for example, <code>GetArtUserAttr(object,\nkArtHidden, kArtHidden)</code>, NOT  <code>GetArtUserAttr(object, kArtHidden, true)</code>.\n\n<b>Selection notes:</b> Pass either \\c kArtSelected or \\c kArtFullySelected to\n\\c #AIArtSuite::SetArtUserAttr() to fully select an object, even if it is a container.\nTo partially select a container, select individual descendants.\nTo synchronize the container state before your plug-in returns,\ncall \\c #AIDocumentSuite::RedrawDocument. Otherwise the container\nstate is justified by Illustrator after the plug-in returns.\n\nThe selection attributes differ only for Get and Match operations, not for Set operations.\n\\li \\c kArtSelected is true for (and matches) partially selected containers, such as groups with some\nselected components, as well as partially selected paths.\n\\li \\c kArtFullySelected is true for paths only if all segments are selected, and for\ncontainer objects (groups, compound paths, text objects, and so on) only if all descendants are selected.\n\nThe functions \\c #AIMatchingArtSuite::GetSelectedArt()  and \\c #AIArtSetSuite::SelectedArtSet()\nare equivalent to using \\c kArtSelected as the attribute selector.\n\n<b>Selection while matching:</b> \\c kArtSelectedTopLevelGroups, \\c kArtSelectedLeaves, and  \\c kArtSelectedTopLevelWithPaint\nare used only with \\c #AIMatchingArtSuite::GetMatchingArt. These values cause an error in \\c #AIArtSuite::SetArtUserAttr().\nThey are mutually exclusive; you can specify only one, and they cannot be combined with other flags."]
pub type AIArtUserAttr = ::std::os::raw::c_uint;
#[doc = " Default. Includes hidden and unpainted objects if they are not guides.\nIgnores direction handles."]
pub const AIArtBoundsOptions_kVisibleBounds: AIArtBoundsOptions = 0;
#[doc = " When off, \\c kNoStrokeBounds, \\c kNoExtendedBounds and \\c kExcludeUnpaintedObjectBounds\ncan be combined to ignore certain aspects of the visual bounds."]
pub const AIArtBoundsOptions_kControlBounds: AIArtBoundsOptions = 1;
#[doc = " Strokes, effects, and other appearance attributes that may make an object extend\npast the bezier outlines are ignored."]
pub const AIArtBoundsOptions_kNoStrokeBounds: AIArtBoundsOptions = 2;
#[doc = " Implies \\c kNoStrokeBounds, but additionally excludes text characters for\ntext on a path or area text, measuring only the path."]
pub const AIArtBoundsOptions_kNoExtendedBounds: AIArtBoundsOptions = 4;
#[doc = " Use the setting of the \"Use Preview Bounds\" user preference\nto control whether the strokes and other appearance attributes are included.\nCannot be used together with \\c kNoStrokeBounds (setting both results in \\c kBadParameterErr)."]
pub const AIArtBoundsOptions_kWStrokeDependsOnPreference: AIArtBoundsOptions = 8;
#[doc = " Exclude hidden object. Can be set with \\c kControlBounds or \\c kVisibleBounds."]
pub const AIArtBoundsOptions_kExcludeHiddenObjectBounds: AIArtBoundsOptions = 16;
#[doc = " Excludes objects with no fill and no stroke."]
pub const AIArtBoundsOptions_kExcludeUnpaintedObjectBounds: AIArtBoundsOptions = 32;
#[doc = " Excludes guides. Can be set with \\c kControlBounds or \\c kVisibleBounds."]
pub const AIArtBoundsOptions_kExcludeGuideBounds: AIArtBoundsOptions = 64;
#[doc = " Flags for \\c #AIArtSuite::GetArtTransformBounds() and \\c #AIArtSuite::GetArtRotatedBounds()\n\n@note \\c #AIArtSuite::GetArtBounds() takes no flags, and has the same behavior as \\c #AIArtSuite::GetArtTransformBounds() with\na null transform and \\c kVisibleBounds|kExcludeGuideBounds. Call \\c #AIArtSuite::GetArtTransformBounds()\nwith a null transform to specify non-default flags."]
pub type AIArtBoundsOptions = ::std::os::raw::c_uint;
#[doc = " Replaces current set with the set specified in \\c list"]
pub const AIArtTargettingAction_kReplaceAction: AIArtTargettingAction = 1;
#[doc = " Appends the set specified in \\c list to current set"]
pub const AIArtTargettingAction_kAppendAction: AIArtTargettingAction = 2;
#[doc = " Removes the set specified in \\c list from the current set"]
pub const AIArtTargettingAction_kRemoveAction: AIArtTargettingAction = 3;
#[doc = " Moves targeting up one level (ignores \\c list and \\c count)"]
pub const AIArtTargettingAction_kUpAction: AIArtTargettingAction = 4;
#[doc = " Moves targeting down one level (ignores \\c list and \\c count)"]
pub const AIArtTargettingAction_kDownAction: AIArtTargettingAction = 5;
#[doc = " Moves targeting down to leaf level (ignores \\c list and \\c count)"]
pub const AIArtTargettingAction_kDownToLeafAction: AIArtTargettingAction = 6;
#[doc = " Moves targeting up to layer level (ignores \\c list and \\c count)"]
pub const AIArtTargettingAction_kUpToLayersAction: AIArtTargettingAction = 7;
#[doc = " The values for the \\c action parameter of \\c #AIArtSuite::ModifyTargetedArtSet().\nDetermines what action is taken to modify the current object set."]
pub type AIArtTargettingAction = ::std::os::raw::c_uint;
#[doc = " Transfer the unique ID, which is the name."]
pub const AIArtTransferAttrsOptions_kTransferID: AIArtTransferAttrsOptions = 1;
#[doc = " Transfer the style of the object."]
pub const AIArtTransferAttrsOptions_kTransferStyle: AIArtTransferAttrsOptions = 2;
#[doc = " Transfer the opacity mask of the object. #AIArtSuite::TransferAttributes(),\nwhen called with this option, will not remove the destination art's opacity mask\nif the source art does not have opacity mask."]
pub const AIArtTransferAttrsOptions_kTransferOpacityMask: AIArtTransferAttrsOptions = 4;
#[doc = " Transfer the text wrap properties--whether or not the object is a text\nwrap object together with the wrap offset and invert properties."]
pub const AIArtTransferAttrsOptions_kTransferTextWrapProperties: AIArtTransferAttrsOptions = 8;
#[doc = " Transfer the compound shape mode used to combine the object geometry with\nothers when it is a part of a compound shape."]
pub const AIArtTransferAttrsOptions_kTransferCompoundShapeMode: AIArtTransferAttrsOptions = 16;
#[doc = " Transfer saved selections. This is information that describes the\nselection state for the object when a named selection is chosen from\nthe \"Select\" menu. The information is a map from selection IDs to the\ncorresponding selection state for the object. The selection state\ninformation can include information about specific parts of the object\nthat are selected. This is not meaningful if the target object\nis not an identical copy of the original, but the function does not\nattempt to determine or deal with that case."]
pub const AIArtTransferAttrsOptions_kTransferSavedSelections: AIArtTransferAttrsOptions = 32;
#[doc = " Transfer slicing attributes, which define properties\nfor exporting the object as a slice forming part of an HTML file; see\nthe \\c #AISlicingSuite."]
pub const AIArtTransferAttrsOptions_kTransferSlicingAttributes: AIArtTransferAttrsOptions = 64;
#[doc = " Transfer the locked attribute; see \\c #AIArtUserAttr."]
pub const AIArtTransferAttrsOptions_kTransferArtLocked: AIArtTransferAttrsOptions = 128;
#[doc = " Transfer the hidden attribute; see \\c #AIArtUserAttr."]
pub const AIArtTransferAttrsOptions_kTransferArtHidden: AIArtTransferAttrsOptions = 256;
#[doc = " Transfer information imported from and exported to SVG files, which\nincludes the SVG interactivity attributes."]
pub const AIArtTransferAttrsOptions_kTransferSVGProperties: AIArtTransferAttrsOptions = 512;
#[doc = " Transfer tags that Live Paint uses to identify paths as being the \"same\".\nUse if one path or set of paths should replace an existing path (to distort\nit or scissor it, for example). Ignored if the destination art\nis not the same object type as the source art; for example, when the\ndestination art is a group that expands the styled art of a path."]
pub const AIArtTransferAttrsOptions_kTransferLivePaintPathTags: AIArtTransferAttrsOptions = 1024;
#[doc = " Transfers the Pixel Perfect property that makes an object align to pixel boundary.\nUse when you want to retain the pixel perfect property of the source art object\nin the destination art object."]
pub const AIArtTransferAttrsOptions_kTransferPixelPerfectAttribute: AIArtTransferAttrsOptions =
    2048;
#[doc = " Transfers live shape related information.\nTransferring these attributes does not guarantee that the destination object will\nbe a live shape, it must fulfill shape-specific geometric constraints also."]
pub const AIArtTransferAttrsOptions_kTransferLiveShapeProperties: AIArtTransferAttrsOptions = 4096;
#[doc = " Transfer all object attributes. This causes all properties\nassociated with the object in the current Illustrator version to be\ntransferred, regardless of the API version a plug-in is built against."]
pub const AIArtTransferAttrsOptions_kTransferAll: AIArtTransferAttrsOptions = 4294967295;
#[doc = " Flags that specify which attributes are transferred\nby \\c #AIArtSuite::TransferAttributes(). These are the attributes that are common to\nall art objects."]
pub type AIArtTransferAttrsOptions = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AICopyScopeOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque handle to a copy scope."]
pub type AICopyScopeHandle = *mut _t_AICopyScopeOpaque;
#[doc = " Groups together a sequence of copy operations that corresponds to\nduplication of the copied objects within a single document."]
pub const AICopyScopeKind_kAICopyScopeForDuplicate: AICopyScopeKind = 0;
#[doc = " Groups together a sequence of calls to \\c #AIPathStyleSuite::RetargetForCurrentDoc().\nThis is needed so that any decisions made about how to handle conflicts between\nglobal objects in the source and destination documents can apply to the entire set\nof objects being retargeted. For example, when there are global color name conflicts\nand the user chooses to apply their choice for handling one conflict (add or merge)\nto all future conflicts."]
pub const AICopyScopeKind_kAICopyScopeForRetarget: AICopyScopeKind = 1;
#[doc = " null value"]
pub const AICopyScopeKind_kDummyScopeKind: AICopyScopeKind = 4294967295;
#[doc = " The type of scope to create using \\c #AIArtSuite::CreateCopyScope()."]
pub type AICopyScopeKind = ::std::os::raw::c_uint;
pub const AIPathPolarity_kAIPolarPath: AIPathPolarity = 0;
pub const AIPathPolarity_kAINonPolarPath: AIPathPolarity = 1;
pub type AIPathPolarity = ::std::os::raw::c_uint;
pub const AIArtTimeStampOptions_kAITimeStampOfArt: AIArtTimeStampOptions = 1;
pub const AIArtTimeStampOptions_kAITimeStampOfChildren: AIArtTimeStampOptions = 2;
pub const AIArtTimeStampOptions_kAITimeStampMaxFromArtAndChildren: AIArtTimeStampOptions = 4;
pub const AIArtTimeStampOptions_kAITimeStampOfDescendents: AIArtTimeStampOptions = 8;
pub const AIArtTimeStampOptions_kAINonRenderTimeStamp: AIArtTimeStampOptions = 16;
pub type AIArtTimeStampOptions = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite allows you to access and modify the artwork in Illustrator documents.\nIt provides functions to create and delete objects,\trearrange objects, and get\nand set information about objects. You use these functions to navigate the tree\nof art objects, and to retrieve or modify generic information about art objects,\nsuch as their bounds or lock status.\n\nThe Art suite is fundamental to implementing most plug-ins. An Illustrator document\nconsists of a collection of art objects referenced by an \\c #AIArtHandle. This\nis an opaque pointer to an art object in the document's artwork database. Access\nthe fields through the Art suite's accessor functions.\n\nAn art object can represent an individual entity, such as a path, block of text or\nplaced image, or a group of objects, such as a collection of paths.\nThe art type identifier (\\c #AIArtType) indicates the type of an art object.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArtSuite and \\c #kAIArtVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtSuite {
    #[doc = " Creates a new art object.\nThis can fail if the layer is locked or hidden. Otherwise, the object is inserted into the\npaint order with respect another art object. For example, this creates \\c new_art above \\c old_art in the paint order.\n@code\nAIArtHandle new_art;\nerror = sArt->NewArt(kPathArt, kPlaceAbove, old_art, &new_art);\n@endcode\nThis places \\c new_art in the specified \\c group above all other objects in the group.\n@code\nerror = sArt->NewArt(kPathArt, kPlaceInsideOnTop, group, &new_art);\n@endcode\nThis places \\c new_art on top of all artwork in the document.\n@code\nerror = sArt->NewArt(kPathArt, kPlaceAboveAll, nullptr, &new_art);\n@endcode\n\n@param type The art type. See \\c ::AIArtType.\nIf the new object type is a path then it is typically given the path style that would be assigned\nto a path created by a tool (for example, the pen tool). Tool plug-ins can depend on this.\nPlug-ins that are not tools should make no assumptions about the style assigned to paths.\n@param paintOrder The paint order position, relative to the \\c prep object, an \\c #AITypes::AIPaintOrder value.\n@param prep The prepositional art object. This can be an object whose boundaries might overlap this one,\nor a compound path or group that might contain this path.\n@param newArt [out] A buffer in which to return the new art object.\n\n@note Change in AI 11.0: If the art is being created during the execution of an effect,\nand \\c prep is styled art, the new art has a path style with a black fill and no stroke.\nThis prevents effect executions from accidentally using the current path style"]
    pub NewArt: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ai_int16,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Removes an art object from the document. If it is a group or compound path,\nalso removes its children.\n@param art The art object. After the call, this reference is no longer valid."]
    pub DisposeArt: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Changes the paint order of an art object, or moves a path in or out of a compound path or group.\n\n@param art The art object.\n@param paintOrder The paint order, relative to the \\c prep object, an \\c #AITypes::AIPaintOrder value.\n@param prep The prepositional art object for the paint order."]
    pub ReorderArt: ::std::option::Option<
        unsafe extern "C" fn(
            thisArt: AIArtHandle,
            paintOrder: ai_int16,
            prep: AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Duplicates an art object with a deep copy (children of groups and compound paths are also duplicated).\nThe copied objects have the same coordinates as the original, so you must do a deep move on them.\n@param art The art object.\n@param paintOrder The paint order, relative to the \\c prep object. See \\c AITypes::AIPaintOrder.\n@param prep The prepositional art object for the paint order.\n@param newArt [out] A buffer in which to return the new art object."]
    pub DuplicateArt: ::std::option::Option<
        unsafe extern "C" fn(
            thisArt: AIArtHandle,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the first art object in a layer, which is the group that contains all of the art in that layer.\nYou can use this to traverse the art objects contained in the layer.\n@param layer The layer. Use \\c nullptr for the current layer. See \\c #AILayerSuite\n@param art [out] A buffer in which to return the new art object.\n@see  \\c #GetArtFirstChild(), \\c #GetArtParent(), \\c #GetArtSibling(), \\c #GetArtPriorSibling()"]
    pub GetFirstArtOfLayer: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves an art object's parent layer, if any.\nThis function is useful with \\c #AIMatchingArtSuite::GetSelectedArt() and \\c #AIMatchingArtSuite::GetMatchingArt(),\nwhich give you a list of art objects. For example, if your filter gets all of the selected objects and\ncreates a path on top of each layer with objects on it, you would need to know the layer of the objects\nin order to place the new path on top:\n@code\nAILayerHandle layer;\nAIArtHandle group, new_path;\nerror = sArt->GetLayerOfArt(art, &layer);\nerror = sArt->GetFirstArtOfLayer(layer, &group);\nerror = sArt->NewArt(kPathArt, kPlaceInsideOnTop, group, &new_path);\n@endcode\n@param art The art object.\n@param layer [out] A buffer in which to return the layer object. See \\c #AILayerSuite\n\n@note Art that is stored in a dictionary or an array is not considered to be on a layer even though\nthe dictionary may belong to an art object that is on a layer."]
    pub GetLayerOfArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, layer: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the type of an art object.\nBefore you begin manipulating an object's type-specific attributes you need to know\nwhat kind of art object it is. For example, you can call path functions if the art\nis a path, or text functions if it is text.\n@code\nshort type;\nerror = sArt->GetArtType(art, &type);\nif (error)\nreturn error;\nswitch (type) {\ncase kGroupArt:\n...\n}\n@endcode\n\n@param art The art object.\n@param type [out] A buffer in which to return the type, an \\c #AIArtType constant."]
    pub GetArtType: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, type_: *mut ::std::os::raw::c_short) -> AIErr,
    >,
    #[doc = " Retrieves user attributes of an art object; that is, flags that show whether it is selected, hidden, or locked.\nThe user attributes of an object do not directly affect the geometry or printing of the artwork.\nThey are temporary and primarily used while the user is editing the document.\nAn art object must be unlocked before making changes to it through the API.\nUnlocking and locking should therefore be the first and last things done to an object.\nAn object cannot be selected if it is hidden or locked.\nBecause most filters operate on the current selection, it is not usually not necessary to unlock objects.\n\n<br>Example:\n@code\nlong attr;\nerror = sArt->GetArtUserAttr(art, kArtLocked | kArtHidden, &attributes);\nif (error) return error;\nif (!(attributes & kArtLocked) || !(attributes & kArtHidden)) {\nerror = sArt->SetArtUserAttr(art, kArtSelected, kArtSelected);\nif (error) return error;\n}\n@endcode\n@param art The art object.\n@param whichAttr  A mask for the attributes of interest, a logical OR of \\c #AIArtType constant values.\n@param attr [out] A buffer in which to return the type, a logical OR of \\c #AIArtType constant values, masked by \\c whichAttr.\n(Note that this is NOT boolean).\n@see \\c #GetArtTextWrapProperty(), \\c #SetArtTextWrapProperty()\n"]
    pub GetArtUserAttr: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, whichAttr: ai_int32, attr: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets user attributes of an object; that is, flags that show whether it is selected, hidden, or locked.\nChanging the selection state of an object is considered by the plug-in interface to be a\nmodification to the document; that is, the document is marked dirty and needs to be saved.\n<br>Example:\n@code\n// unlocks the object\nerror = sArt->SetArtUserAttr(art, kArtLocked, 0);\n// locks the object\nerror = sArt->SetArtUserAttr(art, kArtLocked, kArtLocked);\n@endcode\n@param art The art object.\n@param whichAttr  A mask for the attributes of interest, a logical OR of \\c #AIArtType constant values.\n@param attr The new attribute value, a logical OR of \\c #AIArtType constant values, masked by \\c whichAttr.\n(Note that this is NOT boolean).\n@see \\c #GetArtTextWrapProperty(), \\c #SetArtTextWrapProperty()"]
    pub SetArtUserAttr: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, whichAttr: ai_int32, attr: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the parent group of an art object. This example shows a non-recursive tree walk:\n@code\n...\n// see if parent has sibling\nerror = sArt->GetArtParent(nextart, &nextart);\nif (error) return error;\nerror = sArt->GetArtSibling(nextart, &nextart);\nif (error) return error;\nif (nextart) {  // parent has sibling\n...\n}\n@endcode\n@param art The art object.\n@param parent [out] A buffer in which to return the parent object, or a null object if\nthe specified art object is the topmost group of its layer,\nor the topmost object in a container such as a dictionary or array.\\"]
    pub GetArtParent: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, parent: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = "\tRetrieves the first child of a group object. For example:\n@code\nAIArtHandle child;\n...\nerror = sArt->GetArtType(art, &type);\nif (error) return error;\nswitch (type) {\ncase kGroupArt:\nerror = sArt->GetArtFirstChild(art, &child);\nif (error) return error;\nerror = doArtAndSiblings(message, child);\nif (error) return error;\nbreak;\n...\n@endcode\n@param art The art object.\n@param child [out] A buffer in which to return the child object, or a null object if\nthe specified art object is not a container such as a group, a graph, or a text frame,\nor is an empty container."]
    pub GetArtFirstChild: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, child: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the next object in the same group. This is the opposite of \\c #GetArtPriorSibling().\nUse with \\c #GetArtFirstChild() and \\c #GetArtParent() to look at\nall of the objects in a container. For example:\n@code\n...\n// see if parent has sibling\nerror = sArt->GetArtParent(nextart, &nextart);\nif (error) return error;\nerror = sArt->GetArtSibling(nextart, &nextart);\nif (error) return error;\nif (nextart) {    // parent has sibling\n...\n}\n@endcode\n@param art The art object.\n@param sibling [out] A buffer in which to return the sibling object, or a null object if\nthe specified art object is the last child in its container."]
    pub GetArtSibling: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, sibling: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the previous object in the same group. This is the opposite of \\c #GetArtSibling().\n<br>Example:\n@code\n// get the previous art\nerror = sArt->GetArtPriorSibling(art, &art);\nif (error) return error;\nif (!art){\n// art was first in group\n// see if parent has previous art\nerror = sArt->GetArtParent(art, &art);\nif (error) return error;\n...\n@endcode\n@param art The art object.\n@param sibling [out] A buffer in which to return the sibling objector a null object if\nthe specified art object is the first child in its container."]
    pub GetArtPriorSibling: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, sibling: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the enclosing rectangle of an art object.\n@param art The art object.\n@param bounds [out] A buffer in which to return the value.\n@note This function has the same behavior as \\c #GetArtTransformBounds() with\na null transform and \\c kVisibleBounds|kExcludeGuideBounds.\nCall \\c #GetArtTransformBounds() with a null transform to\nspecify non-default flags."]
    pub GetArtBounds: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, bounds: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Updates cached information for the enclosing rectangle (bounding box)\nof an art object.\n@param art The art object."]
    pub SetArtBounds: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Checks whether the center point of an art object is visible.\nThis option can be set by the user using the Attributes dialog.\n<br> Example:\n@code\nerror = sArt->GetArtCenterPointVisible (art, &visible);\nif (error) return error;\nif (!visible) {\n// its not visible so we do something based on that fact\n...\n@endcode\n@param art The art object.\n@param visible [out] A buffer in which to return the value, true if the center point is visible."]
    pub GetArtCenterPointVisible: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, visible: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Makes the center point of an art object visible or invisible when the object is selected.\n@param art The art object.\n@param visible True to make the center point visible, false to make it invisible."]
    pub SetArtCenterPointVisible:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, visible: AIBoolean) -> AIErr>,
    #[doc = " Retrieves the geometric bounds of an art object after applying a transformation matrix.\nReturns single-precision coordinates.\n@param art The art object.\n@param transform A pointer to a transformation matrix to apply.\nCan be \\c NULL to indicate the identity matrix. You cannot use a non-null matrix\nif the \\c #kControlBounds option is set in \\c flags.\n@param flags Bit flags that specify which bounds to return. A logical OR of \\c #AIArtBoundsOptions constants.\nThe flags must include either \\c kVisibleBounds or \\c kControlBounds,\nand can include additional flags depending on which of these is included.\n@param bounds [out] A buffer in which to return the bounds value containing single-precision coordinates.\n@see \\c #GetPreciseArtTransformBounds(), \\c #GetArtRotatedBounds()"]
    pub GetArtTransformBounds: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            transform: *mut AIRealMatrix,
            flags: ai_int32,
            bounds: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Checks whether any linked objects (linked images or placed objects)\ncontained in the subtree of a given container need updating, and updates them if needed.\nA linked object needs updating if its file has been modified since the contents were\nlast read.\n\n@param art The art object.\n@param force When true, objects are updated regardless of whether they have changed.\n@param updated [out] Optional, a buffer in which the output as to return true if any objects were updated."]
    pub UpdateArtworkLink: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, force: AIBoolean, updated: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Returns true if an art object reference is valid.\n(Note that the function returns a boolean value, not an error code.)\nA reference can test as invalid and still refer to an object that exists in the document,\nif that object is not found in the searched layer.\n@param art The art object.\n@param searchAllLayerLists When true, searches through all layers in\nall layer lists. Otherwise, searches only the current layer list."]
    pub ValidArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, searchAllLayerLists: AIBoolean) -> AIBoolean,
    >,
    #[doc = " Get the paint order or containment relation of  two art objects.\nThis function reflects the order in which the objects are encountered\nin a \\c #GetArtSibling() tree traversal. \"Before\" means above\nor in front in the paint order, and \"After\" means behind or below in the paint order.\n@param art1 The first art object.\n@param art2 The second art object.\n@param order [out] A buffer in which to return the result.\nSee \\c #AIArtOrder for the possible ordering values."]
    pub GetArtOrder: ::std::option::Option<
        unsafe extern "C" fn(
            art1: AIArtHandle,
            art2: AIArtHandle,
            order: *mut ::std::os::raw::c_short,
        ) -> AIErr,
    >,
    #[doc = " Selects specified artwork of a layer by matching a string to the contents\nof art object notes. You can select multiple art objects by specifying a partial\nstring and a matching style.\n@param layer The layer object. See \\c #AILayerSuite.\n@param name A string to match to the note contents of art objects in the layer.\nIf the empty string, matches all leaf objects without notes.\n@param matchWholeWord When true, an art object is selected if its note contents\nexactly matches the \\c name string.\nWhen false, an art object is selected if any part of its note contents\nmatches the \\c name string.\n@param caseSensitive When true, perform case-sensitive matching. When false, ignore case."]
    pub SelectNamedArtOfLayer: ::std::option::Option<
        unsafe extern "C" fn(
            layer: AILayerHandle,
            name: *const ai_UnicodeString,
            matchWholeWord: AIBoolean,
            caseSensitive: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the enclosing rectangle of an art object after rotation.\nThis is the same as \\c #GetArtTransformBounds(), except that the\ntransformation is specified by a rotation angle rather than a matrix.\n@param art The art object.\n@param angle The rotation angle in radians.\n@param flags Option flags for which bounds to return.\nA logical OR of \\c #AIArtBoundsOptions constant values.\n@param bounds [out] A buffer in which to return the value."]
    pub GetArtRotatedBounds: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            angle: AIReal,
            flags: ai_int32,
            bounds: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Returns true if an art object or a descendent object draws something that\nshould be considered a fill. The distinguishing property of a fill is that\nit is drawn behind all other objects when applied to an object that is part\nof a clipping mask. (Note that the function returns a boolean value, not an error code.)\n@param art The art object.\n@return True if the object or a descendant has fill."]
    pub ArtHasFill: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Returns true if an art object or a descendent object draws something that\nshould be considered a stroke. The distinguishing property of a stroke is that\nit is drawn in front of all other objects when applied to an object that is part\nof a clipping mask.\n(Note that the function returns a boolean value, not an error code.)\n@param art The art object.\n@return True if the object or a descendant has stroke."]
    pub ArtHasStroke: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Returns true if two art objects contain nothing other than groups, paths and\ncompound paths and they have identical geometry (control points). The path styles\nand other appearance attributes may be different.\n(Note that the function returns a boolean value, not an error code.)\n@param art1 The first art object.\n@param art2 The second art object.\n@return True if the objects have equal paths.\n@see also \\c #ObjectsAreEquivalent"]
    pub ArtsHaveEqualPaths: ::std::option::Option<
        unsafe extern "C" fn(art1: AIArtHandle, art2: AIArtHandle) -> AIBoolean,
    >,
    #[doc = " Not implemented in AI11 and later; returns \\c kNotImplementedErr."]
    pub ArtCopyFillStyleIfEqualPaths: ::std::option::Option<
        unsafe extern "C" fn(dstArt: AIArtHandle, srcArt: AIArtHandle) -> AIErr,
    >,
    #[doc = " Not implemented in AI11 and later; returns \\c kNotImplementedErr."]
    pub ArtCopyStrokeStyleIfEqualPaths: ::std::option::Option<
        unsafe extern "C" fn(dstArt: AIArtHandle, srcArt: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the insertion point for a document.\nThis is the position in the art tree at which a drawing tool should create new art.\n\n@param art The art object.\n@param paintorder The position in the paint order, relative to the specified art object.\nSee \\c #AITypes::AIPaintOrder for the possible positions.\n@param editable [out] A buffer in which to return the output as true if it is possible to create art\nat the returned position. For example, you cannot create art in a locked layer.\nPass null if not needed."]
    pub GetInsertionPoint: ::std::option::Option<
        unsafe extern "C" fn(
            art: *mut AIArtHandle,
            paintorder: *mut ::std::os::raw::c_short,
            editable: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the insertion point in a document.\nThis is the position in the art tree at which a drawing tool should create new art.\nThe new position is a paint-order position with respect to the given art object.\nSee \\c #AITypes::AIPaintOrder for details.\nIf the object is a group, the new position is \\c kPlaceInsideOnTop;\notherwise it is  \\c kPlaceAbove. If the art object is in a position where an\ninsertion point cannot be set (for example, inside a plug-in group)\nthe position is set relative to the nearest parent defining a valid insertion point.\nIf no valid insertion point can be determined, the function returns an error.\n\n@param art The art object."]
    pub SetInsertionPoint: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Retrieves the key object for object alignment. The key object is the one to which\nother objects are aligned. It is usually the object most recently clicked with the Select tool.\n@param art [out] A buffer in which to return the art object, or a null object if there is no key object."]
    pub GetKeyArt: ::std::option::Option<unsafe extern "C" fn(art: *mut AIArtHandle) -> AIErr>,
    #[doc = " Clears the key object for object alignment. The key object is the one to which\nother objects are aligned. It is usually the object that is most recently clicked using the\nSelection tool.\n@deprecated"]
    pub CancelKeyArt: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "\tRetrieves the dictionary associated with an art object. Creates a new, empty\ndictionary if one is not found.\n\nArbitrary data can be attached to an art object in its dictionary.\nSee the \\c #AIDictionarySuite.\nThe same dictionary is accessed by the \\c #AITagSuite for\nsetting and getting string values.\n\nDictionaries are reference counted. You must call \\c sAIDictionary->Release()\nwhen you no longer need the reference. It is recommended that you use the C++\n\\c #ai::Ref template class, which takes care memory management.\n@param art The art object.\n@param dictionary [out] A buffer in which to return a pointer to the dictionary reference.\n\n@note This call creates an empty dictionary if one is not found.\nTo check for the existence of an item in the art dictionary,\nfirst check that the dictionary exists and is not empty.\n@see \\c #IsDictionaryEmpty() and \\c #HasDictionary()"]
    pub GetDictionary: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, dictionary: *mut *mut _AIDictionary) -> AIErr,
    >,
    #[doc = "\tReports whether a dictionary is associated with an art object.\n(Note that the function returns a boolean value, not an error code.)\n\n@param art The art object.\n@return True if a dictionary is associated with the art object, false otherwise.\n@note If you need to check for the existence of an item in the art dictionary,\nfirst check that the dictionary exists and is not empty. Calling \\c #GetDictionary()\nwhen no dictionary exists creates an unneeded dictionary object.\n\n@see \\c #IsDictionaryEmpty() and \\c #GetDictionary()"]
    pub HasDictionary: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = "\tReports whether the dictionary associated with an art object is empty or does not exist.\n(Note that the function returns a boolean value, not an error code.)\n\n@param art The art object.\n@return True if a dictionary exists and is empty or if no dictionary exists.\nFalse if a dictionary associated with the art object contains any entries.\n@note For best performance, check for existence of a dictionary before calling \\c #GetDictionary().\nCalling  \\c #GetDictionary() when no dictionary exists creates an unneeded dictionary object.\n\n@see \\c #HasDictionary() and \\c #GetDictionary()"]
    pub IsDictionaryEmpty:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Sets the name of an art object. This is the name that appears in the Layers\npalette.\n@param art The art object.\n@param name The new name. Use the empty string to reset the name to\nthe default for the object type."]
    pub SetArtName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the name of an art object. This is the name that appears in the Layers\npalette.\n@param art The art object.\n@param name [out] A buffer in which to return the name.\n@param isDefaultName [out] A buffer in which to return the output as true if the returned name is a\ndefault descriptive name, rather than a user-assigned name. May be null."]
    pub GetArtName: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            name: *mut ai_UnicodeString,
            isDefaultName: *mut ASBoolean,
        ) -> AIErr,
    >,
    #[doc = " Reports whether an art object is a group that corresponds to a layer or a sublayer.\n@param art The art object.\n@param name [out] A buffer in which to return true if the art object is a layer group."]
    pub IsArtLayerGroup: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, isLayerGroup: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Releases elements of a layer, group, or plug-in group to separate layers.\nPlug-in groups can be inside styled art. In this case:\n\\li If the art style consists of only the plug-in group, the plug-in group is\nexpanded and the original art deleted.\n\\li If there is more than one plug-in group or other element in the styled art,\nthe specified art is left in place and the remaining styled art is left intact.\n\n@param art The art object.\n@param build When true, new layers are built upon one another such that\nthe topmost released layer contains everything in the original art and\nthe bottommost released layer contains only the highest object in the\nstacking order. This order is used because the Flash exporter takes the\nbottommost layer as the first animation frame and the topmost layer as the\nlast frame."]
    pub ReleaseToLayers:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, build: ASBoolean) -> AIErr>,
    #[doc = " Modifies the set of targeted objects in the document using a specified action.\n@param list A set of objects to be used as an additional parameter, for actions that need it.\n@param count The number of objects in \\c list.\n@param action The action to take; see \\c #AIArtTargettingAction for the possible actions."]
    pub ModifyTargetedArtSet: ::std::option::Option<
        unsafe extern "C" fn(list: *mut AIArtHandle, count: ai_int32, action: ai_int32) -> AIErr,
    >,
    #[doc = " Returns true if art is part of the styled art of another object.\n(Note that the function returns a boolean value, not an error code.)\n@param art The art object;\n@return True if the object is part of the style art of another object."]
    pub IsArtStyledArt: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Returns true if \\c art adds to clipping. (Note that the function returns\na boolean value, not an error code.) Call this function only on descendents\nof a clip group or a mask object.\n@param art The art object.\n@return True if the specified object is an appropriate art object with the\n\\c kArtIsClipMask flag set, or if it is a non-clip group with a clipping descendent\nthat is not bounded by another clip group."]
    pub IsArtClipping: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Transfers attributes from a source art object to a destination art object.\nUse, for example, when converting an art object from one type to another.\n@param srcart The art object from which to copy attributes.\n@param dstart The art object to which to copy attributes.\n@param which The attributes to transfer, a logical OR of\n\\c #AIArtTransferAttrsOptions values."]
    pub TransferAttributes: ::std::option::Option<
        unsafe extern "C" fn(srcart: AIArtHandle, dstart: AIArtHandle, which: ai_uint32) -> AIErr,
    >,
    #[doc = "\tRetrieves the last child of a container art object. Applies to container\nobjects such as groups, graphs and text frame objects.\n@param art The art object.\n@param child [out] A buffer in which to return the last child art object, or nullptr if\nthe specified art object is not a container or is an empty container."]
    pub GetArtLastChild: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, child: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Sets the properties that affect how text wraps around a text wrap object;\nthat is, one in which the \\c kArtIsTextWrap attribute is set.\nUse \\c #GetArtUserAttr() and \\c #SetArtUserAttr() to inspect and set the \\c kArtIsTextWrap attribute.\n\n@param art The art object.\n@param offset The distance in points from the geometric outline of an object\nthat defines an offset for wrapping.\n@param invert When true, text wraps inside the outline of the offset object.\nWhen false, text wraps around the outside of the offset object.\n@return \\c kBadParameterErr if the object does not have the \\c kArtIsTextWrap attribute set."]
    pub SetArtTextWrapProperty: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, offset: AIReal, invert: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the properties that affect how text wraps around a text wrap object;\nthat is, one in which the \\c kArtIsTextWrap attribute is set.\nUse  \\c #GetArtUserAttr() and \\c #SetArtUserAttr() to inspect and set the\n\\c kArtIsTextWrap attribute.\n\n@param art The art object.\n@param offset [out] A buffer in which to return the distance in points from\nthe geometric outline of an object that defines an offset for wrapping.\n@param invert [out] A buffer in which to return the output as true if text wraps inside the outline\nof the offset object, or false if text wraps around the outside of the offset object.\n@return \\c kBadParameterErr if the object does not have the \\c kArtIsTextWrap attribute set."]
    pub GetArtTextWrapProperty: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            offset: *mut AIReal,
            invert: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Creates and instates a copy scope. Scopes are reference counted. You must\nuse \\c #DestroyCopyScope to release the reference when it is no longer needed.\nIt is recommended that you use the C++ wrapper \\c #ai::CopyScope, which takes\ncare of memory management.\n\n@param kind The type of scope to create, an \\c ::AICopyScopeKind value.\n@param scope [out] A buffer in which to return the new scope reference."]
    pub CreateCopyScope: ::std::option::Option<
        unsafe extern "C" fn(kind: AICopyScopeKind, scope: *mut AICopyScopeHandle) -> AIErr,
    >,
    #[doc = " Uninstates and destroys a copy scope. It is recommended that you use the\nC++ wrapper \\c #ai::CopyScope, which takes care of memory management.\n@param scope The scope reference, as returned by \\c #CreateCopyScope()."]
    pub DestroyCopyScope:
        ::std::option::Option<unsafe extern "C" fn(scope: AICopyScopeHandle) -> AIErr>,
    #[doc = " Checks to see if it is OK to create or insert an art object of a given type at a given insertion point.\n@param paintOrder The insertion point in the paint order, relative to the \\c prep object. See \\c AITypes::AIPaintOrder.\n@param prep The prepositional art object for the paint order.\n@param artType The type of art object, an \\c #AIArtType value.\n\n@return \\c kNoErr if it is OK, and \\c #kInvalidArtTypeForDestErr if it is not."]
    pub InsertionPointBadForArtType: ::std::option::Option<
        unsafe extern "C" fn(paintOrder: ai_int16, prep: AIArtHandle, artType: ai_int16) -> AIErr,
    >,
    #[doc = " Check to see if it is OK to insert an art object or a duplicate copy of it at the indicated\ninsertion point, based on attributes of the insertion context and the candidate art, without actually\nattempting the insertion. This is mainly intended for use during drag-drop mouseover,\nto give proper cursor feedback, and so that an insertion is not attempted if it will fail.\n@param candidateArt The art object to test.\n@param paintOrder The position for the insertion point, with respect to \\c prep, an \\c AITypes::AIPaintOrder value.\n@param prep The prepositional object for the \\c paintOrder position.\n@return \\c kNoErr if it is OK. Possible non-OK returns are \\c #kTooDeepNestingErr,\n\\c #kInvalidArtTypeForDestErr, and \\c #kUntouchableArtObjectErr."]
    pub PreinsertionFlightCheck: ::std::option::Option<
        unsafe extern "C" fn(
            candidateArt: AIArtHandle,
            paintOrder: ai_int16,
            prep: AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Sets the note attribute for an art object, which typically contains text entered by the user.\nTo attach private data to an art object, plug-ins should use the art dictionary interface (see \\c #GetDictionary())\nrather than using the note.\n@param art The art object.\n@param inNote The new text for the note."]
    pub SetNote: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, inNote: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the note attribute text for an art object, which typically contains text entered by the user.\n@param art The art object\n@param outNote [out] A buffer in which to return the contents of the note.\nReturns an empty string if the art object has no note.\n@see \\c #SetNote()"]
    pub GetNote: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, outNote: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Checks whether an art object has a note attached. (Note this function returns a boolean value, not an error code.)\n@param art The art object.\n@return True if there is a note attached."]
    pub HasNote: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Deletes the note attached to an art object, if there is one. No error code is returned.\n@param art The art object."]
    pub DeleteNote: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle)>,
    #[doc = " Gets the size of the XMP metadata associated with an art object.\n@param art The art object.\n@param size [out] A buffer in which to return the number of bytes, or 0 if there is no XMP metadata."]
    pub GetArtXMPSize:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, size: *mut usize) -> AIErr>,
    #[doc = " Retrieves the XML packet associated with an art object's XMP metadata. The format is UTF-8\nUnicode.\n@param art The art object.\n@param xmp [out] A buffer in which to return the XML packet. Allocate a buffer using \\c #GetArtXMPSize().\n@param size The number of bytes in the \\c xmp buffer."]
    pub GetArtXMP: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            xmp: *mut ::std::os::raw::c_char,
            size: usize,
        ) -> AIErr,
    >,
    #[doc = " Sets XMP metadata for an art object, replacing any existing data. Format must be UTF-8\nUnicode.\n@param art The art object.\n@param xmp The new XML packet.Use a null XMP pointer or empty one to remove the existing metadata."]
    pub SetArtXMP: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, xmp: *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the geometric bounds of an art object after applying a transformation matrix.\nReturns double-precision coordinates.\n@param art The art object.\n@param transform A pointer to a transformation matrix to apply.\n@param flags Bit flags that specify which bounds to return. A logical OR of \\c #AIArtBoundsOptions constants.\nThe flags must include either \\c kVisibleBounds or \\c kControlBounds,\nand can include additional flags depending on which of these is included.\n@param bounds [out] A buffer in which to return the bounds value, containing double-precision coordinates.\n@see \\c #GetArtTransformBounds()"]
    pub GetPreciseArtTransformBounds: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            transform: *mut AIRealMatrix,
            flags: ai_int32,
            bounds: *mut AIDoubleRect,
        ) -> AIErr,
    >,
    #[doc = " Removes an art object from the art tree, performing minimal checks for validity of the input\nin order to maximize performance. Disposing of a group or compound path\nalso removes the children.\n@param art The art object. Upon return, the reference is no longer valid."]
    pub UncheckedDisposeArt: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Reports whether an art object is a graph object type.\nGraphs (for historical reasons) have no specific art type in\n\\c #AIArtType enum, and get the type \\c #kUnknownArt.\n@param art The art object to query.\n@param artisgraph [out] A buffer in which to return the output as true if the object\nis a graph."]
    pub ArtIsGraph: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, artisgraph: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the art as KeyArt for object alignment. The key object is the one to which other objects are aligned.\nIf art is NULL, it cancels key art. Use this API to Cancel KeyArt instead of CancelKeyArt().\n@param art [in] The art object to be set as Key Art\nThe art needs to be currently selected.\n@return an AIErr. In case of success returns kNoErr else give kBadParameterErr\n@see \\c #GetKeyArt()"]
    pub SetKeyArt: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Retrieves the drawing mode for current document.\n@param mode [out] A buffer in which to return the drawing mode,  an \\c #AIDrawingMode constant."]
    pub GetDrawingMode: ::std::option::Option<unsafe extern "C" fn(mode: *mut ai_int32) -> AIErr>,
    #[doc = " Sets the drawing mode for current document.\n@param mode [in] The drawing mode to be set for a document, an \\c #AIDrawingMode constant."]
    pub SetDrawingMode: ::std::option::Option<unsafe extern "C" fn(mode: ai_int32) -> AIErr>,
    #[doc = " Retrieves the insertion point for current document based on the drawing mode.\nThis is the position in the art tree at which a drawing tool should create new art.\n@param mode [in] The drawing mode, an \\c #AIDrawingMode constant.\n@param art [out] The art object.\n@param paintorder [out] The position in the paint order, relative to the specified art object.\nSee \\c #AITypes::AIPaintOrder for the possible positions.\n@param editable [out] A buffer in which to return the output as true if it is possible to create art\nat the returned position. For example, you cannot create art in a locked layer.\nPass null if not needed."]
    pub GetInsertionPointForDrawingMode: ::std::option::Option<
        unsafe extern "C" fn(
            mode: ai_int32,
            art: *mut AIArtHandle,
            paintorder: *mut ::std::os::raw::c_short,
            editable: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the insertion point for current document based on the current drawing mode.\nThis is the position in the art tree at which a drawing tool should create new art.\n@param art [out] The art object.\n@param paintorder [out] The position in the paint order, relative to the specified art object.\nSee \\c #AITypes::AIPaintOrder for the possible positions.\n@param editable [out] A buffer in which to return the output as true if it is possible to create art\nat the returned position. For example, you cannot create art in a locked layer.\nPass null if not needed."]
    pub GetInsertionPointForCurrentDrawingMode: ::std::option::Option<
        unsafe extern "C" fn(
            art: *mut AIArtHandle,
            paintorder: *mut ::std::os::raw::c_short,
            editable: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the path polarity of an art object.\n\n@param art The art object.\n@param polarity [out] A buffer in which to return the polarity value.\nValue of polarity is set to \\c #kAIPolarPath or \\c #kAINonPolarPath."]
    pub GetPathPolarity: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, polarity: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Reports whether an art object is in pixel-perfect mode.\n@param art [in]: The art object\nNote that this API returns a boolean value and not an error.\n@return True of the pixel-perfect property is on, false if it is off."]
    pub IsPixelPerfect: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Turns the pixel-perfect mode on or off for an art object.\n@param art [in] The art object\n@param isPixelPerfect [in] True to turn pixel-perfect mode on, false to turn it off."]
    pub SetPixelPerfect: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, isPixelPerfect: AIBoolean) -> AIErr,
    >,
    #[doc = " Compare two art objects to determine if they are equivalent in geometry, appearance attributes,\nand dictionary contents. Typically, one object is in the current document and the other\nis in another document. This function uses the same sense of equivalence in which two patterns\nor symbol definitions are considered equivalent when retargeting an external symbol or pattern\nto the current document. In particular, if one object is in a document with a different color\nmode than the other, then non-global process colors are converted to the color mode of the\nfirst object before comparison, and named global objects are considered equivalent if the\ndefinitions match and the names are equal except for trailing numerical suffixes.\n(Note that this function returns a Boolean value, not an error code.)\n\n@param art1\t The first art object.\n@param art2The second art object.\n@return True if the objects are equivalent, false otherwise.\n\n@see \\c #AISymbolSuite::RetargetForCurrentDocument() and \\c #AIPathStyleSuite::RetargetForCurrentDoc()"]
    pub ObjectsAreEquivalent: ::std::option::Option<
        unsafe extern "C" fn(art1: AIArtHandle, art2: AIArtHandle) -> AIBoolean,
    >,
    #[doc = " Reports whether an art object acts as a layer within a symbol pattern.\nThis is a simulated layer that functions as a group, except when isolated or expanded.\nIt is not a layer object and cannot be manipulated with the \\c #AILayerSuite.\n@param art [in] The art object\n@param isLayerInSymbol [out] A buffer in which to return the output as true if\nthis is a simulated layer in a symbol pattern; false otherwise."]
    pub IsArtALayerInSymbol: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, isLayerInSymbol: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the modification time stamp for an art object.\n@param art [in] The art object\n@param option [in] The type of timeStamp to get, an \\c ::AIArtTimeStampOptions value.\n@param timeStamp [out] A buffer in which to return the modification time stamp."]
    pub GetArtTimeStamp: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            option: AIArtTimeStampOptions,
            timeStamp: *mut usize,
        ) -> AIErr,
    >,
    pub GetGlobalTimeStamp: ::std::option::Option<unsafe extern "C" fn() -> usize>,
    pub ConvertPointTypeToAreaType: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, newArtHandle: *mut AIArtHandle) -> AIErr,
    >,
    pub ConvertAreaTypeToPointType: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, newArtHandle: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = "\tMarks an art object for redraw by incrementing the modification time stamp.\n@param art[in] The art object\n@param markStyleDirty[in] Pass true to dirty the artstyle of the object otherwise artstyle will not be re-executed"]
    pub MarkDirty: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, markStyleDirty: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the SafeArt object associated with an art object. The SafeArt object\ncan be cached for the lifetime of the document. Use \\c #GetArtHandle() to\nretrieve the art object if it is still valid, or report if the art has been\ndeleted or moved to the undo stack.\n@param art [in] The art object.\n@param safeArt [out] A buffer in which to return the SafeArt object.\n@see \\c #GetArtHandle()"]
    pub GetSafeArtHandle: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, safeArt: *mut AISafeArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the art object associated with a SafeArt object, if the art\nis still in scope.\n@param safeArt [in] The SafeArt object.\n@param art [in] A buffer in which to return the valid art object,\nor a null pointer if the art object has been deleted or\nhas moved to the undo stack.\n@return  \\c #kAIArtHandleOutOfScopeErr if the associated art is\nno longer valid."]
    pub GetArtHandle: ::std::option::Option<
        unsafe extern "C" fn(safeArt: AISafeArtHandle, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = "\tRetrieves the default name of an art object.\n@param art The art object.\n@param name [out] A buffer in which to return the name."]
    pub GetArtDefaultName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = "\tRetrieves an art object's document.\n@param art The art object.\n@param document [out] A buffer in which to return the document object. See \\c #AIDocumentSuite"]
    pub GetDocumentOfArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, document: *mut AIDocumentHandle) -> AIErr,
    >,
}
#[doc = "\t@ingroup Suites\nThe artwork in an Illustrator document is contained within layers. The document\nhas a stack of lists of layers. The topmost list of layers in the stack are the\nones currently being edited. See the \\c #AILayerListSuite.\n\nEach layer contains a group of objects, which can include sublayers.\nAll documents begin with at least one layer, and the user or a plug-in\ncan add any number of new layers to it. A layer is a container for\nan artwork tree; use \\c #AIArtSuite::GetFirstArtOfLayer()\nto get the group of art objects belonging to a layer.\n\nIn addition to containing artwork, a layer has a name, a color\n(used to indicate selected art), and state flags that indicate whether\nit is visible, editable or locked, printable, and whether it displays\nplaced art as dimmed. A layer reference is opaque; use the functions\nin this suite to get and set layer properties.\n\nSeveral layer properties affect whether the artwork on the layer is editable.\nNormally objects on a non-editable layer cannot be selected, so plug-ins\nthat operate on the current selection need not check.  However, in\niterating through layers or artwork, call \\c #GetLayerEditable() on each\nlayer before attempting to make any changes to the artwork.\n\nA layer can be designated as a \\e template layer, which contains template\nartwork being used to guide the construction of the document artwork.\nFor example, a template might contain an image that is being traced. Template\nlayers are never printed or exported to final-form file formats.\n\nThere are four notifiers associated with layers:\n<br> \\c #kAICurrentLayerNotifier\n<br> \\c #kAILayerDeletionNotifier\n<br> \\c #kAILayerSetNotifier\n<br> \\c #kAILayerOptionsNotifier\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAILayerSuite and \\c #kAILayerVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILayerSuite {
    #[doc = " Gets the number of top-level layers in the current document\nlayer list.\tUse with \\c #GetNthLayer() to iterate through\na document's layers.\n@param count [out] A buffer in which to return the number\nof layers, or 0 if there is no current document."]
    pub CountLayers: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a top-level layer by index from the current document.\nUse with \\c #CountLayers() to iterate through a document's layers.\nThe layer with index 0 is the topmost layer in the stacking order.\n@param n The index, in the range [0..numLayers-1].\nIf \\c n is greater than the number of layers, an error\nis returned and \\c layer is set to \\c NULL.\n@param layer [out] A buffer in which to return the layer, or\n\\c NULL if the index is out of range.\n@note It is more efficient to iterate layers using \\c #GetFirstLayer()\nand \\c #GetNextLayer()."]
    pub GetNthLayer: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, layer: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the current layer in the current document.\nThis is the layer on which new artwork is created by default. It\nis indicated in the Layers palette by a black triangle.\n@param layer [out] A buffer in which to return the layer."]
    pub GetCurrentLayer:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut AILayerHandle) -> AIErr>,
    #[doc = " Makes a layer current. The current layer is the one in which new artwork\nis created by default. It is indicated in the Layers palette by a\nblack triangle.\n@param layer The layer."]
    pub SetCurrentLayer: ::std::option::Option<unsafe extern "C" fn(layer: AILayerHandle) -> AIErr>,
    #[doc = " Retrieves the topmost layer of the current document layer list.\nUse with \\c #GetNextLayer to iterate through layers.\n@param first [out] A buffer in which to return the layer.\n@see \\c #GetNextLayer(), \\c #GetPrevLayer()"]
    pub GetFirstLayer:
        ::std::option::Option<unsafe extern "C" fn(first: *mut AILayerHandle) -> AIErr>,
    #[doc = " Retrieves the next layer below a given layer in the stacking order,\nat the same level of the layer list stack. Does not descend into\nsublayers.\n@param prev The previous layer, or \\c NULL to get the topmost layer.\n@param next [out] A buffer in which to return the next layer, or\n\\c NULL if there are no more layers.\n@see \\c #GetFirstLayer(), \\c #GetPrevLayer()"]
    pub GetNextLayer: ::std::option::Option<
        unsafe extern "C" fn(prev: AILayerHandle, next: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Adds a new layer to a document, inserting it into the layers' lists\nat a position in the paint order relative to an existing layer.\n@param layer The prepositional layer for \\c paintOrder values\n\\c #kPlaceAbove and \\c #kPlaceBelow, or \\c NULL for values\n\\c #kPlaceAboveAll (inserts at 0) and\n\\c #kPlaceBelowAll (inserts at \\c count).\n@param paintOrder The paint order, relative to the \\c layer object,\nan \\c #AITypes::AIPaintOrder value. See \\c #AIArtSuite::NewArt().\n@param newLayer [out] A buffer in which to return the new layer.\n@see \\c #InsertLayerAtArt()"]
    pub InsertLayer: ::std::option::Option<
        unsafe extern "C" fn(
            layer: AILayerHandle,
            paintOrder: ai_int16,
            newLayer: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Removes a layer and all of its contained art from the current document.\n@param layer The layer.\n@return An error \\c #kCantDeleteLastLayerErr if \\c layer is the only layer\nin the document."]
    pub DeleteLayer: ::std::option::Option<unsafe extern "C" fn(layer: AILayerHandle) -> AIErr>,
    #[doc = " Retrieves the name of a layer.\n@param layer The layer.\n@param  title [out] A buffer in which to return the name."]
    pub GetLayerTitle: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, title: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets the name of a layer.\n@param layer The layer.\n@param  title The new name."]
    pub SetLayerTitle: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, newTitle: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the color used when outlining selected artwork in a layer.\n@param layer The layer.\n@param color [out] A buffer in which to return the\tcolor."]
    pub GetLayerColor: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, color: *mut AIRGBColor) -> AIErr,
    >,
    #[doc = " Sets the color used when outlining selected artwork in a layer.\n@param layer The layer.\n@param color The new color."]
    pub SetLayerColor: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, color: AIRGBColor) -> AIErr,
    >,
    #[doc = " Reports the visibility status of a layer, which affects whether the artwork\nis drawn. If a parent layer's visibility status is false,\nartwork of a sublayer is not drawn, even if the sublayer's visibility\nstatus is true.\n@param layer The layer.\n@param visible [out] A buffer in which to return the output as true if art\nin this layer is visible."]
    pub GetLayerVisible: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, visible: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the visibility status of a layer, which affects whether the artwork\nis drawn. If a parent layer's visibility status is false,\nartwork of a sublayer is not drawn, even if the sublayer's visibility\nstatus is true.\n@param layer The layer.\n@param visible True to make art\tin this layer is visible, false\nto hide it."]
    pub SetLayerVisible: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, visible: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a layer specifies preview or outline mode.\nIf a parent layer specifies outline mode, art in all sublayers is\nrendered in outline mode regardless of the sublayer settings.\n@param layer The layer.\n@param preview [out] A buffer in which to return true if\nthis layer specifies preview mode; false if it\nspecifies outline mode."]
    pub GetLayerPreview: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, preview: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets a layer to preview mode or outline mode.\nIf a parent layer specifies outline mode, art in all sublayers is\nrendered in outline mode regardless of the sublayer settings.\n@param layer The layer.\n@param preview True to set preview mode, false to set outline mode."]
    pub SetLayerPreview: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, preview: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a layer is editable or locked. When a layer is\neditable, its artwork can be created or modified.\nIf a parent layer is not editable, art in all sublayers\ncannot be edited, regardless of the sublayer settings.\n@param layer The layer.\n@param editable [out] A buffer in which to return true if\nthis layer is editable; false if it is locked."]
    pub GetLayerEditable: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, editable: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether a layer is editable or locked. When a layer is\neditable, its artwork can be created or modified.\nIf a parent layer is not editable, art in all sublayers\ncannot be edited, regardless of the sublayer settings.\n@param layer The layer.\n@param editable True to make this layer is editable, false\nto lock it."]
    pub SetLayerEditable: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, editable: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether this layer is considered printable when printing the document.\nYou can print all layers, visible layers or printable, visible layers.\n@param layer The layer.\n@param printed [out] A buffer in which to return true if\nthis layer is printable; false if it is not."]
    pub GetLayerPrinted: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, printed: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether this layer is considered printable when printing the document.\nYou can print all layers, visible layers or printable, visible layers.\n@param layer The layer.\n@param printed True to make\tthis layer printable, false to\nturn printability off."]
    pub SetLayerPrinted: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, printed: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether images in a layer are dimmed (colors shifted toward white)\nwhen rendering. If a parent layer specifies dimming, images in sublayers\nare dimmed regardless of the sublayer setting.\n@param layer The layer.\n@param dimmed [out] A buffer in which to return true if\nthis layer is dimmed; false if it is not."]
    pub GetLayerDimPlacedImages: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, dimmed: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether images in a layer are dimmed (colors shifted toward white)\nwhen rendering. If a parent layer specifies dimming, images in sublayers\nare dimmed regardless of the sublayer setting.\n@param layer The layer.\n@param dimmed True to dim images, false to turn dimming off."]
    pub SetLayerDimPlacedImages: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, dimmed: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a layer is selected.\n@param layer The layer.\n@param selected [out] A buffer in which to return true if\nthis layer is selected; false if it is not.\n@note This function is provided for backward\ncompatibility with Illustrator 6.0."]
    pub GetLayerSelected: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, selected: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether a layer is selected.\n@param layer The layer.\n@param selected True to select this layer, false\nto deselect it.\n@note This function is provided for backward\ncompatibility with Illustrator 6.0."]
    pub SetLayerSelected: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, selected: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves a layer by title.\tThe layer can be top-level or a sublayer.\n@param layer [out] A buffer in which to return the layer.\n@param title The title string."]
    pub GetLayerByTitle: ::std::option::Option<
        unsafe extern "C" fn(layer: *mut AILayerHandle, title: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Reports whether a layer contains objects other than sublayers.\n@param layer The layer.\n@param hasArt [out] A buffer in which to return true if\nthis layer contains art objects; false if it does not."]
    pub LayerHasArt: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, hasArt: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a layer contains any selected artwork.\n@param layer The layer.\n@param hasSel [out] A buffer in which to return true if\nthis layer contains selected art; false if it does not."]
    pub LayerHasSelectedArt: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, hasSel: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Deselects all objects on a layer.\n@param layer The layer."]
    pub DeselectArtOnLayer:
        ::std::option::Option<unsafe extern "C" fn(layer: AILayerHandle) -> AIErr>,
    #[doc = " Selects all objects on a layer that can be selected.\n@param layer The layer."]
    pub SelectArtOnLayer:
        ::std::option::Option<unsafe extern "C" fn(layer: AILayerHandle) -> AIErr>,
    #[doc = " Reports whether a layer is a template layer. All sublayers of a\ntemplate layer are also template layers.\n@param layer The layer.\n@param isTemplate [out] A buffer in which to return true if\nthis layer is a template layer; false if it is not."]
    pub GetLayerIsTemplate: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, isTemplate: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether a layer is a template layer. All sublayers of a\ntemplate layer are also template layers.\n@param layer The layer.\n@param isTemplate True to make this a template layer, false to\nnot make it a template layer."]
    pub SetLayerIsTemplate: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, isTemplate: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the layer above a given layer in the stacking order.\nDoes not descend into sublayers.\n@param next The given layer.\n@param prev [out] A buffer in which to return the previous layer, or\n\\c NULL if there are no more layers.\n@return The error \\c #kNotImplementedErr if \\c next is in a sublayer.\n@see \\c #GetFirstLayer(), \\c #GetNextLayer()"]
    pub GetPrevLayer: ::std::option::Option<
        unsafe extern "C" fn(next: AILayerHandle, prev: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the dimming factor used for drawing images when a layer is set to be\ndimmed.\n@param layer The layer.\n@param percent [out] A buffer in which to return the dimming factor,\nin the range [0..100] where 0 in no dimming, and 100 is maximum\ndimming."]
    pub GetLayerDimmedPercent: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, percent: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the dimming factor used for drawing images when a layer is set to be\ndimmed.\n@param layer The layer.\n@param percent The dimming factor, in the range [0..100]\nwhere 0 in no dimming, and 100 is maximum dimming."]
    pub SetLayerDimmedPercent: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, percent: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the first child sublayer of a layer.\n@param layer The layer.\n@param child [out] A buffer in which to return the sublayer,\nor NULL if there are no sublayers."]
    pub GetLayerFirstChild: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, child: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the parent of a layer.\n@param layer The layer.\n@param parent [out] A buffer in which to return the parent,\nor NULL if there is no parent."]
    pub GetLayerParent: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, parent: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Inserts a new layer into a document at a paint-order position relative\nto an art object.\n@param art The art object.\n@param paintOrder The paint order, relative to the \\c art object,\nan \\c #AITypes::AIPaintOrder value. See \\c #AIArtSuite::NewArt().\nThe position must be appropriate for adding a layer; that is,\nat the top level or such that the resulting parent is a layer.\n@param newLayer [out] A buffer in which to return the new layer.\n@see \\c #InsertLayer()"]
    pub InsertLayerAtArt: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            paintOrder: AIPaintOrder,
            newLayer: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Converts a sublayer of this layer to a simple group. You must ensure that\nthe sublayer has no child layers that would be orphaned by\nremoving the layer information.\n@param layer The layer object for the sublayer,\nor \\c NULL if you pass the group object.\n@param group The art group object associated with the sublayer,\nor \\c NULL if you pass the layer object."]
    pub ChangeLayerToGroup: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, group: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the next layer in preorder traversal, which finds descendents first,\nthen siblings. Use this to iterate through layers and their sublayers.\n@param prev The previous layer.\n@param next [out] A buffer in which to return the next layer, or\n\\c NULL if there are no more layers.\n@see \\c #GetFirstLayer(), \\c #GetNextNonChildPreorderLayer()"]
    pub GetNextPreorderLayer: ::std::option::Option<
        unsafe extern "C" fn(prev: AILayerHandle, next: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the next layer in preorder traversal, skipping descendents and returning\nonly sibling layers. Use this to iterate through layers and their parent layers.\n@param prev The previous layer.\n@param next [out] A buffer in which to return the next layer, or\n\\c NULL if there are no more layers.\n@see \\c #GetFirstLayer(), \\c #GetNextPreorderLayer()"]
    pub GetNextNonChildPreorderLayer: ::std::option::Option<
        unsafe extern "C" fn(prev: AILayerHandle, next: *mut AILayerHandle) -> AIErr,
    >,
}
#[doc = " An \\c AIArtSpec is a filter for matching art objects that have specific\nproperties. Pass an array of these to \\c #AIArtSetSuite::MatchingArtSet()\nto specify the art objects that should be returned.\nSpecify the type of art object to match, then filter objects of that type\nbased on their user attributes.\n\\li Use the special type \\c kAnyArt to match any kind of art object.\n\\li \\c whichAttr specifies the collection of attributes to be considered when filtering objects.\n\\li \\c attr specifies the values those attributes must have to match an object.\n\nFor\texample, specify \\c kSelected for both \\c whichAttr and \\c attr to match\nonly art objects that are selected.\n\nSome \\c #AIArtSuite::AIArtUserAttr values are not art attributes\nbut instead specify additional matching options. Use such a value\nin the \\c whichAttr field; it only needs to be in one of the art specifications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtSpec {
    #[doc = " The type of art object to match, an \\c #AIArtSuite::AIArtType value."]
    pub type_: ai_int16,
    #[doc = " \\c #AIArtSuite::AIArtUserAttr values for which attributes to consider (\\c whichAttr)\nand for the matching value (\\c attr)."]
    pub whichAttr: ai_int32,
    #[doc = " \\c #AIArtSuite::AIArtUserAttr values for which attributes to consider (\\c whichAttr)\nand for the matching value (\\c attr)."]
    pub attr: ai_int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIArt {
    _unused: [u8; 0],
}
#[doc = " Opaque type for an ordered list of art object handles."]
pub type AIArtSet = *mut _t_AIArt;
#[doc = " @ingroup Suites\nAn art set is an ordered list of art object handles. An art object handle should\nappear at most once in the list. This is enforced by most but not all of the\nfunctions for manipulating the set.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArtSetSuite and \\c #kAIArtSetVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtSetSuite {
    #[doc = " Creates a new, empty art set.\nThis is an opaque pointer and cannot be dereferenced.\nUse functions in this suite to fill the set with art objects and access them.\n@param artSet [out] A buffer in which to return the new art set."]
    pub NewArtSet: ::std::option::Option<unsafe extern "C" fn(artSet: *mut AIArtSet) -> AIErr>,
    #[doc = " Frees memory associated with an art set and makes the reference null.\nDoes not affect any artwork referenced by the set.\n@param artSet A pointer to the art set. Upon return, this reference is invalid."]
    pub DisposeArtSet: ::std::option::Option<unsafe extern "C" fn(artSet: *mut AIArtSet) -> AIErr>,
    #[doc = " Gets the number of art handles stored in an art set. Use with \\c #IndexArtSet() to\niterate through a set.\n@param artSet The art set.\n@param count [out] A buffer in which to return the number of art handles."]
    pub CountArtSet:
        ::std::option::Option<unsafe extern "C" fn(artSet: AIArtSet, count: *mut usize) -> AIErr>,
    #[doc = " Retrieves the art object at a given index within an art set.\nUse with \\c #CountArtSet() to iterate through a set. This is the\nmost efficient way to access elements of an art set. Access speed is O(1).\n@param artSet The art set.\n@param index The 0-based position index, in the range \\c [0..count-1].\n@param art [out] A buffer in which to return the art object.\n@note \\c #ReplaceArtInArtSet() can put \\c NULL entries into an art set.\n\\c #NextInArtSet() iterates through the set skipping \\c NULL entries, but\nis not a efficient as this function."]
    pub IndexArtSet: ::std::option::Option<
        unsafe extern "C" fn(artSet: AIArtSet, index: usize, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Fills an art set with an array of art objects.\nThe previous contents of the art set, if any, are lost. It is the\ncaller's responsibility to ensure that the array does not contain duplicates.\n@param artSet The art set.\n@param artArray A pointer to an array of art objects.\nYou must allocate memory for this array, and free it when it is\nno longer needed.\n@param count The number of entries in \\c artArray."]
    pub ArrayArtSet: ::std::option::Option<
        unsafe extern "C" fn(artSet: AIArtSet, artArray: *mut AIArtHandle, count: usize) -> AIErr,
    >,
    #[doc = " Fills an art set with currently selected art.\nThe previous contents of the art set, if any, are lost.\nMany filters operate on the selected objects in a document. Use this function\nto collect the selected art objects without having to iterate through the\nartwork tree to find them.It is the same as calling \\c #MatchingArtSet()\nwith a request for <code> { kAnyArt, kArtSelected, kArtSelected } </code>\n@param artSet The art set."]
    pub SelectedArtSet: ::std::option::Option<unsafe extern "C" fn(artSet: AIArtSet) -> AIErr>,
    #[doc = " Fills an art set with the art objects in the current document\nthat match the criteria given in a list of art specifications; see \\c #AIArtSpec.\nThe art objects are added to the set in the order they are encountered by a pre-order\ntraversal of the document tree. An art object is included\nif it matches any of the art specifications.\n@param spec A pointer to an array of \\c #AIArtSpec structures.\n@param numSpecs The number of entries in \\c specs.\n@param artSet The art set."]
    pub MatchingArtSet: ::std::option::Option<
        unsafe extern "C" fn(specs: *mut AIArtSpec, numSpecs: ai_int16, artSet: AIArtSet) -> AIErr,
    >,
    #[doc = " Fills an art set with all art objects that belong to a specific layer.\nThe previous contents of the art set, if any, are lost.\n@param layer The layer.\n@param artSet The art set."]
    pub LayerArtSet: ::std::option::Option<
        unsafe extern "C" fn(layer: AILayerHandle, artSet: AIArtSet) -> AIErr,
    >,
    #[doc = " Deprecated. Fills an art set \\c dst with all artwork in the\ndocument that is not in the art set \\c src.\n@note This function has not been kept up\nto date with changes to the object model."]
    pub NotArtSet:
        ::std::option::Option<unsafe extern "C" fn(src: AIArtSet, dst: AIArtSet) -> AIErr>,
    #[doc = " Fills an art set with all art objects contained in two art sets without duplicating\ncommon art objects.\n@param src0 The first source art set.\n@param src1 The second source art set.\n@param dst The destination art set."]
    pub UnionArtSet: ::std::option::Option<
        unsafe extern "C" fn(src0: AIArtSet, src1: AIArtSet, dst: AIArtSet) -> AIErr,
    >,
    #[doc = " Fills an art set with all art objects that are common to two art sets.\n@param src0 The first source art set.\n@param src1 The second source art set.\n@param dst The destination art set."]
    pub IntersectArtSet: ::std::option::Option<
        unsafe extern "C" fn(src0: AIArtSet, src1: AIArtSet, dst: AIArtSet) -> AIErr,
    >,
    #[doc = " Retrieves an art object from an art set.\nUse this function to iterate through the objects in an art set.\nUnlike \\c #IndexArtSet() this function skips \\c NULL entries in the set, but it\nis not as efficient; access speed is \\c O(n). Use \\c #IndexArtSet() if possible.\n@param artSet The art set.\n@param prevArt An art object contained in the set, or \\c NULL to get the first object.\n@param nextArt [out] A buffer in which to return the next art object, or a null object\nif \\c prevArt is not in the set or is the last member."]
    pub NextInArtSet: ::std::option::Option<
        unsafe extern "C" fn(
            artSet: AIArtSet,
            prevArt: AIArtHandle,
            nextArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Appends an art object to an art set if it is not already there.\n@param artSet The art set.\n@param art The art object."]
    pub AddArtToArtSet:
        ::std::option::Option<unsafe extern "C" fn(artSet: AIArtSet, art: AIArtHandle) -> AIErr>,
    #[doc = " Removes all occurrences of an art object from an art set.\n@param artSet The art set.\n@param art The art object."]
    pub RemoveArtFromArtSet:
        ::std::option::Option<unsafe extern "C" fn(artSet: AIArtSet, art: AIArtHandle) -> AIErr>,
    #[doc = " Replaces the first occurrence of one art object in a set with another, or, if\n\\c oldArt is not found, appends \\c newArt to the set.\n@param artSet The art set.\n@param oldArt The art object to replace, if found.\n@param newArt The art object to add. Can be \\c NULL,\nin which case a null entry is inserted or added to the set"]
    pub ReplaceArtInArtSet: ::std::option::Option<
        unsafe extern "C" fn(artSet: AIArtSet, oldArt: AIArtHandle, newArt: AIArtHandle) -> AIErr,
    >,
    #[doc = " Clears the art set.\n@param artSet The art set."]
    pub ClearArtSet: ::std::option::Option<unsafe extern "C" fn(artSet: AIArtSet) -> AIErr>,
}
#[doc = " Extension is not registered in Illustrator."]
pub const AICSXSExtensionState_kAICSXSExtensionNotRegisteredState: AICSXSExtensionState = 0;
#[doc = " Extension is registered in Illustrator and ready to load."]
pub const AICSXSExtensionState_kAICSXSExtensionRegisteredState: AICSXSExtensionState = 1;
#[doc = " Extension is loaded."]
pub const AICSXSExtensionState_kAICSXSExtensionLoadedState: AICSXSExtensionState = 2;
#[doc = " Extension is loaded and Visible , valid for Panel and Dashboard Extension as of AI 19.2."]
pub const AICSXSExtensionState_kAICSXSExtensionLoadedVisibleState: AICSXSExtensionState = 3;
#[doc = " Extension is loaded but inVisible , valid for Panel and Dashboard Extension as of AI 19.2."]
pub const AICSXSExtensionState_kAICSXSExtensionLoadedInvisibleState: AICSXSExtensionState = 4;
#[doc = " Extension is unloaded."]
pub const AICSXSExtensionState_kAICSXSExtensionUnLoadedState: AICSXSExtensionState = 5;
#[doc = " Internal use"]
pub const AICSXSExtensionState_kCSXSExtensionMaximumState: AICSXSExtensionState = 65535;
#[doc = "Constants for reporting the status of Creative Suite extensions.\nSee \\c #AICSXSExtensionSuite::GetExtensionState()."]
pub type AICSXSExtensionState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICSXSExtensionNotifierMsg {
    pub state: AICSXSExtensionState,
    pub extensionId: *const ::std::os::raw::c_char,
}
#[doc = " @ingroup Suites\nThis suite provides access to information about the status of Creative Suite\nextensions that might be loaded into Illustrator.\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAICSXSExtensionSuite and \\c #kAICSXSExtensionVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICSXSExtensionSuite {
    #[doc = " Retrieves the current registration and load state of an extension.\n@param extensionId [in] The unique identifier of the extension.\n@param state [out] A buffer in which to return the current state, an \\c #AICSXSExtensionState constant value."]
    pub GetExtensionState: ::std::option::Option<
        unsafe extern "C" fn(
            extensionId: *const ::std::os::raw::c_char,
            state: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Reports whether an extension's main window is currently visible in the UI.\n@param extensionId [in] The unique identifier of the extension.\n@param isVisible [out] True if the extension's main window appears in the UI, false otherwise."]
    pub IsPrimaryStageVisible: ::std::option::Option<
        unsafe extern "C" fn(
            extensionId: *const ::std::os::raw::c_char,
            isVisible: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Launches extension of specified extension ID\n@param extensionId [in] The unique identifier of the extension."]
    pub LaunchExtension: ::std::option::Option<
        unsafe extern "C" fn(extensionId: *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Sends Provided Event To Extension with the provided data\n@param extensionId [in] The unique identifier of the extension.\n@param eventID [in] The unique identifier of the event.\n@param appId [in] The unique identifier of Application.\n@param data [in] data is optional. it can be used to send some data to extension along with the event"]
    pub SendEventToExtension: ::std::option::Option<
        unsafe extern "C" fn(
            extensionId: *const ::std::os::raw::c_char,
            eventID: *const ::std::os::raw::c_char,
            appId: *const ::std::os::raw::c_char,
            data: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Sets the visibility of a panel.\nNOTE: This suite function does not \"launch\" any extension. It simply changes visibility state of container of the input extension\nIf you need to know the \"launch\" status of an extension use GetExtensionState.\n@param extensionId [in] The unique identifier of the extension.\n@param show [in] weather to show/hide the extension panel."]
    pub ShowExtension: ::std::option::Option<
        unsafe extern "C" fn(extensionId: *const ::std::os::raw::c_char, show: bool) -> AIErr,
    >,
    #[doc = " Unloads extension of specified extension ID\n@param extensionId [in] The unique identifier of the extension."]
    pub UnloadExtension: ::std::option::Option<
        unsafe extern "C" fn(extensionId: *const ::std::os::raw::c_char) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite provides functions for working with the \\c #AIReal values that\nIllustrator uses for coordinates. (An \\c #AIReal is a C \\c float type.)\nYou can work with \\c #AIReal values directly,\nwith those contained in position structures for points and rectangles,\nand with those contained in transformation matrices.\n\nThe functions in this suite do not return \\c #AIErr values. For the most part,\nthey return nothing, or return the result of the operation.\n\n@note Adobe Illustrator 8.0 changed all coordinate measurements from\n\\c #AIFixed to \\c #AIReal data types. This change affected many suites;\nin particular, the \\c #AIFixedMathSuite was superseded by this suite.\nFor backward compatibility, this suite provides functions that convert\nbetween \\c #AIReal and \\c #AIFixed numbers.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIRealMathSuite and \\c #kAIRealMathVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRealMathSuite {
    #[doc = " Adds two real numbers.\n@param a The first number.\n@param b The second number.\n@return The result. In case of overflow or underflow,\nreturns the system-defined maximum or minimum constant."]
    pub AIRealAdd: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Multiplies two real numbers.\n@param a The first number.\n@param b The second number.\n@return The result. In case of overflow or underflow,\nreturns the system-defined maximum or minimum constant."]
    pub AIRealMul: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Divides two real numbers (a/b).\n@param a The first number.\n@param b The second number.\n@return The result. In case of overflow, underflow, or divide by 0,\nreturns the system-defined maximum or minimum constant."]
    pub AIRealDiv: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Divides two integers (a/b).\n@param a The first number.\n@param b The second number.\n@return The result. In case of overflow or underflow,\nreturns the system-defined maximum or minimum constant."]
    pub ShortRatio: ::std::option::Option<unsafe extern "C" fn(a: ai_int16, b: ai_int16) -> AIReal>,
    #[doc = " Divides two real numbers (a/b). This is the same as \\c #AIRealDiv().\n@param a The first number.\n@param b The second number.\n@return The result. In case of overflow, underflow, or divide by 0,\nreturns the system-defined maximum or minimum constant."]
    pub AIRealRatio: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Multiplies two sets of numbers and then adds them together: (a * b) + (c * d).\n@param a The first number of the first pair.\n@param b The second number of the first pair.\n@param c The first number of the second pair.\n@param d The second number of the second pair.\n@return The result. In case of overflow or underflow,\nreturns the system-defined maximum or minimum constant."]
    pub AIRealMulAdd: ::std::option::Option<
        unsafe extern "C" fn(a: AIReal, b: AIReal, c: AIReal, d: AIReal) -> AIReal,
    >,
    #[doc = " Rounds a real number to a given multiple.\n@param a The number.\n@param multiple The multiple; for example, 0.01 to round\nto the nearest hundredth, or 0.05 to round to the\nnearest twentieth. Must not be 0.\n@param ceiling When true, round up. When false, round down.\n(Up and down are signed-- that is, floor -0.5 is -1\nand ceiling -0.5 is 0, not the other way around.)\n@note When working with decimals, the result is subject to general\n\\c #AIReal accuracy problems."]
    pub AIRealMultiple: ::std::option::Option<
        unsafe extern "C" fn(a: AIReal, multiple: AIReal, ceiling: AIBoolean) -> AIReal,
    >,
    #[doc = " Computes the sine of a real number in radians.\n@param a The number.\n@return The result."]
    pub AIRealSin: ::std::option::Option<unsafe extern "C" fn(a: AIReal) -> AIReal>,
    #[doc = " Computes the cosine of a real number in radians.\n@param a The number.\n@return The result."]
    pub AIRealCos: ::std::option::Option<unsafe extern "C" fn(a: AIReal) -> AIReal>,
    #[doc = " Computes the arctangent of an angle  in radians, where a and b\nare two real numbers such that a/b is the tangent of the angle\n@param a The first number.\n@param b The second number.\n@return The result."]
    pub AIRealATan: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Converts an angle expressed in degrees to radians.\n@param degree The number of degrees in the angle.\n@return The number of radians in the angle."]
    pub DegreeToRadian: ::std::option::Option<unsafe extern "C" fn(degree: AIReal) -> AIReal>,
    #[doc = " Converts an angle expressed in radians to degrees.\n@param radian The number of radians in the angle.\n@return The number of degrees in the angle."]
    pub RadianToDegree: ::std::option::Option<unsafe extern "C" fn(radian: AIReal) -> AIReal>,
    #[doc = " Computes the square root of a real number.\n@param a The number.\n@return The result."]
    pub AIRealSqrt: ::std::option::Option<unsafe extern "C" fn(a: AIReal) -> AIReal>,
    #[doc = " Computes the length of a vector starting at (0,0) and ending at (a,b).\nThis is the same as <code>AIRealSqrt(a*a + b*b)</code>.\n@param a The X coordinate of the endpoint.\n@param b The Y coordinate of the endpoint.\n@return The result."]
    pub AIRealLength: ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal) -> AIReal>,
    #[doc = " Computes a value between two real numbers by interpolating\nfrom \\c b at \\c t=0 to \\c a at \\c t=1.\tFor example, if t=0.5,\nthe function returns the average of a and b. If a = 0, b = 1,\nand t = 0.25, the function returns 0.75.\n@param a The first number.\n@param b The second number.\n@param t A percentage of (b-a), expressed as a number between 0 and 1.\n@return The result."]
    pub AIRealInterpolate:
        ::std::option::Option<unsafe extern "C" fn(a: AIReal, b: AIReal, t: AIReal) -> AIReal>,
    #[doc = " Adds two points by adding the two X values and the two Y values.\nNo overflow checking is done.\n@param a The first point.\n@param b The second point.\n@param result [out] A buffer in which to return the result."]
    pub AIRealPointAdd: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIRealPoint,
            b: *const AIRealPoint,
            result: *mut AIRealPoint,
        ),
    >,
    #[doc = " Subtracts point a from point b by subtracting the corresponding component values.\nNo overflow checking is done.\n@param a The first point.\n@param b The second point.\n@param result [out] A buffer in which to return the result."]
    pub AIRealPointSubtract: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIRealPoint,
            b: *const AIRealPoint,
            result: *mut AIRealPoint,
        ),
    >,
    #[doc = " Tests for exact equality of two points.\n@param a The first point.\n@param b The second point.\n@param result [out] A buffer in which to return true if the points have the same\ncoordinate values."]
    pub AIRealPointEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealPoint, b: *const AIRealPoint) -> AIBoolean,
    >,
    #[doc = " Tests whether two points are within a specified square proximity of each other.\nThis is true if an axis-aligned, closed rectangle of a given tolerance\ncan be placed such that it can contain the two points.\n@param a The first point.\n@param b The second point.\n@param tolerance The proximity value, the maximum allowed distance between\nthe X and Y coordinates of the points.\n@param result [out] A buffer in which to return true if the points can be\ncontained."]
    pub AIRealPointClose: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIRealPoint,
            b: *const AIRealPoint,
            tolerance: AIReal,
        ) -> AIBoolean,
    >,
    #[doc = " Computes the angle made by the vector \\c ab with the X-axis.\n@param a The first point.\n@param b The second point.\n@return The result, in radians."]
    pub AIRealPointAngle: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealPoint, b: *const AIRealPoint) -> AIReal,
    >,
    #[doc = " Computes the length of the vector \\c ab. The result is always positive.\n@param a The first point.\n@param b The second point.\n@return The result."]
    pub AIRealPointLength: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealPoint, b: *const AIRealPoint) -> AIReal,
    >,
    #[doc = " Computes the location of a point a given distance and angle from the page origin.\n@param length The distance.\n@param angle The angle in radians, counter-clockwise with respect to the X axis.\n@param result [out] A buffer in which to return the result."]
    pub AIRealPointLengthAngle: ::std::option::Option<
        unsafe extern "C" fn(length: AIReal, angle: AIReal, result: *mut AIRealPoint),
    >,
    #[doc = " Computes the location of a point between two points by interpolating new\ncoordinate values between the corresponding coordinates of the points.\nThe result is <code>a * t + b * (1-t)</code>\n@param a The first point.\n@param b The second point.\n@param t A percentage of (b-a), expressed as a number between 0 and 1.\n@param result [out] A buffer in which to return the result."]
    pub AIRealPointInterpolate: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIRealPoint,
            b: *const AIRealPoint,
            t: AIReal,
            result: *mut AIRealPoint,
        ),
    >,
    #[doc = " Sets the coordinate values in a rectangle.  (In the Illustrator\nart coordinate system, the origin, (0, 0), is at the bottom left corner\nof a page. X and Y values increase upward and to the right.)\n@param a The rectangle object.\n@param left The left side location..\n@param top The top side location.\n@param right The right side location.\n@param bottom The bottom side location."]
    pub AIRealRectSet: ::std::option::Option<
        unsafe extern "C" fn(
            a: *mut AIRealRect,
            left: AIReal,
            top: AIReal,
            right: AIReal,
            bottom: AIReal,
        ),
    >,
    #[doc = " Tests whether two rectangles equal (have the same coordinate values).\nUses an inexact equality test to account for floating-point errors.\n@param a The first rectangle.\n@param b The second rectangle.\n@return True if the rectangles are equal."]
    pub AIRealRectEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealRect, b: *const AIRealRect) -> AIBoolean,
    >,
    #[doc = " Tests whether a rectangle is empty (invalid).\nA rectangle is invalid if the right edge is equal to or\nless than the left edge, or the top edge is equal to or\nless than the bottom edge.\n@param a The rectangle.\n@return True if the rectangle is empty."]
    pub AIRealRectEmpty:
        ::std::option::Option<unsafe extern "C" fn(a: *const AIRealRect) -> AIBoolean>,
    #[doc = "\tMoves the edges of a rectangle in or out by a uniform amount.\nPositive values for \\c h or \\c v move the corresponding sides in,\nnegative values move the sides out.\n@param a The rectangle.\n@param h The number of document points to move the edges in or out horizontally.\n@param v The number of document points to move the edges in or out vertically."]
    pub AIRealRectInset:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIRealRect, h: AIReal, v: AIReal)>,
    #[doc = "\tMoves a rectangle by adding given values to the sides. Positive values\nfor \\c h or \\c v move the corresponding rectangle up or right,\nnegative values move it down or left.\n@param a The rectangle.\n@param h The number of document points to move the rectangle horizontally.\n@param v The number of document points to move the rectangle vertically."]
    pub AIRealRectOffset:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIRealRect, h: AIReal, v: AIReal)>,
    #[doc = " Creates a new rectangle that is the union of two rectangles.\n@param a The first rectangle.\n@param b The second rectangle.\n@param result [out] A buffer in which to return the result."]
    pub AIRealRectUnion: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealRect, b: *const AIRealRect, result: *mut AIRealRect),
    >,
    #[doc = " Creates a new rectangle by enlarging a given rectangle to enclose a given point.\n@param a The point.\n@param b The rectangle.\n@param result [out] A buffer in which to return the result."]
    pub AIRealPointUnion: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealPoint, b: *const AIRealRect, result: *mut AIRealRect),
    >,
    #[doc = " Tests whether two rectangles overlap (have any points in common).\n@param a The first rectangle.\n@param b The second rectangle.\n@return True if the rectangles overlap."]
    pub AIRealRectOverlap: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealRect, b: *const AIRealRect) -> AIBoolean,
    >,
    #[doc = " Creates a new rectangle that is the intersection of two rectangles.\n@param a The first rectangle.\n@param b The second rectangle.\n@param result [out] A buffer in which to return the result.\n@return False if the result is an empty (invalid) rectangle, true otherwise."]
    pub AIRealRectIntersect: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIRealRect,
            b: *const AIRealRect,
            result: *mut AIRealRect,
        ) -> AIBoolean,
    >,
    #[doc = " Tests whether one rectangle is inside (entirely contained in) another rectangle.\nBoth must be open or both closed.\n@param a The first rectangle.\n@param b The second rectangle.\n@return True if the set of points contained by \\c a is also contained by \\c b."]
    pub AIRealRectInAIRealRect: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealRect, b: *const AIRealRect) -> AIBoolean,
    >,
    #[doc = " Tests whether a point is inside a rectangle. The point is considered\ninside if it is on one of the rectangle�s sides.\n@param a The point.\n@param b The closed rectangle.\n@return True if the point is contained in the closed rectangle."]
    pub AIRealPointInAIRealRect: ::std::option::Option<
        unsafe extern "C" fn(a: *const AIRealPoint, b: *const AIRealRect) -> AIBoolean,
    >,
    #[doc = " Rounds rectangle coordinates to integer values such that the result\nrectangle contains the original. Does not necessarily return the smallest such\nrectangle; takes the floor of the coordinates and adds 1 to the top\nand right.\n@param a The rectangle.\n@param result [out] A buffer in which to return the result."]
    pub AIRealRectAlign:
        ::std::option::Option<unsafe extern "C" fn(a: *const AIRealRect, result: *mut AIRealRect)>,
    #[doc = " Sets the scale, rotation, and translation values of a transformation matrix.\n@param m The matrix object.\n@param a New a value.\n@param b New b value.\n@param c New c value.\n@param d New d value.\n@param tx New horizontal translation value.\n@param ty New vertical translation value."]
    pub AIRealMatrixSet: ::std::option::Option<
        unsafe extern "C" fn(
            m: *mut AIRealMatrix,
            a: AIReal,
            b: AIReal,
            c: AIReal,
            d: AIReal,
            tx: AIReal,
            ty: AIReal,
        ),
    >,
    #[doc = " Sets a transformation matrix to the identity matrix.\n@param m The matrix object."]
    pub AIRealMatrixSetIdentity: ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix)>,
    #[doc = " Tests two matrices for exact equality.\n@param m The first matrix.\n@param n The second matrix.\n@return True if the matrices are equal."]
    pub AIRealMatrixEqual: ::std::option::Option<
        unsafe extern "C" fn(m: *const AIRealMatrix, n: *const AIRealMatrix) -> AIBoolean,
    >,
    #[doc = " Tests whether a transformation matrix is the identity matrix.\n@param m The matrix object.\n@return True if the matrix is the identity matrix."]
    pub AIRealMatrixIdentity:
        ::std::option::Option<unsafe extern "C" fn(m: *const AIRealMatrix) -> AIBoolean>,
    #[doc = " Tests whether  a matrix is singular (cannot be inverted).\n@param m The matrix object.\n@return True if the matrix is singular."]
    pub AIRealMatrixSingular:
        ::std::option::Option<unsafe extern "C" fn(m: *const AIRealMatrix) -> AIBoolean>,
    #[doc = "\tInitializes a transformation matrix to a single translation.\n@param m The matrix object.\n@param tx New horizontal translation value in document points.\n@param ty New vertical translation value in document points."]
    pub AIRealMatrixSetTranslate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, tx: AIReal, ty: AIReal)>,
    #[doc = "\tInitializes scale values for a transformation matrix.\n@param m The matrix object.\n@param h New horizontal scale value, a percentage where 1 is 100%.\n@param v New vertical scale value, a percentage where 1 is 100%."]
    pub AIRealMatrixSetScale:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, h: AIReal, v: AIReal)>,
    #[doc = "\tInitializes a transformation matrix to a single rotation.\n@param m The matrix object.\n@param angle New angle value in radians."]
    pub AIRealMatrixSetRotate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, angle: AIReal)>,
    #[doc = " Concatenates translation values to the existing translation in a\ntransformation matrix. The matrix must be initialized first.\n@param m The matrix object.\n@param tx New horizontal translation value in document points.\n@param ty New vertical translation value in document points."]
    pub AIRealMatrixConcatTranslate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, tx: AIReal, ty: AIReal)>,
    #[doc = " Concatenates scale values to the existing scale in a\ntransformation matrix. The matrix must be initialized first.\n@param m The matrix object.\n@param h New horizontal scale value.\n@param v New vertical scale value."]
    pub AIRealMatrixConcatScale:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, h: AIReal, v: AIReal)>,
    #[doc = " Concatenates a rotation value to the existing rotation in a\ntransformation matrix. The matrix must be initialized first.\n@param m The matrix object.\n@param angle New angle value in radians."]
    pub AIRealMatrixConcatRotate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix, angle: AIReal)>,
    #[doc = " Creates a new transformation matrix by concatenating one matrix to another.\n@param m The first matrix object.\n@param n The second matrix object.\n@param result [out] A buffer in which to return the result."]
    pub AIRealMatrixConcat: ::std::option::Option<
        unsafe extern "C" fn(
            m: *const AIRealMatrix,
            n: *const AIRealMatrix,
            result: *mut AIRealMatrix,
        ),
    >,
    #[doc = " Inverts a transformation matrix.\n@param m The matrix object.\n@return 3 if the matrix could not be inverted or kNoErr on success."]
    pub AIRealMatrixInvert:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIRealMatrix) -> ai_int16>,
    #[doc = "\tTransforms a point using a transformation matrix.\n@param m The matrix.\n@param a The point.\n@param result [out] A buffer in which to return the result."]
    pub AIRealMatrixXformPoint: ::std::option::Option<
        unsafe extern "C" fn(
            m: *const AIRealMatrix,
            a: *const AIRealPoint,
            result: *mut AIRealPoint,
        ),
    >,
    #[doc = " Transforms a rect using a transformation matrix.\n@param m The matrix.\n@param a The rect.\n@param result [out] A buffer in which to return the result."]
    pub AIRealMatrixXformRect: ::std::option::Option<
        unsafe extern "C" fn(m: *const AIRealMatrix, a: *const AIRealRect, result: *mut AIRealRect),
    >,
    #[doc = "\tConverts an \\c #AIReal value to an \\c #AIFixed value.\n@param r The real value.\n@return The fixed value."]
    pub AIRealToAIFixed: ::std::option::Option<unsafe extern "C" fn(r: AIReal) -> AIFixed>,
    #[doc = " Converts an \\c #AIFixed value to an \\c #AIReal value.\n@param f The fixed value.\n@return The real value."]
    pub AIFixedToAIReal: ::std::option::Option<unsafe extern "C" fn(f: AIFixed) -> AIReal>,
    #[doc = "\tConverts an \\c #AIRealPoint value to an \\c #AIFixedPoint value.\n@param r The real point.\n@param f [out] A buffer in which to return the fixed point."]
    pub AIRealPointToAIFixedPoint:
        ::std::option::Option<unsafe extern "C" fn(r: *const AIRealPoint, f: *mut AIFixedPoint)>,
    #[doc = "\tConverts an \\c #AIFixedPoint value to an \\c #AIRealPoint value.\n@param f The fixed point.\n@param r [out] A buffer in which to return the real point."]
    pub AIFixedPointToAIRealPoint:
        ::std::option::Option<unsafe extern "C" fn(f: *const AIFixedPoint, r: *mut AIRealPoint)>,
    #[doc = "\tConverts an \\c #AIRealRect value to an \\c #AIFixedRect value.\n@param r The real rectangle.\n@param f [out] A buffer in which to return the fixed rectangle."]
    pub AIRealRectToAIFixedRect:
        ::std::option::Option<unsafe extern "C" fn(r: *const AIRealRect, f: *mut AIFixedRect)>,
    #[doc = "\tConverts an \\c #AIFixedRect value to an \\c #AIRealRect value.\n@param f The fixed rectangle.\n@param r [out] A buffer in which to return the real rectangle."]
    pub AIFixedRectToAIRealRect:
        ::std::option::Option<unsafe extern "C" fn(f: *const AIFixedRect, r: *mut AIRealRect)>,
    #[doc = "\tConverts an \\c #AIRealMatrix value to an \\c #AIFixedMatrix value.\n@param r The real matrix.\n@param f [out] A buffer in which to return the fixed matrix."]
    pub AIRealMatrixToAIFixedMatrix:
        ::std::option::Option<unsafe extern "C" fn(r: *const AIRealMatrix, f: *mut AIFixedMatrix)>,
    #[doc = "\tConverts an \\c #AIFixedMatrix value to an \\c #AIRealMatrix value.\n@param f The fixed matrix.\n@param r [out] A buffer in which to return the real matrix."]
    pub AIFixedMatrixToAIRealMatrix:
        ::std::option::Option<unsafe extern "C" fn(f: *const AIFixedMatrix, r: *mut AIRealMatrix)>,
    pub AIFloatMatrixToAIRealMatrix:
        ::std::option::Option<unsafe extern "C" fn(f: *const AIFloatMatrix, r: *mut AIRealMatrix)>,
    pub AIFloatPointToAIRealPoint:
        ::std::option::Option<unsafe extern "C" fn(f: *const AIFloatPoint, r: *mut AIRealPoint)>,
    #[doc = " Tests whether an \\c #AIReal value is \\c #kAIRealUnknown,\nthe special value Illustrator uses to represent unknown quantities.\nThis is sometimes used as a parameter to signal\na special condition; for example, use of a default value.\n@param r The real number.\n@return True if the value is equal to  \\c #kAIRealUnknown."]
    pub IsAIRealUnknown: ::std::option::Option<unsafe extern "C" fn(r: AIReal) -> AIBoolean>,
    #[doc = " Tests whether an \\c #AIReal value is \\c #kAIRealUnknown (\"not a number\").\nThis constant is used for mathematically undefined values such as 0/0.\n@param r The real number.\n@return True if the value is equal to \\c #kAIRealUnknown."]
    pub AIRealIsNAN: ::std::option::Option<unsafe extern "C" fn(r: AIReal) -> AIBoolean>,
    #[doc = " Tests whether two real numbers are within a percentage of one another.\n@param a The first number.\n@param b The second number.\n@param percent A number between 0 and 1, where 1.0 is 100%.\n@return For <code>a > b</code>, true if <code>abs(a) - abs(b) < abs(b) * percent</code>.\n<br>For <code>b > a</code>, true if <code>abs(a) < abs(b) * percent</code>."]
    pub AlmostEqual: ::std::option::Option<
        unsafe extern "C" fn(a: AIReal, b: AIReal, percent: AIReal) -> AIBoolean,
    >,
    #[doc = " Tests whether two real numbers are within a tolerance of one another.\n@param a The first number.\n@param b The second number.\n@param tolerance The tolerance.\n@return True if <code>abs(a-b) <= tolerance</code>"]
    pub EqualWithinTol: ::std::option::Option<
        unsafe extern "C" fn(a: AIReal, b: AIReal, tolerance: AIReal) -> AIBoolean,
    >,
    #[doc = "\tRetrieves the translation values from a transformation matrix.\n@param m The matrix.\n@param tx [out] A buffer in which to return the horizontal translation value.\n@param ty [out] A buffer in which to return the vertical translation value."]
    pub AIRealMatrixGetTranslate: ::std::option::Option<
        unsafe extern "C" fn(m: *const AIRealMatrix, tx: *mut AIReal, ty: *mut AIReal),
    >,
    #[doc = "\tRetrieves the scaling values from a transformation matrix.\n@param m The matrix.\n@param h [out] A buffer in which to return the horizontal scaling value.\n@param v [out] A buffer in which to return the vertical scaling value."]
    pub AIRealMatrixGetScale: ::std::option::Option<
        unsafe extern "C" fn(m: *const AIRealMatrix, h: *mut AIReal, v: *mut AIReal),
    >,
    #[doc = "\tRetrieves the angle of rotation from a transformation matrix.\n@param m The matrix.\n@param angle [out] A buffer in which to return the angle in radians."]
    pub AIRealMatrixGetRotate:
        ::std::option::Option<unsafe extern "C" fn(m: *const AIRealMatrix, angle: *mut AIReal)>,
    #[doc = " Creates a new \\c #AIDoubleRect rectangle that is the union\nof two \\c #AIDoubleRect rectangles.\n@param a The first rectangle.\n@param b The second rectangle.\n@param result [out] A buffer in which to return the result."]
    pub AIDoubleRectUnion: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const AIDoubleRect,
            b: *const AIDoubleRect,
            result: *mut AIDoubleRect,
        ),
    >,
    #[doc = " Restricts an angle to a given range.\n@param angle\t\tThe angle to be restricted in radians.\n@param startAngle\tThe beginning of the range in radians.\nFor startAngle=n, the range is [n, (n + 2 * pi)).\n@return The restricted angle."]
    pub RestrictAngleToRange:
        ::std::option::Option<unsafe extern "C" fn(angle: AIReal, startAngle: AIReal) -> AIReal>,
}
#[doc = " Grayscale color."]
pub const AIColorTag_kGrayColor: AIColorTag = 0;
#[doc = " Solid ink, expressed in four CMYK process colors."]
pub const AIColorTag_kFourColor: AIColorTag = 1;
#[doc = " Color with a pattern from the art's pattern list."]
pub const AIColorTag_kPattern: AIColorTag = 2;
#[doc = " Solid ink, expressed as a custom ink color. See \\c #AICustomColorSuite."]
pub const AIColorTag_kCustomColor: AIColorTag = 3;
#[doc = " Gradient, also called a blend. See \\c #AIGradientSuite."]
pub const AIColorTag_kGradient: AIColorTag = 4;
#[doc = " Solid color, expressed as three RGB values."]
pub const AIColorTag_kThreeColor: AIColorTag = 5;
#[doc = " Null color, If art is painted with \\c kNoneColor, the\n\\c fillPaint or \\c strokePaint of the \\c #AIPathStyle must be false"]
pub const AIColorTag_kNoneColor: AIColorTag = 6;
#[doc = "Advance color can not be represented in AIColor and need to used with parser."]
pub const AIColorTag_kAdvanceColor: AIColorTag = 7;
#[doc = " Types of colors, patterns, and gradients,\nthat can be used to fill or stroke Illustrator art objects."]
pub type AIColorTag = ::std::os::raw::c_uint;
#[doc = " Solid ink, expressed in four process colors"]
pub const AICustomColorTag_kCustomFourColor: AICustomColorTag = 0;
#[doc = " Solid color, expressed as three RGB values."]
pub const AICustomColorTag_kCustomThreeColor: AICustomColorTag = 1;
#[doc = " Lab color. Only valid for spot colors."]
pub const AICustomColorTag_kCustomLabColor: AICustomColorTag = 2;
#[doc = " Defines a named custom color, whose appearance is\ndefined by a color of one of these types. See \\c #AICustomColorSuite."]
pub type AICustomColorTag = ::std::os::raw::c_uint;
#[doc = " Option flags for properties of a named custom color.\nA logical OR of \\c #kCustomSpotColor and \\c #kCustomRegistrationColor."]
pub type AICustomColorFlags = ::std::os::raw::c_short;
#[doc = " A grayscale color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGrayColorStyle {
    pub gray: AIReal,
}
#[doc = " The valid fields of a partial gray color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGrayColorStyleMap {
    pub gray: AIBoolean,
}
#[doc = " A CMYK color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFourColorStyle {
    pub cyan: AIReal,
    pub magenta: AIReal,
    pub yellow: AIReal,
    pub black: AIReal,
}
#[doc = " The valid fields of a partial CMYK color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFourColorStyleMap {
    pub cyan: AIBoolean,
    pub magenta: AIBoolean,
    pub yellow: AIBoolean,
    pub black: AIBoolean,
}
#[doc = " An RGB color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIThreeColorStyle {
    pub red: AIReal,
    pub green: AIReal,
    pub blue: AIReal,
}
#[doc = " The valid fields of a partial RGB color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIThreeColorStyleMap {
    pub red: AIBoolean,
    pub green: AIBoolean,
    pub blue: AIBoolean,
}
#[doc = " A Lab color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILabColorStyle {
    pub l: AIReal,
    pub a: AIReal,
    pub b: AIReal,
}
#[doc = " The valid fields of a partial Lab color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILabColorStyleMap {
    pub l: AIBoolean,
    pub a: AIBoolean,
    pub b: AIBoolean,
}
#[doc = " The union of all possible process colors that can be associated with\na custom color. See \\c #AICustomColorSuite."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AICustomColorUnion {
    #[doc = " A CMYK color"]
    pub f: AIFourColorStyle,
    #[doc = " An RGB color"]
    pub rgb: AIThreeColorStyle,
    #[doc = " A grayscale color"]
    pub gray: AIGrayColorStyle,
    #[doc = " A Lab color"]
    pub lab: AILabColorStyle,
}
#[doc = " A named custom color. A custom color can be a spot (actual ink)\nor a global process color. In either case, it has an associated\nprocess color. See \\c #AICustomColorSuite."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AICustomColor {
    #[doc = " The type of the associated process color (CMYK or RGB)"]
    pub kind: AICustomColorTag,
    #[doc = " The color values, in an appropriate structure."]
    pub c: AICustomColorUnion,
    #[doc = " Option flags for properties of the custom color.\nA logical OR of \\c #kCustomSpotColor and \\c #kCustomRegistrationColor."]
    pub flag: AICustomColorFlags,
}
#[doc = " Opaque reference to a custom color. See \\c #AICustomColorSuite."]
pub type AICustomColorHandle = *mut ::std::os::raw::c_void;
#[doc = " An instance of a custom color paint."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICustomColorStyle {
    #[doc = " Reference to the custom color. See \\c #AICustomColorSuite."]
    pub color: AICustomColorHandle,
    #[doc = " Amount of the custom color to be applied. Value is in the range\n0 to 1 where ((1 - tint) * 100) is the percentage of ink to apply."]
    pub tint: AIReal,
}
#[doc = " The valid fields of a partial custom color paint."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICustomColorStyleMap {
    pub color: AIBoolean,
    pub tint: AIBoolean,
}
#[doc = " Obsolete"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPattern {
    pub not_implemented: AIBoolean,
}
#[doc = " Opaque reference to a pattern.See \\c #AIPatternSuite."]
pub type AIPatternHandle = *mut ::std::os::raw::c_void;
#[doc = " The pattern style record defines a pattern instance, or an application of a\npattern to an art object. The instance includes a reference to the pattern to\nuse in the fill or stroke and information about how it is transformed, such\nas scale value.\n\nWhen a pattern is applied to an object, the pattern's defining art is tiled to\npaint that object. The pattern fill is tiled from the ruler origin rather\nthan relative to the object. Before the tiling is done, the transformations\nin the \\c AIPatternStyle record are applied to the pattern art."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPatternStyle {
    #[doc = " An opaque reference to the pattern object, accessed through the\n\\c #AIPatternSuite, whose functions get and set a patterns name\nand defining art object or objects."]
    pub pattern: AIPatternHandle,
    #[doc = " Distance to translate the unscaled prototype before filling,\nmeasured from the ruler origin."]
    pub shiftDist: AIReal,
    #[doc = " Angle to translate the unscaled prototype before filling,\nin degrees."]
    pub shiftAngle: AIReal,
    #[doc = " Fraction to scale the prototype before filling."]
    pub scale: AIRealPoint,
    #[doc = " Angle to rotate the prototype before filling."]
    pub rotate: AIReal,
    #[doc = " When true, the prototype is reflected before filling"]
    pub reflect: AIBoolean,
    #[doc = " Axis around which to reflect."]
    pub reflectAngle: AIReal,
    #[doc = " Angle to slant the shear by."]
    pub shearAngle: AIReal,
    #[doc = " Axis to shear with respect to."]
    pub shearAxis: AIReal,
    #[doc = " Additional transformation arising from manipulating the path."]
    pub transform: AIRealMatrix,
}
#[doc = " The valid fields of a partial pattern style."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPatternStyleMap {
    pub pattern: AIBoolean,
    pub shiftDist: AIBoolean,
    pub shiftAngle: AIBoolean,
    pub scale: AIBoolean,
    pub rotate: AIBoolean,
    pub reflect: AIBoolean,
    pub reflectAngle: AIBoolean,
    pub shearAngle: AIBoolean,
    pub shearAxis: AIBoolean,
    pub transform: AIBoolean,
}
#[doc = " Opaque reference to a gradient color. See \\c #AIGradientSuite."]
pub type AIGradientHandle = *mut ::std::os::raw::c_void;
#[doc = " The gradient style record defines a gradient instance (also called a blend).\nIt includes a reference to a gradient definition, and the origin point\nand transformation matrix for the blend.\n\nA gradient has a name, and a gradient \\e ramp, which describes where the\ncolor changes of the gradient occur. A gradient can be linear or\nradial. See the \\c #AIGradientSuite. Radial blends have an additional\nattribute called a blend \\e hilight, which is the starting point\nfor the gradient ramp as it expands outward."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGradientStyle {
    #[doc = " An opaque reference to the gradient. Access using functions in the\n\\c #AIGradientSuite. It contains a \\c name, \\c type (linear or radial),\nand a ramp defined by a set of \\e stops."]
    pub gradient: AIGradientHandle,
    #[doc = " \\li For a linear gradient, the origin of the gradient in page coordinates,\nwhich is 0 on the gradient ramp.\n\\li For a radial gradient, the center of the containing circle."]
    pub gradientOrigin: AIRealPoint,
    #[doc = " \\li For a linear gradient, the angle of the gradient in degrees from the X axis.\nThe ramp extends from the origin at this angle. Positive values are counterclockwise.\n\\li Not used for radial gradients, but the value is preserved in case\nthe gradient is changed back to linear."]
    pub gradientAngle: AIReal,
    #[doc = " \\li For a linear gradient, the distance in points over which the gradient ramp\nis applied. The ramp is scaled so that 100% of its value is this length.\n\\li For a radial gradient, the radius of the containing circle."]
    pub gradientLength: AIReal,
    #[doc = " The accumulated transformations of the gradient. It is not necessarily the same\nas the transformation matrix of the object containing the gradient.\nWhen a gradient is first applied to an object, the value is set to the\nidentity matrix. When the user transforms the object, the user\ntransformation matrix is concatenated to the gradient instances matrix."]
    pub matrix: AIRealMatrix,
    #[doc = " \\li For a radial gradient, the angle to the blend highlight point.\n\\li Not used for linear gradients."]
    pub hiliteAngle: AIReal,
    #[doc = " \\li For a radial gradient, the distance of the hilight from the origin\nexpressed as a fraction of the radius, a value between 0 and 1.\n\\li Not used for linear gradients."]
    pub hiliteLength: AIReal,
}
#[doc = " The valid fields of a partial gradient style."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGradientStyleMap {
    pub gradient: AIBoolean,
    pub gradientOrigin: AIBoolean,
    pub gradientAngle: AIBoolean,
    pub gradientLength: AIBoolean,
    pub matrix: AIBoolean,
    pub hiliteAngle: AIBoolean,
    pub hiliteLength: AIBoolean,
}
#[doc = " The union of all possible types of color specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AIColorUnion {
    #[doc = " A grayscale color"]
    pub g: AIGrayColorStyle,
    #[doc = " A CMYK color"]
    pub f: AIFourColorStyle,
    #[doc = " An RGB color"]
    pub rgb: AIThreeColorStyle,
    #[doc = " A custom color"]
    pub c: AICustomColorStyle,
    #[doc = " A pattern"]
    pub p: AIPatternStyle,
    #[doc = " A gradient (blend)"]
    pub b: AIGradientStyle,
}
#[doc = " The valid fields of a partial color union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AIColorUnionMap {
    #[doc = " A grayscale color"]
    pub g: AIGrayColorStyleMap,
    #[doc = " A CMYK color"]
    pub f: AIFourColorStyleMap,
    #[doc = " An RGB color"]
    pub rgb: AIThreeColorStyleMap,
    #[doc = " A custom color"]
    pub c: AICustomColorStyleMap,
    #[doc = " A pattern"]
    pub p: AIPatternStyleMap,
    #[doc = " A gradient (blend)"]
    pub b: AIGradientStyleMap,
}
#[doc = " A color specification, which describes a solid color, pattern, or gradient.\nA color can be partially specified, as when retrieving the common color attributes\nof a collection of objects or when modifying a specific subset of color attributes\nfor one or more objects. When a color is partially specified an associated\n\\c #AIColorMap contains boolean values indicating which fields are valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIColor {
    #[doc = " The type of color being described."]
    pub kind: AIColorTag,
    #[doc = " Contains the detailed specification of the color as appropriate for\nthe \\c kind."]
    pub c: AIColorUnion,
}
#[doc = " The valid fields of a partial color specification. For\nexample, if \\c kind is true, the associated \\c AIColor has\na valid value for \\c kind."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIColorMap {
    pub kind: AIBoolean,
    pub c: AIColorUnionMap,
}
#[doc = " Defines a gradient stop. Each stop is place where the color changes in a blend.\nA set of stops defines the gradient \\e ramp.\nSee \\c #AIGradientStyle and \\c #AIGradientSuite."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIGradientStop {
    #[doc = " The location between two ramp points where there is an equal mix of this\ncolor and the color of the next stop. This value is a percentage of the\ndistance between the two ramp points, between 13 and 87. The midpoint\nfor the previous color stop is not considered."]
    pub midPoint: AIReal,
    #[doc = " The position on the blend ramp where this color begins, in the range\n[0..100]. The first point does not have to be at 0, but the first\ncolor begins at 0. Similarly, the last does not have to be at 100."]
    pub rampPoint: AIReal,
    #[doc = " The type and specification of the color for the gradient stop;\na gray color, a process color, an RGB color, or a custom color."]
    pub color: AIColor,
    #[doc = " The opacity value for the gradient stop, in the range [0,1],\n0 for completely transparent and 1 for completely opaque."]
    pub opacity: AIReal,
}
#[doc = " Result return type for \\c #AIPathStyleSuite::ObjectUsesAIColor()."]
pub type AIColorUsedHow = ::std::os::raw::c_ushort;
#[doc = " The target color is not used."]
pub const AIColorUsedHowValues_kAIColorNotUsed: AIColorUsedHowValues = 0;
#[doc = " The stroke is painted, and is the target \\c #AIColor"]
pub const AIColorUsedHowValues_kAIColorUsedOnStroke: AIColorUsedHowValues = 1;
#[doc = " The fill is painted, and is the target \\c #AIColor"]
pub const AIColorUsedHowValues_kAIColorUsedInFill: AIColorUsedHowValues = 2;
pub const AIColorUsedHowValues_kAIColorUsedIndirectly: AIColorUsedHowValues = 4;
#[doc = " Values for \\c #AIColorUsedHow type, returned from\n\\c #AIPathStyleSuite::ObjectUsesAIColor()."]
pub type AIColorUsedHowValues = ::std::os::raw::c_uint;
#[doc = " Callback function prototype used to iterate through colors, applying a modification\nand returning the modified color.\nThis is used for situations where one component (such as a Color plug-in filter)\nknows how to modify colors, and another component knows how to apply them\nto a specify kind of object or other color collection such as a swatch book.\nSee \\c AIPluginGroup.h and \\c AIPluginSelection.h\nThis supersedes \\c #AIMeshColorMap in \\c AIMesh.h, which is deprecated.\n@param color [in, out] The color to modify and return.\n@param userData A pointer to data needed for the modification.\n@param result [out] A buffer in which to return an error if the iteration should stop.\n(This is a parameter rather than a return value, so that the communication can go both ways.\nIf the component handling the objects wants the component making the color adjustments to stop\nprocessing other objects and report an error back to the user, it should set \\c result to that\nerror code BEFORE calling the callback function.)\n@param altered [out] A buffer in which to return true if the color was modified (and\nshould therefore be applied to the objects or color collection).\n\n@see \\c #AIPluginGroupSuite::PluginArtAdjustColors(), \\c #AIPluginGroupAdjustColorsData"]
pub type AIAdjustColorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        color: *mut AIColor,
        userData: *mut ::std::os::raw::c_void,
        result: *mut AIErr,
        altered: *mut AIBoolean,
    ),
>;
#[doc = " Callback function prototype used to iterate through colors, applying a modification\nand returning the modified color. This version can also access and modify the\noverprint setting for fills and/or strokes.\n@param color [in, out] The color to modify and return.\n@param userData A pointer to data needed for the modification.\n@param result [out] A buffer in which to return an error if the iteration should stop.\n(This is a parameter rather than a return value, so that the communication can go both ways.\nIf the component handling the objects wants the component making the color adjustments to stop\nprocessing other objects and report an error back to the user, it should set \\c result to that\nerror code BEFORE calling the callback function.)\n@param altered [out] A buffer in which to return true if the color or overprint was modified,\n(and should therefore be applied to the objects or color collection).\n@param usedWhere Whether to make overprint changes to fill or stroke.\nEither \\c #kAIColorUsedInFill or \\c #kAIColorUsedOnStroke. For any other\nvalue, overprint is ignored.\n@param overprint [out] A buffer in which to return true if overprint was modified,\n(and should therefore be applied to the objects or color collection)."]
pub type AIAdjustColorsWithOPFunc = ::std::option::Option<
    unsafe extern "C" fn(
        color: *mut AIColor,
        userData: *mut ::std::os::raw::c_void,
        result: *mut AIErr,
        altered: *mut AIBoolean,
        usedWhere: AIColorUsedHow,
        overprint: *mut AIBoolean,
    ),
>;
#[doc = " Callback function prototype used to adjust or extract colors from pattern handles contained\nin the dictionary of an effect or plug-in group. The patterns are expected to be\nbrush patterns, symbol patterns or graph designs; other fill patterns can be recolored\nwith the \\c #AIAdjustColorFunc() callback, passing a pattern \\c #AIColor.\n\nUsed in \\c #AILiveEffectAdjustColorsMessage and \\c #AIPluginGroupAdjustColorsData.\n@param oldPattern [in] The pattern to be examined. This object is not altered.\n@param newPattern [out] A buffer in which to return the pattern after color adjustment.\nIf no colors are changed, contains the input pattern.\n@param userData A pointer to developer-defined data needed for the modification, acquired from the message data."]
pub type AIAdjustPatternHandleFunc = ::std::option::Option<
    unsafe extern "C" fn(
        oldPattern: AIPatternHandle,
        newPattern: *mut AIPatternHandle,
        userData: *mut ::std::os::raw::c_void,
    ) -> AIErr,
>;
#[doc = " Control options for \\c #AIPathStyleSuite::AdjustObjectAIColors()"]
pub type VisitAIColorFlags = ::std::os::raw::c_ushort;
#[doc = "\tSuite\n\n/\n/** @ingroup Suites\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIColorSuite and \\c #kAIColorSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorSuite {
    #[doc = " returns true if colors are equal otherwise false.\n@param color1 : First AIColor\n\n@param color2 : Second AIColor."]
    pub IsEqual: ::std::option::Option<
        unsafe extern "C" fn(color1: *const AIColor, color2: *const AIColor) -> AIBoolean,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAIColorSpaceImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAIColorSpaceListImpl {
    _unused: [u8; 0],
}
pub const AIColorConversionSpaceValue_kAIMonoColorSpace: AIColorConversionSpaceValue = 0;
pub const AIColorConversionSpaceValue_kAIGrayColorSpace: AIColorConversionSpaceValue = 1;
pub const AIColorConversionSpaceValue_kAIRGBColorSpace: AIColorConversionSpaceValue = 2;
pub const AIColorConversionSpaceValue_kAIARGBColorSpace: AIColorConversionSpaceValue = 3;
pub const AIColorConversionSpaceValue_kAICMYKColorSpace: AIColorConversionSpaceValue = 4;
pub const AIColorConversionSpaceValue_kAIACMYKColorSpace: AIColorConversionSpaceValue = 5;
pub const AIColorConversionSpaceValue_kAIAGrayColorSpace: AIColorConversionSpaceValue = 6;
pub const AIColorConversionSpaceValue_kAILabColorSpace: AIColorConversionSpaceValue = 7;
#[doc = " Color spaces that are available for conversion. See \\c #AIColorConversionSuite::ConvertImageColor\nand \\c #AIColorConversionSuite::ConvertSampleColor"]
pub type AIColorConversionSpaceValue = ::std::os::raw::c_uint;
#[doc = " A color sample pixel value. See \\c #AIColorConversionSuite::ConvertSampleColorEx()."]
pub type AISampleComponent = AIReal;
pub type AIFloatSampleComponent = AIFloat;
#[doc = " An image pixel value. See \\c #AIColorConversionSuite::ConvertImageColorEx()."]
pub type AIImageComponent = ::std::os::raw::c_uchar;
#[doc = " Color-space conversion options. When converting CMYK to gray or RGB for\npreview or export, the constructor sets the appropriate black preservation\nvalue-- that is, whether a CMYK to RGB/Gray color transformation maps\nCMYK 0,0,0,1 to the darkest black:\n\\li By default, the operation uses the standard conversion,\nwhich never uses black preservation.\n\\li For export, the operation uses the black-preservation setting\nthat is currently configured in the print and export preferences.\n\\li For preview, the operation uses the black-preservation setting\nthat is currently configured in the screen-display preferences."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorConvertOptions {
    #[doc = " The purpose for performing a color-space conversion.\n\\c #kDefault, \\c #kForPreview or \\c #kForExport"]
    pub purpose: AIColorConvertOptions_Purpose,
}
#[doc = " Do standard conversion, without black preservation."]
pub const AIColorConvertOptions_Purpose_kDefault: AIColorConvertOptions_Purpose = 0;
#[doc = " Use conversion options appropriate to creating an image\nfor screen display."]
pub const AIColorConvertOptions_Purpose_kForPreview: AIColorConvertOptions_Purpose = 1;
#[doc = " Use conversion options appropriate to creating an image\nfor print or export."]
pub const AIColorConvertOptions_Purpose_kForExport: AIColorConvertOptions_Purpose = 2;
#[doc = " Use conversion options appropriate to creating an image\nfor print or export."]
pub const AIColorConvertOptions_Purpose_kDummy: AIColorConvertOptions_Purpose = 4294967295;
#[doc = " The purpose for performing a color-space conversion."]
pub type AIColorConvertOptions_Purpose = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nProvides functions for converting color values and image sample values\nbetween color spaces.\n\n\\li If color management is on, the functions use the document profile if it has one,\notherwise they use the profiles from the Color Settings dialog.\n\\li If color management is off, the functions perform device conversions.\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIColorConversionSuite and \\c #kAIColorConversionVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorConversionSuite {
    #[doc = " Converts a sample-component color from one color space to another.\n(This version uses colorspace data types.)\n@param srcSpace The source color space.\n@param srcColor The color to convert, a color sample object.\n@param dstSpace The destination color space.\n@param dstColor [out] A buffer in which to return the converted color sample object.\n@param options The options structure appropriate to the purpose\nof the conversion (preview or export). See \\c #AIColorConvertOptions.\n@param inGamut [out] A buffer in which to return true if the source color was\nwithin the gamut of the destination space. Can be \\c NULL."]
    pub ConvertSampleColorEx: ::std::option::Option<
        unsafe extern "C" fn(
            srcSpace: *const ai_ColorSpace,
            srcColor: *mut AIFloatSampleComponent,
            dstSpace: *const ai_ColorSpace,
            dstColor: *mut AIFloatSampleComponent,
            options: *const AIColorConvertOptions,
            inGamut: *mut ASBoolean,
        ) -> AIErr,
    >,
    #[doc = " Converts an array of image pixels from one color space to another.\n(This version uses the colorspace data type and specific bits-per-pixel values.)\n@param srcSpace The source color space.\n@param srcBitsPerPixel The bits-per-pixel in the source color.\n@param srcColor The color to convert, an array containing the number of pixels\nspecified by \\c pixelCount, using the bits-per-pixel specified by \\c srcBitsPerPixel.\n@param dstSpace The destination color space.\n@param dstBitsPerPixel The bits-per-pixel in the destination color.\n@param dstColor [out] A buffer in which to return the converted image, an array big enough\nto contain the number of pixels specified by \\c pixelCount, using the bits-per-pixel\nspecified by \\c dstBitsPerPixel.\n@param pixelCount The number of pixels in the image.\n@param flags To specify that the bits of a 1-bit color space (\\c #kAIMonoColorSpace)\nare inverted, pass the constant \\c kRasterInvertBits.\n@param options The options structure appropriate to the purpose\nof the conversion (preview or export). See \\c #AIColorConvertOptions."]
    pub ConvertImageColorEx: ::std::option::Option<
        unsafe extern "C" fn(
            srcSpace: *const ai_ColorSpace,
            srcBitsPerPixel: ai_int32,
            srcColor: *mut AIImageComponent,
            dstSpace: *const ai_ColorSpace,
            dstBitsPerPixel: ai_int32,
            dstColor: *mut AIImageComponent,
            pixelCount: ai_int32,
            flags: ai_uint16,
            options: *const AIColorConvertOptions,
        ) -> AIErr,
    >,
    #[doc = " Converts a sample-component color from one color space to another.\n@param srcSpace The source color space, an \\c #AIColorConversionSpaceValue.\n@param srcColor The color to convert, an array containing the number of color\nvalues appropriate to the source color space.\n@param dstSpace The destination color space, an \\c #AIColorConversionSpaceValue.\n@param dstColor [out] A buffer in which to return the converted color, an array big enough\nto hold the number of color values appropriate to the destination color space.\n@param options The options structure appropriate to the purpose\nof the conversion (preview or export). See \\c #AIColorConvertOptions.\n@param inGamut [out] A buffer in which to return true if the source color was\nwithin the gamut of the destination space."]
    pub ConvertSampleColor: ::std::option::Option<
        unsafe extern "C" fn(
            srcSpace: ai_int32,
            srcColor: *mut AIFloatSampleComponent,
            dstSpace: ai_int32,
            dstColor: *mut AIFloatSampleComponent,
            options: *const AIColorConvertOptions,
            inGamut: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Converts an array of image pixels from one color space to another.\n@param srcSpace The source color space, an \\c #AIColorConversionSpaceValue.\n@param srcColor The color to convert, an array containing the number of pixels\nspecified by \\c pixelCount, where each pixel contains the number of color\nvalues appropriate to the source color space.\n@param dstSpace The destination color space, an \\c #AIColorConversionSpaceValue.\n@param dstColor [out] A buffer in which to return the converted color, an array big enough\nto hold \\c pixelCount pixels using the number of color values appropriate to the\ndestination color space.\n@param pixelCount The number of pixels in the source image.\n@param flags To specify that the bits of a 1-bit color space (\\c #kAIMonoColorSpace)\nare inverted, pass the constant \\c kRasterInvertBits.\n@param options The options structure appropriate to the purpose\nof the conversion (preview or export). See \\c #AIColorConvertOptions."]
    pub ConvertImageColor: ::std::option::Option<
        unsafe extern "C" fn(
            srcSpace: ai_int32,
            srcColor: *mut AIImageComponent,
            dstSpace: ai_int32,
            dstColor: *mut AIImageComponent,
            pixelCount: ai_int32,
            flags: ai_uint16,
            options: *const AIColorConvertOptions,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nUse the functions in this suite to access, create, delete, and modify\ncustom colors. Custom colors represent both spot colors and global process colors.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAICustomColorSuite and \\c #kAICustomColorVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICustomColorSuite {
    #[doc = " Creates a new custom color. The color is not added to the swatch list.\n@param color The color specification.\n@param name The color name. The PostScript/PDF language reserves the names\n\\c All, \\c None, \\c Cyan, \\c Magenta, \\c Yellow and \\c Black.\nThese names cannot be used for spot colors.\n@param customColor [out] A buffer in which to return the new custom color reference."]
    pub NewCustomColor: ::std::option::Option<
        unsafe extern "C" fn(
            color: *mut AICustomColor,
            name: *const ai_UnicodeString,
            customColor: *mut AICustomColorHandle,
        ) -> AIErr,
    >,
    #[doc = " Deletes a custom color. Deletes it from the swatches palette if present\nand replaces any usages by the process equivalent.\n@param customColor The custom color reference. Upon return, this reference is invalid."]
    pub DeleteCustomColor:
        ::std::option::Option<unsafe extern "C" fn(customColor: AICustomColorHandle) -> AIErr>,
    #[doc = " Retrieves the color specification from a custom color, which includes the CMYK or\nRGB values.\n@param customColor The custom color reference.\n@param color [out] A buffer in which to return the color information."]
    pub GetCustomColor: ::std::option::Option<
        unsafe extern "C" fn(customColor: AICustomColorHandle, color: *mut AICustomColor) -> AIErr,
    >,
    #[doc = " Sets the color specification for a custom color, which includes the CMYK or\nRGB values.\n@param customColor The custom color reference.\n@param color The new color information."]
    pub SetCustomColor: ::std::option::Option<
        unsafe extern "C" fn(customColor: AICustomColorHandle, color: *mut AICustomColor) -> AIErr,
    >,
    #[doc = " Retrieves the unique name of a custom color.\n@param customColor The custom color reference.\n@param name [out] A buffer in which to return the color name."]
    pub GetCustomColorName: ::std::option::Option<
        unsafe extern "C" fn(
            customColor: AICustomColorHandle,
            name: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Sets the name of a custom color.\n@param customColor The custom color reference.\n@param name The new name. The PostScript/PDF language reserves the names\n\\c All, \\c None, \\c Cyan, \\c Magenta, \\c Yellow and \\c Black.\nThese names cannot be used for spot colors."]
    pub SetCustomColorName: ::std::option::Option<
        unsafe extern "C" fn(
            customColor: AICustomColorHandle,
            name: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "  Gets the number  of defined custom colors currently available.\nUse with \\c #GetNthCustomColor() to iterate through the list of custom colors.\n@param count [out] A buffer in which to return the number of custom colors."]
    pub CountCustomColors:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = "  Retrieves a custom color by position index.\nUse with \\c #CountCustomColors() to iterate through the list of custom colors.\n@param n The position index, in the range <code>[0..numColors-1]</code>.\n@param customColor [out] A buffer in which to return the custom color reference."]
    pub GetNthCustomColor: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, customColor: *mut AICustomColorHandle) -> AIErr,
    >,
    #[doc = "  Retrieves a custom color by name.\n@param name The name.\n@param customColor [out] A buffer in which to return the custom color reference."]
    pub GetCustomColorByName: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ai_UnicodeString,
            customColor: *mut AICustomColorHandle,
        ) -> AIErr,
    >,
    #[doc = " Generates a unique name for a custom color If the specified base name does not already exist,\nit is returned. If the base name already exists, the function concatenates the string\n\\c \"\\nxxx\", where \\c xxx is an integer, starting at 000 and incrementing as necessary\nto create a unique name. This allows you to keep track of multiple versions of the\nsame color name..\n@param name [in, out] A string containing the base name. The string is modified\nin place if needed."]
    pub NewCustomColorName:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " @deprecated This function is now a no-op. An earlier version of Illustrator\nstored unique internal names for custom colors different from those displayed in the UI."]
    pub GetCustomColorDisplayName:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = "  Retrieves the custom color currently used as the registration color.\n@param customColor [out] A buffer in which to return the custom color reference."]
    pub GetCurrentRegistrationColor:
        ::std::option::Option<unsafe extern "C" fn(customColor: *mut AICustomColorHandle) -> AIErr>,
    #[doc = " Retrieves the registration color for the current document, or\ncreates a new registration color if needed, using default values.\nIgnores the color and kind input parameters.\n@param customColor [out] A buffer in which to return the\ncurrent registration color, or the new registration color."]
    pub NewRegistrationColor: ::std::option::Option<
        unsafe extern "C" fn(
            customColor: *mut AICustomColorHandle,
            cyan: AIReal,
            magenta: AIReal,
            yellow: AIReal,
            black: AIReal,
            kind: AICustomColorTag,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a custom color handle represents a valid custom\ncolor in the current document. (Note that this function returns a\nboolean value, not an error code.)\n@param customColor The custom color reference.\n@return True if the reference is valid."]
    pub ValidateCustomColor:
        ::std::option::Option<unsafe extern "C" fn(customColor: AICustomColorHandle) -> AIBoolean>,
    #[doc = " Reports whether a custom color is a spot color that is used by a linked file.\nIf this is the case it cannot be modified. (Note that this function returns a\nboolean value, not an error code.)\n@param customColor The custom color reference.\n@return True if the custom color is used externally."]
    pub HasExternalUses:
        ::std::option::Option<unsafe extern "C" fn(customColor: AICustomColorHandle) -> AIBoolean>,
    #[doc = " Converts a tint of a custom color to its closest non-global approximation\nthat is consistent with the document color model. For example,\nin a CMYK document, Lab and RGB based spot colors are converted\nto CMYK.\n\\li If the custom color is a global process color, the returned color\nis the process\nequivalent.\n\\li If the custom color is a spot color, the returned color\nis the process approximation\nof the appearance of the spot color.\n\\li If the custom color is a registration color, the returned color\nis the process color used to represent the registration color.\n\n@param customColor  The custom color reference.\n@param tint The amount of the color used in paint, a percentage value\nin the range [0..1], where 0 is full tint and 1 is white.\n@param color [out] A buffer in which to return the converted color."]
    pub ConvertToNonGlobal: ::std::option::Option<
        unsafe extern "C" fn(
            customColor: AICustomColorHandle,
            tint: AIReal,
            color: *mut AIColor,
        ) -> AIErr,
    >,
    #[doc = " Converts a tint of a custom color to its best appearance approximation,\na color that approximates the way the custom color looks.\n\\li For global process colors, returns the process color with the given tint.\n\\li For spot colors, returns a color that approximates the appearance of the\ntint of the spot ink.\n\nThis differs from \\c #ConvertToNonGlobal() in that the resulting color\nneed not be consistent with the document color model.\n@param customColor  The custom color reference.\n@param tint The amount of the color used in paint, a percentage value\nin the range [[0..1], where 0 is full tint and 1 is white.\n@param space [out] A buffer in which to return the color space, a\n\\c #AIColorConversionSpaceValue.\n@param color [out] A buffer in which to return the converted color."]
    pub GetAppearanceApproximation: ::std::option::Option<
        unsafe extern "C" fn(
            customColor: AICustomColorHandle,
            tint: AIReal,
            space: *mut ai_int32,
            values: *mut AIFloatSampleComponent,
        ) -> AIErr,
    >,
    #[doc = " Sets the book id for global spot color. If color is not spot then this method\nreturns an error.\n@param customColor  The custom color reference.\n@param bookid The custom color source book id."]
    pub SetCustomColorBookID: ::std::option::Option<
        unsafe extern "C" fn(customColor: AICustomColorHandle, bookid: ai_int32) -> AIErr,
    >,
    #[doc = " Gets the source book id for global spot color. If color is not spot then this\nmethod returns -1\n@param customColor  The custom color reference."]
    pub GetCustomColorBookID:
        ::std::option::Option<unsafe extern "C" fn(customColor: AICustomColorHandle) -> ai_int32>,
}
#[doc = " @ingroup Suites\nThis suite provides basic memory management for PICA (the Adobe plug-in manager)\nand defines the basic functions for acquiring and releasing other suites.\n\nA suite consists of a list of function pointers. The application, or a\nplug-in that loads a suite, provides valid pointers when the suite is\nacquired. When a suite is not available, the pointers are set to the\naddress of the \\c #Undefined() function.\n\nDo not attempt to acquire a suite (other than the \\c #SPBlocksSuite)\nin response to a PICA access (\\c #kSPAccessCaller) or property\n(\\c #kSPPropertiesCaller) message. Most suites are unavailable\nduring these load and unload operations.\n\nYou can acquire all the suites you will need when your plug-in is first\nloaded, as long as you release them before your plug-in is unloaded.\nAt shutdown, however, it is most efficient to acquire only those\nsuites explicitly needed to shut down; for example, to free memory\nand save preferences.\n\nThe \\c SPBasicSuite itself is a part of the message data passed\nto your plug-in with any call. To access it from the message data structure:\n@code\nSPBasicSuite sBasic = message->d.basic;\nsBasic->function( )\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPBasicSuite {
    #[doc = " Acquires a function suite. Loads the suite if necessary,\nand increments its reference count. For example:\n@code\nSPErr error;\nSPBasicSuite *sBasic = message->d.basic;\nAIRandomSuite *sRandom;\nsBasic->AcquireSuite( kAIRandomSuite, kAIRandomVersion, &sRandom );\n@endcode\n@param name The suite name.\n@param version The suite version number.\n@param suite [out] A buffer in which to return the suite pointer.\n@see \\c #SPSuitesSuite::AcquireSuite()"]
    pub AcquireSuite: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            version: ai_int32,
            suite: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Decrements the reference count of a suite and unloads it when the\nreference count reaches 0.\n@param name The suite name.\n@param version The suite version number."]
    pub ReleaseSuite: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char, version: ai_int32) -> SPErr,
    >,
    #[doc = " Compares two strings for equality.\n@param token1 The first null-terminated string.\n@param token2 The second null-terminated string.\n@return True if the strings are the same, false otherwise."]
    pub IsEqual: ::std::option::Option<
        unsafe extern "C" fn(
            token1: *const ::std::os::raw::c_char,
            token2: *const ::std::os::raw::c_char,
        ) -> SPBoolean,
    >,
    #[doc = " Allocates a block of memory.\n@param size The number of bytes.\n@param block [out] A buffer in which to return the block pointer.\n@see \\c #SPBlocksSuite::AllocateBlock()"]
    pub AllocateBlock: ::std::option::Option<
        unsafe extern "C" fn(size: usize, block: *mut *mut ::std::os::raw::c_void) -> SPErr,
    >,
    #[doc = " Frees a block of memory allocated with \\c #AllocateBlock().\n@param block The block pointer.\n@see \\c #SPBlocksSuite::FreeBlock()"]
    pub FreeBlock:
        ::std::option::Option<unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> SPErr>,
    #[doc = " Reallocates a block previously allocated with \\c #AllocateBlock().\nIncreases the size without changing the location, if possible.\n@param block The block pointer.\n@param newSize The new number of bytes.\n@param newblock [out] A buffer in which to return the new block pointer.\n@see \\c #SPBlocksSuite::ReallocateBlock()"]
    pub ReallocateBlock: ::std::option::Option<
        unsafe extern "C" fn(
            block: *mut ::std::os::raw::c_void,
            newSize: usize,
            newblock: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " A function pointer for unloaded suites. This is a protective measure\nagainst other plug-ins that may mistakenly use the suite after they have\nreleased it.\n\nA plug-in that exports a suite should unload the suite's procedure pointers\nwhen it is unloaded, and restore them when the plug-in is reloaded.\n\\li On unload, replace the suite's procedure pointers\nwith the address of this function.\n\\li On reload, restore the suite's procedure\npointers with the updated addresses of their functions.\n\nFor example:\n@code\nSPErr UnloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = (void *) message->d.basic->Undefined;\nmySuite->functionB = (void *) message->d.basic->Undefined;\n}\n\nSPErr ReloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = functionA;\nmySuite->functionB = functionB;\n}\n@endcode"]
    pub Undefined: ::std::option::Option<unsafe extern "C" fn() -> SPErr>,
}
#[doc = " A basic message, sent with \\c #kSPInterfaceCaller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPInterfaceMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
}
#[doc = " Suite\n\n/\n/** @ingroup Suites\nThis suite provides is the ability for a plug-in to call\nother plug-ins, by sending a message to the main entry point.\nThis is how the application communicates with plug-ins.\n\nUse \\c #SetupMessageData() to prepare the message for a call,\n\\c #SendMessage() to send the call with the message, and\n\\c #EmptyMessageData() to terminate the operation, allowing\nPICA to release the basic suite and store global variables.\n\nThese calls work only with PICA plug-ins. Before making the calls,\nuse  \\c #SPAdaptersSuite::GetAdapterName() to determine that\nthe target is a PICA plug-in.  For non-PICA plug-ins, use the\ninterface suite provided by the adapter. See \\c #SPAdaptersSuite.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kSPInterfaceSuite and \\c #kSPInterfaceSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPInterfaceSuite {
    #[doc = " Sends a message to a PICA plug-in, loading it if needed and\npassing the caller, selector, and message to the main entry point.\n@param plug-in The target plug-in object.\n@param caller The caller constant. See @ref Callers.\n@param selector The selector constant. See @ref Selectors.\n@param message The message, initialized by \\c #SetupMessageData().\n@param result [out] A buffer in which to return the result of the call,\nas returned by the target plug-in."]
    pub SendMessage: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            caller: *const ::std::os::raw::c_char,
            selector: *const ::std::os::raw::c_char,
            message: *mut ::std::os::raw::c_void,
            result: *mut SPErr,
        ) -> SPErr,
    >,
    #[doc = " Initializes a message to be sent with \\c #SendMessage().\nThe function fills in the basic suite, the plug-in reference,\nand the globals pointer that PICA keeps for that plug-in.\nYou must provide any additional data needed.\n@param plugin The target plug-in object.\n@param data The message structure, initialized with data required\nfor the intended call."]
    pub SetupMessageData: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, data: *mut SPMessageData) -> SPErr,
    >,
    #[doc = " Terminates a call to another plug-in, releasing the basic suite and\nupdating the target plug-in's globals pointer, in case it has changed.\nUse after a call to \\c #SendMessage().\n@param plugin The target plug-in object.\n@param data The message structure, updated during the call."]
    pub EmptyMessageData: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, data: *mut SPMessageData) -> SPErr,
    >,
    #[doc = " Starts up the plug-in in a plug-in list that exports a given suite.\nSearches in the given plug-in list for the plug-in that exports the named\nsuite, and, if found, sends it the startup message.\n@param pluginList The plug-in list object. Access PICA's global plug-in\nlist using \\c #SPRuntimeSuite::GetRuntimePluginList(),\nor create your own lists with \\c #SPPluginsSuite::AllocatePluginList().\n@param name The suite name constant.\n@param version The suite version number constant.\n@param started [out] A buffer in which to return true (non-zero) if a\nplug-in that exports the suite was found, false (0) if not."]
    pub StartupExport: ::std::option::Option<
        unsafe extern "C" fn(
            pluginList: SPPluginListRef,
            name: *const ::std::os::raw::c_char,
            version: ai_int32,
            started: *mut ai_int32,
        ) -> SPErr,
    >,
}
#[doc = "\tWhen  true (the default for plug-in filters) Illustrator automatically\nselects any artwork a plug-in modifies while running,\nand that art remains selected when the plug-in finishes running.\nAny artwork that was in a selected state on entry but not touched by the\nplug-in is deselected.\n\nWhen false (the default for all other plug-ins) the plug-in handles\nthe selection and deselection of artwork before exit."]
pub const AIPluginOptions_kPluginWantsResultsAutoSelectedOption: AIPluginOptions = 2;
#[doc = " When true, retains the state of partially selected path objects in the plug-in\nwhen an Undo operation is performed.\n\nWhen false (the default), when a plug-in edits a partially selected path object\nand the edit is undone, Illustrator does not retain the partial selection\nstate that existed prior to the edit."]
pub const AIPluginOptions_kPluginWantsPartialPathSelectionOption: AIPluginOptions = 4;
#[doc = "When true, Plugin will participate in the Ai'Fast Exit framework and all shutdown sequence notifiers and messages are not sent to the plugin.\ne.g. kAIPluginStoppingNotifier and kAIApplicationShutdownNotifier Notifiers\nand Messages\nwith (caller = kSPInterfaceCaller, selector = kSPInterfaceCaller) and\nwith (caller = kSPAccessCaller, selector = kSPAccessUnloadSelector)\nare not sent to the plugin.\n\nIt is expected that these plugins registers for kAISaveUserDataNotifier notifier and only saves persistent data in this notifier.\nPlugin *must not* cleanup any resource in this notifier handler. e.g. Plugin must not delete any object,\ndestroy any thread or free up memory etc. in this notifier.\n\nAfter kAISaveUserDataNotifier message is sent, app will quit immediately and resources will be released to the OS automatically."]
pub const AIPluginOptions_kPluginWantsFastExitOption: AIPluginOptions = 8;
#[doc = " Options available to plug-ins."]
pub type AIPluginOptions = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThese functions access Illustrator-specific plug-in options, and allow\nIllustrator plug-ins to send messages to one another.\n\n@note The original version of this suite, version 2, has been largely replaced by\nthe PICA \\c #SPPluginsSuite, a core suite available to other Adobe applications.\nUse that suite to access the plug-in list, identify their type and location, and so on.\nSimilarly, it is better to use the PICA \\c #SPInterfaceSuite to send messages.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPluginSuite and \\c #kAIPluginSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginSuite {
    #[doc = " Retrieves the Illustrator-specific options for a plug-in.\n@param plugin The plug-in reference.\n@param options [out] A buffer in which to return the options,\nan #AIPluginOptions value."]
    pub GetPluginOptions: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the Illustrator-specific options for a plug-in.\n@param plugin The plug-in reference.\n@param options The new options, an #AIPluginOptions value."]
    pub SetPluginOptions: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, options: ai_int32) -> AIErr,
    >,
    #[doc = " Sets up data for sending a message to another plug-in.\n@param plug-in The destination plug-in.\n@param data A pointer to the message data.\n@see \\c #CallPlugin()"]
    pub SetupPluginData: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, data: *mut ::std::os::raw::c_void) -> AIErr,
    >,
    #[doc = " Sends a message to the main entry point of another Illustrator plug-in.\nFor example:\n@code\n// The plug-in reference for the plug-in to call.\nSPPluginRef somePlugin;\n// A plug-in message structure, contains an SPMessageData as first member.\nAISomePluginMessage message;\n\n// fill out the message structure\nerror = sAIPluginSetupPluginData(somePlugin, &message.d);\n// send the message to the plug-in\nif (!error)\nerror = sAIPluginCallPlugin(somePlugin, kSomePluginSelector, &message );\n// release the message data memory.\nif (!error)\nerror = sAIPluginEmptyPluginData(somePlugin, &message.d);\n@endcode\n@param plugin The destination plug-in.\n@param selector\tThe selector for the destination plug-in, see @ref Selectors.\n@param message The message, of the type suitable for the selector.\n@note It is recommended that you use the newer PICA \\c #SPInterfaceSuite to send messages."]
    pub CallPlugin: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            selector: *const ::std::os::raw::c_char,
            message: *mut ::std::os::raw::c_void,
        ) -> AIErr,
    >,
    #[doc = " Ensures that the destination plug-in's global data (as sent in \\c #SPMessageData::globals)\nis properly stored back into the plug-in that modified it when responding to the message.\n@param plugin The destination plug-in.\n@param data A pointer to the message data.\n@note It is recommended that you use the newer PICA \\c #SPInterfaceSuite to send messages."]
    pub EmptyPluginData: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, data: *mut ::std::os::raw::c_void) -> AIErr,
    >,
}
#[doc = "\t@ingroup Suites\nThis suite provides utilities that allow you to create and manipulate\nUnicode strings.\n@note It is recommended that you use the wrapper class, \\c #ai::UnicodeString,\nrather than calling these functions directly.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUnicodeStringSuite and \\c #kAIUnicodeStringVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUnicodeStringSuite {
    #[doc = " Initializes a Unicode string with the contents of a C string.\n@param str [out] A buffer in which to return the Unicode string.\n@param string The C string.\n@param srcByteLen The number of bytes in the C string.\n@param encoding The encoding type for the new string."]
    pub Initialize: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            string: *const ::std::os::raw::c_char,
            srcByteLen: ai_UnicodeString_offset_type,
            encoding: AICharacterEncoding,
        ) -> AIErr,
    >,
    #[doc = " Initializes a Unicode string with the contents of a UTF-16 encoded string.\n@param str [out] A buffer in which to return the Unicode string.\n@param utfs The UTF-16 encoded string, an array UTF-16 code units.\n@param srcUTF16Count The number of UTF-16 code units to be taken from the source string.\nA value of \\c npos mean that the source string is 0-terminated."]
    pub InitializeUTF16: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            utfs: *const ASUnicode,
            srcUTF16Count: ai_UnicodeString_offset_type,
        ) -> AIErr,
    >,
    #[doc = " Initializes a Unicode string with a single UTF-32 code point (character) repeated a\ngiven number of times.\n@param str [out] A buffer in which to return the Unicode string.\n@param count The number of characters.\n@param ch The UTF code point."]
    pub InitializeUTF32Char: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            count: ai_UnicodeString_offset_type,
            ch: ai_UnicodeString_UTF32TextChar,
        ) -> AIErr,
    >,
    #[doc = " Deletes the contents of a Unicode string, and reset it to an uninitialized state.\nAny pointers to UTF-16 buffers derived from that string become invalid.\n@param str The string."]
    pub Destroy: ::std::option::Option<unsafe extern "C" fn(str_: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Appends one Unicode string to another.\n@param str The string to append to.\n@param str2 The string to append."]
    pub Append: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, str2: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Appends a sub-string of one Unicode string to another.\n@param str The string to append to.\n@param str2 The source string for the substring to append.\n@param startOffset The 0-based character offset for the substring.\n@param count the maximum number of characters for the substring."]
    pub AppendSubString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> AIErr,
    >,
    #[doc = " Assigns one Unicode string to another.\n@param str The destination string.\n@param str2 The source string."]
    pub Assign: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, str2: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Copies one Unicode string into another.\n@param str The destination string.\n@param str2 The source string. If empty or uninitialized,\nthe destination string is truncated."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, str2: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the UTF-32 code point at an index position in a Unicode string.\n@param str The string.\n@param position The 0-based character offset for the character.\n@param ch [out] A buffer in which to return the character.\n@return An error if the given position is not a valid offset into\nthe string."]
    pub GetChar: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            position: ai_UnicodeString_size_type,
            ch: *mut ai_UnicodeString_UTF32TextChar,
        ) -> AIErr,
    >,
    #[doc = " Clears the contents of a Unicode string. An uninitialized string remains unchanged.\n(Note that this function does not return an error code.)\n@param str The string."]
    pub Clear: ::std::option::Option<unsafe extern "C" fn(str_: *mut ai_UnicodeString)>,
    #[doc = " Compares substrings in two Unicode strings. Uninitialized strings\nare equal to other uninitialized strings and empty strings, and are less\nthan initialized, non-empty strings.\n(Note that this function returns a numeric value, not an error code.)\n@param str The first string (left side of compare).\n@param pos The 0-based offset for the first character of the first substring.\n@param num The number of characters in the first substring.\n@param str2 The second string (right side of compare).\n@param startOffset The 0-based offset for the first character of the second substring.\n@param count The number of characters in the second substring.\n@return 0 if the substrings are equal.\n<br> Positive if the first substring is greater than the second.\n<br> Negative if the second substring is greater than the first."]
    pub Compare: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            pos: ai_UnicodeString_size_type,
            num: ai_UnicodeString_size_type,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_int32,
    >,
    #[doc = " Convert the characters in this to lower case following the conventions of\n the default locale.\n @param UnicodeString to modify via reference\n @return nothing."]
    pub toLower: ::std::option::Option<unsafe extern "C" fn(src: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Convert the characters in this to upper case following the conventions of\n the default locale.\n @param UnicodeString to modify via reference\n @return nothing."]
    pub toUpper: ::std::option::Option<unsafe extern "C" fn(src: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Performs a caseless comparison of substrings in two Unicode strings.\nStrings are case folded in a locale-independent manner prior to comparison.\nUninitialized strings are equal to other uninitialized strings and\nempty strings, and are less than initialized, non-empty strings.\n(Note that this function returns a numeric value, not an error code.)\n@param str The first string (left side of compare).\n@param pos The 0-based offset for the first character of the first substring.\n@param num The number of characters in the first substring.\n@param str2 The second string (right side of compare).\n@param startOffset The 0-based offset for the first character of the second substring.\n@param count The number of characters in the second substring.\n@return 0 if the substrings are equal.\n<br> Positive if the first substring is greater than the second.\n<br> Negative if the second substring is greater than the first."]
    pub CaseCompare: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            pos: ai_UnicodeString_size_type,
            num: ai_UnicodeString_size_type,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_int32,
    >,
    #[doc = " Performs a normalized comparison of substrings in two Unicode strings.\nUninitialized strings are equal to other uninitialized strings and\nempty strings, and are less than initialized, non-empty strings.\n(Note that this function returns a numeric value, not an error code.)\n@param str The first string (left side of compare).\n@param pos The 0-based offset for the first character of the first substring.\n@param num The number of characters in the first substring.\n@param str2 The second string (right side of compare).\n@param startOffset The 0-based offset for the first character of the second substring.\n@param count The number of characters in the second substring.\n@return 0 if the substrings are equal.\n<br> Positive if the first substring is greater than the second.\n<br> Negative if the second substring is greater than the first."]
    pub CanonicalCompare: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            compareResult: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Performs a normalized, caseless comparison of substrings in two Unicode strings.\nStrings are case folded in a locale-independent manner prior to comparison.\nUninitialized strings are equal to other uninitialized strings and\nempty strings, and are less than initialized, non-empty strings.\n(Note that this function returns a numeric value, not an error code.)\n@param str The first string (left side of compare).\n@param pos The 0-based offset for the first character of the first substring.\n@param num The number of characters in the first substring.\n@param str2 The second string (right side of compare).\n@param startOffset The 0-based offset for the first character of the second substring.\n@param count The number of characters in the second substring.\n@return 0 if the substrings are equal.\n<br> Positive if the first substring is greater than the second.\n<br> Negative if the second substring is greater than the first."]
    pub CanonicalCaseCompare: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            compareResult: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the number of UTF-32 code points (characters) in a Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string.\n@return The number of characters, 0 for an uninitialized or empty string."]
    pub Length: ::std::option::Option<
        unsafe extern "C" fn(str_: *const ai_UnicodeString) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Reports whether a Unicode string is empty.\n(Note that this function returns a boolean value, not an error code.)\n@param str The string.\n@return True if the string is uninitialized or empty."]
    pub Empty:
        ::std::option::Option<unsafe extern "C" fn(str_: *const ai_UnicodeString) -> AIBool8>,
    #[doc = " Erases characters from a Unicode string.\n@param str The string, which is modified in place.\n@param startOffset The 0-based index of the first character to erase.\n@param count The maximum number of characters to erase.\n@return An error if the given position index is not a valid offset into the string."]
    pub Erase: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> AIErr,
    >,
    #[doc = " Searches for the first occurrence of a character in a substring of a Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string.\n@param ch The character to search for.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub FindChar: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            ch: ai_UnicodeString_UTF32TextChar,
            startOffset: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches for the first occurrence of an entire string within a substring of a Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@return The 0-based character index of the found string,\nor \\c npos if the string is not found."]
    pub FindString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches for the first occurrence of a substring of one Unicode string within\na substring of another Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The maximum number of characters within \\c str2 to search for.\n@return The 0-based character index of the found string,\nor \\c npos if the string is not found."]
    pub FindSubString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches for the first occurrence of a substring of one Unicode string within\na substring of another Unicode string, performing a caseless comparison.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The maximum number of characters within \\c str2 to search for.\n@return The 0-based character index of the found string,\nor \\c npos if the string is not found."]
    pub CaseFindSubString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = "\tSearches for the last occurrence of a character in a substring of a Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string.\n@param ch The character to search for.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub RFindChar: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            ch: ai_UnicodeString_UTF32TextChar,
            startOffset: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = "\tSearches for the last occurrence of an entire string within a substring of a Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@return The 0-based character index of the found string,\nor \\c npos if the string is not found."]
    pub RFindString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = "\tSearches for the last occurrence of a substring of one Unicode string within\na substring of another Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The maximum number of characters within \\c str2 to search for.\n@return The 0-based character index of the found string,\nor \\c npos if the string is not found."]
    pub RFindSubString: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = "\tSearches for the first occurrence of any character from a subset of one\nUnicode string in a substring of another string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The number of characters from the start of \\c str2 to compare.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub FindFirstOf: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches in a Unicode string for the first occurrence of any character that\ndoes not appear in a subset of another string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The number of characters from the start of \\c str2 to compare.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub FindFirstNotOf: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches in a Unicode string for the last character that also appears in\na substring of another string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The number of characters from the start of \\c str2 to compare.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub FindLastOf: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Searches in a Unicode string for the last character that does not appear in\na substring of another string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string to search in.\n@param str2 The string to compare against.\n@param startOffset The 0-based index in \\c str at which to start the search.\n@param count The number of characters from the start of \\c str2 to compare.\n@return The 0-based character index of the found character,\nor \\c npos if the character is not found."]
    pub FindLastNotOf: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            str2: *const ai_UnicodeString,
            startOffset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Resizes a Unicode string to hold a given number of characters, truncating\nor padding it as needed.\n@param str The string, which is modified in place.\n@param count The number of characters.\n@param ch The padding character, if needed."]
    pub Resize: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            count: ai_UnicodeString_size_type,
            ch: ai_UnicodeString_UTF32TextChar,
        ) -> AIErr,
    >,
    #[doc = " Retrieves number of characters (UTF code points) that this string can hold without reallocation.\nThis may be the same as or more than \\c #Length().\n@param str The string.\n@return The number of characters that can be held in this string without reallocation."]
    pub Capacity: ::std::option::Option<
        unsafe extern "C" fn(str_: *const ai_UnicodeString) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Request to change the capacity of this string to accommodate at least the specified number of characters.\nIf new capacity is greater than the current \\c #Capacity(), new storage is allocated, and \\c #Capacity()\nis made equal or greater than new capacity.\nIf new capacity is less than or equal to the current \\c #Capacity(), there is no effect.\n(Note that this function does not return an error code.)\n@param str The string, which is modified in place.\n@param count The new desired capacity of this string in number of characters."]
    pub Reserve: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, count: ai_UnicodeString_size_type),
    >,
    #[doc = " Creates a substring of a Unicode string.\n@param subString [in, out] A Unicode string in which to return the substring.\nIf it is uninitialized on input, it is initialized only if the source\nstring is initialized and not empty.\n@param str The source string.\n@param offset The 0-based index in \\c str at which to start the substring.\n@param count The maximum number of characters to place in the new substring."]
    pub SubStr: ::std::option::Option<
        unsafe extern "C" fn(
            subString: *mut ai_UnicodeString,
            str_: *const ai_UnicodeString,
            offset: ai_UnicodeString_size_type,
            count: ai_UnicodeString_size_type,
        ) -> AIErr,
    >,
    #[doc = " Swaps the contents of two Unicode strings.\n@param str The first string.\n@param str2 The second string."]
    pub SwapStr: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, str2: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Reports whether a Unicode string contains surrogate pairs.\n(Note that this function returns a boolean value, not an error code.)\n@param str The string.\n@return True if it contains at least one surrogate pair."]
    pub HasSurrogates:
        ::std::option::Option<unsafe extern "C" fn(str_: *const ai_UnicodeString) -> AIBool8>,
    #[doc = " Retrieves a read-only pointer to a buffer that contains UTF-16 encoded\ncharacters in platform byte order, for a given Unicode string.\n(Note that this function returns a numeric value, not an error code.)\n@param str The string.\n@param buffer [out] The pointer to the buffer. Can be 0 if the string is\nempty or uninitialized.\tMight not be 0 terminated.\n@return The length of the buffer in UTF-16 code units."]
    pub UTF_16: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            buffer: *mut *const ai_UnicodeString_UTF16Char,
        ) -> ai_UnicodeString_size_type,
    >,
    #[doc = " Retrieves the contents of a Unicode string in a given encoding.\n@param str The string.\n@param encoding The encoding.\n@param buffer [out] A buffer in which to return the encoded\ncontents. Need not be initialized prior to the call.\n@param bufferByteCount [out] A buffer in which to return the number of bytes\nin the buffer that contain the requested data. The buffer can be\nlarger than this."]
    pub GetAs: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ai_UnicodeString,
            encoding: AICharacterEncoding,
            buffer: *mut ai_AutoBuffer<::std::os::raw::c_char, ::std::os::raw::c_ulong>,
            bufferByteCount: *mut ai_UnicodeString_size_type,
        ) -> AIErr,
    >,
    #[doc = " Initializes a Unicode string from a ZString. (ZStrings are used internally\nfor localization.)\n@param str The string.\n@param zStringKey The ZString key."]
    pub InitializeZString: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut ai_UnicodeString, zStringKey: ZRef) -> AIErr,
    >,
    #[doc = " Normalizes a Unicode string.\n@param str The string.\n@param form The normalization format."]
    pub Normalize: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *mut ai_UnicodeString,
            form: ai_UnicodeString_NormalizedForm,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIObjectSetOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an object set.\nObject sets are deprecated in favor of dictionaries, see \\c #AIDictionarySuite"]
pub type AIObjectSetHandle = *mut _t_AIObjectSetOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIObjectOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an object in an object set.\nObject sets are deprecated in favor of dictionaries, see \\c #AIDictionarySuite"]
pub type AIObjectHandle = *mut _t_AIObjectOpaque;
pub const AIObjectSetChangeType_kAIObjectSetChangeDelete: AIObjectSetChangeType = 0;
pub const AIObjectSetChangeType_kAIObjectSetChangeNew: AIObjectSetChangeType = 1;
pub const AIObjectSetChangeType_kAIObjectSetChangeChange: AIObjectSetChangeType = 2;
pub const AIObjectSetChangeType_kAIObjectSetChangeRename: AIObjectSetChangeType = 3;
#[doc = " Types of changes that can be made to object sets.\nObject sets are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
pub type AIObjectSetChangeType = ::std::os::raw::c_uint;
pub const AIObjectMapType_kAIObjectMapCustomColor: AIObjectMapType = 0;
pub const AIObjectMapType_kAIObjectMapPattern: AIObjectMapType = 1;
pub const AIObjectMapType_kAIObjectMapBrushPattern: AIObjectMapType = 2;
pub const AIObjectMapType_kAIObjectMapGradient: AIObjectMapType = 3;
pub const AIObjectMapType_kAIObjectMapPluginObject: AIObjectMapType = 4;
pub const AIObjectMapType_kAIObjectMapDone: AIObjectMapType = -1;
#[doc = " Types of objects that can be stored in an object set.\nObject sets are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
pub type AIObjectMapType = ::std::os::raw::c_int;
#[doc = " Object map for object set. Object sets are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIObjectMap {
    #[doc = " A value from #AIObjectMapType"]
    pub objectType: ai_int16,
    pub offset: ai_int16,
}
pub const AIReplaceColorTag_kRepGrayColor: AIReplaceColorTag = 0;
pub const AIReplaceColorTag_kRepFourColor: AIReplaceColorTag = 1;
pub const AIReplaceColorTag_kRepPattern: AIReplaceColorTag = 2;
pub const AIReplaceColorTag_kRepCustomColor: AIReplaceColorTag = 3;
pub const AIReplaceColorTag_kRepGradient: AIReplaceColorTag = 4;
pub const AIReplaceColorTag_kRepThreeColor: AIReplaceColorTag = 5;
pub const AIReplaceColorTag_kRepNoneColor: AIReplaceColorTag = 6;
pub const AIReplaceColorTag_kRepBrushPattern: AIReplaceColorTag = 11;
pub const AIReplaceColorTag_kRepColorDone: AIReplaceColorTag = -1;
pub const AIReplaceColorTag_kRepColorSameTagAsInAIColor: AIReplaceColorTag = -2;
#[doc = " Color replacement types in object sets.\nObject sets are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
pub type AIReplaceColorTag = ::std::os::raw::c_int;
#[doc = " For object sets, which are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIReplaceColor {
    pub kind: AIReplaceColorTag,
    pub c: AIColorUnion,
}
#[doc = " For object sets, which are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIReplaceColorNotifierData {
    pub pairs: ASInt32,
    pub colorPtr: *mut AIReplaceColor,
}
#[doc = " The contents of an object-set message.\nObject Sets are deprecated in favor of dictionaries,\nsee \\c #AIDictionarySuite\n@internal\nFields are used for the different selectors as indicated:\n<br>\\c #kSelectorObjectSetDisposeContents. The object in the message is about to be permanently disposed.\nDo not free the internal or external memory (the suite will do this) but dispose\nof any referred-to memory.  Subobject and change fields are unused.\n<br>\\c #kSelectorObjectSetMarkUsage. Mark all objects managed by this plug-in that are used in the\ncurrent document by calling AIObjectSetSuite::MarkObjectInUse().  If markArt is not nullptr, just\nmark all objects within that sub-tree.  Set, object, subobject, and change fields are unused.\n<br>\\c #kSelectorObjectSetUpdateInternal. Fetch the external representation for this object and update\nthe internal. Also serves to notify of a new object; this will be the first selector received\nfor a new one.  Subobject and change fields are unused.\n<br>\\c #kSelectorObjectSetUpdateExternal. Fetch the internal representation for this object and update\nthe external. Subobject and change fields are unused.\n<br>\\c #kSelectorObjectSetPurge. The object contains a reference to the object described in the\nsubobject fields, and that object is going away.  Remove the reference to it and make any\nnecessary changes to the artwork.  Change fields are unused\n<br>\\c #kSelectorObjectSetChange. The object has been changed as a result of an undo/redo.  Subobject\nfields are unused.\n<br>\\c #kSelectorObjectSetChangeIndirect. The object contains a reference to an object that has changed.\nMake any necessary changes to the artwork.  Subobject and change fields are unused.\n(Note, change from AI8, which set subobject).\n<br>\\c #kSelectorObjectSetCopy. The object has been copied into the current document.\nSubobject and change fields are unused.\n<br>\\c #kSelectorObjectSetInitializationDone. All UpdateInternal calls for objects that were in the\ndocument are over with.  Called once per plug-in, not per object set.  All fields are unused."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIObjectSetMessage {
    pub d: SPMessageData,
    pub set: AIObjectSetHandle,
    pub object: AIObjectHandle,
    pub subobjectType: ai_int16,
    pub subobject: AIObjectSetMessage__bindgen_ty_1,
    pub changeType: AIObjectSetChangeType,
    pub markArt: AIArtHandle,
    pub aiVersion: AIVersion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AIObjectSetMessage__bindgen_ty_1 {
    pub pattern: AIPatternHandle,
    pub gradient: AIGradientHandle,
    pub ccolor: AICustomColorHandle,
    pub object: AIObjectSetMessage__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIObjectSetMessage__bindgen_ty_1__bindgen_ty_1 {
    pub set: AIObjectSetHandle,
    pub object: AIObjectHandle,
}
#[doc = "\t@deprecated\nObject sets provide an obsolete mechanism for attaching global information to a document. Their use is\ndeprecated in favor of dictionaries. Each document contains a dictionary where arbitrary information\ncan be stored. See \\c #AIDocumentSuite::GetDictionary() and \\c #AIDocumentSuite::GetNonRecordedDictionary()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIObjectSetSuite {
    pub NewObjectSet: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_uchar,
            map: *const AIObjectMap,
            set: *mut AIObjectSetHandle,
        ) -> AIErr,
    >,
    pub CountObjectSets: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    pub GetNthObjectSet: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, set: *mut AIObjectSetHandle) -> AIErr,
    >,
    pub GetObjectSetName: ::std::option::Option<
        unsafe extern "C" fn(set: AIObjectSetHandle, name: *mut ::std::os::raw::c_uchar) -> AIErr,
    >,
    pub GetObjectSetByName: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_uchar,
            set: *mut AIObjectSetHandle,
        ) -> AIErr,
    >,
    pub GetObjectSetMap: ::std::option::Option<
        unsafe extern "C" fn(set: AIObjectSetHandle, map: *mut *const AIObjectMap) -> AIErr,
    >,
    pub NewObject: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            name: *const ai_UnicodeString,
            def: *const ::std::os::raw::c_void,
            defLen: ai_int32,
            object: *mut AIObjectHandle,
        ) -> AIErr,
    >,
    pub DeleteObject: ::std::option::Option<
        unsafe extern "C" fn(setHandle: AIObjectSetHandle, object: AIObjectHandle) -> AIErr,
    >,
    pub SetObjectInternal: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            data: *const ::std::os::raw::c_void,
            dataLen: ai_int32,
        ) -> AIErr,
    >,
    pub SetObjectExternal: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            data: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    pub GetObjectInternal: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            data: *mut *const ::std::os::raw::c_void,
            dataLen: *mut ai_int32,
        ) -> AIErr,
    >,
    pub GetObjectExternal: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            data: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    pub CountObjects: ::std::option::Option<
        unsafe extern "C" fn(setHandle: AIObjectSetHandle, count: *mut ai_int32) -> AIErr,
    >,
    pub GetNthObject: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            n: ai_int32,
            object: *mut AIObjectHandle,
        ) -> AIErr,
    >,
    pub GetObjectName: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            name: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    pub SetObjectName: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            name: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    pub GetObjectByName: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            name: *mut ai_UnicodeString,
            object: *mut AIObjectHandle,
        ) -> AIErr,
    >,
    pub NewObjectName: ::std::option::Option<
        unsafe extern "C" fn(setHandle: AIObjectSetHandle, name: *mut ai_UnicodeString) -> AIErr,
    >,
    pub MarkObjectInUse: ::std::option::Option<
        unsafe extern "C" fn(setHandle: AIObjectSetHandle, object: AIObjectHandle) -> AIErr,
    >,
    pub RetargetForCurrentDocument: ::std::option::Option<
        unsafe extern "C" fn(object: AIObjectHandle, newObj: *mut AIObjectHandle) -> AIErr,
    >,
    pub GetExternalObjectName: ::std::option::Option<
        unsafe extern "C" fn(
            setHandle: AIObjectSetHandle,
            object: AIObjectHandle,
            aiVersion: AIVersion,
            buf: *mut ::std::os::raw::c_char,
            bufLen: *mut ai_int32,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIEntry {
    _unused: [u8; 0],
}
#[doc = "A reference to a container dictionary entry, which associates a string key\nwith a value of a given type (\\c #AIEntryType).\n\\li Use the \\c #AIDictionarySuite functions to get and set keys,\nand to get and set entries by key.\n\\li Use the \\c #AIEntrySuite functions to get and set entry values\nof specific data types."]
pub type AIEntryRef = *mut _AIEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIArray {
    _unused: [u8; 0],
}
#[doc = " An array is a heterogeneous sequence of entries indexed by integers.\n@see \\c #AIArraySuite"]
pub type AIArrayRef = *mut _AIArray;
#[doc = " A dictionary is a heterogeneous collection of entries indexed by keys that are character strings.\n@see \\c #AIDictionarySuite"]
pub type AIDictionaryRef = *mut _AIDictionary;
pub type ConstAIDictionaryRef = *const _AIDictionary;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIUID {
    _unused: [u8; 0],
}
#[doc = " A unique identifier, which can be stored in dictionaries and arrays.\nA unique identifier cannot occur in more than one container,\nor more than once in a container.\n@see \\c #AIUIDREFSuite"]
pub type AIUIDRef = *mut _AIUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIUIDREF {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a unique identifier.\nThe \\c #AIEntrySuite provides methods to convert between\n\\c #AIEntryRef and \\c #AIUIDRef.\n@see \\c #AIUIDREFSuite"]
pub type AIUIDREFRef = *mut _AIUIDREF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIXMLNode {
    _unused: [u8; 0],
}
#[doc = " A reference to an XML element.\n@see \\c #AIXMLElementSuite"]
pub type AIXMLNodeRef = *mut _AIXMLNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AISVGFilterOpaque {
    _unused: [u8; 0],
}
#[doc = " A reference to an SVG filter\n@see \\c #AISVGFilterSuite"]
pub type AISVGFilterHandle = *mut _t_AISVGFilterOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIArtStyle {
    _unused: [u8; 0],
}
#[doc = " A reference to an art style.\n@see \\c #AIArtStyleSuite."]
pub type AIArtStyleHandle = *mut _t_AIArtStyle;
#[doc = " Container entry type, the data type for the value of an entry."]
pub type AIEntryType = ai_int32;
#[doc = "\t@ingroup Suites\n\nThis suite provides functions for constructing and inspecting dictionary\nand array entries.\n\nEntry objects associate a string key with a value of a given type\n(\\c #AIEntryType). Access array entries by integer index.\nAccess dictionary entries  by key, using the functions of the\n\\c #AIDictionarySuite.\n\n\\li Functions with names \"To<Type>\" create entries of certain\ndata types; for example, \\c #ToInteger() creates an integer entry from\nan integer value.\n\\li Functions with names \"From<Type>\" retrieve the values of entries; for\nexample, use \\c #FromInteger() to get an integer entry value.\n\n@see \\c #AIArraySuite::MoveArtToEntry(), <br>\n\\c #AIArraySuite::MoveEntryToArt(), <br>\n\\c #AIDictionarySuite::MoveArtToEntry(), <br>\n\\c #AIDictionarySuite::MoveEntryToArt()\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIEntrySuite and \\c #kAIEntryVersion.\n\n\nEntries, like the dictionaries and arrays that contain them, are reference\ncounted. A function that returns an entry increments the count first. The\ncaller must decrement the count when that entry is no longer needed to avoid\nmemory leaks. For convenience, the \"To<Type>\" and \\c #AIDictionarySuite::Set()\nfunctions  automatically decrement the reference count of the entry you pass in.\nThis allows you to get the value of an entry in a container such as\na dictionary with code like this:\n@code\nASBoolean value;\nresult = sAIEntry->ToBoolean(sAIDictionary->Get(dict, \"MyKey\"), &value);\n@endcode\n\nSimilarly, you can set an entry value in a container such as a dictionary\nwith code like this:\n@code\nresult = sAIDictionary->Set(dict, \"MyKey\", sAIEntry->FromReal(15));\n@endcode\n\nThe \\c #GetType() and \\c #Equiv() functions do not consume the parameter;\nmanage reference counts accordingly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIEntrySuite {
    #[doc = " Reference count maintenance. increments the count of references to an entry.\n@param entry The entry object."]
    pub AddRef: ::std::option::Option<unsafe extern "C" fn(entry: AIEntryRef) -> ai_int32>,
    #[doc = " Reference count maintenance. decrements the count of references to an entry.\n@param entry The entry object."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(entry: AIEntryRef) -> ai_int32>,
    #[doc = " Retrieves the type of an entry. Does not affect the reference count of the passed\nentry. (Note that this function returns a type value, not an error code.)\n@param entry The entry object\n@return The entry type."]
    pub GetType: ::std::option::Option<unsafe extern "C" fn(entry: AIEntryRef) -> AIEntryType>,
    #[doc = " Retrieves the boolean value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToBoolean: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Constructs an entry from a boolean value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromBoolean: ::std::option::Option<unsafe extern "C" fn(value: ASBoolean) -> AIEntryRef>,
    #[doc = " Retrieves the integer value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToInteger: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Constructs an entry from an integer value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromInteger: ::std::option::Option<unsafe extern "C" fn(value: ai_int32) -> AIEntryRef>,
    #[doc = "  Retrieves the real-number value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToReal:
        ::std::option::Option<unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIReal) -> AIErr>,
    #[doc = " Constructs an entry from a real-number value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromReal: ::std::option::Option<unsafe extern "C" fn(value: AIReal) -> AIEntryRef>,
    #[doc = "  Retrieves the point value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToRealPoint: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIRealPoint) -> AIErr,
    >,
    #[doc = " Constructs an entry from a point value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromRealPoint:
        ::std::option::Option<unsafe extern "C" fn(value: *const AIRealPoint) -> AIEntryRef>,
    #[doc = "  Retrieves the transformation-matrix value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToRealMatrix: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Constructs an entry from a transformation-matrix value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromRealMatrix:
        ::std::option::Option<unsafe extern "C" fn(value: *const AIRealMatrix) -> AIEntryRef>,
    #[doc = "  Retrieves the string value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToString: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Constructs an entry from a string value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromString: ::std::option::Option<
        unsafe extern "C" fn(value: *const ::std::os::raw::c_char) -> AIEntryRef,
    >,
    #[doc = "  Retrieves the dictionary value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToDict: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Constructs an entry from a dictionary value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromDict: ::std::option::Option<unsafe extern "C" fn(value: AIDictionaryRef) -> AIEntryRef>,
    #[doc = "  Retrieves the art object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type.\n@see \\c #AIArraySuite::MoveArtToEntry()<br> \\c #AIDictionarySuite::MoveArtToEntry()."]
    pub ToArt: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = "  Retrieves the array value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToArray: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIArrayRef) -> AIErr,
    >,
    #[doc = " Constructs an entry from an array value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromArray: ::std::option::Option<unsafe extern "C" fn(value: AIArrayRef) -> AIEntryRef>,
    #[doc = "  Retrieves the binary data value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value, or \\c NULL to\nretrieve the size needed for the value.\n@param size [out] A buffer in which to return the number of bytes\nwritten to the \\c value buffer, or the size needed if \\c value is \\c NULL.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type.\n@note If you call the function twice to get the size needed and then retrieve the\nvalue, keep in mind that each call decrements the reference count of the entry."]
    pub ToBinary: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIEntryRef,
            value: *mut ::std::os::raw::c_void,
            size: *mut usize,
        ) -> AIErr,
    >,
    #[doc = " Constructs an entry from a binary data value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@param size The number of bytes in the \\c value buffer.\n@return The new entry object. The initial reference count is 1."]
    pub FromBinary: ::std::option::Option<
        unsafe extern "C" fn(value: *mut ::std::os::raw::c_void, size: usize) -> AIEntryRef,
    >,
    #[doc = "  Retrieves the pattern object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToPattern: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIPatternHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a pattern object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromPattern:
        ::std::option::Option<unsafe extern "C" fn(value: AIPatternHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the brush pattern object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToBrushPattern: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIPatternHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a brush pattern object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromBrushPattern:
        ::std::option::Option<unsafe extern "C" fn(value: AIPatternHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the gradient object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToGradient: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIGradientHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a gradient object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromGradient:
        ::std::option::Option<unsafe extern "C" fn(value: AIGradientHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the custom color object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToCustomColor: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AICustomColorHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a custom color object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromCustomColor:
        ::std::option::Option<unsafe extern "C" fn(value: AICustomColorHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the plug-in global object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToPluginObject: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIObjectHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a plug-in global object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromPluginObject:
        ::std::option::Option<unsafe extern "C" fn(value: AIObjectHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the fill style value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToFillStyle: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIFillStyle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a fill style value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromFillStyle:
        ::std::option::Option<unsafe extern "C" fn(value: *const AIFillStyle) -> AIEntryRef>,
    #[doc = "  Retrieves the stroke style value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToStrokeStyle: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIStrokeStyle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a stroke style value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromStrokeStyle:
        ::std::option::Option<unsafe extern "C" fn(value: *const AIStrokeStyle) -> AIEntryRef>,
    #[doc = "  Retrieves the unique identifier value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToUID: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIUIDRef) -> AIErr,
    >,
    #[doc = " Constructs an entry from a unique identifier value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromUID: ::std::option::Option<unsafe extern "C" fn(value: AIUIDRef) -> AIEntryRef>,
    #[doc = "  Retrieves the unique identifier reference value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToUIDREF: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIUIDREFRef) -> AIErr,
    >,
    #[doc = " Constructs an entry from a unique identifier reference value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromUIDREF: ::std::option::Option<unsafe extern "C" fn(value: AIUIDREFRef) -> AIEntryRef>,
    #[doc = "  Retrieves the XML node value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToXMLNode: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Constructs an entry from an XML node value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromXMLNode: ::std::option::Option<unsafe extern "C" fn(value: AIXMLNodeRef) -> AIEntryRef>,
    #[doc = "  Retrieves the SVG filter value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToSVGFilterHandle: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AISVGFilterHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from an SVG filter value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromSVGFilterHandle:
        ::std::option::Option<unsafe extern "C" fn(value: AISVGFilterHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the symbol pattern object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToSymbolPattern: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIPatternHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a symbol pattern object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromSymbolPattern:
        ::std::option::Option<unsafe extern "C" fn(value: AIPatternHandle) -> AIEntryRef>,
    #[doc = " Retrieves a string entry as a boolean if possible. Only valid for entries with\nvalue \"1\", \"0\", \"true\", or \"false\".\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsBoolean: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Retrieves a string entry as an integer if possible.\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsInteger: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a string entry as a real number if possible.\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsReal:
        ::std::option::Option<unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIReal) -> AIErr>,
    #[doc = " Retrieves an entry as a string if possible. Converts an integer, boolean,\nreal, UID, UID reference, or Unicode string value to a platform-encoded string.\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\nThis block of memory is reused by the next call to this function; do not delete\nit.\tIf needed, make a copy of the returned string before making another call\nto this function.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsString: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves a string entry as a unique identifier if possible. The string\nvalue must be in the form \"id(\\e uid )\".\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsUIDREF: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIUIDREFRef) -> AIErr,
    >,
    #[doc = "  Retrieves the art style object value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToArtStyle: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut AIArtStyleHandle) -> AIErr,
    >,
    #[doc = " Constructs an entry from a art style object value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromArtStyle:
        ::std::option::Option<unsafe extern "C" fn(value: AIArtStyleHandle) -> AIEntryRef>,
    #[doc = "  Retrieves the Unicode string value of an entry.\n@param entry The entry object. This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the value.\n@return The error \\c #kBadParameterErr if the entry is not of the correct type."]
    pub ToUnicodeString: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Constructs an entry from a Unicode string value.\n(Note that this function returns an entry object, not an error code.)\n@param value The entry value.\n@return The new entry object. The initial reference count is 1."]
    pub FromUnicodeString:
        ::std::option::Option<unsafe extern "C" fn(value: *const ai_UnicodeString) -> AIEntryRef>,
    #[doc = " Retrieves an entry as a Unicode string, if possible. Converts an integer, boolean,\nreal, UID, UID reference, or platform-encoded string value to a Unicode string.\n@param entry The entry object.  This call automatically decrements\nthe reference count.\n@param value [out] A buffer in which to return the new value.\n@return The error \\c #kNoConversionErr if conversion is not possible."]
    pub AsUnicodeString: ::std::option::Option<
        unsafe extern "C" fn(entry: AIEntryRef, value: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Reports whether two entries are equivalent.\nEquivalent entries have the same type and value.\nTwo NULL entries are considered equivalent.\n@param entry1 The first entry.\n@param entry2 The second entry.\n@return True if the entries are equivalent, false otherwise."]
    pub Equiv: ::std::option::Option<
        unsafe extern "C" fn(entry1: AIEntryRef, entry2: AIEntryRef) -> ASBoolean,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIDictKey {
    _unused: [u8; 0],
}
#[doc = " A key that identifies a dictionary entry."]
pub type AIDictKey = *const _t_AIDictKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIDictionaryIterator {
    _unused: [u8; 0],
}
#[doc = " An iterator that allows you to enumerate the contents of a dictionary. See\nthe \\c #AIDictionaryIteratorSuite for iteration functions."]
pub type AIDictionaryIterator = *mut _AIDictionaryIterator;
#[doc = " The data for the dictionary key-changed notifier. (Not currently sent)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIDictionaryKeyChangedNotifyData {
    #[doc = " Current notification sequence timestamp"]
    pub refStamp: ai_int32,
    #[doc = " The dictionary that changed"]
    pub dictionary: AIDictionaryRef,
    #[doc = " The key whose value changed"]
    pub key: AIDictKey,
}
#[doc = " The data for the dictionary key-changed notifier. (Not currently sent)."]
pub type AIDictionaryKeyChangedNotifyData = _AIDictionaryKeyChangedNotifyData;
#[doc = "\t@ingroup Suites\nThis suite provides function to create and manage Illustrator data dictionaries.\nA dictionary is a heterogeneous container whose elements, called \\e entries,\nare accessed by \\e keys.\n\nEntries are of type \\c #AIEntryRef. The \\c #AIEntrySuite provides methods\nto construct and query entries of different types. Entries can contain\nvalues of various data types; simple types such\tas booleans, integers, floats,\nand strings; and complex types such as arrays, other dictionaries, and\nreferences to document objects including art objects,\nbrushes and styles. This makes dictionaries very flexible and\npowerful containers.\n\nDictionaries can themselves be stored in other containers such as arrays\nor other dictionaries. In particular they can be stored in the dictionaries\nattached to art objects and to the document. When a dictionary is stored in\none of these places (directly or indirectly) it is read and written as\na part of the document.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIDictionarySuite and \\c #kAIDictionaryVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDictionarySuite {
    #[doc = " Creates a new dictionary. Dictionaries are reference counted;\nthe initial reference count is 1.\n@param dictionary [out] A buffer in which to return the new dictionary reference.\n@see \\c #AddRef(), \\c #Release()"]
    pub CreateDictionary:
        ::std::option::Option<unsafe extern "C" fn(dictionary: *mut AIDictionaryRef) -> AIErr>,
    #[doc = " Opens a JSON file from the provided path and parses it to a newly created dictionary.\nThe JSON file must have an object as top-level element.\nDictionaries are reference counted;\nthe initial reference count is 1.\n@param dictionary [out] A buffer in which to return the new dictionary reference.\n@param file The path to the JSON file\n@see \\c #AddRef(), \\c #Release()"]
    pub CreateDictionaryFromJSONFile: ::std::option::Option<
        unsafe extern "C" fn(dictionary: *mut AIDictionaryRef, file: *const ai_FilePath) -> AIErr,
    >,
    #[doc = "  Increments the reference count of a dictionary.\n@param dictionary The dictionary reference."]
    pub AddRef:
        ::std::option::Option<unsafe extern "C" fn(dictionary: AIDictionaryRef) -> ai_int32>,
    #[doc = "  Frees the memory associated with a dictionary\nwhen it is no longer needed (the reference count is 0).\n@param dictionary The dictionary reference. Upon return, the reference is\nno longer valid."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(dictionary: AIDictionaryRef) -> ai_int32>,
    #[doc = " Creates a new dictionary that is an exact duplicate of an existing dictionary.\nPerforms a deep copy.\n@param src The dictionary to copy.\n@param dst [out] A buffer in which to return the new dictionary reference."]
    pub Clone: ::std::option::Option<
        unsafe extern "C" fn(src: ConstAIDictionaryRef, dst: *mut AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Makes a copy of a dictionary, replacing the current contents of an existing dictionary.\n@param dict The dictionary into which to copy contents.\n@param src The dictionary to copy."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(dict: AIDictionaryRef, src: ConstAIDictionaryRef) -> AIErr,
    >,
    #[doc = " Gets the number of entries in a dictionary. (Note that this function returns\na numeric value, not an error code.)\n@param dict The dictionary.\n@return The number of entries."]
    pub Size: ::std::option::Option<unsafe extern "C" fn(dict: ConstAIDictionaryRef) -> ai_uint32>,
    #[doc = " Creates a new iterator object for visiting dictionary entries. Iterators are\nreference counted.\n@param dict The dictionary.\n@param iterator [out] A buffer in which to return the iterator object.\n@see \\c #AIDictionaryIteratorSuite::AddRef(), \\c #AIDictionaryIteratorSuite::Release()"]
    pub Begin: ::std::option::Option<
        unsafe extern "C" fn(
            dict: ConstAIDictionaryRef,
            iterator: *mut AIDictionaryIterator,
        ) -> AIErr,
    >,
    #[doc = " Finds a dictionary key, or creates a new one if the specified key does not\nexist. (Note that this function returns a key object, not an error code.)\n@param key The name of the key.\n@return The key object."]
    pub Key: ::std::option::Option<
        unsafe extern "C" fn(keyString: *const ::std::os::raw::c_char) -> AIDictKey,
    >,
    #[doc = " Retrieves the name string of a key. (Note that this function returns a string value,\nnot an error code.)\n@param key The key object.\n@return The key name."]
    pub GetKeyString: ::std::option::Option<
        unsafe extern "C" fn(key: AIDictKey) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Reports whether there is an entry with a given key in a dictionary.\n(Note that this function returns a boolean value, not an error code.)\n@param dict The dictionary.\n@param key The key object."]
    pub IsKnown: ::std::option::Option<
        unsafe extern "C" fn(dictionary: ConstAIDictionaryRef, key: AIDictKey) -> AIBoolean,
    >,
    #[doc = " Removes the entry with a given key from a dictionary.\n@param dict The dictionary.\n@param key The key object."]
    pub DeleteEntry: ::std::option::Option<
        unsafe extern "C" fn(dictionary: AIDictionaryRef, key: AIDictKey) -> AIErr,
    >,
    #[doc = " Retrieves the data type of an entry.\n@param dict The dictionary.\n@param key The key object.\n@param entryType [out] A buffer in which to return the entry type.\n@see \\c #AIEntrySuite"]
    pub GetEntryType: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            entryType: *mut AIEntryType,
        ) -> AIErr,
    >,
    #[doc = " Copies an entry from one dictionary to another, or to another key in the same\ndictionary.\n@param dictionary1 The source dictionary.\n@param dictionary2 The destination dictionary.\n@param key1 The key for the entry to copy.\n@param key2 The key for the new entry."]
    pub CopyEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary1: ConstAIDictionaryRef,
            dictionary2: AIDictionaryRef,
            key1: AIDictKey,
            key2: AIDictKey,
        ) -> AIErr,
    >,
    #[doc = " Moves an entry from one dictionary to another (or to another key in the same\ndictionary), removing the source entry.\n@param dictionary1 The source dictionary.\n@param dictionary2 The destination dictionary.\n@param key1 The key for the entry to copy and remove.\n@param key2 The key for the new entry."]
    pub MoveEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary1: AIDictionaryRef,
            dictionary2: AIDictionaryRef,
            key1: AIDictKey,
            key2: AIDictKey,
        ) -> AIErr,
    >,
    #[doc = " Swaps two entries in two dictionaries, or in the same dictionary.\n@param dictionary1 The source dictionary.\n@param dictionary2 The destination dictionary.\n@param key1 The first key (in \\c dictionary1, moved to \\c dictionary2).\n@param key2 The second key (in \\c dictionary2, moved to \\c dictionary1).\n"]
    pub SwapEntries: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary1: AIDictionaryRef,
            dictionary2: AIDictionaryRef,
            key1: AIDictKey,
            key2: AIDictKey,
        ) -> AIErr,
    >,
    #[doc = " Retrieves an art object from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param art [out] A buffer in which to return the art object."]
    pub GetArtEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates an entry which is a new art object of a specified type.\n@param dictionary The dictionary.\n@param key The entry key.\n@param art The art type, an \\c #AIArtType value."]
    pub NewArtEntry: ::std::option::Option<
        unsafe extern "C" fn(dictionary: AIDictionaryRef, key: AIDictKey, type_: ai_int16) -> AIErr,
    >,
    #[doc = " Moves an art object from the artwork tree into a dictionary, removing it from\nthe artwork tree.\n@param dictionary The dictionary.\n@param key The entry key.\n@param art The art object."]
    pub MoveArtToEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            art: AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Moves an art object from a dictionary into the artwork tree, removing the entry from\nthe dictionary.\n@param dictionary The dictionary.\n@param key The entry key.\n@param paintOrder The paint order, relative to the \\c prep object. See \\c AITypes::AIPaintOrder.\n@param prep The prepositional art object. This can be an object whose boundaries might overlap this one,\nor a compound path or group that might contain this path.\n@param art [out] A buffer in which to return a pointer to the art object.\n@see \\c #AIArtSuite"]
    pub MoveEntryToArt: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Copies an art object from the artwork tree into a dictionary.\n@param dictionary The dictionary.\n@param key The entry key.\n@param art The art object."]
    pub CopyArtToEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            art: AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Copies an art object from a dictionary into the artwork tree.\n@param dictionary The dictionary.\n@param key The entry key.\n@param paintOrder The paint order, relative to the \\c prep object. See \\c AITypes::AIPaintOrder.\n@param prep The prepositional art object. This can be an object whose boundaries might overlap this one,\nor a compound path or group that might contain this path.\n@param art [out] A buffer in which to return a pointer to the art object.\n@see \\c #AIArtSuite"]
    pub CopyEntryToArt: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Sets an entry in a dictionary to refer to the topmost group of a layer.\n@param dictionary The dictionary.\n@param key The entry key.\n@param layer The layer."]
    pub SetEntryToLayer: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            layer: AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Inserts a new layer in the current document, whose topmost group is the group referenced by\na dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key, which must reference an art object that is a group.\n@param paintOrder The paint order, relative to the \\c prep object. See \\c AITypes::AIPaintOrder.\nValid values are \\c #kPlaceDefault, \\c #kPlaceAbove, \\c #kPlaceBelow, \\c #kPlaceAboveAll and \\c #kPlaceBelowAll.\n@param prep The prepositional art object. This can be an object whose boundaries might overlap this one,\nor a compound path or group that might contain this path.\n@param art [out] A buffer in which to return the layer object.\n@see \\c #AIArtSuite, \\c #AILayerSuite"]
    pub SetLayerToEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            paintOrder: ai_int16,
            prep: AILayerHandle,
            layer: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a dictionary entry.\n(Note that this function returns an entry object, not an error code.)\n@param dictionary The dictionary.\n@param key The entry key.\n@return The entry object or a null entry if an entry with the given key does not exist.."]
    pub Get: ::std::option::Option<
        unsafe extern "C" fn(dictionary: ConstAIDictionaryRef, key: AIDictKey) -> AIEntryRef,
    >,
    #[doc = " Sets a dictionary entry. Entries whose keys are prefixed with\nthe character '-' are temporary, and are not saved to file.\n@param dictionary The dictionary.\n@param key The entry key.\n@param entry The entry object."]
    pub Set: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            entry: AIEntryRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a boolean value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetBooleanEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets a boolean value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetBooleanEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves an integer value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetIntegerEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Sets an integer value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetIntegerEntry: ::std::option::Option<
        unsafe extern "C" fn(dictionary: AIDictionaryRef, key: AIDictKey, value: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a pointer value from a dictionary entry (pointers may be 64-bit or 32-bit depending on platform).\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetPointerEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut ai_intptr,
        ) -> AIErr,
    >,
    #[doc = " Sets a pointer value for a temporary dictionary entry. If the key is not temporary i.e. does not begin with \"-\", it returns kBadParameterErr\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetPointerEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: ai_intptr,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a real-number value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetRealEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Sets a real-number value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetRealEntry: ::std::option::Option<
        unsafe extern "C" fn(dictionary: AIDictionaryRef, key: AIDictKey, value: AIReal) -> AIErr,
    >,
    #[doc = " Retrieves a string value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Sets a string value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a binary value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value.\n@param size [out] A buffer in which to return the number of bytes in the \\c value buffer."]
    pub GetBinaryEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut ::std::os::raw::c_void,
            size: *mut usize,
        ) -> AIErr,
    >,
    #[doc = " Sets a binary value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The pointer to the buffer containing the new value.\n@param size The number of bytes in the \\c value buffer."]
    pub SetBinaryEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a dictionary value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetDictEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut AIDictionaryRef,
        ) -> AIErr,
    >,
    #[doc = " Sets a dictionary value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetDictEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: AIDictionaryRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves an array value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetArrayEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut AIArrayRef,
        ) -> AIErr,
    >,
    #[doc = " Sets an array value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetArrayEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: AIArrayRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a Unicode string value from a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value [out] A buffer in which to return the value."]
    pub GetUnicodeStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: ConstAIDictionaryRef,
            key: AIDictKey,
            value: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Sets a Unicode string value for a dictionary entry.\n@param dictionary The dictionary.\n@param key The entry key.\n@param value The new value."]
    pub SetUnicodeStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            dictionary: AIDictionaryRef,
            key: AIDictKey,
            value: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Marks art as changed when a change has been made to the dictionary that affects\na user-visible property of any associated art object. This causes any styles or plug-in groups\ncontaining the affected object to execute.\n@param dictionary The dictionary."]
    pub TouchArt:
        ::std::option::Option<unsafe extern "C" fn(dictionary: ConstAIDictionaryRef) -> AIErr>,
    #[doc = " Creates a new iterator object for the matched key. Iterators are reference counted.\n@param dict The dictionary.\n@param key The key to find\n@param iterator [out] A buffer in which to return the iterator object.\nuse AIDictionaryIteratorSuite::GetEntry to get value directly from iterator\nreturns kNoSuchKey if the key is not found.\n@see \\c #AIDictionaryIteratorSuite::AddRef(), \\c #AIDictionaryIteratorSuite::Release()"]
    pub Find: ::std::option::Option<
        unsafe extern "C" fn(
            dict: ConstAIDictionaryRef,
            key: AIDictKey,
            iterator: *mut AIDictionaryIterator,
        ) -> AIErr,
    >,
}
#[doc = " Use these functions to iterate through the contents of a dictionary.\nObtain the iterator object with \\c #AIDictionarySuite::Begin(), and\nget the number of entries with  \\c #AIDictionarySuite::Size().\n\nIterators are reference counted. The initial count is 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDictionaryIteratorSuite {
    #[doc = " Increments the reference count of an iterator.\n@param iterator The iterator object."]
    pub AddRef:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> ai_int32>,
    #[doc = " Frees the memory associated with an iterator when it is no\nlonger used (the reference count is 0).\n@param iterator The iterator object. Upon return, this\nreference is no longer valid."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> ai_int32>,
    #[doc = " Reports whether an iterator is valid. (Not yet implemented)\n@param iterator The iterator object.\n@return True if the iterator is valid, false if the dictionary has\nchanged due to insertion or deletion of elements since the\niterator was constructed."]
    pub IsValid:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> AIBoolean>,
    #[doc = " Makes an iterator refer to the same dictionary entry as another iterator.\n@param iterator The iterator object.\n@param from Another iterator object, whose current entry reference is copied."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(iterator: AIDictionaryIterator, from: AIDictionaryIterator) -> AIErr,
    >,
    #[doc = " Creates a new iterator which is a copy of another iterator.\n@param iterator The iterator object to copy.\n@param clone [out] A buffer in which to return the new iterator object."]
    pub Clone: ::std::option::Option<
        unsafe extern "C" fn(
            iterator: AIDictionaryIterator,
            clone: *mut AIDictionaryIterator,
        ) -> AIErr,
    >,
    #[doc = " Reports whether two iterators refer to the same entry of the same dictionary.\n(Note that this function returns a boolean value, not an error code.)\n@param iterator1 The first iterator.\n@param iterator2 The second iterator.\n@return True if both iterators refer to the same entry of the same dictionary."]
    pub IsEqual: ::std::option::Option<
        unsafe extern "C" fn(
            iterator1: AIDictionaryIterator,
            iterator2: AIDictionaryIterator,
        ) -> AIBoolean,
    >,
    #[doc = " Reports whether an iterator has exhausted all dictionary entries.\n(Note that this function returns a boolean value, not an error code.)\n@param iterator The iterator object.\n@return True if the iteration has reached the end."]
    pub AtEnd:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> AIBoolean>,
    #[doc = " Advance an iterator's current-entry reference to the next entry.\n(Note that this function does not return an error code. Use \\c #AtEnd()\nto determine if the iterator has exhausted all entries.)\n@param iterator The iterator object."]
    pub Next: ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator)>,
    #[doc = " Back up an iterator's current-entry reference to the previous entry.\n(Note that this function does not return an error code. Calling it\non the first entry has undefined results.)\n@param iterator The iterator object."]
    pub Prev: ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator)>,
    #[doc = " Retrieves the key of an iterator's current entry.\n(Note that this function returns a key object, not an error code.)\n@param iterator The iterator object.\n@return The key object."]
    pub GetKey:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> AIDictKey>,
    #[doc = " Retrieves a dictionary entry for the dictionary iterator\n(Note that this function returns an entry object, not an error code.)\n@param iterator The iterator object.\n@return The entry object or a null entry if the iterator is at the end"]
    pub GetEntry:
        ::std::option::Option<unsafe extern "C" fn(iterator: AIDictionaryIterator) -> AIEntryRef>,
}
pub use self::ai_RasterColorSpace as AIRasterColorSpace;
#[doc = " Data states for \\c #AIRasterLink::datastate. Direct linking of images is deprecated\n(although still supported). Create linked objects using the \\c #AIPlacedSuite."]
pub use self::ai_RasterDataState as AIRasterDataState;
#[doc = " Used only for 1-bit gray images. When set, the 1-bit data\nis to be used as a mask. In this case the path style of the image indicates\nthe color that the bits of the image with a value of 1 are painted."]
pub const AIRasterFlags_kRasterMaskImageType: AIRasterFlags = 2;
#[doc = " Used only for 1-bit gray images. Reverses the sense of the component\nvalues so that for a gray image 0=white and 1=black and for an image mask\nthe 0 value pixels are painted."]
pub const AIRasterFlags_kRasterInvertBits: AIRasterFlags = 4;
#[doc = " Used only for 8-bit spot color rasters, or 16-bit if there is an extra\nalpha channel. When set, the gray component values are interpreted in\nthe subtractive color spaces."]
pub const AIRasterFlags_kRasterGraySubtractive: AIRasterFlags = 8;
#[doc = " Used to specify either we need to create this image in shared space or\nwe need to use the heap memory space to create storage for this image"]
pub const AIRasterFlags_kRasterCreatedInSharedSpace: AIRasterFlags = 16;
#[doc = " Used to specify if we need to create this image in single buffer in\nthe heap memory space"]
pub const AIRasterFlags_kRasterCreateInSingleBuffer: AIRasterFlags = 32;
#[doc = " Options for raster data, bit flags for \\c #AIRasterRecord::flags."]
pub type AIRasterFlags = ::std::os::raw::c_uint;
#[doc = " The image is linked; when saving native round-trip information,\nimage data is not saved into the file."]
pub const AIRasterLinkState_kAIRasterLinked: AIRasterLinkState = 0;
#[doc = " The image is embedded; when saving native round-trip information,\nimage data is saved with the file."]
pub const AIRasterLinkState_kAIRasterEmbedded: AIRasterLinkState = 1;
#[doc = " Link states for \\c #AIRasterLink::linkstate. Direct linking of images is deprecated\n(although still supported). Create linked objects using the \\c #AIPlacedSuite."]
pub type AIRasterLinkState = ::std::os::raw::c_uint;
#[doc = " Only update if the data is not embedded"]
pub const AIResolveRasterLinkFlags_kAIResolveCheckExternal: AIResolveRasterLinkFlags = 1;
#[doc = " Only update if the file has changed"]
pub const AIResolveRasterLinkFlags_kAIResolveCheckFile: AIResolveRasterLinkFlags = 2;
#[doc = " Report errors to user and show progress"]
pub const AIResolveRasterLinkFlags_kAIResolveVerbose: AIResolveRasterLinkFlags = 4;
#[doc = " Allow a replacement file to be selected in case of error"]
pub const AIResolveRasterLinkFlags_kAIResolveReplace: AIResolveRasterLinkFlags = 8;
#[doc = " Do automatic searching for a replacement"]
pub const AIResolveRasterLinkFlags_kAIResolveSearch: AIResolveRasterLinkFlags = 16;
#[doc = " Flags for \\c #AIRasterSuite::ResolveRasterLink(). Direct linking of images is deprecated\n(although still supported). Create linked objects using the \\c #AIPlacedSuite."]
pub type AIResolveRasterLinkFlags = ::std::os::raw::c_uint;
#[doc = " Decompose the original raster into an array of rasters specified in the standard\ncolor spaces (Gray, RGB, CMYK and spot Separation). If\nthe original raster contains a partial set of CMYK process colors,\nit is expanded to the full process colors."]
pub const AISplitRasterFlags_kAISplitRasterStandard: AISplitRasterFlags = 0;
#[doc = " Decompose the CMYK process channels of the original raster\ninto individual process Separation color spaces. If\nthe original raster contains a partial set of CMYK process colors,\nis \\e not expanded to the full process channels."]
pub const AISplitRasterFlags_kAISplitRasterSeparateProcess: AISplitRasterFlags = 1;
#[doc = " Flags for \\c #AIRasterSuite::SplitChannels()"]
pub type AISplitRasterFlags = ::std::os::raw::c_uint;
#[doc = "\tA slice, which defines a subset of a raster data to be copied or\nreplaced, in \\c #AITile::bounds. The slice of the source and\ndestination are of equal dimensions, but differ in location.\n\nThe \\c top, \\c bottom, \\c left, and \\c right values specify\nthe rectangle containing the pixel data. As you iterate through a\nraster object accessing slices of pixels, these values change,\ncontrolling which section of the pixel map is being processed.\n\nThe slice values for local pixel data are typically the same as\nthe bounding rectangle of the tile (although you can also iterate\nthrough slices in a tile).\n\nThe \\c front and \\c back, together with the \\c #AITile::channelInterleave\nvalue, the control which of the pixel channels should be copied.\nThe \\c front value specifies the first channel to be affected, and the\n\\c back value specifies the last channel + 1. See @ref ChannelInterleaving."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AISlice {
    pub top: ai_int32,
    pub left: ai_int32,
    pub bottom: ai_int32,
    pub right: ai_int32,
    pub front: ai_int32,
    pub back: ai_int32,
}
#[doc = " A tile, which describes local storage for copying image data to and from.\nUse with \\c #AIRasterSuite::GetRasterTile() and \\c #AIRasterSuite::SetRasterTile()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AITile {
    #[doc = " A pointer to the memory containing the local copy of the pixels. Can be\na generic block of memory or a platform-specific data structure.\nMust be allocated by the plug-in."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The slice that defines the tile (a subset of the pixel map to\nbe copied in one iteration), a rectangular area plus depth\ninformation that controls how interleaving occurs.\nSee  @ref ChannelInterleaving."]
    pub bounds: AISlice,
    #[doc = " The number of bytes in a row of pixel data."]
    pub rowBytes: ai_int32,
    #[doc = " The number of bytes used to specify a single pixel. For a raw RGB pixel,\nfor example, it is 3."]
    pub colBytes: ai_int32,
    #[doc = " When 0, the tile receives all color data for a single pixel together.\n<br>When non-zero, the tile receives all data for a color together\n(in a planar form). In this case, the value is the number of bytes\nmaking up a single plane. For instance if the pixel map is\n80 by 80 pixels and the RGB data is in a planar form, the\nvalue is 6400."]
    pub planeBytes: ai_int32,
    #[doc = " Together with the slice information, this array specifies how to change\nthe order of bytes making up a pixel when transferring between\na raster art object and the tile data. See @ref ChannelInterleaving."]
    pub channelInterleave: [ai_int16; 32usize],
}
#[doc = " An RGB color table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRGBColorRec {
    pub mustBeZero: ai_uint8,
    pub red: ai_uint8,
    pub green: ai_uint8,
    pub blue: ai_uint8,
}
#[doc = " An extended (16-bit) RGB color table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIExtendedRGBColorRec {
    pub mustBeZero: ai_uint16,
    pub red: ai_uint16,
    pub green: ai_uint16,
    pub blue: ai_uint16,
}
#[doc = " A CMYK color table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICMYKColorRec {
    pub cyan: ai_uint8,
    pub magenta: ai_uint8,
    pub yellow: ai_uint8,
    pub black: ai_uint8,
}
#[doc = " Configuration information for the raster image data associated with an art\nobject of type \\c #kRasterArt. Use with \\c #AIRasterSuite::GetRasterInfo()\nand \\c #AIRasterSuite::SetRasterInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRasterRecord {
    #[doc = " Flags defining additional options for the image. A logical\nOR of \\c #AIRasterFlags."]
    pub flags: ai_uint16,
    #[doc = " The width and height of the image data in pixels. The top left value of\nthe bounds must be zero. The right value gives the width and the bottom\nvalue the height. (The coordinate system for a raster object is inverted\non the vertical axis with respect to the Illustrator artboard coordinate\nsystem.)"]
    pub bounds: AIRect,
    #[doc = " The number of bytes in a single row of pixel data. Not needed\nfor \\c #AIRasterSuite::SetRasterInfo(). 1-bit data is packed so\nthat there are 8 pixels per byte.\n\\li If \\c bitsPerPixel is 1 (for a black-and-white bitmap), the value is:\n<code>rasterRecord.bounds.right / 8 + 1</code>\n\\li For all other \\c bitsPerPixel values, the value is:\n<code>rasterRecord.bounds.right * (rasterRecord.bitsPerPixel / 8)</code>"]
    pub byteWidth: ai_int32,
    #[doc = " The color model of the pixel data, which can include an alpha channel,\nan \\c #AIRasterColorSpace constant."]
    pub colorSpace: ai_int16,
    #[doc = " The number of bits used to define each pixel in the pixel map.\nValid values depend on the color space:\nGray: 1 (black and white) or 8 (gray)\nRGB: 24 (8 bits for each color)\tor 48 (16 bits for each color)\nCMYK: 32 (8 bits for each color)"]
    pub bitsPerPixel: ai_int16,
    #[doc = " For an image that has been converted from one color space to another,\nthe original color space, an \\c #AIRasterColorSpace constant.\n<br>If the image has not been converted, the value is -1."]
    pub originalColorSpace: ai_int16,
}
#[doc = " Link information about an image. Direct linking of images is deprecated\n(although still supported). Create linked objects using the \\c #AIPlacedSuite."]
#[repr(C)]
#[derive(Debug)]
pub struct AIRasterLink {
    #[doc = " The source file for the image data (the linked file)."]
    pub file: ai_FilePath,
    #[doc = " The link state, an \\c #AIRasterLinkState constant."]
    pub linkstate: ai_int32,
    #[doc = " The data state, an \\c #AIRasterDataState constant."]
    pub datastate: ai_int32,
}
#[doc = " Parameters for controlling the curve fitting used when outlining a raster.\nKeep parameters within valid ranges to avoid excessive performance impact.\nTo reduce performance impact, try increasing smoothness and fidelity tolerance.\nSee \\c AIRasterSuite::ExtractOutline()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRasterOutlineParams {
    #[doc = " Valid range [0 to 5] inclusive."]
    pub noiseFilterDegree: ai_int32,
    #[doc = " Valid range [-1 to 1] inclusive."]
    pub cornerAngleTolerance: f64,
    #[doc = " Valid range [0 to 100] inclusive."]
    pub smoothnessTolerance: f64,
    #[doc = " Valid range greater than 0."]
    pub fidelityTolerance: f64,
}
#[doc = " When extracting an outline from a raster, the curves are enumerated to\nthese callbacks. See \\c AIRasterSuite::ExtractOutline()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRasterOutlineConsumer {
    #[doc = " Called at the beginning of the enumeration, use to initialize processing.\n@param self The current curve.\n@param knots The number of knots in the curve."]
    pub BeginComponent: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void, knots: ai_int32) -> AIErr,
    >,
    #[doc = " Called for each knot in each curve.\n@param self The current curve.\n@param in The in-point for the current knot.\n@param p The p-point for the current knot.\n@param out The out-point for the current knot."]
    pub PutKnot: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut ::std::os::raw::c_void,
            in_: AIRealPoint,
            p: AIRealPoint,
            out: AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Called at the end of the enumeration, use to terminate processing.\n@param self The current curve."]
    pub EndComponent:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> AIErr>,
}
#[doc = " @ingroup Suites\nThis suite provides functions with which to access and modify the\ndata associated with an art object of type \\c #kRasterArt.\n(Use \\c #AIArtSuite, \\c #AIMatchingArtSuite, or \\c #AIArtSetSuite\nto create or access\tthe raster art object itself.)\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIRasterSuite and \\c #kAIRasterVersion.\n\nThe art associated with a raster object is defined by its pixel data\nand a matrix that positions the pixel data in the document. This information\nis kept in an \\c #AIRasterRecord associated with the raster art object.\nThis suite allows you to work with the raster data as whole, for instance by\ngetting and setting its transformation matrix; or at a pixel level, using\nthe tile functions.\n\nAll values in the associated raster record are initialized to zero\nwhen you create a raster art object\twith \\c #AIArtSuite::NewArt().\nRetrieve the structure from the new art object using \\c #GetRasterInfo(),\nand use \\c #SetRasterInfo() to update the object.\n\nSet to the rectangle containing the pixel map using \\c #SetRasterInfo().\nThis is not the same rectangle as the artwork bounds, which Illustrator\ncalculates and provides. The origin of a raster art object is in the top\nleft corner; the coordinate system for a raster object is inverted on the\nvertical axis with respect to the Illustrator artboard coordinate system.\n\nAll pixel data in a raster object uses a base resolution of\t72 pixels\nper inch (PPI). You cannot directly specify the resolution; it is set\nfrom the bounds and the raster matrix. For a one inch square image\nat 72 PPI, the scale component of the raster matrix is set to 1.0 and\nthe bounds would be 72 x 72. To create a one inch square image at 300 PPI,\nset the bounds to 300 x 300; the scale becomes 0.24 (72/300).\n\nKeep your local pixel data in a \\e tile (\\c #AITile). Use \\c #GetRasterTile()\nto retrieve pixels from the pixel map and create a tile, and\n\\c #SetRasterTile() to copy pixel information from the tile to the pixel map.\n\nWhen copying or replacing image data between a raster art object\nand a local data buffer (tile), it can be impractical to work with\nall the information at one time. You can define and work with a more\npractical subset of the data called a \\e slice. Slices are defined in\nparameters of the functions that copy the data, \\c #GetRasterTile and\n\\c #SetRasterTile().\n\nA slice in the \\c #AITile structure defines the tile (the area to be copied or replaced),\nand additional slices are defined for both the raster art object (\\c artSlice) and\nfor the local data buffer (\\c workSlice). The one for the source controls\nhow the transfer occurs:\n\\li When copying from the raster art object to local data, \\c #GetRasterTile()\niterates over art slices.\n\\li When copying from the local data to the raster art object,\n\\c #SetRasterTile() iterates over work slices.\n\n@section ChannelInterleaving Channel Interleaving\n\nTogether with the slice information (see \\c #AISlice), the\n\\c #AITile::channelInterleave array specifies how to change the order of\nbytes making up a pixel when transferring between a raster art object and\nthe tile data buffer. This is useful when translating between similar\nbut not identical color formats.\n\nThe array contains a value for each channel, or color byte to be transferred.\nThe array index of a value specifies the source, for bytes read in order from\nthe internal bitmap. The array value maps the corresponding byte to a\ndestination position.\n\nIf there is no change in the data order, the array would be:\n\\verbatim\nmyTile.channelInterleave[0] = 0;\nmyTile.channelInterleave[1] = 1;\nmyTile.channelInterleave[2] = 2;\nmyTile.channelInterleave[3] = 3;\n\\endverbatim\n...\nAn example of using the channel interleave is transferring from the internal\nRGB format to a Mac OS GWorld PixMap. The internal format uses 3 bytes in\nthe order R G B to define a pixel. The GWorld uses 4 bytes in the order\nA R G B, where the A byte is the alpha channel information.\n\nWhen transferring between the raster art object and the GWorld,\nthe channel interleave specifies the mapping between the two\nincompatible forms. To transfer from the raster object to the\nGWorld this mapping would be used:\n\\verbatim\nGWorldTile.channelInterleave[0] = 1; // Map 24-bit red value to 32-bit red value\nGWorldTile.channelInterleave[1] = 2; // Map 24-bit green value to 32bit green value\nGWorldTile.channelInterleave[2] = 3; // Map 24-bit blue value to 32-bit blue value\nGWorldTile.channelInterleave[3] = 0; // Unused, handled by the slice definition\n\\endverbatim\n\nOnly three channels are mapped. The alpha channel of the GWorld receives\nno information. To transfer from the GWorld back to the raster object,\nthis mapping would be used:\n\\verbatim\nGWorldTile.channelInterleave[0] = 0; // Alpha channel ignored, handled by slice definition\nGWorldTile.channelInterleave[1] = 0; // Map 32-bit red value to 24-bit red value\nGWorldTile.channelInterleave[2] = 1; // Map 32-bit green value to 24bit green value\nGWorldTile.channelInterleave[3] = 2; // Map 32-bit blue value to 24-bit blue value\n\\endverbatim\n\nHere the data in the alpha channel of the GWorld is not transferred\nback to the raster object.\n\nThis example sets the art-object slice�s \\c front and \\c back values\nto limit the \\c channelInterleave array:\n\\verbatim\nGWorldTile.channelInterleave[0] = 1; // Map 24-bit red value to 32-bit red value\nGWorldTile.channelInterleave[1] = 2; // Map 24-bit green value to 32bit green value\nGWorldTile.channelInterleave[2] = 3; // Map 24-bit blue value to 32-bit blue value\nGWorldTile.channelInterleave[3] = 0; // Unused, handled by the slice definition\nartSlice.front = 0;\nartSlice.back = 3;\n\\endverbatim\n\nBecause \\c artSlice.back is set to 3, only the color information for\nthe first three channels is copied. When transferring data from the\nGWorld back to the raster art object, the GWorld�s slice controls the\nchannel interleave. To skip the alpha channel, \\c GWorldSlice.front is\nset to channel 1, causing channel 0 to be ignored.\n\n\\verbatim\nGWorldTile.channelInterleave[0] = 0; // Alpha channel is ignored, handled by the slice definition\nGWorldTile.channelInterleave[1] = 0; // Map 32-bit red value to 24-bit red value\nGWorldTile.channelInterleave[2] = 1; // Map 32-bit green value to 24bit green value\nGWorldTile.channelInterleave[3] = 2; // Map 32-bit blue value to 24-bit blue value\nGWorldSlice.front = 1;\nGWorldSlice.back = 4;\n\\endverbatim"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRasterSuite {
    #[doc = " Retrieves the raster record associated with a raster art object.\n@param raster An art object of type \\c #kRasterArt.\n@param info [out] A buffer in which to return the raster record."]
    pub GetRasterInfo: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, info: *mut AIRasterRecord) -> AIErr,
    >,
    #[doc = " Associates a raster record with a raster art object. After setting\nthe record, use other functions such as \\c #SetColorSpaceInfo() to\nspecify the image data configuration.\n@param raster An art object of type \\c #kRasterArt.\n@param info The raster record."]
    pub SetRasterInfo: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, info: *mut AIRasterRecord) -> AIErr,
    >,
    #[doc = " Retrieves the file information associated with a raster art object\nfor a link. (Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param file [out] A buffer in which to return the file specification."]
    pub GetRasterFileSpecification: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, file: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Not implemented. Returns \\c #kNotImplementedErr."]
    pub SetRasterFileSpecification: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, arg1: *const ai_FilePath) -> AIErr,
    >,
    #[doc = " Retrieves the transformation matrix for a raster art object. This is the\nconcatenation of all transforms applied to the image after it was created.\nIt typically contains at least the initial translation and a scale;\nsee \\c #SetRasterMatrix().\n@param raster An art object of type \\c #kRasterArt.\n@param matrix [out] A buffer in which to return the matrix."]
    pub GetRasterMatrix: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, matrix: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Sets the transformation matrix for a raster art object.\nAll raster data is internally kept at 72 PPI and uses the object�s\nscale to set a resolution.\n@param raster An art object of type \\c #kRasterArt.\n@param matrix The new matrix."]
    pub SetRasterMatrix: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, matrix: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Retrieves the raster image bounding box of a raster art object.\n@param raster An art object of type \\c #kRasterArt.\n@param bbox [out] A buffer in which to return the bounding rectangle.\n@note The raster bounding box, as specified for \\c #SetRasterInfo()\nor \\c #SetRasterBoundingBox(), is not the same rectangle\nas the artwork bounds, which Illustrator calculates\nand provides for any art object. To do transformations,\nuse \\c #AIArtSuite::GetArtBounds()."]
    pub GetRasterBoundingBox: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, bbox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Sets the raster image bounding box of a raster art object.\n@param raster An art object of type \\c #kRasterArt.\n@param bbox The bounding rectangle for the raster image.\nThe top left value must be zero. The right value gives\nthe width and the bottom value the height. (The coordinate\nsystem for a raster object is inverted on the vertical\naxis with respect to the Illustrator artboard coordinate\nsystem.)\n@see \\c #GetRasterBoundingBox(), \\c #AIRasterRecord::bounds"]
    pub SetRasterBoundingBox: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, bbox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Copies all or part of the pixel data for a raster art object into a\nlocal buffer (a tile). Use with \\c #SetRasterTile() to filter raster data.\n@param raster An art object of type \\c #kRasterArt.\n@param artSlice\tThe slice that defines a subset of the pixel map to be copied.\n@param workTile\tThe tile, which defines the data buffer in which\npixel data is returned, and parameters for the transfer operation.\n@param workSlice The slice that defines a subset of the local data buffer\nto which to copy data. Typically, the bounds are the same as those\nof the work tile."]
    pub GetRasterTile: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            artSlice: *mut AISlice,
            workTile: *mut AITile,
            workSlice: *mut AISlice,
        ) -> AIErr,
    >,
    #[doc = " Copies pixel data in a local buffer (a tile) to all or part of\na raster art object�s pixel map. This can be used, for instance,\nwhen reading a raster file format into a new raster art object.\n@param raster An art object of type \\c #kRasterArt.\n@param artSlice\tThe slice that defines a subset of the pixel map to be replaced.\n@param workTile\tThe tile, which defines the data buffer in which\npixel data is returned, and parameters for the transfer operation.\n@param workSlice The slice that defines a subset of the local data buffer\nfrom which to copy data. Typically, the bounds are the same as those\nof the work tile."]
    pub SetRasterTile: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            artSlice: *mut AISlice,
            workTile: *mut AITile,
            workSlice: *mut AISlice,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the link information for a raster object that is a link.\n(Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param link [out] A buffer in which to return the link information."]
    pub GetRasterLink: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, link: *mut AIRasterLink) -> AIErr,
    >,
    #[doc = " Sets link information for a raster object.\n(Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param link The link information."]
    pub SetRasterLink: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, link: *const AIRasterLink) -> AIErr,
    >,
    #[doc = " Retrieves the link information for a raster art object, and reloads\nthe raster data if needed. Marks the data as unmodified, but does not\nchange the embedded state.\n\nDepending on the option flags, this can force reload, regardless of\nthe embedded or modified state. If the flags do not specify that\nresolution should be forced, it is done only if the linked to data\nis more recent than the current copy.\n\nAttempting to resolve a link can fail for any of the following reasons:\n\\li No link source is specified\n\\li The link source is not found (\\c #kRasterLinkFileNotFoundErr)\n\\li A plug-in that can load the link source data is not found\n(\\c #kRasterLinkPluginNotFoundErr)\n\\li The link source data cannot be read\n\\li Out of memory\n\n(Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param flags Option flags for how the operation is performed.\nA logical OR of \\c #AIResolveRasterLinkFlags."]
    pub ResolveRasterLink:
        ::std::option::Option<unsafe extern "C" fn(raster: AIArtHandle, flags: ai_int32) -> AIErr>,
    #[doc = " Retrieves the file information associated with a raster art object\nthat is a link, such as the time the file was created and last modified.\nThis information is stored with the object from when the file\nwas last read; compare to the current file information to check\nif the file has changed.<br>\n(Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param pSPFileInfo [out] A buffer in which to return the file information,\n@see \\c #GetRasterFileInfoFromFile()"]
    pub GetRasterFileInfoFromArt: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, pSPFileInfo: *mut SPPlatformFileInfo) -> AIErr,
    >,
    #[doc = " Retrieves the file information for the file associated with a raster art object\nthat is a link, such as the time the file was created and last modified.\nCompare to the file information stored with the object to check\nif the file has changed since it was last read.<br>\n(Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param pSPFileInfo [out] A buffer in which to return the file information,\n@see \\c #GetRasterFileInfoFromArt()"]
    pub GetRasterFileInfoFromFile: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, pSPFileInfo: *mut SPPlatformFileInfo) -> AIErr,
    >,
    #[doc = " Retrieves the path for the file associated with a raster art object that is a link.\n<br> (Direct linking of images is deprecated, although still supported.\nCreate linked objects using the \\c #AIPlacedSuite.)\n@param raster An art object of type \\c #kRasterArt.\n@param path [out] A buffer in which to return the platform-specific path."]
    pub GetRasterFilePathFromArt: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, path: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the number of levels in the MIP map that stores the raster data\nfor a raster art object.\n@param raster An art object of type \\c #kRasterArt.\n@param count [out] A buffer in which to return the number of levels\n(Currently always 6.)"]
    pub CountLevels: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, count: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the bitmap format information for a level in the MIP map for\na raster art object. Use with \\c #CountLevels() to iterate through levels.\n@param raster An art object of type \\c #kRasterArt.\n@param level The 0-based level index.\n@param info [out] A buffer in which to return the bitmap information.\n@note In the returned raster record:\n\\li The \\c flags are those you would get by querying the image\nas a whole.\n\\li The \\c bounds are those of the image at the given level of\nthe MIP map. Each level is a power of two less than the\nprevious one, with odd dimensions rounded up. For example,\n<code>levelWidth = (prevLevelWidth + 1) / 2 </code>\n<br>Do not rely on this algorithm, however. The only important\nproperty maintained is that any rectangle contained within the base\nimage is contained within an image at a given level after\nscaling to that\tlevel, even if its dimensions are rounded up.\n\\li The \\c byteWidth is ignored.\n\\li The \\c colorSpace and \\c bitsPerPixel describe the format of\nthe pixel data at the given level of the MIP map (currently\nalways the same as that of the base image). The\tsubsampled\nlevels of a bitmap's MIP map are bitmaps; random sampling is\nused to avoid aliasing."]
    pub GetLevelInfo: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            level: ai_int32,
            info: *mut AIRasterRecord,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the tile information for a level in the MIP map for a\nraster art object. Use with \\c #CountLevels() to iterate through levels.\n@param raster An art object of type \\c #kRasterArt.\n@param level The 0-based level index.\n@param artSlice\tThe slice that defines a subset of the pixel map to be copied.\n@param workTile\tThe tile, which defines the data buffer in which\npixel data is returned, and parameters for the transfer operation.\n@param workSlice The slice that defines a subset of the local data buffer\nto which to copy data. Typically, the bounds are the same as those\nof the work tile.\n@see \\c #GetRasterTile()"]
    pub GetLevelTile: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            level: ai_int32,
            artSlice: *mut AISlice,
            workTile: *mut AITile,
            workSlice: *mut AISlice,
        ) -> AIErr,
    >,
    #[doc = " Extracts an outline path from the image data, and enumerates the curves\nto the supplied callback functions.\n@param raster An art object of type \\c #kRasterArt.\n@param params Parameters that control the curve fitting, or \\c NULL\nto use defaults. Keep parameters within valid ranges to\navoid excessive performance impact.\n@param consumer The developer-defined callbacks."]
    pub ExtractOutline: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            params: *const AIRasterOutlineParams,
            consumer: *mut AIRasterOutlineConsumer,
        ) -> AIErr,
    >,
    #[doc = " Post-concatenate a transformation onto the matrix applied to a raster object.\n@param raster An art object of type \\c #kRasterArt.\n@param concat The new transformation matrix information."]
    pub ConcatRasterMatrix: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, concat: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Attaches additional color space information to a raster art object,\nrequired for non-standard color spaces  (Separation, NChannel, and Indexed).\n@param raster An art object of type \\c #kRasterArt.\n@param cs The color space information, with the same number of\ncolors and channels as the color space specified in\nthe \\c #AIRasterRecord::colorSpace."]
    pub SetColorSpaceInfo: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, cs: *const ai_ColorSpace) -> AIErr,
    >,
    #[doc = " Retrieves the additional color space information from a raster art object,\nwhich is required for non-standard color spaces  (Separation, NChannel, and Indexed).\n@param raster An art object of type \\c #kRasterArt.\n@param cs [out] A buffer in which to return the color space information\n@note If the raster is a colorized grayscale image, returns the actual color space\nused for the colorization. <br>\nIf the color space info for non-standard color space has not been specified,\nreturns an error code and an invalid color space."]
    pub GetColorSpaceInfo: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, cs: *mut ai_ColorSpace) -> AIErr,
    >,
    #[doc = " Enables or disables overprinting for a raster object.\n@param raster An art object of type \\c #kRasterArt.\n@param enable True to enable overprint, false to disable it."]
    pub SetOverprint: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, enable: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the overprint status for a raster object.\n@param raster An art object of type \\c #kRasterArt.\n@param enable [out] A buffer in which to return true if\noverprint is enabled, false if it is disabled."]
    pub GetOverprint: ::std::option::Option<
        unsafe extern "C" fn(raster: AIArtHandle, status: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a raster object is a colorized grayscale or bitmap image.\n@param raster An art object of type \\c #kRasterArt.\n@param isColorized [out] A buffer in which to return true if the raster\nis a colorized grayscale or bitmap image.\n@param isAdditive [out] Optional. A buffer in which to return true if the\nraster should be interpreted as additive."]
    pub IsColorized: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            isColorized: *mut AIBoolean,
            isAdditive: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Clears the colorization on a colorized grayscale or bitmap image.\n@param raster An art object of type \\c #kRasterArt."]
    pub ClearColorization:
        ::std::option::Option<unsafe extern "C" fn(raster: AIArtHandle) -> AIErr>,
    #[doc = " Converts the colors in a raster object to a non-indexed color space.\n@param raster [in, out] An art object of type \\c #kRasterArt, which is modified in place.\n@param dstCS The destination color space, which must not be indexed."]
    pub ConvertColors: ::std::option::Option<
        unsafe extern "C" fn(raster: *mut AIArtHandle, dstCS: *const ai_ColorSpace) -> AIErr,
    >,
    #[doc = " Inverts the colors in a raster object.\n@param raster [in, out] An art object of type \\c #kRasterArt, which is modified in place."]
    pub InvertColors:
        ::std::option::Option<unsafe extern "C" fn(raster: *mut AIArtHandle) -> AIErr>,
    #[doc = " Decomposes a raster object into an array of rasters specified in the standard\ncolor spaces (Gray, RGB, CMYK and spot Separation).\nThe alpha channel from the original raster is duplicated among all the\noutput rasters.\n@param raster An art object of type \\c #kRasterArt.\n@param rasterArray [out] A buffer in which to return a pointer to a\nblock of memory containing the array of new raster art objects.\nYou must release the memory block when it is no longer\nneeded using \\c #SPBasicSuite::FreeBlock().\n@param numRasters [out] A buffer in which to return the number of objects\nin the raster array, 0 if no rasters are constructed.\n@param flag How to treat CMYK process channels, one of the constants\n\\c #kAISplitRasterStandard or \\c #kAISplitRasterSeparateProcess.\n@see \\c #InterleaveChannels()"]
    pub SplitChannels: ::std::option::Option<
        unsafe extern "C" fn(
            raster: AIArtHandle,
            rasterArray: *mut *mut AIArtHandle,
            numRasters: *mut ai_int32,
            flags: ai_uint32,
        ) -> AIErr,
    >,
    #[doc = " Interleaves the color channels from an array of raster objects and\nrecombines them into a single raster.\nThe source rasters and the destination raster must have the same width and height. 1-bit bitmap rasters are\nnot allowed in the input raster array. The alpha channel of the output raster is the average of all the alpha\nchannels in the input raster array (if there are any). It is ok that not all the input rasters have alpha\nchannels.\n@param rasterArray A pointer to a block of memory containing the array of raster art objects\nto be interleaved.\n@param numRasters The number of objects in the raster array.\n@param raster [out] A buffer in which to return the combined raster, an\nart object of type \\c #kRasterArt.\n@param flag Not used. Pass \\c NULL.\n@see \\c #SplitChannels()"]
    pub InterleaveChannels: ::std::option::Option<
        unsafe extern "C" fn(
            rasterArray: *mut AIArtHandle,
            numRasters: ai_int32,
            raster: *mut AIArtHandle,
            flags: ai_uint32,
        ) -> AIErr,
    >,
}
#[doc = " EPS file"]
pub const AIPlacedObjectType_kEPSType: AIPlacedObjectType = 0;
#[doc = " Not EPS"]
pub const AIPlacedObjectType_kOtherType: AIPlacedObjectType = 1;
#[doc = " Types of placed object."]
pub type AIPlacedObjectType = ::std::os::raw::c_uint;
#[doc = " Placed object has Black(K) Plate"]
pub const AIPlacedPlateInfo_kAIPlacedHasBlack: AIPlacedPlateInfo = 1;
#[doc = " Placed object has Cyan Plate"]
pub const AIPlacedPlateInfo_kAIPlacedHasCyan: AIPlacedPlateInfo = 2;
#[doc = " Placed object has Magenta Plate"]
pub const AIPlacedPlateInfo_kAIPlacedHasMagenta: AIPlacedPlateInfo = 4;
#[doc = " Placed object has Yellow Plate"]
pub const AIPlacedPlateInfo_kAIPlacedHasYellow: AIPlacedPlateInfo = 8;
#[doc = " Placed object has at least one spot Plate"]
pub const AIPlacedPlateInfo_kAIPlacedHasCustomColors: AIPlacedPlateInfo = 16;
#[doc = " Flag value to represent plates used by Placed object"]
pub type AIPlacedPlateInfo = ::std::os::raw::c_uint;
pub const AIPlaceTransformType_kAIPlaceTransformTypeNone: AIPlaceTransformType = 0;
pub const AIPlaceTransformType_kAIPlacedTransformTypeFitToView: AIPlaceTransformType = 1;
pub type AIPlaceTransformType = ::std::os::raw::c_uint;
#[doc = " Request data for \\c #AIPlacedSuite::ExecPlaceRequest().\nInitialize all fields, even when not expecting to use them."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPlaceRequestData {
    #[doc = " The type of placement request, a \\c #PlaceRequestMode constant\nwhich determines what operation is performed."]
    pub m_lPlaceMode: ai_int32,
    #[doc = " Art to be replaced."]
    pub m_hOldArt: AIArtHandle,
    #[doc = " Returns the handle for new art that was placed or created."]
    pub m_hNewArt: AIArtHandle,
    #[doc = " File path of the placed file. If \\c NULL, shows a File Place dialog\nto query the user for the path and any relevant placement options."]
    pub m_pFilePath: *const ai_FilePath,
    #[doc = " The type of art to create for the \\c #kCreateNewArt request,\nan \\c #AIArtType value."]
    pub m_lParam: ai_int32,
    #[doc = " 0 to place or import the file, 1 to link the file."]
    pub m_filemethod: ai_int16,
    #[doc = " True to disable the Template placement option."]
    pub m_disableTemplate: ASBoolean,
    #[doc = " True to show the parameters dialog even when the file path is known."]
    pub m_doShowParamDialog: AIBoolean,
    #[doc = " to trigger what kind of placement you want"]
    pub m_PlaceTransformType: AIPlaceTransformType,
}
#[doc = "\t@ingroup Suites\nThis suite provides functions that allow you to access and manipulate\n\\e placed \\e art. Illustrator uses placed art to link artwork contained\nin external files into an Illustrator document. For a file to be linked,\nthere must be an installed file-format plug-in that supports linking the format.\n\nA placed object is defined by its file specification and a matrix positioning\nthe file content in the document.\n\nAfter creating an empty placed object, use \\c #SetPlacedBoundingBox() to\nset initial bounds, then call \\c #AIArtSuite::UpdateArtworkLink() to read\nthe content of the referenced file. If the file is read successfully,\nthe initial bounds are replaced by the true bounds from the file. If the read fails,\nthe bounds are not changed, and, if this function were not used to\nset them, the result would be a placed object without width or height.\n\nAll file types except EPS also have a group of art objects that represents\nthe parsed contents of the file.When a file-format plug-in is requested to\nlink a file other than an EPS, it does the following:\n\n\\li Creates a placed object for the linked file, setting its file specification\nto reference the file.\n\\li Calls \\c #SetPlacedObject() to create a group to contain the artwork\nrepresenting the content of the linked file.\n\\li Reads the content of the linked file, creating the artwork to represent\nthe content.\n\\li Sets the matrix of the placed object as needed to position the content\nin the document.\n\nThe transformation matrix of a placed image is the concatenation of all of the\ntransforms applied to the image after it has been placed. The matrix begins as\na simple translate which positions the image on the page. You can also rotate,\nscale and shear the image.\n\nPlacement options control how a linked image is positioned and scaled\nrelative to the bounds of the placed object. Placement is\nadjusted whenever the image size changes; that is, when the file changes\non disk, or when it is explicitly relinked with \\c #SetPlacedFileSpecification().\nThe replacement image can be placed into the bounds of the original object, or\nthe bounds of the original object can be scaled, and the replacement placed\ninto the resulting bounds.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPlacedSuite and \\c #kAIPlacedVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPlacedSuite {
    #[doc = " Retrieves the file specification for the linked file of a placed object.\nIf the linked file does not exist, the returned file specification\nsupplies only the file name.\n@param placed The placed object.\n@param file [out] A buffer in which to return the file specification."]
    pub GetPlacedFileSpecification: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, file: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Associates a placed object with a linked file. If the file is an EPS,\nimmediately parses the contents and acquires the PICT preview.\nOtherwise, defers parsing until you request it with\n\\c #AIArtSuite::UpdateArtworkLink() or \\c #AIDocumentSuite::UpdateLinks().\n@param placed The placed object.\n@param file The file specification. If this identifies an EPS, i"]
    pub SetPlacedFileSpecification: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, file: *const ai_FilePath) -> AIErr,
    >,
    #[doc = " Retrieves the transformation matrix that positions the content of a placed art object's\nlinked file in the document. Use with \\c #SetPlacedMatrix() to modify the transformation.\n@param placed The placed object.\n@param matrix [out] A buffer in which to return the transformation matrix.\n@see \\c #ConcatPlacedMatrix()"]
    pub GetPlacedMatrix: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, matrix: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Sets the transformation matrix of a placed art object. The matrix includes\nthe simple translate that places the image on the page, as well as any rotate,\nscale, and shear values. Use with \\c #GetPlacedMatrix() to modify the transformation.\n@param placed The placed object.\n@param matrix The new transformation matrix.\n@see \\c #ConcatPlacedMatrix()"]
    pub SetPlacedMatrix: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, matrix: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Retrieves the boundary dimensions of placed art, regardless of the\ntransformations applied to it.\n@param placed The placed object.\n@param bbox [out] A buffer in which to return the bounding rectangle."]
    pub GetPlacedBoundingBox: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, bbox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Creates or clears and returns a group art object to hold the parsed content of\nthe linked file for a placed object. File-format plug-ins call this when reading\nthe content of a linked file.\n@param placed The placed object.\n@param group [out] A buffer in which to return the group art object."]
    pub SetPlacedObject: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, group: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Gets the number of custom colors used by a placed art object for an EPS file. Use with\n\\c #GetNthPlacedCustomColorName() to iterate through the colors and get their names.\n@param art The placed object.\n@param count [out] A buffer in which to return the number of spot colors.\n@return The error \\c #kBadParameterErr if the linked file is not an EPS.\n@see \\c #AICustomColorSuite."]
    pub CountPlacedCustomColors: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, count: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the name of custom color used by a placed art object for an EPS file.\nUse with \\c #CountPlacedCustomColors to iterate through the custom colors.\n@param art The placed art object.\n@param num The 0-based position index of the color.\n@param name [out] A buffer in which to return the color name.\n@return The error \\c #kBadParameterErr if the linked file is not an EPS."]
    pub GetNthPlacedCustomColorName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, num: ai_int32, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Changes a linked placed-art or raster-art object to an  embedded art object.\n@param placed The art object, of type \\c #kPlacedArt or \\c #kRasterArt.\n@param native [out] A buffer in which to return the new embedded art object.\n@param askForParam When true, show dialog for user input if needed."]
    pub MakePlacedObjectNative: ::std::option::Option<
        unsafe extern "C" fn(
            placed: AIArtHandle,
            native: *mut AIArtHandle,
            askForParam: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the type of a placed object (EPS or other file type).\n@param placed The art object, of type \\c #kPlacedArt or \\c #kRasterArt.\n@param pPlacedType [out] A buffer in which to return the type constant,\nan \\c #AIPlacedObjectType value."]
    pub GetPlacedType: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, pPlacedType: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Retrieves the art group representing the parsed content of the\nnon-EPS linked file for a placed object.\n@param placed The placed object.\n@param group [out] A buffer in which to return the art group object.\n@return The error \\c #kBadParameterErr if the linked file is not an EPS."]
    pub GetPlacedChild: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, group: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Executes a  request related to a placed object.\nThe request can place or replace the art, either explicitly\nor in relation to the current selection.\n@param placeRequestData An \\c #AIPlaceRequestData structure in which to\nspecify the request and return results."]
    pub ExecPlaceRequest: ::std::option::Option<
        unsafe extern "C" fn(placeRequestData: *mut AIPlaceRequestData) -> AIErr,
    >,
    #[doc = " Retrieves the file information for a placed object's linked file (such\nas the creation and modification dates), as stored from the most recent\nfile read operation.\n@param placed The placed object.\n@param spFileInfo [out] A buffer in which to return the file information.\n@note Compare this file information (stored with the placed object)\nto the current information for the file itself (\\c #GetPlacedFileInfoFromFile())\nto determine if the file has changed."]
    pub GetPlacedFileInfoFromArt: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, spFileInfo: *mut SPPlatformFileInfo) -> AIErr,
    >,
    #[doc = " Retrieves the file information for a placed object's linked file (such\nas the creation and modification dates), from the file itself (as opposed to\nthe file information stored with the object).\n@param placed The placed object.\n@param spFileInfo [out] A buffer in which to return the file information.\n@see  \\c #GetPlacedFileInfoFromArt()"]
    pub GetPlacedFileInfoFromFile: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, spFileInfo: *mut SPPlatformFileInfo) -> AIErr,
    >,
    #[doc = " Retrieves the path specification for the file associated with a placed-art object.\n@param placed The placed object.\n@param path [out] A buffer in which to return the platform-specific file path string."]
    pub GetPlacedFilePathFromArt: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, path: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Concatenates a new transformation onto the existing transformation matrix\nfor a placed object.\n@param placed The placed object.\n@param concat The new transformation matrix."]
    pub ConcatPlacedMatrix: ::std::option::Option<
        unsafe extern "C" fn(placed: AIArtHandle, concat: *mut AIRealMatrix) -> AIErr,
    >,
    #[doc = " Sets the placement options for a placed object, used to scale and place the\nlinked image relative to the bounds of the placed object. Placement is\nadjusted whenever the image size changes; that is, when the file changes\non disk, or when it is explicitly relinked with \\c #SetPlacedFileSpecification().\n@param placed The placed object.\n@param method The way to position and size the linked object.\n@param alignment The way to align the linked object\n@param clip\tTrue to clip the linked object."]
    pub SetPlaceOptions: ::std::option::Option<
        unsafe extern "C" fn(
            placed: AIArtHandle,
            method: ai_PlaceMethod,
            alignment: ai_PlaceAlignment,
            clip: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the placement options for a placed object. See \\c #SetPlaceOptions().\n@param placed The placed object.\n@param method [out] A buffer in which to return the method used to position and size the linked object.\n@param alignment [out] A buffer in which to return the alignment of the linked object.\n@param clip\t[out] A buffer in which to return true if the linked object is clipped."]
    pub GetPlaceOptions: ::std::option::Option<
        unsafe extern "C" fn(
            placed: AIArtHandle,
            method: *mut ai_PlaceMethod,
            alignment: *mut ai_PlaceAlignment,
            clip: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the size, placement, and transformation of a placed object itself,\nand of its linked image.The matrices are those used to transform the object and\nimage from the original bounds to their current locations on the screen.\nWith the \\c #kConform placement option, these are the same.\n@param placed The placed object.\n@param size [out] A buffer in which to return the size (the X and Y dimensions)\nof the original image.\n@param viewBounds [out] A buffer in which to return the bounding box of the placed object.\n@param viewMatrix [out] A buffer in which to return the transformation matrix of the placed object.\n@param imageBounds [out] A buffer in which to return the bounding box of the linked image.\n@param imageMatrix [out] A buffer in which to return the transformation matrix of the linked image."]
    pub GetPlacedDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            placed: AIArtHandle,
            size: *mut AIRealPoint,
            viewBounds: *mut AIRealRect,
            viewMatrix: *mut AIRealMatrix,
            imageBounds: *mut AIRealRect,
            imageMatrix: *mut AIRealMatrix,
        ) -> AIErr,
    >,
    #[doc = " Sets the preliminary bounding box information for a placed object.\n@param art The placed object.\n@param bbox The bounding rectangle."]
    pub SetPlacedBoundingBox: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, bbox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Retrieves the raster record describing the image for a placed object\nthat represents a placed, linked image.\n@param art The placed object.\n@param info [out] A buffer in which to return the information.\n@param israster [out] A buffer in which to return if the placed object\ndoes represent an image, false if it does not."]
    pub GetRasterInfo: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            info: *mut AIRasterRecord,
            israster: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Gets the process colors plates used by a placed art object for an EPS file or a placed, linked image.\n@param art The placed object.\n@param plateInfo [out]  A buffer in which to return which plates are used by the placed object"]
    pub GetProcessPlatesInfo: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, plateInfo: *mut AIPlacedPlateInfo) -> AIErr,
    >,
    pub IsPlacedFileDamaged:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    pub IsProxyUsedForRendering:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_Opaque_ArtboardRange {
    _unused: [u8; 0],
}
#[doc = " Opaque artboard range reference. See \\c #AIArtboardRangeSuite"]
pub type AIArtboardRangeHandle = *mut _t_Opaque_ArtboardRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_Opaque_ArtboardRangeIterator {
    _unused: [u8; 0],
}
#[doc = " Opaque artboard range iteration object. See \\c #AIArtboardRangeSuite"]
pub type AIArtboardRangeIterator = *mut _t_Opaque_ArtboardRangeIterator;
#[doc = " @ingroup Suites\nThis suite allows you to validate a string containing a range of artboard indices and\nsequentially iterate over the range. A range of artboards\nis typically provided by the user in the Print, Save and Export dialogs.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArtboardRangeSuite and \\c #kAIArtboardRangeSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtboardRangeSuite {
    #[doc = "  Creates an artboard range reference.\n\n@param allArtboards True to include all defined artboards in the range. False to use a range string.\n@param rangeStr A valid artboard range string. Ignored if \\c allArtboards is true.\n@param range [out] A buffer in which to return the new artboard range reference.\n@see \\c #ValidateString()"]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            allArtboards: ASBoolean,
            rangeStr: *const ai_UnicodeString,
            range: *mut AIArtboardRangeHandle,
        ) -> AIErr,
    >,
    #[doc = "Retrieves the number of artboards in an artboard range.\n\n@param range An artboard range reference.\n@param count [out] A buffer in which to return the number of artboards."]
    pub GetCount: ::std::option::Option<
        unsafe extern "C" fn(range: AIArtboardRangeHandle, count: *mut ASInt32) -> AIErr,
    >,
    #[doc = "Creates a bi-directional iterator for an artboard range.\n\n@param range An artboard range reference.\n@param rangeItr [out] A buffer in which to return the iterator, which initially\npoints to the first element of the artboard range.\n@see \\c #DisposeIterator()"]
    pub Begin: ::std::option::Option<
        unsafe extern "C" fn(
            range: AIArtboardRangeHandle,
            rangeItr: *mut AIArtboardRangeIterator,
        ) -> AIErr,
    >,
    #[doc = "Retrieves the next element in an artboard range and increments the iterator.\n\n@param rangeItr The artboard range iterator.\n@param artboardNumber [out] A buffer in which to return the 0-based index of the next artboard.\n@return The error \\c #kEndOfRangeErr if the iterator has reached the end of the range."]
    pub Next: ::std::option::Option<
        unsafe extern "C" fn(
            rangeItr: AIArtboardRangeIterator,
            artboardNumber: *mut ASInt32,
        ) -> AIErr,
    >,
    #[doc = "Retrieves the previous element in an artboard range and decrements the iterator.\n\n@param rangeItr The artboard range iterator.\n@param artboardNumber [out] A buffer in which to return the 0-based index of the previous artboard.\n@return The error \\c #kEndOfRangeErr if the iterator has reached the beginning of the range."]
    pub Previous: ::std::option::Option<
        unsafe extern "C" fn(
            rangeItr: AIArtboardRangeIterator,
            artboardNumber: *mut ASInt32,
        ) -> AIErr,
    >,
    #[doc = "Sets the iterator to the last element in an artboard range.\n\n@param rangeItr The artboard range iterator."]
    pub Back:
        ::std::option::Option<unsafe extern "C" fn(rangeItr: AIArtboardRangeIterator) -> AIErr>,
    #[doc = "Disposes of an artboard range iterator created by \\c #Begin().\n\n@param rangeItr An artboard range iterator."]
    pub DisposeIterator:
        ::std::option::Option<unsafe extern "C" fn(rangeItr: AIArtboardRangeIterator) -> AIErr>,
    #[doc = "Disposes of an artboard range handle created by \\c #Create().\n\n@param range An artboard range reference."]
    pub Dispose: ::std::option::Option<unsafe extern "C" fn(arg1: AIArtboardRangeHandle) -> AIErr>,
    #[doc = "Validates an artboard range string. A valid range string contains a comma-separated\nlist of artboard index numbers and index ranges (n-m). The index is 0-based.\nA valid string could be, for example, \"1,2,3-5,8\".\n\n@param rangeStr The string containing the artboard range.\n@return The error \\c #kBadParameterErr if the range string is invalid."]
    pub ValidateString:
        ::std::option::Option<unsafe extern "C" fn(rangeStr: *const ai_UnicodeString) -> AIErr>,
    #[doc = "Reports whether an artboard range includes all defined artboards.\n@param range An artboard range reference.\n@param result [out] A buffer in which to return the output as true if the range includes all artboards, false otherwise.\n@return The error \\c #kBadParameterErr if any parameter is NULL."]
    pub IsAllSelected: ::std::option::Option<
        unsafe extern "C" fn(range: AIArtboardRangeHandle, result: *mut ASBoolean) -> AIErr,
    >,
    #[doc = "Removes duplicate crop areas from an artboard range. This call re-sorts the range\nand invalidates all iterators for this range.\n@param range An artboard range reference.\n@return The error \\c #kBadParameterErr if any parameter is NULL."]
    pub RemoveDuplicate:
        ::std::option::Option<unsafe extern "C" fn(range: AIArtboardRangeHandle) -> AIErr>,
}
#[doc = " Identifies the data type of an action parameter."]
pub type ActionParamTypeID = ai_uint32;
#[doc = " Identifies units for some numeric parameters. Units are shown when type is \\c actionTypeUnitReal."]
pub type ActionParamUnitID = ai_uint32;
#[doc = " Identifies a unique key associated with a parameter block"]
pub type ActionParamKeyID = ai_uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ActionParamType {
    _unused: [u8; 0],
}
#[doc = " A reference to a Type Parameter Block (TPB)"]
pub type AIActionParamTypeRef = *mut ActionParamType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ActionParamValue {
    _unused: [u8; 0],
}
#[doc = " A reference to a Value Parameter Block (VPB)"]
pub type AIActionParamValueRef = *mut ActionParamValue;
#[doc = " User-defined data. This is cast after it has been defined."]
pub type AIActionUserData = *mut ::std::os::raw::c_void;
#[doc = " Callback procedure prototype."]
pub type AIActionCallbackProc = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: AIActionParamValueRef,
        userData: AIActionUserData,
        showDialog: AIBoolean,
    ) -> ASErr,
>;
#[doc = " Idle procedure prototype."]
pub type AIActionIdleProc = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " No dialog is defined for this action"]
pub const _ActionDialogStatus_kDialogNone: _ActionDialogStatus = 0;
#[doc = " Dialog appears on playback"]
pub const _ActionDialogStatus_kDialogOn: _ActionDialogStatus = 1;
#[doc = " Internal, not used by 3rd-party plug-ins"]
pub const _ActionDialogStatus_kDialogPartialOn: _ActionDialogStatus = 2;
#[doc = " Dialog does not appear on playback"]
pub const _ActionDialogStatus_kDialogOff: _ActionDialogStatus = 3;
#[doc = " Choices for whether a parameters dialog appears by default when an action is played back.\nThis status is visually represented by a dialog icon to the left of the\nevent name in the Actions palette."]
pub type _ActionDialogStatus = ::std::os::raw::c_uint;
#[doc = " Choices for whether a parameters dialog appears by default when an action is played back.\nThis status is visually represented by a dialog icon to the left of the\nevent name in the Actions palette."]
pub use self::_ActionDialogStatus as ActionDialogStatus;
#[doc = " shown or hidden according to parameter data type"]
pub const _ActionValueVisibility_kDependOnParamType: _ActionValueVisibility = -1;
#[doc = " hidden"]
pub const _ActionValueVisibility_kHideInPalette: _ActionValueVisibility = 0;
#[doc = " shown"]
pub const _ActionValueVisibility_kShowInPalette: _ActionValueVisibility = 1;
#[doc = " Values that control whether values are shown in the Actions palette."]
pub type _ActionValueVisibility = ::std::os::raw::c_int;
#[doc = " Values that control whether values are shown in the Actions palette."]
pub use self::_ActionValueVisibility as ActionValueVisibility;
#[doc = " A plug-in receives this message with the request to execute an action. The\nmessage caller is \\c ::kActionCaller and the selector is \\c ::kDoActionSelector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoActionMessage {
    #[doc = " Message data"]
    pub d: SPMessageData,
    #[doc = " Plug-in defined data"]
    pub userData: AIActionUserData,
    #[doc = " When true, the plug-in should show the parameters dialog."]
    pub showDialog: AIBoolean,
    #[doc = " VPB containing parameter values previously recorded or set by another plug-in."]
    pub param: AIActionParamValueRef,
}
#[doc = "\t@ingroup Suites\n\nThe Action Manager suite allows you to access the internal scripting system built into\nAdobe Illustrator. The Action Manager allows you to record and play actions which\nexecute Illustrator menu commands or plug-in commands. The Action Manager suite allows\nyour plug-in to play actions or register itself to the Illustrator application to enable\nyour plug-in to be scriptable via the Actions palette.\n\nAn action event is an execution of an Illustrator command. An action event\ncan originate from the Illustrator application or a plug-in. It is normally, but\nnot limited to, an evaluation or modification to Illustrator artwork. Adobe\nIllustrator�s Action Manager dispatches action events.\n\nIn order for your plug-in�s action events to be recorded or played back you\nmust register them with the Action Manager and specify the parameters\nassociated with your action event. In addition to registering you actions,\nyour plug-in must respond to the Action Manager when it tells you to play\nyour plug-in�s action event.\n\nThe Action Manager suite is exported by a plug-in. It may be disabled by removing\nthe Action Manager plug-in. Because of this, during startup you must always check for\nthe presence of the AIActionManager suite pointer before calling any Action Manager\nfunctions.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIActionManagerSuite and \\c #kAIActionManagerVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIActionManagerSuite {
    #[doc = "\tThis function registers a plug-in�s action event with the Adobe Illustrator application.\nCall it during the startup procedure of your plug-in. This is necessary for your plug-in event\nto be recognized by the Actions palette. It is the first step in making your plug-in into an action.\n\nThe Action Manager suite is exported by a plug-in. It may be disabled by removing the Action Manager plug-in.\nBecause of this, during startup you must always check for the presence of the AIActionManager suite pointer\nbefore calling any Action Manager functions.\n\nIf your plug-in registers an action event at startup, you are responsible for recording your action event\nand any associated parameters whenever the user is in Record mode.See \\c #InRecordMode() and \\c #RecordActionEvent().\n\n@param eventName A string that identifies your plug-in event internally; not localized.\nMust be unique among plug-ins. Typically the name of your plug-in, preceded by your\ncompany name; for example, \"adobe_saveDocumentAs\".\n\n@param localizedName A string that is shown in the Adobe Illustrator Actions palette;\nwill be localized.\n\n@param callback Not used, pass a \\c null value.\n\n@param plugin The plug-in registering the event (usually <code>message.d->self</code>).\n\n@param userData A pointer to private data associated with the action event.\nMust be allocated by your  plug-in (using \\c SPBlocks.h) at startup.\nThis is passed back to your code in \\c GetActionEventUserData and in the \\c DoActionMessage.\n\n@param parameters A reference to a type parameter block (TPB).\nA TPB contains keys that describe the parameter block of your plug-in.\nTo provide this value:\n\\li Create an \\c AIActionParamTypeRef using \\c #AINewActionParamType().\n\\li Fill it with keys that describe your parameter block using \\c #AIActionSetTypeKey().\n\\li Pass it to this function.\n\\li Destroy it using \\c #AIDeleteActionParamType()."]
    pub RegisterActionEvent: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            localizedName: *const ::std::os::raw::c_char,
            version: ai_int32,
            flag: ai_int32,
            callback: AIActionCallbackProc,
            plugin: SPPluginRef,
            userData: AIActionUserData,
            parameters: AIActionParamTypeRef,
        ) -> ASErr,
    >,
    #[doc = "\tReports whether a plug-in has been registered as an action event.\n(Note that this function returns a boolean value, not an error code.)\n\n@param eventName The name with which the action was registered.\n@return True if the action was registered, false otherwise.\n@see  \\c #RegisterActionEvent()"]
    pub IsActionEventRegistered: ::std::option::Option<
        unsafe extern "C" fn(eventName: *const ::std::os::raw::c_char) -> AIBoolean,
    >,
    #[doc = "\tGets the localized name associated with a registered action event\n(the string that appears in the Actions palette).\n\n@param eventName [in] The name with which the action was registered.\n@param localizedName [out] A character buffer in which to return the localized name.\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventLocalizedName: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            localizedName: *mut ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = "\tGets the version number associated with a registered action event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [out] A buffer in which to return the version number.\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventVersion: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            version: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = "\tCurrently unused"]
    pub GetActionEventFlag: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            flag: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = "\tGets the callback procedure associated with a registered action event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [out] A buffer in which to return the callback procedure.\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventCallbackProc: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            callback: *mut AIActionCallbackProc,
        ) -> ASErr,
    >,
    #[doc = "\tGets the plug-in associated with a registered action event--that is, the plug-in that executes the event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [out] A buffer in which to return the plug-in reference..\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventPluginRef: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            pluginRef: *mut SPPluginRef,
        ) -> ASErr,
    >,
    #[doc = "\tGets the user data associated with a registered action event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [out] A buffer in which to return the user data.\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventUserData: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            userData: *mut AIActionUserData,
        ) -> ASErr,
    >,
    #[doc = "\tSets the user data associated with a registered action event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [in] The new user data, in the structure allocated at registration.\n@see  \\c #RegisterActionEvent()"]
    pub SetActionEventUserData: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            userData: AIActionUserData,
        ) -> ASErr,
    >,
    #[doc = "\tGets the type parameter block (TPB) associated with a registered action event.\n\n@param eventName [in] The name with which the action was registered.\n@param version [out] A buffer in which to return the TPB.\n@see  \\c #RegisterActionEvent()"]
    pub GetActionEventParamType: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            param: *mut AIActionParamTypeRef,
        ) -> ASErr,
    >,
    #[doc = " Calls the action idle procedure, as set by \\c #SetActionIdleProc()."]
    pub Idle: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Specifies the action idle procedure for this action.\n\n@param idleProc The procedure to call when the action is idle.\nDefine the function using this prototype:<br>\n<code>typedef void AIActionIdleProc (void);</code>"]
    pub SetActionIdleProc:
        ::std::option::Option<unsafe extern "C" fn(idleProc: AIActionIdleProc) -> ASErr>,
    #[doc = " Gets the current idle procedure for this action.\n\n@param idleProc [out] A buffer in which to return the procedure."]
    pub GetActionIdleProc:
        ::std::option::Option<unsafe extern "C" fn(idleProc: *mut AIActionIdleProc) -> ASErr>,
    #[doc = " Creates a type parameter block (TPB) for an action, which describes the data types\nof your plug-in�s parameters.\n\nIn order to register as an action event, your plug-in must create an \\c AIActionParamTypeRef\nusing this function, then fill it with keys that describe your parameter block\nusing \\c #AIActionSetTypeKey().\nPass the filled TPB to \\c #RegisterActionEvent() when registering the event.\nDestroy it after registration, using \\c #AIDeleteActionParamType().\nYou do not need to keep your reference; Illustrator keeps a copy of it,\nand you can retrieve it using \\c #GetActionEventParamType().\n\nThe TPB does not contain actual values, just type descriptors.\nThe keys that you add to the parameter block represent data types,\ntypically for information that is gathered when your plug-in presents\na modal dialog to the user. The values are kept in a value parameter block\n(VPB), created with \\c #AINewActionParamValue().\n\n@param param [out] A buffer in which to return the new type parameter block (TPB)."]
    pub AINewActionParamType:
        ::std::option::Option<unsafe extern "C" fn(param: *mut AIActionParamTypeRef) -> ASErr>,
    #[doc = " Deletes a type parameter block (TPB). You do not need to keep your reference;\nIllustrator keeps a copy of it, and you can retrieve it using \\c #GetActionEventParamType().\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType().\n@see \\c #AIActionSetTypeKey(), \\c #RegisterActionEvent()"]
    pub AIDeleteActionParamType:
        ::std::option::Option<unsafe extern "C" fn(param: AIActionParamTypeRef) -> ASErr>,
    #[doc = " Retrieves a type key from a type parameter block (TPB).\n\nThe returned key is, by convention, a 4-character long value that describes\nthe parameter. For example, in the Tutorial the keys for the \"corner\" and \"size\"\nparameters are �crnr� and �size�. The key for the parameter type in the TPB matches\nthe key for its value in the VPB: see \\c #AIActionGetValueKey().\n\n\\li To check that the TPB contains a specific key, use \\c #AIActionHasTypeKey().\n\\li To iterate through all of the keys, get the number of keys with \\c #AIActionGetTypeCount().\n\\li To set a key type, use \\c #AIActionSetTypeKey().\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param index [in] The position index of the desired parameter type key.\n@param key [out] A buffer in which to return the type key."]
    pub AIActionGetTypeKey: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            index: ai_uint32,
            key: *mut ActionParamKeyID,
        ) -> ASErr,
    >,
    #[doc = " Determines whether a value parameter block (VPB) contains a particular key.\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  hasKey [out] A buffer in which to return the result, true if the key is contained in the VPB,\nfalse otherwise."]
    pub AIActionHasTypeKey: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            hasKey: *mut AIBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the number of keys in a type parameter block (TPB).\nUse with \\c #AIActionGetTypeKey() to iterate through keys.\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param count [out] A buffer in which to return the number of keys."]
    pub AIActionGetTypeCount: ::std::option::Option<
        unsafe extern "C" fn(param: AIActionParamTypeRef, count: *mut ai_uint32) -> ASErr,
    >,
    #[doc = " Associates a type key with a type parameter block (TPB). Creates a new key, or sets\nvalues for an existing key.\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param key [in] The parameter type key, by convention a 4-character \\c long value that\ndescribes the parameter. For example, in the Tutorial the keys for the\n\"corner\" and \"size\" parameters are �crnr� and �size�. See also \\c #AIActionGetTypeKey().\n@param name [in] The localizable name of the parameter, which appears in the Actions palette.\n@param type [in] The data type of the key. An \\c ::ActionParamTypeID value.\n@param show [in] When true, the parameter is shown in the Actions palette.\n"]
    pub AIActionSetTypeKey: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            name: *const ::std::os::raw::c_char,
            type_: ActionParamTypeID,
            show: AIBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the display name of an event parameter.\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param key [in] The parameter type key, a 4-character \\c long, See \\c #AIActionGetTypeKey().\n@param value [out] A buffer in which to return the localizable name of the parameter,\nwhich appears in the Actions palette. See \\c #AIActionSetTypeKey()."]
    pub AIActionGetName: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            value: *mut ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the data type of an event parameter.\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetTypeKey().\n@param value [out] A buffer in which to return the data type of the key. An \\c ::ActionParamTypeID value."]
    pub AIActionGetType: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            value: *mut ActionParamTypeID,
        ) -> ASErr,
    >,
    #[doc = " Reports whether a specific event parameter is displayed in the Actions palette.\n(Note that the function returns a boolean value, not an error code.)\n\n@param param [in] The type parameter block (TPB), as created by \\c #AINewActionParamType()\nand returned by \\c #GetActionEventParamType().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetTypeKey().\n@return True if the show flag is on, false otherwise."]
    pub AIActionTypeIsShow: ::std::option::Option<
        unsafe extern "C" fn(param: AIActionParamTypeRef, key: ActionParamKeyID) -> AIBoolean,
    >,
    #[doc = " Not used for third-party plug-ins"]
    pub AcquirePalette: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Not used for third-party plug-ins"]
    pub ReleasePalette: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Records your plug-in�s action event and displays it in the Actions palette\nwith its parameter list.\n\nYou should call this only when you have determined that the user is in Record mode,\nby calling \\c #InRecordMode(). You must create the VPB and set its values,\nuse it to record the action, then destroy the VPB. For example:<br>\n@code\n// If in record mode, record the event\nif (sAIActionManager && sAIActionManager->InRecordMode()) {\n// create a VPB using AINewActionParamValue()\n// load the VPB with values, according to the parameter types\n// record the action event using RecordActionEvent()\n// delete the VPB using AIDeleteActionParamValue()\n}\n@endcode\n\n@param eventName The name with which the action was registered. See \\c #RegisterActionEvent().\n@param dialogStatus Whether a dialog appears by default when the action is played back.\nThis status is visually represented by a dialog icon to the left of the\nevent name in the Actions palette.\n@param parameters The event�s value parameter block (VPB), as created by\n\\c #AINewActionParamValue(). This structure contains the parameter values that\nwere used during the action event. Typically, these are the values entered by\nthe user in the parameter dialog box. If your action event does not have parameters,\npass \\c null."]
    pub RecordActionEvent: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            dialogStatus: ActionDialogStatus,
            parameters: AIActionParamValueRef,
        ) -> ASErr,
    >,
    #[doc = " Plays back a recorded action event.\n\nYou can use this to play back any registered action event, not just the one for\nthis plug-in. The event names and their parameter types are documented in \\c actions folder\nin the SDK installation.\n\nFor example, the following executes copy, new document, and paste action events:\n@code\nsAIActionManager->PlayActionEvent(\"adobe_copy\", kDialogNone, NULL);\nsAIActionManager->PlayActionEvent(\"adobe_newDocument\", kDialogNone, NULL);\nsAIActionManager->PlayActionEvent(\"adobe_paste\", kDialogNone, NULL);\n@endcode\n\n@param eventName The name with which the action was registered. See \\c #RegisterActionEvent().\n@param dialogStatus Whether a dialog appears by default when the action is played back.\nThis status is visually represented by a dialog icon to the left of the\nevent name in the Actions palette. See \\c ::_ActionDialogStatus.\n@param parameters The event�s value parameter block (VPB), as created by\n\\c #AINewActionParamValue(). This structure contains the parameter values that\nwere used during the action event. Typically, these are the values entered by\nthe user in the parameter dialog box. If your action event does not have parameters,\npass \\c null."]
    pub PlayActionEvent: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            dialogStatus: ActionDialogStatus,
            parameters: AIActionParamValueRef,
        ) -> ASErr,
    >,
    #[doc = " Reports whether  the user is currently in Record mode. (Note that the function\nreturns a boolean value, not an error code.)\n\nWhen a new action is first created or whenever the record button is pressed in the\nActions palette, the user is in Record mode, and all actions are recorded into the\nActions palette.\n\nIf your plug-in registers an action event at startup, you are responsible for\nrecording your action event and any associated parameters whenever the user is\nin Record mode. See \\c #RecordActionEvent().\n\nThis function is often used within a conditional statement during the normal\nexecution of a plug-in. For example:\n@code\n// If in record mode, record the event\nif (sAIActionManager && sAIActionManager->InRecordMode()) {\n// create a VPB\n// load the VPB with values\n// record the action event\n// delete the VPB\n}\n@endcode\n\n@return True if the user is in record mode, false otherwise."]
    pub InRecordMode: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Not used for third-party plug-ins"]
    pub InInsertMenuItemState: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Not used for third-party plug-ins"]
    pub ActivateInsertMennuItemDialog: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = "  Not used for third-party plug-ins"]
    pub SetCurrentCommandLocalizedName: ::std::option::Option<
        unsafe extern "C" fn(localizedName: *const ::std::os::raw::c_char) -> ASErr,
    >,
    #[doc = " Not used for third-party plug-ins"]
    pub DoFunctionKey:
        ::std::option::Option<unsafe extern "C" fn(fkey: ai_int32, modifier: ai_uint32) -> ASErr>,
    #[doc = " Creates a value parameter block (VPB) structure.\n\nThe VPB contains a set of event parameter values, whose types are determined\nby the type parameter block (TPB) with which the event is registered.\nSee \\c #RegisterActionEvent() and \\c #AINewActionParamValue().\n\nIn order to record an action event, your plug-in must create an\n#AIActionParamValueRef using this function, then fill it with key/value pairs\nthat contain values of the correct type, using the appropriate \\c AIActionSetXx function.\nFor example, to set an integer value, use \\c #AIActionSetInteger().\n\nPass the filled VPB to \\c #RecordActionEvent() when recording the event.\nDestroy it after recording, using \\c #AIDeleteActionParamValue().\nYou do not need to keep your reference; Illustrator keeps a copy of it,\nand you can retrieve it using \\c #AIActionGetValueKey().\n\n@param param A buffer in which to return the new value parameter block (VPB)."]
    pub AINewActionParamValue:
        ::std::option::Option<unsafe extern "C" fn(param: *mut AIActionParamValueRef) -> ASErr>,
    #[doc = " Deletes a value parameter block (VPB). You do not need to keep your reference\nafter recording or playing back an action with its parameter value set.\n@param param The value parameter block (VPB) as returned by \\c #AINewActionParamValue().\n@see \\c #RecordActionEvent(), \\c #PlayActionEvent()"]
    pub AIDeleteActionParamValue:
        ::std::option::Option<unsafe extern "C" fn(param: AIActionParamValueRef) -> ASErr>,
    #[doc = " Retrieves a value key from a value parameter block (VPB).\n\nThe returned key is, by convention, a 4-character long value that describes\nthe parameter. For example, in the Tutorial the keys for the \"corner\" and \"size\"\nparameters are �crnr� and �size�. The key for the parameter value in the VPB\nmatches the key for its type in the TPB. See \\c #AIActionGetTypeKey().\n\n\\li To check that the VPB contains a specific key, use \\c #AIActionHasValueKey().\n\\li To iterate through all of the keys, get the number of keys with\n\\c #AIActionGetValueCount().\n\\li To extract or set the value for a specific key, use the accessor function appropriate\nto its data type. For example, to get an integer value, use \\c #AIActionGetInteger(),\nand to set it, use \\c #AIActionSetInteger().\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param index [in] The position index of the desired parameter value key.\n@param key [out] A buffer in which to return the value key."]
    pub AIActionGetValueKey: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            index: ai_uint32,
            key: *mut ActionParamKeyID,
        ) -> ASErr,
    >,
    #[doc = " Determines whether a VPB contains a particular key.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  hasKey [out] A buffer in which to return the result, true if the key is contained in the VPB,\nfalse otherwise."]
    pub AIActionHasValueKey: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            hasKey: *mut AIBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the number of keys in a value parameter block (VPB).\nUse with \\c #AIActionGetValueKey() to iterate through keys\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param count [out] A buffer in which to return the number of keys."]
    pub AIActionGetValueCount: ::std::option::Option<
        unsafe extern "C" fn(param: AIActionParamValueRef, count: *mut ai_uint32) -> ASErr,
    >,
    pub AIActionGetValueType: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            type_: *mut ActionParamTypeID,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the integer value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetInteger: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Sets the integer value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value."]
    pub AIActionSetInteger: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the \\c real value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetReal: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut AIReal,
        ) -> ASErr,
    >,
    #[doc = " Sets the \\c real value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value."]
    pub AIActionSetReal: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: AIReal,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the unit-real value associated with a particular key in a VPB. Unit-real values are\ndisplayed in the Actions palette with unit labels.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetUnitReal: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            unit: *mut ActionParamUnitID,
            value: *mut AIReal,
        ) -> ASErr,
    >,
    #[doc = " Sets the unit-real value associated with a particular key in a VPB.Unit-real values are\ndisplayed in the Actions palette with unit labels.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value."]
    pub AIActionSetUnitReal: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            unit: ActionParamUnitID,
            value: AIReal,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the string value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetString: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = " Sets the string value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value."]
    pub AIActionSetString: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *const ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the boolean value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetBoolean: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut AIBoolean,
        ) -> ASErr,
    >,
    #[doc = " Sets the boolean value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value."]
    pub AIActionSetBoolean: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: ASBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the enumerated value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param name [in] The name of the enumeration, as shown in the Actions palette.\n@param  value [out] A buffer in which to return the value."]
    pub AIActionGetEnumerated: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            name: *mut ::std::os::raw::c_char,
            value: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Sets the enumerated value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param name [in] The name of the enumeration, as shown in the Actions palette.\n@param  value [in] The new value."]
    pub AIActionSetEnumerated: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            name: *const ::std::os::raw::c_char,
            value: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Sets the raw-data value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  size [in] The number of bytes in the new value.\n@param  value [in] The new value. You must allocate memory for the value."]
    pub AIActionSetRawDataBytes: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            size: ai_uint32,
            value: *const ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the size of a raw-data value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  size [out] A buffer in which to return the number of bytes in the value."]
    pub AIActionGetRawDataSize: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            size: *mut ai_uint32,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the raw-data value associated with a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [out] A buffer in which to return the value. You must allocate memory for the value,\nusing the size obtained with \\c #AIActionGetRawDataSize()."]
    pub AIActionGetRawData: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut ::std::os::raw::c_char,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the current visibility state of a particular key in a VPB.(Not that this function returns\na visibility value, not an error code.)\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@return The visibility state value; see \\c ::ActionValueVisibility."]
    pub AIActionValueGetVisibility: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
        ) -> ActionValueVisibility,
    >,
    #[doc = " Sets the visibility state of a particular key in a VPB.\n\n@param param [in] The value parameter block (VPB), as created by \\c #AINewActionParamValue().\n@param key [in] The parameter type key, a 4-character \\c long. See \\c #AIActionGetValueKey().\n@param  value [in] The new value, see \\c ::ActionValueVisibility."]
    pub AIActionValueSetVisibility: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: ActionValueVisibility,
        ) -> ASErr,
    >,
    #[doc = " Not used for third-party plug-ins"]
    pub UndoLastTransaction: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Not used for third-party plug-ins"]
    pub RedoLastTransaction: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Not used for third-party plug-ins"]
    pub IgnoreRecording: ::std::option::Option<unsafe extern "C" fn(ignore: AIBoolean) -> ASErr>,
    #[doc = " Registers an action using a Unicode name.\nFor details, see \\c #RegisterActionEvent()."]
    pub RegisterActionEventUS: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            localizedName: *const ai_UnicodeString,
            version: ai_int32,
            flag: ai_int32,
            callback: AIActionCallbackProc,
            plugin: SPPluginRef,
            userData: AIActionUserData,
            parameters: AIActionParamTypeRef,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the localized name of an event as a Unicode string.\nFor details, see \\c #GetActionEventLocalizedName()."]
    pub GetActionEventLocalizedNameUS: ::std::option::Option<
        unsafe extern "C" fn(
            eventName: *const ::std::os::raw::c_char,
            localizedName: *mut ai_UnicodeString,
        ) -> ASErr,
    >,
    #[doc = "  Associates a type key with a type parameter block (TPB), using Unicode strings.\nFor details, see \\c #AIActionSetTypeKey()."]
    pub AIActionSetTypeKeyUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            name: *const ai_UnicodeString,
            type_: ActionParamTypeID,
            show: AIBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the identifying name of an event as a Unicode string.\nFor details, see \\c #AIActionGetNameUS()."]
    pub AIActionGetNameUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamTypeRef,
            key: ActionParamKeyID,
            value: *mut ai_UnicodeString,
        ) -> ASErr,
    >,
    #[doc = " Sets the localized name of an event using a Unicode string.\nFor details, see \\c #SetCurrentCommandLocalizedName()."]
    pub SetCurrentCommandLocalizedNameUS: ::std::option::Option<
        unsafe extern "C" fn(localizedName: *const ai_UnicodeString) -> ASErr,
    >,
    #[doc = " Retrieves the string value associated with a particular key in a VPB, as a Unicode string.\nFor details, see \\c #AIActionGetString()."]
    pub AIActionGetStringUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *mut ai_UnicodeString,
        ) -> ASErr,
    >,
    #[doc = " Sets the string value associated with a particular key in a VPB, using a Unicode string.\nFor details, see \\c #AIActionSetString()."]
    pub AIActionSetStringUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            value: *const ai_UnicodeString,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the enumerated value associated with a particular key in a VPB, as a Unicode string.\nFor details, see \\c #AIActionGetEnumeratedUS()."]
    pub AIActionGetEnumeratedUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            name: *mut ai_UnicodeString,
            value: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Sets the enumerated value associated with a particular key in a VPB, using a Unicode string.\nFor details, see \\c #AIActionSetEnumeratedUS()."]
    pub AIActionSetEnumeratedUS: ::std::option::Option<
        unsafe extern "C" fn(
            param: AIActionParamValueRef,
            key: ActionParamKeyID,
            name: *const ai_UnicodeString,
            value: ai_int32,
        ) -> ASErr,
    >,
}
#[doc = " Read the file, creating artwork in a new document.\nThe format is included in the File > Open file types.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatRead: AIFileFormatOptions = 1;
#[doc = " Write the documents contents to a file\nin a non-Illustrator format.\nThe format is included in the File > Export file types.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatExport: AIFileFormatOptions = 2;
#[doc = " Read the file and embed artwork to the current document.\nThe format is included in the File > Import file types.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatImportArt: AIFileFormatOptions = 4;
#[doc = " Read the file and embed artwork to the current document.\nThis is the same as \\c #kFileFormatImportArt.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatPlaceArt: AIFileFormatOptions = 8;
#[doc = " Not used."]
pub const AIFileFormatOptions_kFileFormatImportStyles: AIFileFormatOptions = 16;
#[doc = " When reading, the plug-in sets the print record. See\n\\c #AIDocumentSuite::SetDocumentPrintRecord().\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatSuppliesPrintRecordOption: AIFileFormatOptions = 32;
#[doc = " Makes this the default format for all documents. If specified\nby more than one plug-in, the last one becomes the default.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatIsDefaultOption: AIFileFormatOptions = 64;
#[doc = " Allows \"Template\" to be checked in the Place dialog when\nlinking or embedding a file of this type, so the art is\nplaced in a template layer.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatConvertTemplate: AIFileFormatOptions = 128;
#[doc = " Make a link from the contents of a file to an Illustrator\ndocument.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatLinkArt: AIFileFormatOptions = 256;
#[doc = " Write the documents contents to a file\nin a format from which is can be read back into\nIllustrator without loss of data.\nThe format is included in the File > Save As file types.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatWrite: AIFileFormatOptions = 512;
#[doc = " The plug-in will not respond to the \\c #kSelectorAICheckFileFormat\nselector. (For example, the PhotoShop adapter plug-in always returns\n\\c #kNoErr.)\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatNoAutoCheckFormat: AIFileFormatOptions = 1024;
#[doc = " Read the file, creating artwork in a new template layer in\nthe current document.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatCreateTemplateLayer: AIFileFormatOptions = 2048;
#[doc = " Handle the extended data passed in a Go message for a placement request\nor in the Set Parameters message for additional options.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatHasExtendedData: AIFileFormatOptions = 4096;
#[doc = " This file format supplies its own startup objects (colors, patterns,\nand so on), Illustrator does not copy the startup file\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatSkipStartupObjectsOption: AIFileFormatOptions = 8192;
#[doc = " Disable warning dialogs upon read and write.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatNoWarningOption: AIFileFormatOptions = 16384;
#[doc = " Write the current document to a copy of the file it was\nloaded from.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatSaveCopyOption: AIFileFormatOptions = 32768;
#[doc = " Write the contents of selected artwork in a document to a file\nin a non-Illustrator format.\nThe format is included in the File > Export Selection file types.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatExportSelection: AIFileFormatOptions = 65536;
#[doc = "  Enables Batch Export mode which prevents certain actions like:\n1. Prevent individual file format plugins from showing File Replace Dialog.\n2. Prevent individual file format plugins to add exported files to Recent File Menu Items.\nNot used when adding a format."]
pub const AIFileFormatOptions_kFileFormatBatchExport: AIFileFormatOptions = 131072;
#[doc = "  Prevent a file format plugin from uniquifying file name.\nNot used when adding a format."]
pub const AIFileFormatOptions_kFileFormatSuppressPluginFileNameUniquify: AIFileFormatOptions =
    262144;
#[doc = " Optimize Save on network locations by first saving the file to a local scratch disk\nand then copying this saved file to network.\nNote: During the file save and export, if the format saves some additional files along with the main file,\nthis flag should not be used. This is because the format plugins will have a path to the\nlocal disk location, which will be different from the final network location.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatOptimizeNetworkOperation: AIFileFormatOptions = 524288;
#[doc = " Optimize Save on network locations by first saving the file to a local scratch disk\nand then copying this saved file to network.\nNote: During the file save and export, if the format saves some additional files along with the main file,\nthis flag should not be used. This is because the format plugins will have a path to the\nlocal disk location, which will be different from the final network location.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatSaveInBackground: AIFileFormatOptions = 1048576;
#[doc = "  Prevents this file format from appearing in the file\nselection menu of the Open, Place, Save and Export dialogs.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatSuppressUI: AIFileFormatOptions = 2097152;
#[doc = " Set in combination with \\c #kFileFormatWrite for a\nSave As operation, to distinguish it from Save.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteAs: AIFileFormatOptions = 4194304;
#[doc = " Always receive the Check message, even for operations this plug-in\ndoes not support. Allows an opportunity to explicitly reject operations\non files matching this plug-in's type.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatCheckAlways: AIFileFormatOptions = 8388608;
#[doc = " Handle additional parameters passed in \\c #AIFileFormatMessage::actionParm.\nThese supplement the usual parameters of the file format,\nand may not be complete. Can be used, for instance, for scripting or optimizing.\n\nIf set in the Go message for a plug-in that does not handle the option,\nyou can ignore it.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatContainsPartialParameters: AIFileFormatOptions = 16777216;
#[doc = " Import only the SLO composite fonts.\nDo not import artwork or other global objects, and\ndo not perform font fauxing.\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatImportCompositeFonts: AIFileFormatOptions = 33554432;
#[doc = " Treat the file as stationary--that is, open a copy with an Untitled name.\nUse only in conjunction with \\c #kFileFormatRead\nNot used for adding a format."]
pub const AIFileFormatOptions_kFileFormatOpenUntitledCopy: AIFileFormatOptions = 67108864;
#[doc = " An option for the native (PGF) AI File Format Writer,\ntelling it to write out only the indicated palettes and the global objects,\ndirectly or indirectly. Not used for adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteSwatchLibrary: AIFileFormatOptions = 134217728;
#[doc = " An option for the native (PGF) AI File Format Writer,\ntelling it to write out only the indicated palettes and the global objects,\ndirectly or indirectly. Not used for adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteBrushLibrary: AIFileFormatOptions = 268435456;
#[doc = " An option for the native (PGF) AI File Format Writer,\ntelling it to write out only the indicated palettes and the global objects,\ndirectly or indirectly. Not used for adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteStyleLibrary: AIFileFormatOptions = 536870912;
#[doc = " An option for the native (PGF) AI File Format Writer,\ntelling it to write out only the indicated palettes and the global objects,\ndirectly or indirectly. Not used for adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteSymbolLibrary: AIFileFormatOptions = 1073741824;
#[doc = " Write the documents contents to a file\nin a format from which it can be read back into\nIllustrator without loss of data.\nThe format should be added if this format can be saved\nin touch workspace.\nUse when adding a format."]
pub const AIFileFormatOptions_kFileFormatWriteInTouch: AIFileFormatOptions = -2147483648;
#[doc = " These options specify the capabilities of a file format plug-in.\nA subset of options are used with \\c #AIFileFormatSuite::AddFileFormat()\nto specify which operations are supported, and are also sent in the\n\\c #AIFileFormatMessage\tto indicate the requested action.\nAdditional options can be set in the Go selector message to provide\nmore information about the requested operation.\n\n@note The read, embed (import/place), and link operations\nare very similar in execution. In all cases, Illustrator\ncreates an empty artwork and send the plug-in a message to\nread the file into the artwork. Special handling is required\nonly if the plug-in needs to do different things depending\non the type of operation; for example the Photoshop file format\nplug-in has options for preserving Photoshop's layers if it is\nnot linking."]
pub type AIFileFormatOptions = ::std::os::raw::c_int;
#[doc = " Highest priority"]
pub const AIFileFormatPriority_kAIFileFormatPriorityNative: AIFileFormatPriority = 10000;
#[doc = " Normal priority. This is the value assigned when a file format is added."]
pub const AIFileFormatPriority_kAIFileFormatPriorityNormal: AIFileFormatPriority = 0;
#[doc = " Lowest priority"]
pub const AIFileFormatPriority_kAIFileFormatPriorityLowest: AIFileFormatPriority = -10000;
#[doc = " File format priorities, which determine the order in which Illustrator\nsearches through formats in deciding which one to use to open a file.\nThe first format found that handles a file type is used to open the file.\n@see \\c #AIFileFormatSuite::SetFileFormatPriority()"]
pub type AIFileFormatPriority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIFileFormatOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a file format. Never dereferenced.\nUse the functions in \\c #AIFileFormatSuite to access it."]
pub type AIFileFormatHandle = *mut _t_AIFileFormatOpaque;
#[doc = " Information needed to add a file format.\n@see \\c  #PlatformAddFileFormatExData."]
#[repr(C)]
#[derive(Debug)]
pub struct PlatformAddFileFormatData {
    #[doc = " The variable type is the 4 digit Macintosh file type identifier. Windows\nplug-ins can ignore this."]
    pub type_: ai_int32,
    #[doc = " The Pascal-type string shown in the file type menu of\nthe Save As and Open dialog."]
    pub title: ai_UnicodeString,
    #[doc = " The order of menu items if a plug-in adds multiple file formats.\nUse 0 if the plug-in adds only one filter."]
    pub titleOrder: ai_int32,
    #[doc = " A comma-delimited list of DOS-style extensions that\nare filtered in the Open dialog, or appended to the file name in the\nSaves As dialog. For example, \\c \"ai,eps\".\n\nThe list has a maximum of 31 characters, and each\nextension has a maximum of 5 characters."]
    pub extension: ai_UnicodeString,
}
#[doc = " Information needed to add a file format.\nExtends \\c #PlatformAddFileFormatData by allowing a list of Mac OS file types."]
#[repr(C)]
#[derive(Debug)]
pub struct PlatformAddFileFormatExData {
    #[doc = " Number of elements in  \\c typeList."]
    pub numTypes: ai_int32,
    #[doc = " Address of list of Mac OS file types."]
    pub typeList: *mut ai_int32,
    #[doc = " The Pascal-type string shown in the file type menu of\nthe Save As and Open dialog."]
    pub title: ai_UnicodeString,
    #[doc = " The order of menu items if a plug-in adds multiple file formats.\nUse 0 if the plug-in adds only one filter."]
    pub titleOrder: ai_int32,
    #[doc = " A comma-delimited list of DOS-style extensions that\nare filtered in the Open dialog, or appended to the file name in the\nSaves As dialog. For example, \\c \"ai,eps\".\n\nThe list has a maximum of 31 characters, and each\nextension has a maximum of 5 characters."]
    pub extension: ai_UnicodeString,
}
#[doc = " A Mac OS file creator/type pair"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AICreatorTypePair {
    #[doc = " The file creator."]
    pub creator: ::std::os::raw::c_long,
    #[doc = " The Mac OS file type"]
    pub type_: ai_int32,
}
pub const AIFFExtendedOptions_kNoExtendedOptions: AIFFExtendedOptions = 0;
pub const AIFFExtendedOptions_kSaveMultiArtboards: AIFFExtendedOptions = 1;
#[doc = " Used internally to request app not to exit \"Text Editing Mode\" before calling this File format plugin for save/export."]
pub const AIFFExtendedOptions_kDoNotExitTextEditingModeOption: AIFFExtendedOptions = 2;
#[doc = " Read the file and embed artwork to the current document.\nUse when adding a format, this option should be added\nif this format can be placed in touch workspace."]
pub const AIFFExtendedOptions_kFileFormatPlaceInTouch: AIFFExtendedOptions = 4;
#[doc = " On placing the content on the scaled document, if this flag won't be set, content will be scaled by the scale factor of the document."]
pub const AIFFExtendedOptions_kDoNotHonourDocumentScaleOnPlace: AIFFExtendedOptions = 8;
#[doc = " On placing the content on the scaled document, if this flag won't be set, content will be scaled by the scale factor of the document."]
pub const AIFFExtendedOptions_kFileFormatSupportsLargeCanvas: AIFFExtendedOptions = 16;
#[doc = " On placing the content on the scaled document, if this flag won't be set, content will be scaled by the scale factor of the document."]
pub const AIFFExtendedOptions_kFileFormatSupportsPreload: AIFFExtendedOptions = 32;
#[doc = " On placing the content on the scaled document, if this flag won't be set, content will be scaled by the scale factor of the document."]
pub const AIFFExtendedOptions_kFileFormatUnEmbed: AIFFExtendedOptions = 64;
#[doc = " On placing the content on the scaled document, if this flag won't be set, content will be scaled by the scale factor of the document."]
pub const AIFFExtendedOptions_kFileFormatPreloadIsNonBlocking: AIFFExtendedOptions = 128;
#[doc = "\n** Extended options of various file formats*/"]
pub type AIFFExtendedOptions = ::std::os::raw::c_uint;
#[doc = " Union of extended file format datatypes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union FileFormatExtUnion {
    #[doc = " Additional options to be used during import/export.\nEntries in the dictionary are file format specific.\nCurrently this is used for AI save and SVG export."]
    pub m_AdditionalOptionsDict: AIDictionaryRef,
    #[doc = " Additional data needed for a placement request"]
    pub m_pPlaceRequestData: *mut AIPlaceRequestData,
}
#[doc = " Extended file format message data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FileFormatExtData {
    #[doc = " The type of union. See \\c #eFFExtType for valid values."]
    pub m_lExtType: ai_int32,
    #[doc = " The placement data for a placement request"]
    pub m_unExt: FileFormatExtUnion,
}
#[doc = " Message data sent by the file format selectors."]
#[repr(C)]
#[derive(Debug)]
pub struct AIFileFormatMessage {
    #[doc = " The message data"]
    pub d: SPMessageData,
    #[doc = " The file format for which the message is intended. If your\nplug-in handles more than one type, compare to the format handle\nreturned when the format was added."]
    pub fileFormat: AIFileFormatHandle,
    #[doc = " The requested operation (such as read or write). A logical OR of\n\\c #AIFileFormatOptions values."]
    pub option: ai_int32,
    #[doc = " Additional information required for specific operation (currently\nfor placement and export). Used if the plug-in registered\nthe format as handling extended data (\\c #kFileFormatHasExtendedData)"]
    pub m_pExtData: *mut FileFormatExtData,
    #[doc = " A pointer to additional parameter data,  if\n\\c #kFileFormatContainsPartialParameters is set in the \\c option field."]
    pub actionParm: *mut ::std::os::raw::c_void,
    #[doc = " The file to read, write or check. Get and set with public functions\n\\c #SetFilePath() and \\c #GetFilePath(),\nto maintain compatibility with deprecated file spec type."]
    pub filePath: ai_FilePath,
    #[doc = " Requested save/export file types. Values \\c # AIFFExtendedOptions"]
    pub operationOptions: ai_int32,
    #[doc = " Handle of the artboard range specified by the user"]
    pub rangeHandle: AIArtboardRangeHandle,
}
#[doc = " Obsolete - linked raster art is now implemented as placed art.\nMessage structure for \\c #kSelectorAIUpdateFileFormat."]
#[repr(C)]
#[derive(Debug)]
pub struct AIUpdateFileFormatMessage {
    #[doc = " The message data."]
    pub ffm: AIFileFormatMessage,
    #[doc = " The art object to be updated."]
    pub art: AIArtHandle,
    #[doc = " A pointer to the update data. Not used, always \\c NULL."]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " Notification data sent with the \\c #kAIFileFormatLinkUpdateNotifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILinkUpdateNotifyData {
    #[doc = "  The type of link update that occurred, an \\c #eLinkUpdateType value."]
    pub m_iUpdateType: ai_int32,
    #[doc = " A pointer to update parameters. Currently unused."]
    pub m_pvParam: *mut ::std::os::raw::c_void,
}
pub const AIDocumentStartupProfile_kAIStartupProfileUnknown: AIDocumentStartupProfile = 0;
pub const AIDocumentStartupProfile_kAIStartupProfilePrint: AIDocumentStartupProfile = 1;
pub const AIDocumentStartupProfile_kAIStartupProfileWeb: AIDocumentStartupProfile = 2;
pub const AIDocumentStartupProfile_kAIStartupProfileVideo: AIDocumentStartupProfile = 3;
pub const AIDocumentStartupProfile_kAIStartupProfileSocial: AIDocumentStartupProfile = 4;
pub const AIDocumentStartupProfile_kAIStartupProfileBranding: AIDocumentStartupProfile = 5;
pub const AIDocumentStartupProfile_kAIStartupProfileCMYK: AIDocumentStartupProfile = 6;
pub const AIDocumentStartupProfile_kAIStartupProfileRGB: AIDocumentStartupProfile = 7;
pub const AIDocumentStartupProfile_kAIStartupProfileMobile: AIDocumentStartupProfile = 8;
#[doc = " Document startup profile types, returned by\n\\c #AIDocumentSuite::GetDocumentStartupProfile()\nand \\c #AIFileFormatSuite::GetFileStartupProfileType()."]
pub type AIDocumentStartupProfile = ::std::os::raw::c_uint;
#[doc = "\t@ingroup Suites\nThis suite provides functions for creating and managing file-format plug-ins,\nwhich extend the number of file formats that Illustrator can read and write.\n\nReading a format can be transparent to the user; when a file of the\ndefined type is selected in the Open dialog, your file format plug-in\ncreates artwork in the Illustrator document. If there is a plug-in that writes\na file format, that format appears in the Save As dialog as an option for the user\nto select. If it is selected, the plug-in walks the artwork tree and writes out\ninformation on the artwork in the appropriate manner. If your plug-in needs more\nparameters for either reading or writing, it defines a modal dialog to interact\nwith the user.\n\nPlug-ins tell Illustrator about the file formats they\nsupport by specifying platform file information: the type (such as \\c 'ART3')\nin Mac OS, or the extension (such as \\c '.AI') in Windows. Plug-ins also indicate\nwhat read/write capabilities they support.\n\nOne plug-in can register multiple formats. Illustrator handles some parts of the\nfile I/O process, and the plug-in does the rest.\n\nA file-format plug-in receives message actions telling it to:\n\n\\li Check if a file can be read, The Check selector is sent only to plug-ins\nthat can read files. It extends the simple type checking done by the  Open dialog.\n\\li Ask for parameters.  This selector can be ignored if the plug-in does not need\nuser input.\n\\li Go. In response, your plug-in executes the read or write operation.\n\nIf a file format plug-in can read, files of its registered file type appear\nin the file list of the Open dialog. In addition to screening by file type,\nIllustrator sends a selector giving a plug-in a chance to check that the\nfile can be read. This is useful in the case of text files or files from a\ndifferent file system. If more than one format matches the type, Illustrator\ndetermines which plug-in should actually open the file, asking the user if necessary.\n\nIf a file format plug-in supports both reading and writing, when reading it should\nstore any information about the file needed to write the file back to disk. It can\nstore data (for example, the pixel depth of an EPS preview) in the plug-ins globals,\nor in a parameter block. The reference to a block should be attached to the document\nusing \\c #AIDocumentSuite::SetDocumentFileFormatParameters(). Illustrator keeps this\nparameter-block reference with the document. The plug-in can retrieve it when the\ndocument is being saved.\n\nWhen the user does a Save, by default Illustrator uses the same file format that was\nused to read the file. If the file format does not support writing, the Save As\ndialog appears to let the user choose the save format. All file format plug-ins\nthat support saving appear in the format menu of this dialog.\n\nIf you need information from the user to open or save a file, you can present a\ndialog when the ask-for-parameters message is received. When saving files, this\nwill be after the Save As dialog has appeared. Your plug-in should save the\ninformation it collects, keeping it with the document to use for later saves.\n\nWhen the go message is received, file formats that read files typically parse\nthe input file and create Illustrator artwork using API calls. File formats for\nsaving Illustrator artwork traverse the artwork database and write out all\npertinent information.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFileFormatSuite and \\c #kAIFileFormatVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFileFormatSuite {
    #[doc = " Adds a file format to the standard file dialog.\nCall during startup to install a plug-in file format.\n@param self\tA reference to this plug-in, which adds the format.\n@param name\tThe unique name of the new file format. You can use\nyour company name with a descriptor to make it unique.\nNot displayed or localized.\n@param data\tInformation about the file format.\n@param options File format operations that this plug-in supports.\nA logical OR of these \\c #AIFileFormatOptions values:\n\\verbatim\nkFileFormatRead\nkFileFormatImportArt\nkFileFormatExport\nkFileFormatExportSelection\nkFileFormatPlaceArt\nkFileFormatImportStyles\nkFileFormatSuppliesPrintRecordOption\nkFileFormatIsDefaultOption\nkFileFormatConvertTemplate\nkFileFormatLinkArt\nkFileFormatWrite\nkFileFormatNoAutoCheckFormat\nkFileFormatSkipStartupObjectsOption\nkFileFormatHasExtendedData\nkFileFormatSuppressUI\nkFileFormatCheckAlways\n\\endverbatim\n@param fileFormat [out] A buffer in which to return  the handle of\nthe new plug-in file format. If you install multiple file formats,\nstore this reference in the plug-ins \\c globals record, so that your\nplug-in can use it to determine which file format command is to be processed.\n@param extendedOptions File format extended operations that this plug-in supports. A logical OR of these \\c #AIFFExtendedOptions values:\n\\verbatim\nkNoExtendedOptions\nkSaveMultiArtboards\nkFileFormatPlaceInTouch\n\\endverbatim\n\n\n@see \\c #AddFileFormatEx()"]
    pub AddFileFormat: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            data: *mut PlatformAddFileFormatData,
            options: ai_int32,
            fileFormat: *mut AIFileFormatHandle,
            extendedOptions: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the name of a file format.\n@param fileFormat The file format.\n@param name [out] A buffer in which to return the name string, as\npassed to \\c #AddFileFormat(). Do not modify this string."]
    pub GetFileFormatName: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            name: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a file format.\n@param fileFormat The file format.\n@param options [out] A buffer in which to return the options, a logical OR of\n\\c #AIFileFormatOptions values"]
    pub GetFileFormatOptions: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the option flags of a file format, which specify what file operations can be handled.\n@param fileFormat The file format.\n@param options The options, a logical OR of \\c #AIFileFormatOptions values"]
    pub SetFileFormatOptions: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, options: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the plug-in that installed a file format,\nto be passed to \\c #AIPluginSuite functions.\n@param fileFormat The file format.\n@param plugin [out] A buffer in which to return the plug-in reference."]
    pub GetFileFormatPlugin: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Gets the number of installed plug-in file formats.\nUse with \\c #GetNthFileFormat() to iterate through all plug-in formats.\n@param count [out] A buffer in which to return the number of formats."]
    pub CountFileFormats:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a plug-in file format reference by position index.\nUse with \\c #CountFileFormats() to iterate through all installed formats.\n@param n The index, in the range <code>[1..numFormats]</code>.\n@param fileFormat [out] A buffer in which to return the file format reference.\n"]
    pub GetNthFileFormat: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, fileFormat: *mut AIFileFormatHandle) -> AIErr,
    >,
    #[doc = " Retrieves the file extension for a plug-in file format.\n@param fileFormat The file format.\n@param extension [out] A buffer in which to return the file extension string."]
    pub GetFileFormatExtension: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            extension: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Adds a plug-in file format. This extended version allows you to specify\na list of Mac OS file types. Call during startup to install a plug-in file format.\n@param self\tA reference to this plug-in, which adds the format.\n@param name\tThe unique name of the new file format. You can use\nyour company name with a descriptor to make it unique.\nNot displayed or localized.\n@param dataEx\tInformation about the file format. This extended version\nuses a data structure with additional fields that allow you to\nspecify a list of Mac OS file types. Use \\c #SetFileFormatFilter()\nto specify a creator/type pair as the file filter.\n@param options File format operations that this plug-in supports.\nA logical OR of \\c #AIFileFormatOptions values.\nWhen the format is called with a Go selector,\none of these flags is set in the \\c option field to indicate the\nrequested operation.\n@param fileFormat [out] A buffer in which to return  the handle of\nthe new plug-in file format. If you install multiple file formats,\nstore this reference in the plug-ins \\c globals record, so that your\nplug-in can use it to determine which file format command is to be processed.\n@param extendedOptions File format extended operations that this plug-in supports. A logical OR of these \\c #AIFFExtendedOptions values:\n\\verbatim\nkNoExtendedOptions\nkSaveMultiArtboards\nkFileFormatPlaceInTouch\n\\endverbatim\n\n@see \\c #AddFileFormat(), \\c #SetFileFormatFilter()"]
    pub AddFileFormatEx: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            dataEx: *mut PlatformAddFileFormatExData,
            options: ai_int32,
            fileFormat: *mut AIFileFormatHandle,
            extendedOptions: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the localizable display name of a plug-in file format.\n@param fileFormat The file format.\n@param szTitle [out] A buffer in which to return the display name."]
    pub GetFileFormatTitle: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            szTitle: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the Mac OS file types for a plug-in file format.\n@param fileFormat The file format.\n@param maxNumTypes [in, out] A buffer in which to specify the maximum number\nand return the actual number of values in \\c typeList.\n@param typeList [out] A buffer in which to return the 4-character Mac OS type codes.\n@see \\c #GetFileFormatCreatorType()\tto get the full Mac OS file information."]
    pub GetFileFormatType: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            maxNumTypes: *mut ai_int32,
            typeList: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Associates a file format with a file type filter. File types are specified by (creator, type)\npairs in Mac OS, and by filename extensions in Windows.\n@note This function extends the \\c #AddFileFormat() and \\c #AddFileFormatEx() functions\nby allowing filters based on (creator, type) pairs in Mac OS, rather than simple type values.\n@param fileFormat The file format.\n@param numPairs In Mac OS, the number of (creator, type) pairs specified in \\c pairList.\nIgnored in Windows.\n@param pairList In Mac OS, a pointer to an array of (creator, type) pairs. These can use\nthe Mac OS wild-card value '****' for creator or type. Ignored in Windows.\n@param extensions In Windows, a comma-delimited list of DOS-style extensions that\nare filtered in the Open dialog, or appended to the file name in the\nSaves As dialog. For example, \\c \"ai,eps\"."]
    pub SetFileFormatFilter: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            numPairs: ai_int32,
            pairList: *mut AICreatorTypePair,
            extensions: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the file type filter for a file format, as specified by (creator, type)\npairs for Mac OS.\n@param fileFormat The file format.\n@param maxNumTypes [in, out] A buffer in which to specify the maximum number\nand return the actual number of (creator, type) pairs specified in \\c pairList.\n@param pairList [out] A buffer in which to return the array of (creator, type) pairs."]
    pub GetFileFormatCreatorType: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            maxNumPairs: *mut ai_int32,
            pairList: *mut AICreatorTypePair,
        ) -> AIErr,
    >,
    #[doc = " Invokes the File > Save dialog, allowing you to filter the available file formats.\n@param options Limits available file formats to those that support these\nwrite operations. A logical OR of write operation constants:<br>\n\\c #kFileFormatExport<<br>\n\\c #kFileFormatWrite\n@param dlgTitle\tThe title for the Save dialog.\n@param fileSpec\t[in, out] A buffer in which to pass the initial file specification\nand return the user-chosen specification.\n@param fileFormat [out] A buffer in which to return the user-chosen file format.\n@param good\t[out] A buffer in which to return true if the user clicked Save,\nor false if the user clicked Cancel."]
    pub PutFile: ::std::option::Option<
        unsafe extern "C" fn(
            options: ai_int32,
            dlgTitle: *const ai_UnicodeString,
            fileSpec: *mut ai_FilePath,
            fileFormat: *mut AIFileFormatHandle,
            good: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the priority of a file format. which determines the order in which Illustrator\nsearches through formats in deciding which one to use to open a file. The first format\nfound that handles a file type is used to open the file.\n@param fileFormat The file format.\n@param priority The new priority, an \\c #AIFileFormatPriority value,"]
    pub SetFileFormatPriority: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, priority: ai_int32) -> AIErr,
    >,
    #[doc = " Finds all plug-in file formats that can perform a specified operation for a file.\n@param options The operation, a \\c #AIFileFormatOptions value.\n@param file\tThe file.\n@param maxMatches The maximum number of formats to return.\n@param matchingFormats [out] An array of size \\c maxMatches in which to return the matching file formats.\n@param numMatches [out] A buffer in which to return the number of matching file formats found."]
    pub FindMatchingFileFormats: ::std::option::Option<
        unsafe extern "C" fn(
            options: ai_int32,
            file: *const ai_FilePath,
            maxMatches: ai_int32,
            matchingFormats: *mut AIFileFormatHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Obsolete"]
    pub ResolveImportConflicts: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Reports the version of Illustrator in which a raster file\nformat, for example the JPEG file format plug-in, was converted from\nusing raster art to using placed art in order to perform a place link\noperation. The information is needed so that Illustrator knows when it\nshould convert placed linked art back to raster art when saving to a\nlegacy file format. For example, if the JPEG file format used raster art\nin version 10 and started using placed art in version 11 then\nIllustrator must convert placed linked JPEG images back to raster art\nwhen saving to a version 10 or earlier Illustrator file.\n(Note that this function returns a version value, not an error code.)\n@param fileFormat The file format.\n@return The Illustrator version. The default version is 0,\nmeaning that placed objects are not converted on export.\n@see \\c #SetFirstVersionUsingPlacedArt() to set the version."]
    pub GetFirstVersionUsingPlacedArt:
        ::std::option::Option<unsafe extern "C" fn(fileFormat: AIFileFormatHandle) -> AIVersion>,
    #[doc = " Sets the version of Illustrator in which a raster file\nformat was converted from using raster art to using placed art\nin order to perform a place link operation.\n@param fileFormat The file format.\n@param The Illustrator version value. The default version is 0,\nmeaning that placed objects are not converted on export.\n@see \\c #GetFirstVersionUsingPlacedArt()."]
    pub SetFirstVersionUsingPlacedArt: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, version: AIVersion) -> AIErr,
    >,
    #[doc = " Retrieves the Illustrator startup profile type from the XMP metadata embedded in a file.\n@param file  The file path.\n@param docStartupProfile [out] A buffer in which to return the Illustrator\nstartup profile constant.  If the information is not in the metadata,\nor if the file does not contain XMP metadata, this is \\c #kAIStartupProfileUnknown.\n@return  The error \\c #kBadParameterErr if file is empty or does not exist."]
    pub GetFileStartupProfileType: ::std::option::Option<
        unsafe extern "C" fn(
            file: *const ai_FilePath,
            docStartupProfile: *mut AIDocumentStartupProfile,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the Illustrator default document profile from the startup-profile type.\n@param docStartupProfile The startup profile type.\n@param profile [out] A buffer in which to return the file-path object for the default document profile.\n@return\tThe error \\c #kCantHappenErr if the file does not exists. <br>\nThe error \\c #kBadParameterErr if the startup profile is invalid,"]
    pub GetStartupFileOfType: ::std::option::Option<
        unsafe extern "C" fn(
            docStartupProfile: AIDocumentStartupProfile,
            profile: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the extended option flags of a file format.\n@param fileFormat The file format.\n@param extendedOptions [out] A buffer in which to return the extended options\n\\c #AIFFExtendedOptions values\n\\verbatim\nkNoExtendedOptions\nkSaveMultiArtboards\nkFileFormatPlaceInTouch\n\\endverbatim"]
    pub GetFileFormatExtendedOptions: ::std::option::Option<
        unsafe extern "C" fn(
            fileFormat: AIFileFormatHandle,
            extendedOptions: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Sets the extended option flags of a file format, which specify what file operations can be handled.\n@param fileFormat The file format.\n@param extendedOptions File format operations that this plug-in supports. A logical OR of these\n\\c #AIFFExtendedOptions values:\n\\verbatim\nkNoExtendedOptions\nkSaveMultiArtboards\nkFileFormatPlaceInTouch\n\\endverbatim"]
    pub SetFileFormatExtendedOptions: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, extendedOptions: ai_int32) -> AIErr,
    >,
    #[doc = " Used for exporting the current document as one whole file or as multiple artBoards\n@param actionParam An action parameter block containing keys \"name\", \"frmt\", \"ext\", \"smab\", \"sall\", \"sran\" as defined in AIDocumentAction.h\nWill return error (and not throw a dialog) if the above action keys are missing."]
    pub GoExport:
        ::std::option::Option<unsafe extern "C" fn(actionParam: AIActionParamValueRef) -> AIErr>,
}
#[doc = " @deprecated. Obsolete platform-specific functions.\tUse functions in \\c #AIFileFormatSuite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMacFileFormatSuite {
    pub MacXGetFileFormatTitle: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, title: *mut ai_UnicodeString) -> AIErr,
    >,
    pub MacXSetFileFormatTitle: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, title: ai_UnicodeString) -> AIErr,
    >,
    pub MacXGetFileFormatType: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, type_: *mut ai_int32) -> AIErr,
    >,
    pub MacXSetFileFormatType: ::std::option::Option<
        unsafe extern "C" fn(fileFormat: AIFileFormatHandle, type_: ai_int32) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ApplicationPaint {
    _unused: [u8; 0],
}
pub type ATE_ApplicationPaintRef = *mut ATE__ApplicationPaint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CompFont {
    _unused: [u8; 0],
}
pub type ATE_CompFontRef = *mut ATE__CompFont;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CompFontClass {
    _unused: [u8; 0],
}
pub type ATE_CompFontClassRef = *mut ATE__CompFontClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CompFontClassSet {
    _unused: [u8; 0],
}
pub type ATE_CompFontClassSetRef = *mut ATE__CompFontClassSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CompFontComponent {
    _unused: [u8; 0],
}
pub type ATE_CompFontComponentRef = *mut ATE__CompFontComponent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CompFontSet {
    _unused: [u8; 0],
}
pub type ATE_CompFontSetRef = *mut ATE__CompFontSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__GlyphRun {
    _unused: [u8; 0],
}
pub type ATE_GlyphRunRef = *mut ATE__GlyphRun;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__GlyphRunsIterator {
    _unused: [u8; 0],
}
pub type ATE_GlyphRunsIteratorRef = *mut ATE__GlyphRunsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ListStyle {
    _unused: [u8; 0],
}
pub type ATE_ListStyleRef = *mut ATE__ListStyle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ListStyleSet {
    _unused: [u8; 0],
}
pub type ATE_ListStyleSetRef = *mut ATE__ListStyleSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__MojiKumi {
    _unused: [u8; 0],
}
pub type ATE_MojiKumiRef = *mut ATE__MojiKumi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__MojiKumiSet {
    _unused: [u8; 0],
}
pub type ATE_MojiKumiSetRef = *mut ATE__MojiKumiSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextFrame {
    _unused: [u8; 0],
}
pub type ATE_TextFrameRef = *mut ATE__TextFrame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextFramesIterator {
    _unused: [u8; 0],
}
pub type ATE_TextFramesIteratorRef = *mut ATE__TextFramesIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextLine {
    _unused: [u8; 0],
}
pub type ATE_TextLineRef = *mut ATE__TextLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextLinesIterator {
    _unused: [u8; 0],
}
pub type ATE_TextLinesIteratorRef = *mut ATE__TextLinesIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextResources {
    _unused: [u8; 0],
}
pub type ATE_TextResourcesRef = *mut ATE__TextResources;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ApplicationTextResources {
    _unused: [u8; 0],
}
pub type ATE_ApplicationTextResourcesRef = *mut ATE__ApplicationTextResources;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__DocumentTextResources {
    _unused: [u8; 0],
}
pub type ATE_DocumentTextResourcesRef = *mut ATE__DocumentTextResources;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__VersionInfo {
    _unused: [u8; 0],
}
pub type ATE_VersionInfoRef = *mut ATE__VersionInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayApplicationPaintRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayApplicationPaintRefRef = *mut ATE__ArrayApplicationPaintRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayReal {
    _unused: [u8; 0],
}
pub type ATE_ArrayRealRef = *mut ATE__ArrayReal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayBool {
    _unused: [u8; 0],
}
pub type ATE_ArrayBoolRef = *mut ATE__ArrayBool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayInteger {
    _unused: [u8; 0],
}
pub type ATE_ArrayIntegerRef = *mut ATE__ArrayInteger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayLineCapType {
    _unused: [u8; 0],
}
pub type ATE_ArrayLineCapTypeRef = *mut ATE__ArrayLineCapType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFigureStyle {
    _unused: [u8; 0],
}
pub type ATE_ArrayFigureStyleRef = *mut ATE__ArrayFigureStyle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayLineJoinType {
    _unused: [u8; 0],
}
pub type ATE_ArrayLineJoinTypeRef = *mut ATE__ArrayLineJoinType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayWariChuJustification {
    _unused: [u8; 0],
}
pub type ATE_ArrayWariChuJustificationRef = *mut ATE__ArrayWariChuJustification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayStyleRunAlignment {
    _unused: [u8; 0],
}
pub type ATE_ArrayStyleRunAlignmentRef = *mut ATE__ArrayStyleRunAlignment;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayAutoKernType {
    _unused: [u8; 0],
}
pub type ATE_ArrayAutoKernTypeRef = *mut ATE__ArrayAutoKernType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayBaselineDirection {
    _unused: [u8; 0],
}
pub type ATE_ArrayBaselineDirectionRef = *mut ATE__ArrayBaselineDirection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayLanguage {
    _unused: [u8; 0],
}
pub type ATE_ArrayLanguageRef = *mut ATE__ArrayLanguage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFontCapsOption {
    _unused: [u8; 0],
}
pub type ATE_ArrayFontCapsOptionRef = *mut ATE__ArrayFontCapsOption;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFontBaselineOption {
    _unused: [u8; 0],
}
pub type ATE_ArrayFontBaselineOptionRef = *mut ATE__ArrayFontBaselineOption;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFontOpenTypePositionOption {
    _unused: [u8; 0],
}
pub type ATE_ArrayFontOpenTypePositionOptionRef = *mut ATE__ArrayFontOpenTypePositionOption;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayUnderlinePosition {
    _unused: [u8; 0],
}
pub type ATE_ArrayUnderlinePositionRef = *mut ATE__ArrayUnderlinePosition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayStrikethroughPosition {
    _unused: [u8; 0],
}
pub type ATE_ArrayStrikethroughPositionRef = *mut ATE__ArrayStrikethroughPosition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayParagraphJustification {
    _unused: [u8; 0],
}
pub type ATE_ArrayParagraphJustificationRef = *mut ATE__ArrayParagraphJustification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayArrayReal {
    _unused: [u8; 0],
}
pub type ATE_ArrayArrayRealRef = *mut ATE__ArrayArrayReal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayBurasagariType {
    _unused: [u8; 0],
}
pub type ATE_ArrayBurasagariTypeRef = *mut ATE__ArrayBurasagariType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayPreferredKinsokuOrder {
    _unused: [u8; 0],
}
pub type ATE_ArrayPreferredKinsokuOrderRef = *mut ATE__ArrayPreferredKinsokuOrder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayKinsokuRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayKinsokuRefRef = *mut ATE__ArrayKinsokuRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayListStyleRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayListStyleRefRef = *mut ATE__ArrayListStyleRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayListStyleSetRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayListStyleSetRefRef = *mut ATE__ArrayListStyleSetRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayMojiKumiRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayMojiKumiRefRef = *mut ATE__ArrayMojiKumiRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayMojiKumiSetRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayMojiKumiSetRefRef = *mut ATE__ArrayMojiKumiSetRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayTabStopsRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayTabStopsRefRef = *mut ATE__ArrayTabStopsRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayLeadingType {
    _unused: [u8; 0],
}
pub type ATE_ArrayLeadingTypeRef = *mut ATE__ArrayLeadingType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFontRef {
    _unused: [u8; 0],
}
pub type ATE_ArrayFontRefRef = *mut ATE__ArrayFontRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayGlyphID {
    _unused: [u8; 0],
}
pub type ATE_ArrayGlyphIDRef = *mut ATE__ArrayGlyphID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayRealPoint {
    _unused: [u8; 0],
}
pub type ATE_ArrayRealPointRef = *mut ATE__ArrayRealPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayFontSizeRefType {
    _unused: [u8; 0],
}
pub type ATE_ArrayFontSizeRefTypeRef = *mut ATE__ArrayFontSizeRefType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayRealMatrix {
    _unused: [u8; 0],
}
pub type ATE_ArrayRealMatrixRef = *mut ATE__ArrayRealMatrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayParagraphDirection {
    _unused: [u8; 0],
}
pub type ATE_ArrayParagraphDirectionRef = *mut ATE__ArrayParagraphDirection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayJustificationMethod {
    _unused: [u8; 0],
}
pub type ATE_ArrayJustificationMethodRef = *mut ATE__ArrayJustificationMethod;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayKashidaWidth {
    _unused: [u8; 0],
}
pub type ATE_ArrayKashidaWidthRef = *mut ATE__ArrayKashidaWidth;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayKashidas {
    _unused: [u8; 0],
}
pub type ATE_ArrayKashidasRef = *mut ATE__ArrayKashidas;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayDirOverride {
    _unused: [u8; 0],
}
pub type ATE_ArrayDirOverrideRef = *mut ATE__ArrayDirOverride;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayDigitSet {
    _unused: [u8; 0],
}
pub type ATE_ArrayDigitSetRef = *mut ATE__ArrayDigitSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayDiacVPos {
    _unused: [u8; 0],
}
pub type ATE_ArrayDiacVPosRef = *mut ATE__ArrayDiacVPos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CharFeatures {
    _unused: [u8; 0],
}
pub type ATE_CharFeaturesRef = *mut ATE__CharFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CharInspector {
    _unused: [u8; 0],
}
pub type ATE_CharInspectorRef = *mut ATE__CharInspector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CharStyle {
    _unused: [u8; 0],
}
pub type ATE_CharStyleRef = *mut ATE__CharStyle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CharStyles {
    _unused: [u8; 0],
}
pub type ATE_CharStylesRef = *mut ATE__CharStyles;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__CharStylesIterator {
    _unused: [u8; 0],
}
pub type ATE_CharStylesIteratorRef = *mut ATE__CharStylesIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Find {
    _unused: [u8; 0],
}
pub type ATE_FindRef = *mut ATE__Find;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Font {
    _unused: [u8; 0],
}
pub type ATE_FontRef = *mut ATE__Font;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Glyph {
    _unused: [u8; 0],
}
pub type ATE_GlyphRef = *mut ATE__Glyph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Glyphs {
    _unused: [u8; 0],
}
pub type ATE_GlyphsRef = *mut ATE__Glyphs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__GlyphsIterator {
    _unused: [u8; 0],
}
pub type ATE_GlyphsIteratorRef = *mut ATE__GlyphsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Kinsoku {
    _unused: [u8; 0],
}
pub type ATE_KinsokuRef = *mut ATE__Kinsoku;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__KinsokuSet {
    _unused: [u8; 0],
}
pub type ATE_KinsokuSetRef = *mut ATE__KinsokuSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParaFeatures {
    _unused: [u8; 0],
}
pub type ATE_ParaFeaturesRef = *mut ATE__ParaFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Paragraph {
    _unused: [u8; 0],
}
pub type ATE_ParagraphRef = *mut ATE__Paragraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParagraphsIterator {
    _unused: [u8; 0],
}
pub type ATE_ParagraphsIteratorRef = *mut ATE__ParagraphsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParaInspector {
    _unused: [u8; 0],
}
pub type ATE_ParaInspectorRef = *mut ATE__ParaInspector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParaStyle {
    _unused: [u8; 0],
}
pub type ATE_ParaStyleRef = *mut ATE__ParaStyle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParaStyles {
    _unused: [u8; 0],
}
pub type ATE_ParaStylesRef = *mut ATE__ParaStyles;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ParaStylesIterator {
    _unused: [u8; 0],
}
pub type ATE_ParaStylesIteratorRef = *mut ATE__ParaStylesIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Spell {
    _unused: [u8; 0],
}
pub type ATE_SpellRef = *mut ATE__Spell;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Stories {
    _unused: [u8; 0],
}
pub type ATE_StoriesRef = *mut ATE__Stories;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__Story {
    _unused: [u8; 0],
}
pub type ATE_StoryRef = *mut ATE__Story;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TabStop {
    _unused: [u8; 0],
}
pub type ATE_TabStopRef = *mut ATE__TabStop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TabStops {
    _unused: [u8; 0],
}
pub type ATE_TabStopsRef = *mut ATE__TabStops;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TabStopsIterator {
    _unused: [u8; 0],
}
pub type ATE_TabStopsIteratorRef = *mut ATE__TabStopsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextRange {
    _unused: [u8; 0],
}
pub type ATE_TextRangeRef = *mut ATE__TextRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextRanges {
    _unused: [u8; 0],
}
pub type ATE_TextRangesRef = *mut ATE__TextRanges;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextRangesIterator {
    _unused: [u8; 0],
}
pub type ATE_TextRangesIteratorRef = *mut ATE__TextRangesIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__TextRunsIterator {
    _unused: [u8; 0],
}
pub type ATE_TextRunsIteratorRef = *mut ATE__TextRunsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__WordsIterator {
    _unused: [u8; 0],
}
pub type ATE_WordsIteratorRef = *mut ATE__WordsIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayLine {
    _unused: [u8; 0],
}
pub type ATE_ArrayLineRef = *mut ATE__ArrayLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE__ArrayComposerEngine {
    _unused: [u8; 0],
}
pub type ATE_ArrayComposerEngineRef = *mut ATE__ArrayComposerEngine;
pub type ATE_ATEGlyphID = ::std::os::raw::c_int;
pub type ATE_ATEBool8 = ::std::os::raw::c_uchar;
pub const ATE_ATEErr_kNoError: ATE_ATEErr = 0;
pub const ATE_ATEErr_kBadParameter: ATE_ATEErr = 1;
pub const ATE_ATEErr_kOutOfMemory: ATE_ATEErr = 2;
pub const ATE_ATEErr_kOutOfRange: ATE_ATEErr = 3;
pub const ATE_ATEErr_kNullPointer: ATE_ATEErr = 4;
pub const ATE_ATEErr_kInternalError: ATE_ATEErr = 5;
pub const ATE_ATEErr_kMissingSpellingDictionary: ATE_ATEErr = 6;
pub const ATE_ATEErr_kMissingHyphenationDictionary: ATE_ATEErr = 7;
#[doc = " @ingroup Errors Adobe Text Engine (ATE) error codes."]
pub type ATE_ATEErr = ::std::os::raw::c_uint;
pub const ATE_StreamVersion_kStreamVersion1: ATE_StreamVersion = 1;
pub const ATE_StreamVersion_kStreamVersion2: ATE_StreamVersion = 2;
pub const ATE_StreamVersion_kStreamVersion3: ATE_StreamVersion = 3;
pub const ATE_StreamVersion_kStreamLastNonPersistedVersion: ATE_StreamVersion = 3;
pub const ATE_StreamVersion_kStreamCS2Redux: ATE_StreamVersion = 3;
pub const ATE_StreamVersion_kStreamVersion4: ATE_StreamVersion = 4;
pub const ATE_StreamVersion_kVerticalTextScaleChange: ATE_StreamVersion = 4;
pub const ATE_StreamVersion_kStreamVersion5: ATE_StreamVersion = 5;
pub const ATE_StreamVersion_kComplexScriptSupport: ATE_StreamVersion = 5;
pub const ATE_StreamVersion_kStreamVersion6: ATE_StreamVersion = 6;
pub const ATE_StreamVersion_kStreamVersion7: ATE_StreamVersion = 7;
pub const ATE_StreamVersion_kStreamVersion8: ATE_StreamVersion = 8;
pub const ATE_StreamVersion_kStreamVersion9: ATE_StreamVersion = 9;
pub const ATE_StreamVersion_kStreamVersion10: ATE_StreamVersion = 10;
pub const ATE_StreamVersion_kStreamVersion11: ATE_StreamVersion = 11;
pub const ATE_StreamVersion_kDontUseLastPlusOne: ATE_StreamVersion = 12;
pub const ATE_StreamVersion_kStreamCurrentVersion: ATE_StreamVersion = 11;
#[doc = " Adobe Text Engine (ATE) stream version constants"]
pub type ATE_StreamVersion = ::std::os::raw::c_uint;
pub const ATE_StreamFormatting_kEfficientPDFOutput: ATE_StreamFormatting = 0;
pub const ATE_StreamFormatting_kPrettyPDFOutput: ATE_StreamFormatting = 1;
pub const ATE_StreamFormatting_kBinaryPDFOutput: ATE_StreamFormatting = 2;
#[doc = " Adobe Text Engine (ATE) stream formatting constants"]
pub type ATE_StreamFormatting = ::std::os::raw::c_uint;
pub const ATE_FeatureSet_kLatinCJKFeatureSet: ATE_FeatureSet = 0;
pub const ATE_FeatureSet_kMEFeatureSet: ATE_FeatureSet = 1;
pub const ATE_FeatureSet_kIndicFeatureSet: ATE_FeatureSet = 2;
pub type ATE_FeatureSet = ::std::os::raw::c_uint;
pub const ATE_FontLockingAllowance_kAllowFontLocking: ATE_FontLockingAllowance = 0;
pub const ATE_FontLockingAllowance_kDontAllowFontLocking: ATE_FontLockingAllowance = 1;
pub const ATE_FontLockingAllowance_kUseFontLockDocumentSetting: ATE_FontLockingAllowance = 2;
pub const ATE_FontLockingAllowance_kAllowFontFallback: ATE_FontLockingAllowance = 3;
pub type ATE_FontLockingAllowance = ::std::os::raw::c_uint;
pub const ATE_LineCapType_kButtCap: ATE_LineCapType = 0;
pub const ATE_LineCapType_kRoundCap: ATE_LineCapType = 1;
pub const ATE_LineCapType_kSquareCap: ATE_LineCapType = 2;
pub const ATE_LineCapType_kNumLineCapTypes: ATE_LineCapType = 3;
#[doc = " Adobe Text Engine (ATE) line cap type constants"]
pub type ATE_LineCapType = ::std::os::raw::c_uint;
#[doc = " Space character"]
pub const ATE_ASCharType_kASSpaceChar: ATE_ASCharType = 0;
#[doc = " Punctuation character"]
pub const ATE_ASCharType_kPunctuationChar: ATE_ASCharType = 1;
#[doc = " Paragraph end character CR"]
pub const ATE_ASCharType_kParagraphEndChar: ATE_ASCharType = 2;
#[doc = " This character is anything but space, punctuation or paragraph end"]
pub const ATE_ASCharType_kNormalChar: ATE_ASCharType = 3;
#[doc = " Adobe Text Engine (ATE) character type constants"]
pub type ATE_ASCharType = ::std::os::raw::c_uint;
#[doc = " A mitered join"]
pub const ATE_LineJoinType_kMiterJoin: ATE_LineJoinType = 0;
#[doc = " A round join"]
pub const ATE_LineJoinType_kRoundJoin: ATE_LineJoinType = 1;
#[doc = " A beveled join"]
pub const ATE_LineJoinType_kBevelJoin: ATE_LineJoinType = 2;
#[doc = " A beveled join"]
pub const ATE_LineJoinType_kNumLineJoinTypes: ATE_LineJoinType = 3;
#[doc = " Adobe Text Engine (ATE) line-join type constants"]
pub type ATE_LineJoinType = ::std::os::raw::c_uint;
pub const ATE_ParagraphJustification_kLeftJustify: ATE_ParagraphJustification = 0;
pub const ATE_ParagraphJustification_kRightJustify: ATE_ParagraphJustification = 1;
pub const ATE_ParagraphJustification_kCenterJustify: ATE_ParagraphJustification = 2;
pub const ATE_ParagraphJustification_kFullJustifyLastLineLeft: ATE_ParagraphJustification = 3;
pub const ATE_ParagraphJustification_kFullJustifyLastLineRight: ATE_ParagraphJustification = 4;
pub const ATE_ParagraphJustification_kFullJustifyLastLineCenter: ATE_ParagraphJustification = 5;
pub const ATE_ParagraphJustification_kFullJustifyLastLineFull: ATE_ParagraphJustification = 6;
#[doc = " Adobe Text Engine (ATE) paragraph justification type constants"]
pub type ATE_ParagraphJustification = ::std::os::raw::c_uint;
pub const ATE_FrameAlignment_kTopAlignment: ATE_FrameAlignment = 0;
pub const ATE_FrameAlignment_kCenterAlignment: ATE_FrameAlignment = 1;
pub const ATE_FrameAlignment_kBottomAlignment: ATE_FrameAlignment = 2;
pub const ATE_FrameAlignment_kJustifyAlignment: ATE_FrameAlignment = 3;
#[doc = " Adobe Text Engine (ATE) text vertical alignment type constants"]
pub type ATE_FrameAlignment = ::std::os::raw::c_uint;
pub const ATE_FrameFitPolicy_kDontAutoFit: ATE_FrameFitPolicy = 0;
pub const ATE_FrameFitPolicy_kHeightExtensionWithCursorHeight: ATE_FrameFitPolicy = 1;
pub const ATE_FrameFitPolicy_kHeightExtensionWithPreciseBounds: ATE_FrameFitPolicy = 2;
pub const ATE_FrameFitPolicy_kHeightExtensionWithBaseline: ATE_FrameFitPolicy = 3;
pub const ATE_FrameFitPolicy_kSoftBottomWithCursorHeight: ATE_FrameFitPolicy = 4;
#[doc = " Adobe Text Engine (ATE) text Frame Fitting Options"]
pub type ATE_FrameFitPolicy = ::std::os::raw::c_uint;
pub const ATE_ComposerEngine_kLatinCJKComposer: ATE_ComposerEngine = 0;
pub const ATE_ComposerEngine_kOptycaComposer: ATE_ComposerEngine = 1;
pub const ATE_ComposerEngine_kAdornment: ATE_ComposerEngine = 2;
#[doc = " Adobe Text Engine (ATE) composer engine type constants\n\nkLatinCJKComposer:  Original ATE US composer supporting Latin and CJK\nkOptycaComposer:        Optyca composer provided by WinSoft WRServices, supporting complex scripts\ne.g. Hebrew, Arabic, Thai, Vietnames, Indic.\nCJK is not supported by version 3.0 of WRServices"]
pub type ATE_ComposerEngine = ::std::os::raw::c_uint;
pub const ATE_ParagraphDirection_kLeftToRight: ATE_ParagraphDirection = 0;
pub const ATE_ParagraphDirection_kRightToLeft: ATE_ParagraphDirection = 1;
#[doc = " Adobe Text Engine (ATE) paragraph direction type constants"]
pub type ATE_ParagraphDirection = ::std::os::raw::c_uint;
pub const ATE_JustificationMethod_kJustifMethodDefault: ATE_JustificationMethod = 0;
pub const ATE_JustificationMethod_kJustifMethodArabic: ATE_JustificationMethod = 1;
pub const ATE_JustificationMethod_kJustifMethodNaskh: ATE_JustificationMethod = 2;
pub const ATE_JustificationMethod_kJustifMethodNaskhTatweel: ATE_JustificationMethod = 3;
pub const ATE_JustificationMethod_kJustifMethodNaskhKashida: ATE_JustificationMethod = 4;
pub const ATE_JustificationMethod_kJustifMethodNaskhTatweelFrac: ATE_JustificationMethod = 5;
pub const ATE_JustificationMethod_kJustifMethodNaskhKashidaFrac: ATE_JustificationMethod = 6;
pub const ATE_JustificationMethod_kJustifMethodAuto: ATE_JustificationMethod = 7;
#[doc = " Adobe Text Engine (ATE) justification method type constants"]
pub type ATE_JustificationMethod = ::std::os::raw::c_uint;
pub const ATE_DigitSet_kDefaultDigits: ATE_DigitSet = 0;
pub const ATE_DigitSet_kArabicDigits: ATE_DigitSet = 1;
pub const ATE_DigitSet_kHindiDigits: ATE_DigitSet = 2;
pub const ATE_DigitSet_kFarsiDigits: ATE_DigitSet = 3;
pub const ATE_DigitSet_kArabicDigitsRTL: ATE_DigitSet = 4;
#[doc = " Adobe Text Engine (ATE) digit set type constants"]
pub type ATE_DigitSet = ::std::os::raw::c_uint;
pub const ATE_DirOverride_kDirOverrideDefault: ATE_DirOverride = 0;
pub const ATE_DirOverride_kDirOverrideLTR: ATE_DirOverride = 1;
pub const ATE_DirOverride_kDirOverrideRTL: ATE_DirOverride = 2;
#[doc = " Adobe Text Engine (ATE) direction override type constants"]
pub type ATE_DirOverride = ::std::os::raw::c_uint;
pub const ATE_DiacVPos_kDiacVPosOff: ATE_DiacVPos = 0;
pub const ATE_DiacVPos_kDiacVPosLoose: ATE_DiacVPos = 1;
pub const ATE_DiacVPos_kDiacVPosMedium: ATE_DiacVPos = 2;
pub const ATE_DiacVPos_kDiacVPosTight: ATE_DiacVPos = 3;
pub const ATE_DiacVPos_kDiacVPosOpenType: ATE_DiacVPos = 4;
#[doc = " Adobe Text Engine (ATE) diacritic vertical position type constants"]
pub type ATE_DiacVPos = ::std::os::raw::c_uint;
pub const ATE_Kashidas_kKashidaDefault: ATE_Kashidas = 0;
pub const ATE_Kashidas_kKashidaOn: ATE_Kashidas = 0;
pub const ATE_Kashidas_kKashidaOff: ATE_Kashidas = 1;
#[doc = " Adobe Text Engine (ATE) kashida type constants"]
pub type ATE_Kashidas = ::std::os::raw::c_uint;
pub const ATE_KashidaWidth_kKashidaNone: ATE_KashidaWidth = 0;
pub const ATE_KashidaWidth_kKashidaSmall: ATE_KashidaWidth = 1;
pub const ATE_KashidaWidth_kKashidaMedium: ATE_KashidaWidth = 2;
pub const ATE_KashidaWidth_kKashidaLong: ATE_KashidaWidth = 3;
pub const ATE_KashidaWidth_kKashidaStylistic: ATE_KashidaWidth = 4;
pub type ATE_KashidaWidth = ::std::os::raw::c_uint;
pub const ATE_WariChuJustification_kWariChuLeftJustify: ATE_WariChuJustification = 0;
pub const ATE_WariChuJustification_kWariChuRightJustify: ATE_WariChuJustification = 1;
pub const ATE_WariChuJustification_kWariChuCenterJustify: ATE_WariChuJustification = 2;
pub const ATE_WariChuJustification_kWariChuFullJustifyLastLineLeft: ATE_WariChuJustification = 3;
pub const ATE_WariChuJustification_kWariChuFullJustifyLastLineRight: ATE_WariChuJustification = 4;
pub const ATE_WariChuJustification_kWariChuFullJustifyLastLineCenter: ATE_WariChuJustification = 5;
pub const ATE_WariChuJustification_kWariChuFullJustifyLastLineFull: ATE_WariChuJustification = 6;
pub const ATE_WariChuJustification_kWariChuAutoJustify: ATE_WariChuJustification = 7;
#[doc = " Adobe Text Engine (ATE) Wari Chu justification type constants"]
pub type ATE_WariChuJustification = ::std::os::raw::c_uint;
pub const ATE_PreferredKinsokuOrder_kPushIn: ATE_PreferredKinsokuOrder = 0;
pub const ATE_PreferredKinsokuOrder_kPushOutFirst: ATE_PreferredKinsokuOrder = 1;
pub const ATE_PreferredKinsokuOrder_kPushOutOnly: ATE_PreferredKinsokuOrder = 2;
#[doc = " Adobe Text Engine (ATE) Kinsoku order constants"]
pub type ATE_PreferredKinsokuOrder = ::std::os::raw::c_uint;
pub const ATE_BurasagariType_kBurasagariNone: ATE_BurasagariType = 0;
pub const ATE_BurasagariType_kBurasagariStandard: ATE_BurasagariType = 1;
pub const ATE_BurasagariType_kBurasagariStrong: ATE_BurasagariType = 2;
#[doc = " Adobe Text Engine (ATE) Burasagari type constants"]
pub type ATE_BurasagariType = ::std::os::raw::c_uint;
pub const ATE_LeadingType_kRomanLeadingType: ATE_LeadingType = 0;
pub const ATE_LeadingType_kJapaneseLeadingType: ATE_LeadingType = 1;
#[doc = " Adobe Text Engine (ATE) leading type constants"]
pub type ATE_LeadingType = ::std::os::raw::c_uint;
pub const ATE_LineHeightType_kEMBoxLineHeightType: ATE_LineHeightType = 0;
pub const ATE_LineHeightType_kPointSizeLineHeightType: ATE_LineHeightType = 1;
#[doc = " Adobe Text Engine (ATE) line height type constants"]
pub type ATE_LineHeightType = ::std::os::raw::c_uint;
pub const ATE_TabType_kLeftTabType: ATE_TabType = 0;
pub const ATE_TabType_kCenterTabType: ATE_TabType = 1;
pub const ATE_TabType_kRightTabType: ATE_TabType = 2;
pub const ATE_TabType_kDecimalTabType: ATE_TabType = 3;
#[doc = " Adobe Text Engine (ATE) tab type constants"]
pub type ATE_TabType = ::std::os::raw::c_uint;
pub const ATE_AutoKernType_kNoAutoKern: ATE_AutoKernType = 0;
pub const ATE_AutoKernType_kMetricKern: ATE_AutoKernType = 1;
pub const ATE_AutoKernType_kOpticalKern: ATE_AutoKernType = 2;
pub const ATE_AutoKernType_kMetricRomanOnlyKern: ATE_AutoKernType = 3;
#[doc = " Adobe Text Engine (ATE) kerning type constants"]
pub type ATE_AutoKernType = ::std::os::raw::c_uint;
pub const ATE_JapaneseAlternateFeature_kDefaultForm: ATE_JapaneseAlternateFeature = 0;
pub const ATE_JapaneseAlternateFeature_kTraditionalForm: ATE_JapaneseAlternateFeature = 1;
pub const ATE_JapaneseAlternateFeature_kExpertForm: ATE_JapaneseAlternateFeature = 2;
pub const ATE_JapaneseAlternateFeature_kJIS78Form: ATE_JapaneseAlternateFeature = 3;
pub const ATE_JapaneseAlternateFeature_kJIS83Form: ATE_JapaneseAlternateFeature = 4;
pub const ATE_JapaneseAlternateFeature_kHalfWidthForm: ATE_JapaneseAlternateFeature = 5;
pub const ATE_JapaneseAlternateFeature_kThirdWidthForm: ATE_JapaneseAlternateFeature = 6;
pub const ATE_JapaneseAlternateFeature_kQuarterWidthForm: ATE_JapaneseAlternateFeature = 7;
pub const ATE_JapaneseAlternateFeature_kFullWidthForm: ATE_JapaneseAlternateFeature = 8;
pub const ATE_JapaneseAlternateFeature_kProportionalWidthForm: ATE_JapaneseAlternateFeature = 9;
pub const ATE_JapaneseAlternateFeature_kJIS90Form: ATE_JapaneseAlternateFeature = 10;
pub const ATE_JapaneseAlternateFeature_kJIS04Form: ATE_JapaneseAlternateFeature = 11;
#[doc = " Adobe Text Engine (ATE) Japanese alternate feature type constants"]
pub type ATE_JapaneseAlternateFeature = ::std::os::raw::c_uint;
pub const ATE_BaselineDirection_kNeverUseMustBeKnown: ATE_BaselineDirection = 0;
pub const ATE_BaselineDirection_kBaselineWithStream: ATE_BaselineDirection = 1;
pub const ATE_BaselineDirection_kBaselineVerticalRotated: ATE_BaselineDirection = 2;
pub const ATE_BaselineDirection_kBaselineVerticalCrossStream: ATE_BaselineDirection = 3;
#[doc = " Adobe Text Engine (ATE) baseline direction constants"]
pub type ATE_BaselineDirection = ::std::os::raw::c_uint;
pub const ATE_FontSizeRefType_kFontSizeRefDefault: ATE_FontSizeRefType = 0;
pub const ATE_FontSizeRefType_kFontSizeRef_CapHeight: ATE_FontSizeRefType = 1;
pub const ATE_FontSizeRefType_kFontSizeRef_XHeight: ATE_FontSizeRefType = 2;
pub const ATE_FontSizeRefType_kFontSizeRef_ICFBox: ATE_FontSizeRefType = 3;
#[doc = " Adobe Text Engine (ATE) Font Height Option Reference .\nThis is also being referred as setting the reference type which will\nalso guide how to evaluate reference font size value."]
pub type ATE_FontSizeRefType = ::std::os::raw::c_uint;
pub const ATE_UnderlinePosition_kUnderlineOff: ATE_UnderlinePosition = 0;
pub const ATE_UnderlinePosition_kUnderlineOn_RightInVertical: ATE_UnderlinePosition = 1;
pub const ATE_UnderlinePosition_kUnderlineOn_LeftInVertical: ATE_UnderlinePosition = 2;
#[doc = " Adobe Text Engine (ATE) underline position constants"]
pub type ATE_UnderlinePosition = ::std::os::raw::c_uint;
pub const ATE_UnderlineStyle_kUnderlineSolid: ATE_UnderlineStyle = 0;
pub const ATE_UnderlineStyle_kUnderlineDashed: ATE_UnderlineStyle = 1;
#[doc = " Adobe Text Engine (ATE) underline style constants"]
pub type ATE_UnderlineStyle = ::std::os::raw::c_uint;
pub const ATE_StrikethroughPosition_kStrikethroughOff: ATE_StrikethroughPosition = 0;
pub const ATE_StrikethroughPosition_kStrikethroughOn_XHeight: ATE_StrikethroughPosition = 1;
pub const ATE_StrikethroughPosition_kStrikethroughOn_EMBox: ATE_StrikethroughPosition = 2;
#[doc = " Adobe Text Engine (ATE) strike-through position constants"]
pub type ATE_StrikethroughPosition = ::std::os::raw::c_uint;
pub const ATE_StyleRunAlignment_kAlignStylesByBottom: ATE_StyleRunAlignment = 0;
pub const ATE_StyleRunAlignment_kAlignStylesByICFBottom: ATE_StyleRunAlignment = 1;
pub const ATE_StyleRunAlignment_kAlignStylesByRomanHorizontalCenterVertical: ATE_StyleRunAlignment =
    2;
pub const ATE_StyleRunAlignment_kAlignStylesByCenterHorizontalRomanVertical: ATE_StyleRunAlignment =
    3;
pub const ATE_StyleRunAlignment_kAlignStylesByICFTop: ATE_StyleRunAlignment = 4;
pub const ATE_StyleRunAlignment_kAlignStylesByTop: ATE_StyleRunAlignment = 5;
#[doc = " Adobe Text Engine (ATE) style-run alignment constants"]
pub type ATE_StyleRunAlignment = ::std::os::raw::c_uint;
pub const ATE_CaseChangeType_kUppercase: ATE_CaseChangeType = 0;
pub const ATE_CaseChangeType_kLowercase: ATE_CaseChangeType = 1;
pub const ATE_CaseChangeType_kTitleCase: ATE_CaseChangeType = 2;
pub const ATE_CaseChangeType_kSentenceCase: ATE_CaseChangeType = 3;
#[doc = " Adobe Text Engine (ATE) character case change constants"]
pub type ATE_CaseChangeType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATE_SLOToOTLanguage {
    pub fScript: *const ::std::os::raw::c_char,
    pub fLanguage: *const ::std::os::raw::c_char,
}
pub const ATE_Language_kEnglishLanguage: ATE_Language = 0;
pub const ATE_Language_kFinnishLanguage: ATE_Language = 1;
pub const ATE_Language_kStandardFrenchLanguage: ATE_Language = 2;
pub const ATE_Language_kCanadianFrenchLanguage: ATE_Language = 3;
pub const ATE_Language_kGerman1996ReformLanguage: ATE_Language = 4;
pub const ATE_Language_kOldGermanLanguage: ATE_Language = 5;
pub const ATE_Language_kOldSwissGermanLanguage: ATE_Language = 6;
pub const ATE_Language_kItalianLanguage: ATE_Language = 7;
pub const ATE_Language_kBokmalNorwegianLanguage: ATE_Language = 8;
pub const ATE_Language_kNynorskNorwegianLanguage: ATE_Language = 9;
pub const ATE_Language_kStandardPortugueseLanguage: ATE_Language = 10;
pub const ATE_Language_kBrazillianPortugueseLanguage: ATE_Language = 11;
pub const ATE_Language_kSpanishLanguage: ATE_Language = 12;
pub const ATE_Language_kSwedishLanguage: ATE_Language = 13;
pub const ATE_Language_kUKEnglishLanguage: ATE_Language = 14;
pub const ATE_Language_kOldDutchLanguage: ATE_Language = 15;
pub const ATE_Language_kDanish: ATE_Language = 16;
pub const ATE_Language_kCatalan: ATE_Language = 17;
pub const ATE_Language_kRussian: ATE_Language = 18;
pub const ATE_Language_kUkranian: ATE_Language = 19;
pub const ATE_Language_kBulgarian: ATE_Language = 20;
pub const ATE_Language_kSerbian: ATE_Language = 21;
pub const ATE_Language_kCzech: ATE_Language = 22;
pub const ATE_Language_kPolish: ATE_Language = 23;
pub const ATE_Language_kRumanian: ATE_Language = 24;
pub const ATE_Language_kGreek: ATE_Language = 25;
pub const ATE_Language_kTurkish: ATE_Language = 26;
pub const ATE_Language_kIcelandic: ATE_Language = 27;
pub const ATE_Language_kHungarian: ATE_Language = 28;
pub const ATE_Language_kChineseLanguage: ATE_Language = 29;
pub const ATE_Language_kJapaneseLanguage: ATE_Language = 30;
pub const ATE_Language_kCroatian: ATE_Language = 31;
pub const ATE_Language_kHebrew: ATE_Language = 32;
pub const ATE_Language_kSlovenian: ATE_Language = 33;
pub const ATE_Language_kBelarussian: ATE_Language = 34;
pub const ATE_Language_kAlbanian: ATE_Language = 35;
pub const ATE_Language_kLithuanian: ATE_Language = 36;
pub const ATE_Language_kLatvian: ATE_Language = 37;
pub const ATE_Language_kSlovakian: ATE_Language = 38;
pub const ATE_Language_kArabic: ATE_Language = 39;
pub const ATE_Language_kEstonian: ATE_Language = 40;
pub const ATE_Language_kFarsi: ATE_Language = 41;
pub const ATE_Language_kGerman2006ReformLanguage: ATE_Language = 42;
pub const ATE_Language_kDutch2005ReformLanguage: ATE_Language = 43;
pub const ATE_Language_kSwissGerman2006ReformLanguage: ATE_Language = 44;
pub const ATE_Language_kCanadianEnglish: ATE_Language = 45;
pub const ATE_Language_kThai: ATE_Language = 46;
pub const ATE_Language_kVietnamese: ATE_Language = 47;
pub const ATE_Language_kLao: ATE_Language = 48;
pub const ATE_Language_kHindi: ATE_Language = 49;
pub const ATE_Language_kMarathi: ATE_Language = 50;
pub const ATE_Language_kBengaliIndia: ATE_Language = 51;
pub const ATE_Language_kPunjabi: ATE_Language = 52;
pub const ATE_Language_kGujarati: ATE_Language = 53;
pub const ATE_Language_kOriya: ATE_Language = 54;
pub const ATE_Language_kTamil: ATE_Language = 55;
pub const ATE_Language_kTelugu: ATE_Language = 56;
pub const ATE_Language_kKannada: ATE_Language = 57;
pub const ATE_Language_kMalayalam: ATE_Language = 58;
pub const ATE_Language_kBurmese: ATE_Language = 59;
pub const ATE_Language_kSinhalese: ATE_Language = 60;
pub const ATE_Language_kKhmer: ATE_Language = 61;
pub const ATE_Language_kIndonesian: ATE_Language = 62;
pub const ATE_Language_kKoreanLanguage: ATE_Language = 63;
pub const ATE_Language_kNumberOfLanguages: ATE_Language = 64;
pub const ATE_Language_kInvalidLanguage: ATE_Language = 1000;
#[doc = " Adobe Text Engine (ATE) language constants"]
pub type ATE_Language = ::std::os::raw::c_uint;
pub type ATE_DictionaryServiceType = ASUTF16;
pub const kSpellingService: ATE__bindgen_ty_1 = 0;
pub const kHyphenationService: ATE__bindgen_ty_1 = 1;
pub const kInvalidService: ATE__bindgen_ty_1 = 2;
pub type ATE__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const ATE_SyntheticFontType_kNoSynthetic: ATE_SyntheticFontType = 0;
pub const ATE_SyntheticFontType_kItalicSynthetic: ATE_SyntheticFontType = 1;
pub const ATE_SyntheticFontType_kBoldSynthetic: ATE_SyntheticFontType = 2;
pub const ATE_SyntheticFontType_kBoldItalicSynthetic: ATE_SyntheticFontType = 3;
#[doc = " Adobe Text Engine (ATE) synthetic font type constants"]
pub type ATE_SyntheticFontType = ::std::os::raw::c_uint;
pub const ATE_FigureStyle_kDefaultFigureStyle: ATE_FigureStyle = 0;
pub const ATE_FigureStyle_kTabularLining: ATE_FigureStyle = 1;
pub const ATE_FigureStyle_kProportionalOldStyle: ATE_FigureStyle = 2;
pub const ATE_FigureStyle_kProportionalLining: ATE_FigureStyle = 3;
pub const ATE_FigureStyle_kTabularOldStyle: ATE_FigureStyle = 4;
#[doc = " Adobe Text Engine (ATE) figure style constants"]
pub type ATE_FigureStyle = ::std::os::raw::c_uint;
pub const ATE_FontCapsOption_kFontNormalCaps: ATE_FontCapsOption = 0;
pub const ATE_FontCapsOption_kFontSmallCaps: ATE_FontCapsOption = 1;
pub const ATE_FontCapsOption_kFontAllCaps: ATE_FontCapsOption = 2;
pub const ATE_FontCapsOption_kFontAllSmallCaps: ATE_FontCapsOption = 3;
#[doc = " Adobe Text Engine (ATE) font capitalization constants"]
pub type ATE_FontCapsOption = ::std::os::raw::c_uint;
pub const ATE_FontBaselineOption_kFontNormalBaseline: ATE_FontBaselineOption = 0;
pub const ATE_FontBaselineOption_kFontFauxedSuperScript: ATE_FontBaselineOption = 1;
pub const ATE_FontBaselineOption_kFontFauxedSubScript: ATE_FontBaselineOption = 2;
#[doc = " Adobe Text Engine (ATE) baseline option constants"]
pub type ATE_FontBaselineOption = ::std::os::raw::c_uint;
pub const ATE_FontOpenTypePositionOption_kFontOTNormalPosition: ATE_FontOpenTypePositionOption = 0;
pub const ATE_FontOpenTypePositionOption_kFontOTSuperscriptPosition:
    ATE_FontOpenTypePositionOption = 1;
pub const ATE_FontOpenTypePositionOption_kFontOTSubscriptPosition: ATE_FontOpenTypePositionOption =
    2;
pub const ATE_FontOpenTypePositionOption_kFontOTNumeratorPosition: ATE_FontOpenTypePositionOption =
    3;
pub const ATE_FontOpenTypePositionOption_kFontOTDenominatorPosition:
    ATE_FontOpenTypePositionOption = 4;
#[doc = " Adobe Text Engine (ATE) OpenType font position constants"]
pub type ATE_FontOpenTypePositionOption = ::std::os::raw::c_uint;
pub const ATE_MakeEmptyMemoryHint_kMakeEmptyAndFreeAllocations: ATE_MakeEmptyMemoryHint = 0;
pub const ATE_MakeEmptyMemoryHint_kMakeEmptyAndPreserveAllocations: ATE_MakeEmptyMemoryHint = 1;
#[doc = " Adobe Text Engine (ATE) memory management constants"]
pub type ATE_MakeEmptyMemoryHint = ::std::os::raw::c_uint;
pub const ATE_Direction_kForward: ATE_Direction = 1;
pub const ATE_Direction_kStationary: ATE_Direction = 0;
pub const ATE_Direction_kBackward: ATE_Direction = -1;
#[doc = " Adobe Text Engine (ATE) direction constants"]
pub type ATE_Direction = ::std::os::raw::c_int;
pub const ATE_FlattenWithParentStyles_kDoNotFlattenWithParent: ATE_FlattenWithParentStyles = 0;
pub const ATE_FlattenWithParentStyles_kFlattenWithParent: ATE_FlattenWithParentStyles = 1;
#[doc = " Adobe Text Engine (ATE) flattening options"]
pub type ATE_FlattenWithParentStyles = ::std::os::raw::c_uint;
pub const ATE_SearchScope_kSearchEntireDocument: ATE_SearchScope = 0;
pub const ATE_SearchScope_kSearchStory: ATE_SearchScope = 1;
#[doc = " Adobe Text Engine (ATE) search options"]
pub type ATE_SearchScope = ::std::os::raw::c_uint;
pub const ATE_CollapseDirection_CollapseEnd: ATE_CollapseDirection = 0;
pub const ATE_CollapseDirection_CollapseStart: ATE_CollapseDirection = 1;
#[doc = " Adobe Text Engine (ATE) collapse direction options"]
pub type ATE_CollapseDirection = ::std::os::raw::c_uint;
pub const kOpenParenthesis_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 1;
pub const kCloseParenthesis_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 2;
pub const kCantBeginLineCharacters_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 3;
pub const kBreakingPunctuation_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 4;
pub const kMiddlePunctuation_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 5;
pub const kPeriods_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 6;
pub const kComma_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 7;
pub const kIndivisibleCharacters_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 8;
pub const kPreAbbreviationSymbols_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 9;
pub const kPostAbbreviationSymbols_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 10;
pub const kJapaneseSpace_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 11;
pub const kHiragana_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 12;
pub const kDoubleByteNumber_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 13;
pub const kOtherJapaneseCharacters_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 14;
pub const kSingleByteNumber_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 15;
pub const kRomanNonSpaceCharacters_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 16;
pub const kTopOrEndOfLine_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 17;
pub const kTopOfParagraph_MojiKumiCharacterClass: ATE__bindgen_ty_2 = 18;
#[doc = " Adobe Text Engine (ATE) Moji Kumi constants"]
pub type ATE__bindgen_ty_2 = ::std::os::raw::c_uint;
pub const ATE_CompositeFontClassType_kCompositeFontClassOverride: ATE_CompositeFontClassType = 0;
pub const ATE_CompositeFontClassType_kCompositeFontClassBase: ATE_CompositeFontClassType = 1;
pub const ATE_CompositeFontClassType_kCompositeFontClassKana: ATE_CompositeFontClassType = 2;
pub const ATE_CompositeFontClassType_kCompositeFontClassPunctuation: ATE_CompositeFontClassType = 3;
pub const ATE_CompositeFontClassType_kCompositeFontClassFWSymbolsAndAlphabetic:
    ATE_CompositeFontClassType = 4;
pub const ATE_CompositeFontClassType_kCompositeFontClassHWSymbolsAndAlphabetic:
    ATE_CompositeFontClassType = 5;
pub const ATE_CompositeFontClassType_kCompositeFontClassHWNumerals: ATE_CompositeFontClassType = 6;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji0: ATE_CompositeFontClassType = 7;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji1: ATE_CompositeFontClassType = 8;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji2: ATE_CompositeFontClassType = 9;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji3: ATE_CompositeFontClassType = 10;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji4: ATE_CompositeFontClassType = 11;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji5: ATE_CompositeFontClassType = 12;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji6: ATE_CompositeFontClassType = 13;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji7: ATE_CompositeFontClassType = 14;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji8: ATE_CompositeFontClassType = 15;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji9: ATE_CompositeFontClassType = 16;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji10: ATE_CompositeFontClassType = 17;
pub const ATE_CompositeFontClassType_kCompositeFontClassGaiji11: ATE_CompositeFontClassType = 18;
pub const ATE_CompositeFontClassType_kEndOfCompositeFontClassType: ATE_CompositeFontClassType = 19;
#[doc = " Adobe Text Engine (ATE) composite font class constants"]
pub type ATE_CompositeFontClassType = ::std::os::raw::c_uint;
pub const ATE_MojiKumiCodeClass_kOpen: ATE_MojiKumiCodeClass = 1;
pub const ATE_MojiKumiCodeClass_kClose: ATE_MojiKumiCodeClass = 2;
pub const ATE_MojiKumiCodeClass_kNoBegin: ATE_MojiKumiCodeClass = 3;
pub const ATE_MojiKumiCodeClass_kEndPunctuation: ATE_MojiKumiCodeClass = 4;
pub const ATE_MojiKumiCodeClass_kMiddlePunctuation: ATE_MojiKumiCodeClass = 5;
pub const ATE_MojiKumiCodeClass_kPeriodPunctuation: ATE_MojiKumiCodeClass = 6;
pub const ATE_MojiKumiCodeClass_kCommaPunctuation: ATE_MojiKumiCodeClass = 7;
pub const ATE_MojiKumiCodeClass_kNotSeparatePunctuation: ATE_MojiKumiCodeClass = 8;
pub const ATE_MojiKumiCodeClass_kSymbolsPrecedingNumbers: ATE_MojiKumiCodeClass = 9;
pub const ATE_MojiKumiCodeClass_kSymbolsFollowingNumbers: ATE_MojiKumiCodeClass = 10;
pub const ATE_MojiKumiCodeClass_kIdeographic: ATE_MojiKumiCodeClass = 11;
pub const ATE_MojiKumiCodeClass_kHiragana: ATE_MojiKumiCodeClass = 12;
pub const ATE_MojiKumiCodeClass_kDoubleByteNumbers: ATE_MojiKumiCodeClass = 13;
pub const ATE_MojiKumiCodeClass_kOtherJapaneseCharacters: ATE_MojiKumiCodeClass = 14;
pub const ATE_MojiKumiCodeClass_kSingleByteNumbers: ATE_MojiKumiCodeClass = 15;
pub const ATE_MojiKumiCodeClass_kRomanNonSpace: ATE_MojiKumiCodeClass = 16;
pub const ATE_MojiKumiCodeClass_kLineEdgeClass: ATE_MojiKumiCodeClass = 17;
pub const ATE_MojiKumiCodeClass_kParagraphStartClass: ATE_MojiKumiCodeClass = 18;
pub const ATE_MojiKumiCodeClass_kEndOfCodeClasses: ATE_MojiKumiCodeClass = 19;
#[doc = " Adobe Text Engine (ATE) Moji Kumi code-class constants"]
pub type ATE_MojiKumiCodeClass = ::std::os::raw::c_uint;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionNone: ATE_ClassMetricRestriction = 0;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionSize: ATE_ClassMetricRestriction = 1;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionBaseline: ATE_ClassMetricRestriction =
    2;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionHorizontalScale:
    ATE_ClassMetricRestriction = 4;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionVerticalScale:
    ATE_ClassMetricRestriction = 8;
pub const ATE_ClassMetricRestriction_kClassMetricRestrictionCenterGlyph:
    ATE_ClassMetricRestriction = 16;
#[doc = " Adobe Text Engine (ATE) class metric restrictions for a composite font component."]
pub type ATE_ClassMetricRestriction = ::std::os::raw::c_uint;
pub const ATE_LineOrientation_kHorizontalLines: ATE_LineOrientation = 0;
#[doc = " Not supported by Illustrator"]
pub const ATE_LineOrientation_kVerticalLeftToRight: ATE_LineOrientation = 1;
#[doc = " Not supported by Illustrator"]
pub const ATE_LineOrientation_kVerticalRightToLeft: ATE_LineOrientation = 2;
#[doc = " Adobe Text Engine (ATE) line orientation options"]
pub type ATE_LineOrientation = ::std::os::raw::c_uint;
#[doc = " Horizontal left to right."]
pub const ATE_GlyphOrientation_kHorizontalGlyphs: ATE_GlyphOrientation = 0;
#[doc = " Standard vertical, straight from the font as vertical glyphs."]
pub const ATE_GlyphOrientation_kVerticalGlyphs: ATE_GlyphOrientation = 1;
#[doc = " Horizontal glyphs rotated 90 degrees to be on side in vertical."]
pub const ATE_GlyphOrientation_kHorizontalGlyphsRotated: ATE_GlyphOrientation = 2;
#[doc = " Not used; we are no longer setting this constant but it may exist in files."]
pub const ATE_GlyphOrientation_kVerticalUprightRomanGlyphs: ATE_GlyphOrientation = 3;
#[doc = " Adobe Text Engine (ATE) glyph orientation constants"]
pub type ATE_GlyphOrientation = ::std::os::raw::c_uint;
pub const ATE_FrameType_kPointTextFrame: ATE_FrameType = 0;
pub const ATE_FrameType_kInPathTextFrame: ATE_FrameType = 1;
pub const ATE_FrameType_kOnPathTextFrame: ATE_FrameType = 2;
#[doc = " Adobe Text Engine (ATE) frame type constants"]
pub type ATE_FrameType = ::std::os::raw::c_uint;
pub const ATE_PointTextAlignmentMode_kPointTextAlignOnOrigin: ATE_PointTextAlignmentMode = 0;
pub const ATE_PointTextAlignmentMode_kPointTextAlignOnFrameWidth: ATE_PointTextAlignmentMode = 1;
#[doc = " [gfrancis]: ProjectX introduced the Unified Text Object, which requires different\n alignment behavior for ATE's PointText frame type.\n\n The enum should only be used for Point Text."]
pub type ATE_PointTextAlignmentMode = ::std::os::raw::c_uint;
pub const ATE_SpellCheckingResult_kNoProblems: ATE_SpellCheckingResult = 0;
pub const ATE_SpellCheckingResult_kUnknownWord: ATE_SpellCheckingResult = 1;
pub const ATE_SpellCheckingResult_kRepeatedWords: ATE_SpellCheckingResult = 2;
pub const ATE_SpellCheckingResult_kUncappedStartOfSentence: ATE_SpellCheckingResult = 3;
pub const ATE_SpellCheckingResult_kUncappedUnknownStartOfSentence: ATE_SpellCheckingResult = 4;
#[doc = " Adobe Text Engine (ATE) spell-checking result constants"]
pub type ATE_SpellCheckingResult = ::std::os::raw::c_uint;
pub const ATE_KinsokuPredefinedTag_kUserDefinedKinsokuTag: ATE_KinsokuPredefinedTag = 0;
pub const ATE_KinsokuPredefinedTag_kPredefinedHardKinsokuTag: ATE_KinsokuPredefinedTag = 1;
pub const ATE_KinsokuPredefinedTag_kPredefinedSoftKinsokuTag: ATE_KinsokuPredefinedTag = 2;
pub const ATE_KinsokuPredefinedTag_kPredefinedSoftV2KinsokuTag: ATE_KinsokuPredefinedTag = 3;
#[doc = " Adobe Text Engine (ATE) Kinsoku predefined tag constants"]
pub type ATE_KinsokuPredefinedTag = ::std::os::raw::c_uint;
pub const ATE_MojikumiTablePredefinedTag_kUserDefinedMojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 0;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedYakumonoHankakuMojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 1;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedYakumonoZenkakuMojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 2;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedGyomatsuYakumonoHankakuMojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 3;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedGyomatsuYakumonoZenkakuMojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 4;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedGyomatsuYakumonoZenkakuOrHankakuMojikumiTableTag : ATE_MojikumiTablePredefinedTag = 5 ;
pub const ATE_MojikumiTablePredefinedTag_kPredefinedGyomatsuYakumonoHankakuV2MojikumiTableTag:
    ATE_MojikumiTablePredefinedTag = 3;
#[doc = " Adobe Text Engine (ATE) Moji Kumi predefined tag constants"]
pub type ATE_MojikumiTablePredefinedTag = ::std::os::raw::c_uint;
pub const ATE_ListStylePredefinedTag_kUserDefinedListStyleTag: ATE_ListStylePredefinedTag = 0;
pub const ATE_ListStylePredefinedTag_kPredefinedNumericListStyleTag: ATE_ListStylePredefinedTag = 1;
pub const ATE_ListStylePredefinedTag_kPredefinedUppercaseAlphaListStyleTag:
    ATE_ListStylePredefinedTag = 2;
pub const ATE_ListStylePredefinedTag_kPredefinedLowercaseAlphaListStyleTag:
    ATE_ListStylePredefinedTag = 3;
pub const ATE_ListStylePredefinedTag_kPredefinedUppercaseRomanNumListStyleTag:
    ATE_ListStylePredefinedTag = 4;
pub const ATE_ListStylePredefinedTag_kPredefinedLowercaseRomanNumListStyleTag:
    ATE_ListStylePredefinedTag = 5;
pub const ATE_ListStylePredefinedTag_kPredefinedBulletListStyleTag: ATE_ListStylePredefinedTag = 6;
pub const ATE_ListStylePredefinedTag_kPredefinedSingleZeroPrefixNumericListStyleTag:
    ATE_ListStylePredefinedTag = 7;
pub const ATE_ListStylePredefinedTag_kPredefinedDoubleZeroPrefixNumericListStyleTag:
    ATE_ListStylePredefinedTag = 8;
#[doc = " Adobe Text Engine (ATE) List Style predefined tag constants"]
pub type ATE_ListStylePredefinedTag = ::std::os::raw::c_uint;
pub const ATE_BNListAlignment_kBN_AlignStart: ATE_BNListAlignment = 0;
pub const ATE_BNListAlignment_kBN_AlignCenter: ATE_BNListAlignment = 1;
pub const ATE_BNListAlignment_kBN_AlignEnd: ATE_BNListAlignment = 2;
#[doc = " Adobe Text Engine (ATE) text list label alignment type constants"]
pub type ATE_BNListAlignment = ::std::os::raw::c_uint;
pub const ATE_IndentUnits_kEms: ATE_IndentUnits = 0;
pub const ATE_IndentUnits_kPoints: ATE_IndentUnits = 1;
#[doc = " Adobe Text Engine (ATE) text list indent units"]
pub type ATE_IndentUnits = ::std::os::raw::c_uint;
pub const ATE_ListStyleSettings_kDefaultList: ATE_ListStyleSettings = 0;
pub const ATE_ListStyleSettings_kDontBreakNumberingForSameSeqSameLevel: ATE_ListStyleSettings = 1;
pub const ATE_ListStyleSettings_kUseOriginalFontTag: ATE_ListStyleSettings = 2;
pub const ATE_ListStyleSettings_kHandleMultipleCROnAllLevelsNParas: ATE_ListStyleSettings = 4;
pub const ATE_ListStyleSettings_kDontAccumulateTextIndentFromPreviousLevels: ATE_ListStyleSettings =
    8;
pub const ATE_ListStyleSettings_kEnableListTierChange: ATE_ListStyleSettings = 16;
pub const ATE_ListStyleSettings_kEnableListStyleDetection: ATE_ListStyleSettings = 32;
pub const ATE_ListStyleSettings_kDeindentOnBackspaceKey: ATE_ListStyleSettings = 64;
pub const ATE_ListStyleSettings_kEnableExistingListStyleItemDetection: ATE_ListStyleSettings = 128;
pub const ATE_ListStyleSettings_kKeepListLabelsWithinFrameBounds: ATE_ListStyleSettings = 256;
pub const ATE_ListStyleSettings_kDisableListStyleUniformizationForCopyPaste: ATE_ListStyleSettings =
    512;
#[doc = " Adobe Text Engine (ATE) text editing policies\n\nExample:\n1. abc                      >> List resource 1 <Numeric>\n2. sdf                       >> List resource 1 <Numeric>\na. qwr             >> List resource 2 <Alpha>\nb.    fgjh          >> List resource 3 <Alpha> with different indent\n3. asd                      >> List resource 1 <Numeric>\n4. vvv                      >> List resource 1 <Numeric>\n\nkDefaultList:: Does not include any extra text processing like updated renumbering logic and breaks the list as soon as a\ndifferent list resource is encoutered\nExample:\n1. abc                      >> List resource 1\n2. sdf                       >> List resource 1\na. qwr             >> List resource 2\na.    fgjh          >> List resource 3         >>List got broken as different list resource\n1. asd                      >> List resource 1         >>List got broken\n2. vvv                      >> List resource 1         >>List got broken\n\n\nkDontBreakNumberingForSamSeqSameLevel: This is a new renumbering logic to prevent breaking of numbering when at same\nlevel, same sequences are present irrespective of overall liststyle\nExample:\n1. abc                      >> List resource 1\n2. sdf                       >> List resource 1\na. qwr             >> List resource 2\nb.     fgjh         >> List resource 3        >>List did not break as list comparison is level wise independent of list other features\n3. asd                      >> List resource 1        >>List did not break\n4. vvv                      >> List resource 1         >>List did not break\n\nkUseOriginalFontTag : Remember font for the list label based on the value of \"UseOriginalFont\" Tag data\n\nkHandleMultipleCROnAllLevelsNParas : On enabling Smart lists in ATE, multiple CRs are handled only on last paragraph of 0th level where\non pressing multiple CRS, list is removed. Enabling the handling of Multiple CRs on levels other than 0, will make them to\ndecrease the tier of that paragraph on double CR press. Also, Multiple CRs has been enabled on all intermediate paragraphs to\nallow for list removal OR tier decrement.\n\nkDontAccumulateTextIndentFromPreviousLevels : On enabling this setting, the text indent value in a level of a liststyle will be used as it is for\ncalculating the list indent of that paragraph instead of acumullating the text indent of all previous levels in addition to current level text\nindent for total list indent calculation.\n\nkEnableListTierChange: enables the automatic indenting to the next tier level of list on press Tab and auto\ndecrease the tier level on press of Shift+Tab\n\nkEnableListStyleDetection: enables thhe automatic smart detection of list styles using patterns like '1.' , 'a.' etc\n\nkDeindentOnBackspaceKey: Enabling this option allows tier decrement / list removal when the user presses the Backspace key\nwhen the cursor is at the start of the paragraph.\n\nkEnableExistingListStyleItemDetection. Detects if new paragraphs belongs to an existing list using patterns like '1.', 'a.' etc.\n\nkKeepListLabelsWithinFrameBounds: When this option is enabled, the rendered paragraph runs are scanned and\nseveral list offset metrics will be computed for each tier of every list found within the paragraphs. These metrics\nwill then be used to compute for each list paragraph the lineOrigin and labelOrigin such that the list labels will\nfit within the frame bounds."]
pub type ATE_ListStyleSettings = ::std::os::raw::c_uint;
pub const ATE_StreamingPolicy_kAll: ATE_StreamingPolicy = 0;
pub const ATE_StreamingPolicy_kOmitPredefinedData: ATE_StreamingPolicy = 1;
pub const ATE_StreamingPolicy_kOmitRenderedText: ATE_StreamingPolicy = 2;
pub const ATE_StreamingPolicy_kOmitMostDocumentSettings: ATE_StreamingPolicy = 4;
pub const ATE_StreamingPolicy_kOmitDictionaryProviders: ATE_StreamingPolicy = 8;
pub const ATE_StreamingPolicy_kOmitTextFrameAsResource: ATE_StreamingPolicy = 16;
pub const ATE_StreamingPolicy_kIncludeOnlyGivenStream: ATE_StreamingPolicy = 32;
pub const ATE_StreamingPolicy_kIncludeOnlyResources: ATE_StreamingPolicy = 64;
pub const ATE_StreamingPolicy_kRefResourcesByUUID: ATE_StreamingPolicy = 128;
#[doc = " ATE Document policies regarding streaming data and predefined resources during Read/Write operation.\n\nThis allows bitwise operation. For example, if one would like to write a document and omit both predefined data and\nRenderedText, kOmitPredefinedData |kOmitRenderedText should be passed as a streaming policy to Document::Write.\n\nkAll:: stream in/out all data\n\nkOmitPredefinedData: do not stream out predefined data (only for Write operation)\nThis significantly reduces the size of the written data. However, fidelity between versions may suffer\nif the omitted predefined data changes from version to version.\n\nWithout specifying this flag, all predefined data will be streamed out; this provides maximum fidelity\nbut increases the file size.\n\nkOmitRenderedText: do not stream in/out RenderedText data\nThis reduces the size of the written data. Text will be recomposed and the view will be re-rendered\nwhen streamed back in. This policy needs to be consistent across read and write.\n\nWithout specifying this flag, all RenderedText data will be streamed out and the view will be maintained\nwhen streamed back in, until before the text is recomposed.\n\nkOmitMostDocumentSettings: do not stream in/out document settings like smart quote settings for every language.\nThis reduces the size of the written data. However, if settings were changed by a user action, these changes\nwill be rolled back to the default state. Use this option only if your application does not allow user changes\nto these settings.\n\nkRefResourcesByUUID: By default, streamed objects and resources refer the resource by its index in resource set.\nBut by this policy, resources will be referred by their UUIDs instead of indexes.\n\nkIncludeOnlyGivenStream: Adding this policy will stream only the passed streamable object :both while reading and writing\n\nkIncludeOnlyResources : This will include only the Test Global resources in the streaming , omitting the text objects\n\nkOmitTextFrameAsResource :  Till kStreamVersion8 , text frames were referred via resource ids from within the stream of\nSLORenderedText. With policy ATE::kOmitTextFrameAsResource , text frames instead of being written as part of text\nglobal resources , they will be embedded into the stream of the sloRenderedText itself in place of the frames resource ids.\n"]
pub type ATE_StreamingPolicy = ::std::os::raw::c_uint;
pub const ATE_OwnedItemChangeIndicator_kNoneOwnedItem: ATE_OwnedItemChangeIndicator = 0;
pub const ATE_OwnedItemChangeIndicator_kHyperlinkOwnedItem: ATE_OwnedItemChangeIndicator = 1;
pub const ATE_OwnedItemChangeIndicator_kAllOwnedItems: ATE_OwnedItemChangeIndicator = 1;
pub type ATE_OwnedItemChangeIndicator = ::std::os::raw::c_uint;
pub const ATE_OutlineExtractionPolicy_kExtractAll: ATE_OutlineExtractionPolicy = 0;
pub const ATE_OutlineExtractionPolicy_kOmitGlyphs: ATE_OutlineExtractionPolicy = 1;
pub const ATE_OutlineExtractionPolicy_kOmitUnderlines: ATE_OutlineExtractionPolicy = 2;
pub const ATE_OutlineExtractionPolicy_kOmitStrikeThrough: ATE_OutlineExtractionPolicy = 4;
pub const ATE_OutlineExtractionPolicy_kForceIncludeUnderlines: ATE_OutlineExtractionPolicy = 8;
pub const ATE_OutlineExtractionPolicy_kAnnotationNoStrokePath: ATE_OutlineExtractionPolicy = 16;
pub type ATE_OutlineExtractionPolicy = ::std::os::raw::c_uint;
pub const ATE_AddEquivalentFormsSetting_kDoNotAddEquivalentForms: ATE_AddEquivalentFormsSetting = 0;
pub const ATE_AddEquivalentFormsSetting_kAddEquivalentForms: ATE_AddEquivalentFormsSetting = 1;
pub type ATE_AddEquivalentFormsSetting = ::std::os::raw::c_uint;
pub const ATE_CheckEquivalentFormsSetting_kDoNotCheckEquivalentForms:
    ATE_CheckEquivalentFormsSetting = 0;
pub const ATE_CheckEquivalentFormsSetting_kCheckEquivalentForms: ATE_CheckEquivalentFormsSetting =
    1;
pub type ATE_CheckEquivalentFormsSetting = ::std::os::raw::c_uint;
pub const ATE_AddOriginalWordSetting_kDoNotAddOriginalWord: ATE_AddOriginalWordSetting = 0;
pub const ATE_AddOriginalWordSetting_kAddOriginalWord: ATE_AddOriginalWordSetting = 1;
pub type ATE_AddOriginalWordSetting = ::std::os::raw::c_uint;
#[doc = " Data passed in kAIDocumentScaleConvertedNotifier and kAIActiveDocumentScaleChangedNotifier"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentScaleNotifyData {
    #[doc = " Old document Scale"]
    pub oldScale: AIReal,
    #[doc = " New Document Scale"]
    pub newScale: AIReal,
}
#[repr(C)]
#[derive(Debug)]
pub struct AISaveMultipleArtboardsParameters {
    pub fType: ai_int32,
    pub fAllArtboards: AIBoolean,
    pub fSaveSuffix: AIBoolean,
    pub fRange: ai_UnicodeString,
}
pub const AIDocumentRulerUnitValue_kUnknownUnits: AIDocumentRulerUnitValue = 0;
#[doc = " inches"]
pub const AIDocumentRulerUnitValue_kInchesUnits: AIDocumentRulerUnitValue = 1;
#[doc = " centimeters"]
pub const AIDocumentRulerUnitValue_kCentimetersUnits: AIDocumentRulerUnitValue = 2;
#[doc = " points"]
pub const AIDocumentRulerUnitValue_kPointsUnits: AIDocumentRulerUnitValue = 3;
#[doc = " picas"]
pub const AIDocumentRulerUnitValue_kPicasUnits: AIDocumentRulerUnitValue = 4;
#[doc = " millimeters"]
pub const AIDocumentRulerUnitValue_kMillimetersUnits: AIDocumentRulerUnitValue = 5;
#[doc = " pixels"]
pub const AIDocumentRulerUnitValue_kPixelsUnits: AIDocumentRulerUnitValue = 6;
#[doc = " Q units"]
pub const AIDocumentRulerUnitValue_kQUnits: AIDocumentRulerUnitValue = 7;
#[doc = " feet-inch"]
pub const AIDocumentRulerUnitValue_kFeetInchesUnits: AIDocumentRulerUnitValue = 8;
#[doc = " meters"]
pub const AIDocumentRulerUnitValue_kMetersUnits: AIDocumentRulerUnitValue = 9;
#[doc = " yards"]
pub const AIDocumentRulerUnitValue_kYardsUnits: AIDocumentRulerUnitValue = 10;
#[doc = " feet"]
pub const AIDocumentRulerUnitValue_kFeetsUnits: AIDocumentRulerUnitValue = 11;
#[doc = "last"]
pub const AIDocumentRulerUnitValue_kLastUnit: AIDocumentRulerUnitValue = 11;
#[doc = " Ruler unit values, see \\c #AIDocumentSuite::GetDocumentRulerUnits()"]
pub type AIDocumentRulerUnitValue = ::std::os::raw::c_uint;
pub const AIDocumentColorModelValue_kDocUnknownColor: AIDocumentColorModelValue = -1;
pub const AIDocumentColorModelValue_kDocGrayColor: AIDocumentColorModelValue = 0;
pub const AIDocumentColorModelValue_kDocRGBColor: AIDocumentColorModelValue = 1;
pub const AIDocumentColorModelValue_kDocCMYKColor: AIDocumentColorModelValue = 2;
#[doc = " Color models that can be used to specify artwork colors\nfor a specific document. See \\c #AIDocumentSuite::GetDocumentColorModel()"]
pub type AIDocumentColorModelValue = ::std::os::raw::c_int;
#[doc = " The legacy definition matches prior versions of Illustrator,\ntypically given using CMYK."]
pub const AISpotColorMode_kAILegacySpotColorMode: AISpotColorMode = 0;
#[doc = " The standard definition is the most accurate, typically given\nusing Lab."]
pub const AISpotColorMode_kAIStandardSpotColorMode: AISpotColorMode = 1;
#[doc = " The standard definition is the most accurate, typically given\nusing Lab."]
pub const AISpotColorMode_kAIDummySpotColorMode: AISpotColorMode = 4294967295;
#[doc = " A \\e book \\e color is one of the named spot colors defined in files\ninstalled in the \"Presets/Color Books\" directory.\nThe appearance definition of a book color specifies how to simulate\nthe appearance of the spot ink when the physical ink is not available.\n\nThis mode value indicates whether new book colors added to\na document should use the standard or legacy appearance definition. It affects\nnew spot colors that are added from a swatch library, by placing a file, or\nby cut and paste. See \\c #AIDocumentSuite::GetDocumentSpotColorMode() and\n\\c #AIDocumentSuite::GetDocumentSpotColorMode().\n\n@note Illustrator does not enforce the mode setting for new spot colors.\nHowever, the import code automatically resolves spot color conflicts."]
pub type AISpotColorMode = ::std::os::raw::c_uint;
pub const AIExportTriggeredFrom_kAIExportAs: AIExportTriggeredFrom = 0;
pub const AIExportTriggeredFrom_kAIExportForScreen: AIExportTriggeredFrom = 1;
pub const AIExportTriggeredFrom_kAISaveForWeb: AIExportTriggeredFrom = 2;
#[doc = " Export can be triggered from Export as, Export for screens and Save for web.\nWe have maintained different default settings for each export.\nGetLastExportedFilePath()\nSetLastExportedFilePath()\nrequire this parameter of type AIExportTriggeredFrom to know which export was used"]
pub type AIExportTriggeredFrom = ai_uint8;
#[doc = " Struct for notification data of <b>kAIDocumentWriteOnDiskCompleteNotifier</b>"]
#[repr(C)]
#[derive(Debug)]
pub struct AIDocumentWriteOnDiskCompleteNotifyData {
    pub documentFilepath: ai_FilePath,
}
#[doc = " Struct for notification data of <b>kAIDocumentWriteOnDiskFailedNotifier</b>"]
#[repr(C)]
#[derive(Debug)]
pub struct AIDocumentWriteOnDiskFailedNotifyData {
    pub error: AIErr,
    pub documentFilepath: ai_FilePath,
}
#[doc = " Document setup information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentSetup {
    #[doc = " The document height and width, in points"]
    pub width: AIReal,
    #[doc = " The document height and width, in points"]
    pub height: AIReal,
    #[doc = " When true, show placed images in the document."]
    pub showPlacedImages: AIBoolean,
    #[doc = " The output resolution for the document, in dots-per-inch (DPI). Available only through API.\nControls how fine a detail bezier curves are flattened to when output to print. Default is 800."]
    pub outputResolution: AIReal,
    #[doc = " When true, split long paths. Available only through API.\nControls whether long paths are split into multiple separate paths when saved or printed.\nWhich paths are split also depends on output resolution. Default is false."]
    pub splitLongPaths: AIBoolean,
    #[doc = " (For compatibility with earlier versions.)\nWhen true, use printer default halftone screens when printing to Illustrator 8 or earlier EPS,\nrather than Illustrator 5 screens. The screens define the shapes of ink dots.\nDefault is true."]
    pub useDefaultScreen: AIBoolean,
    #[doc = " (For compatibility with earlier versions.)\nWhen true, printing to Illustrator 8 or earlier EPS emits PostScript Level 1-compatible gradients\nthat do not use smooth shading (a Level 2 feature), but synthesize gradients by drawing many\nthin rectangular fills. Default is false. Available in UI through Graphics tab of Print dialog."]
    pub compatibleGradients: AIBoolean,
    #[doc = " When true, print multiple tiled pages for this document. When false, print a single page.\n\\c #AIDocumentSuite::SetDocumentSetup() does not set this value,\nbut available in UI through Setup tab of Print dialog."]
    pub printTiles: AIBoolean,
    #[doc = " When \\c printTiles is true, if this is also true, create as many tiles\nas needed to print the entire art board. When false, tile only the\nimageable area of a page. Ignored when \\c printTiles is false.\n\\c #AIDocumentSuite::SetDocumentSetup() does not set this value,\nbut available in UI through Setup tab of Print dialog."]
    pub tileFullPages: AIBoolean,
}
pub const AICropMarkStyle_kStandardCropStyle: AICropMarkStyle = 0;
pub const AICropMarkStyle_kJapaneseCropStyle: AICropMarkStyle = 1;
#[doc = " Styles of crop marks."]
pub type AICropMarkStyle = ::std::os::raw::c_uint;
pub const AILibraryType_kAIBrushLibraryType: AILibraryType = 0;
pub const AILibraryType_kAIStyleLibraryType: AILibraryType = 1;
pub const AILibraryType_kAISwatchLibraryType: AILibraryType = 2;
pub const AILibraryType_kAISymbolLibraryType: AILibraryType = 3;
#[doc = " Types of libraries."]
pub type AILibraryType = ai_uint8;
#[doc = " Not supported."]
pub type AIDocumentPlatformPrintRecord = *mut ::std::os::raw::c_void;
#[doc = " @deprecated\nInformation about how a document will print.\nNo longer used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentMiPrintRecord {
    pub version: ai_int32,
    pub recordSize: ai_int32,
    pub paperRect: AIRect,
    pub imageRect: AIRect,
}
#[doc = " @deprecated\nInformation about how a document will print.\nNo longer used."]
pub type AIDocumentMiPrintRecordPtr = *mut AIDocumentMiPrintRecord;
#[doc = " Version information for the document being processed.\nPassed with \\c #kAIDocumentWritePreprocessNotifier to allow\nconversion of data based on the AI Version of the document being saved."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentVersionInfo {
    pub aiVersion: AIVersion,
}
#[doc = " Opaque reference to a file format's parameters."]
pub type AIDocumentFileFormatParameters = *mut ::std::os::raw::c_void;
#[doc = " @ingroup Suites\nUse these functions to get and set information about the current document.\n\nSome functions are only applicable while reading a file format.\nSome are intended for use during a file format write, but can\nbe used at any time.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIDocumentSuite and \\c #kAIDocumentVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentSuite {
    #[doc = " Retrieves the file specification for the current document.\n@param file [out] A buffer in which to return the file specification."]
    pub GetDocumentFileSpecification:
        ::std::option::Option<unsafe extern "C" fn(file: *mut ai_FilePath) -> AIErr>,
    #[doc = " Retrieves the file specification  associated with the given document.\n@param document The document reference.\n@param file [out] A buffer in which to return the file specification."]
    pub GetDocumentFileSpecificationFromHandle: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, file: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Retrieves the coordinates of the lower left corner of the imageable\npage, specified relative to the ruler origin.\n@param origin [out] A buffer in which to return the origin point."]
    pub GetDocumentPageOrigin:
        ::std::option::Option<unsafe extern "C" fn(origin: *mut AIRealPoint) -> AIErr>,
    #[doc = " Sets the coordinates of the lower left corner of the imageable\npage. The origin for artwork\ncoordinates is not changed; affects only what is printed.\n@param origin The new imageable page origin, specified relative\nto the ruler origin."]
    pub SetDocumentPageOrigin:
        ::std::option::Option<unsafe extern "C" fn(origin: *mut AIRealPoint) -> AIErr>,
    #[doc = " Sets the ruler origin for the current document. Positive ruler values\ngo the right and above the origin. Negative values go the left and below the\norigin,\n@param origin The new ruler origin, specified relative to the lower left\nof the artboard page, which is always (0,0)."]
    pub SetDocumentRulerOrigin:
        ::std::option::Option<unsafe extern "C" fn(origin: *mut AIRealPoint) -> AIErr>,
    #[doc = " Retrieves the current unit of measurement, shown in the ruler and\ndisplayed in dialog boxes.\n@param units The new ruler unit, an \\c #AIDocumentRulerUnitValue."]
    pub GetDocumentRulerUnits:
        ::std::option::Option<unsafe extern "C" fn(units: *mut ai_int16) -> AIErr>,
    #[doc = " Sets the current unit of measurement, shown in the ruler and\ndisplayed in dialog boxes. Can be used only when reading\na document.\n@param units [out] A buffer in which to return the ruler unit,\nan \\c #AIDocumentRulerUnitValue."]
    pub SetDocumentRulerUnits:
        ::std::option::Option<unsafe extern "C" fn(units: ai_int16) -> AIErr>,
    #[doc = " Retrieves the style of crop marks that are created by the Create Crop Marks command\nand filter. This is not a document setting; it is an application preference.\nIn AI11 and later this no longer affects separations printing.\n@param cropStyle [out] A buffer in which to return the style."]
    pub GetDocumentCropStyle:
        ::std::option::Option<unsafe extern "C" fn(cropStyle: *mut AICropMarkStyle) -> AIErr>,
    #[doc = " Sets the style of crop marks that are created by the Create Crop Marks command\nand filter. This is not a document setting. It is an application preference.\nIn AI11 and later this no longer affects separations printing."]
    pub SetDocumentCropStyle:
        ::std::option::Option<unsafe extern "C" fn(cropStyle: AICropMarkStyle) -> AIErr>,
    #[doc = " Not implemented."]
    pub GetDocumentPrintRecord: ::std::option::Option<
        unsafe extern "C" fn(print: *mut AIDocumentPlatformPrintRecord) -> AIErr,
    >,
    #[doc = " Not implemented."]
    pub SetDocumentPrintRecord:
        ::std::option::Option<unsafe extern "C" fn(print: AIDocumentPlatformPrintRecord) -> AIErr>,
    #[doc = " Retrieves information about the current document that is set through the\ndocument Setup dialog.\n@param setup [out] A buffer in which to return the setup information."]
    pub GetDocumentSetup:
        ::std::option::Option<unsafe extern "C" fn(setup: *mut AIDocumentSetup) -> AIErr>,
    #[doc = " Sets the document setup information, as set through the document Setup dialog.\nCan be used only when reading a document.\n@param setup A pointer to a structure containing the new setup information."]
    pub SetDocumentSetup:
        ::std::option::Option<unsafe extern "C" fn(setup: *mut AIDocumentSetup) -> AIErr>,
    #[doc = " Reports whether the document has been edited since it was last saved.\nWhen it has, the user is prompted to save the document before closing it.\n@param modified [out] A buffer in which to return true if the document has\nbeen modified."]
    pub GetDocumentModified:
        ::std::option::Option<unsafe extern "C" fn(modified: *mut AIBoolean) -> AIErr>,
    #[doc = " Sets the modification state of the current document. When a document is marked\nas modified, the user is prompted to save before closing it.\n@param modified True to mark the document as modified, false to mark it\nas unmodified."]
    pub SetDocumentModified:
        ::std::option::Option<unsafe extern "C" fn(modified: AIBoolean) -> AIErr>,
    #[doc = " Retrieves the file format to be used when saving the current document.\nBy default, this is the format that opened the document\nor the latest native file format for a new document.\nIf the user changes the file format from the Save As dialog, the new format\nis assigned to the document.\n@param fileFormat [out] A buffer in which to return the file format.\n@see \\c #AIFileFormatSuite"]
    pub GetDocumentFileFormat:
        ::std::option::Option<unsafe extern "C" fn(fileFormat: *mut AIFileFormatHandle) -> AIErr>,
    #[doc = " Sets the file format to be used when saving the current document.\n@param fileFormat The file format.\n@see \\c #AIFileFormatSuite"]
    pub SetDocumentFileFormat:
        ::std::option::Option<unsafe extern "C" fn(fileFormat: AIFileFormatHandle) -> AIErr>,
    #[doc = " Retrieves the block of user parameters associated with the current document's\nassociated file format.\n@param parameters [out] A buffer in which to return the parameter block.\nThis is a \\c void* pointer. The actual format of the parameter block\nis determined by the file format.\n@see \\c #AIFileFormatSuite"]
    pub GetDocumentFileFormatParameters: ::std::option::Option<
        unsafe extern "C" fn(parameters: *mut AIDocumentFileFormatParameters) -> AIErr,
    >,
    #[doc = " Sets the block of user parameters associated with the current document's\nassociated file format.\n@param parameters [out] A buffer in which to return the parameter block.\nThis is a \\c void* pointer. The actual format of the parameter block\nis determined by the file format. Use the \\c #AIBlockSuite functions\nto allocate this memory, so that Illustrator can release it when\nit is no longer needed.\n@see \\c #AIFileFormatSuite"]
    pub SetDocumentFileFormatParameters: ::std::option::Option<
        unsafe extern "C" fn(parameters: AIDocumentFileFormatParameters) -> AIErr,
    >,
    #[doc = " Forces the current document to be redrawn. Illustrator automatically redraws\nthe document when a plug-in returns, so this function is not usually needed."]
    pub RedrawDocument: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves an opaque reference for the current document, to use with functions\nthat can operate on documents other than the current one.\n@param document [out] A buffer in which to return the document reference."]
    pub GetDocument:
        ::std::option::Option<unsafe extern "C" fn(document: *mut AIDocumentHandle) -> AIErr>,
    #[doc = " Writes the current document to a file without modifying the document\nor changing its modification status.\n@param file The file specification.\n@param fileFormatName The file format name.\n@param askForParms When true, show a dialog to query user for file-format parameters.\nIf no format parameters are available, the function queries the user even if this\nvalue is false.\n@see \\c #WriteDocumentWithOptions() and \\c #WriteDocumentAsLibrary()"]
    pub WriteDocument: ::std::option::Option<
        unsafe extern "C" fn(
            file: *const ai_FilePath,
            fileFormatName: *const ::std::os::raw::c_char,
            askForParms: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = "  Retrieves the print record for the current document.\n@param print [in, out] A print record with the \\c version and \\c recordSize\nmembers initialized, in which to return the print information."]
    pub GetDocumentMiPrintRecord:
        ::std::option::Option<unsafe extern "C" fn(print: AIDocumentMiPrintRecordPtr) -> AIErr>,
    #[doc = " Not implemented."]
    pub SetDocumentMiPrintRecord:
        ::std::option::Option<unsafe extern "C" fn(print: AIDocumentMiPrintRecordPtr) -> AIErr>,
    #[doc = " Retrieves the ruler origin for the current document. Positive ruler values\ngo the right and above the origin. Negative values go the left and below the\norigin.\n@param origin [out] A buffer in which to return the ruler origin,\nrelative to the lower left of the artboard page, which is always (0,0)."]
    pub GetDocumentRulerOrigin:
        ::std::option::Option<unsafe extern "C" fn(origin: *mut AIRealPoint) -> AIErr>,
    #[doc = " Updates linked objects in the current document, if needed.\n@param updatedSomething [out] Optional. A buffer in which to\nreturn true if any links were found that needed update."]
    pub UpdateLinks:
        ::std::option::Option<unsafe extern "C" fn(updatedSomething: *mut AIBoolean) -> AIErr>,
    #[doc = " Retrieves the limits of zooming as scale factors.\n@param min [out] A buffer in which to return the minimum zoom scale factor.\n@param max [out] A buffer in which to return the maximum zoom scale factor."]
    pub GetDocumentZoomLimit:
        ::std::option::Option<unsafe extern "C" fn(min: *mut AIReal, max: *mut AIReal) -> AIErr>,
    #[doc = " Retrieves the maximum valid bounds of any artboard, expressed relative to\nthe ruler origin of the current document, regardless of the current\nsize of the document's artboard.\n@param bounds [out] A buffer in which to return the rectangle,"]
    pub GetDocumentMaxArtboardBounds:
        ::std::option::Option<unsafe extern "C" fn(bounds: *mut AIRealRect) -> AIErr>,
    #[doc = " Reports whether a document exists; that is, is an open document or a clipboard document.\n@param document The document reference.\n@param exists [out] A buffer in which to return true if the document\nis open or in the clipboard."]
    pub DocumentExists: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, exists: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the recorded dictionary associated with the current document.\nChanges in this dictionary and its contents are recorded in the undo history.\n\nDictionaries are reference counted. You must call \\c #AIDictionarySuite::Release()\nwhen you no longer need the reference.\n@param dictionary [out] A buffer in which to return a pointer to\nthe dictionary reference.\n@see \\c #GetNonRecordedDictionary()"]
    pub GetDictionary:
        ::std::option::Option<unsafe extern "C" fn(dictionary: *mut *mut _AIDictionary) -> AIErr>,
    #[doc = " Retrieves the document color model.\n@param colorModel [out] A buffer in which to return the color model,\nan \\c #AIDocumentColorModelValue."]
    pub GetDocumentColorModel:
        ::std::option::Option<unsafe extern "C" fn(colorModel: *mut ai_int16) -> AIErr>,
    #[doc = " Sets the intended color model for documents upon load.\nUse when reading a file. This function does not convert artwork in\nthe current document to the new model. After Illustrator reads\na file, it processes artwork in the document to ensure it matches\nthe model.\n@param colorModel The color model, an \\c #AIDocumentColorModelValue."]
    pub SetDocumentColorModel:
        ::std::option::Option<unsafe extern "C" fn(colorModel: ai_int16) -> AIErr>,
    #[doc = " Retrieves the color calibration profiles for the current document.\n@param rgbProfile [out] A buffer in which to return the RGB profile or \\c NULL.\n@param cmykProfile [out] A buffer in which to return the CMYK profile or \\c NULL.\n@param grayProfile [out] A buffer in which to return the grayscale profile or \\c NULL."]
    pub GetDocumentProfiles: ::std::option::Option<
        unsafe extern "C" fn(
            rgbProfile: *mut AIColorProfile,
            cmykProfile: *mut AIColorProfile,
            grayProfile: *mut AIColorProfile,
        ) -> AIErr,
    >,
    #[doc = " Sets the color calibration profiles for the current document.\n@param rgbProfile The RGB profile. Can be \\c NULL.\n@param cmykProfile The CMYK profile. Can be \\c NULL.\n@param grayProfile The grayscale profile. Can be \\c NULL."]
    pub SetDocumentProfiles: ::std::option::Option<
        unsafe extern "C" fn(
            rgbProfile: AIColorProfile,
            cmykProfile: AIColorProfile,
            grayProfile: AIColorProfile,
        ) -> AIErr,
    >,
    #[doc = " Copies the currently selected objects to the clipboard. This is the same as\nthe Copy menu command.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub Copy: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Cuts the currently selected objects to the clipboard. This is the same as\nthe Cut menu command.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub Cut: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Pastes the contents of the clipboard into the document. This is the same as\nthe Paste menu command.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub Paste: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Updates cached artwork properties. For example, the selection state\nof a group is cached, and is determined from the states of its children.\nYou do not typically need to call this function. Illustrator recomputes\ncached properties as needed."]
    pub SyncDocument: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Unimplemented. Always returns \\c #kDocTargetExplicit"]
    pub GetDocumentTargeting: ::std::option::Option<
        unsafe extern "C" fn(
            paintTarget: *mut ::std::os::raw::c_short,
            transparencyTarget: *mut ::std::os::raw::c_short,
            effectsTarget: *mut ::std::os::raw::c_short,
        ) -> AIErr,
    >,
    #[doc = " Unimplemented. A no-op."]
    pub SetDocumentTargeting: ::std::option::Option<
        unsafe extern "C" fn(
            paintTarget: ::std::os::raw::c_short,
            transparencyTarget: ::std::os::raw::c_short,
            effectsTarget: ::std::os::raw::c_short,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the non-recorded dictionary associated with the current document.\nChanges to this dictionary and its contents are not recorded in the undo\nhistory.\n\nDictionaries are reference counted. You must call \\c #AIDictionarySuite::Release()\nwhen you no longer need the reference.\n@param dictionary [out] A buffer in which to return a pointer to\nthe dictionary reference.\n@see \\c #GetNonRecordedDictionary()"]
    pub GetNonRecordedDictionary:
        ::std::option::Option<unsafe extern "C" fn(dictionary: *mut *mut _AIDictionary) -> AIErr>,
    #[doc = " Retrieves the non-recorded dictionary associated with the document passed as input.\nChanges to this dictionary and its contents are not recorded in the undo\nhistory.\n\nDictionaries are reference counted. You must call \\c #AIDictionarySuite::Release()\nwhen you no longer need the reference.\n@param document The document reference whose non-recorded dictionary is being asked for.\n@param dictionary [out] A buffer in which to return a pointer to\nthe dictionary reference.\n@see \\c #GetNonRecordedDictionary()"]
    pub GetNonRecordedDictionaryForDocument: ::std::option::Option<
        unsafe extern "C" fn(
            document: AIDocumentHandle,
            dictionary: *mut *mut _AIDictionary,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the version of the Illustrator file format in which\nthe current document was last saved. (Note that this function returns\na constant value, not an error code.)\n@return The version number, an \\c #AIVersion value, or 0 if the\nversion is unknown or the file is not an AI file."]
    pub GetAIVersion: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    #[doc = " Reports whether rendering the current document according to its current\nview settings requires any non-opaque drawing operations.\n@param hasTransparency [out] A buffer in which to return true if the\ndocument has transparency.\n@param detectOverprint When true, drawing an overprinted object\nis considered a non-opaque operation."]
    pub DocumentHasTransparency: ::std::option::Option<
        unsafe extern "C" fn(hasTransparency: *mut AIBoolean, detectOverprint: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether rendering the current document according to its current\nview settings requires painting any spot colors.\n@param hasSpotColorArt [out] A buffer in which to return true if the\ndocument has art that uses spot colors."]
    pub DocumentHasSpotColorArt:
        ::std::option::Option<unsafe extern "C" fn(hasSpotColorArt: *mut AIBoolean) -> AIErr>,
    #[doc = " @deprecated\nRetrieves asset management information. Pass \\c null for any parameter whose\nstate you do not want to retrieve.\n@param managed [out] A buffer in which to return true if the file has an associated server URL.\n@param pNAlternates [out] A buffer in which to return the number\nof alternates for a document that is part of Version Cue project,\nor 0 if it is not part of a Version Cue project.\n@param checkedOut [out] A buffer in which to return true if the document is being\nmanaged by a version-control system and is currently checked out (that is,\neditable and locked by the current user).\n@param URL [out] A buffer in which to return the server URL of a managed file.\n@param canEdit Deprecated, pass \\c null.\n@param fileType [out] A buffer in which to return the name of the plug-in\nused to open the current document, or to perform the last Save As operation."]
    pub GetDocumentAssetMgmtInfo: ::std::option::Option<
        unsafe extern "C" fn(
            managed: *mut AIBoolean,
            pNAlternates: *mut ai_int32,
            checkedOut: *mut AIBoolean,
            URL: *mut *const ::std::os::raw::c_char,
            canEdit: *mut AIBoolean,
            fileType: *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " @deprecated\nSets asset management information. Pass \\c null for any parameter whose\nstate you do not want to set.\n@param managed When true, the file has an associated server URL.\n@param checkedOut Deprecated, pass \\c null.\n@param URL The server URL of a managed file.\n@param canEdit Deprecated, pass \\c null."]
    pub SetDocumentAssetMgmtInfo: ::std::option::Option<
        unsafe extern "C" fn(
            managed: *mut AIBoolean,
            checkedOut: *mut AIBoolean,
            URL: *const ::std::os::raw::c_char,
            canEdit: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the URL associated with a document.\n@param document The document reference.\n@param URL [out] A buffer in which to return the URL."]
    pub GetDocumentURL: ::std::option::Option<
        unsafe extern "C" fn(
            document: AIDocumentHandle,
            URL: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the XMP metadata for the current the document.\n@param xap [out] A buffer in which to return the XML packet\n(in UTF-8 Unicode format)."]
    pub GetDocumentXAP: ::std::option::Option<
        unsafe extern "C" fn(xap: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Sets the XMP metadata of the current document. Replaces any existing XMP metadata\n@param xap The new XML packet (must be in UTF-8 Unicode format). This is\ncopied into the document, and can be deleted after the call. Pass \\c null\nto clear metadata."]
    pub SetDocumentXAP:
        ::std::option::Option<unsafe extern "C" fn(xap: *const ::std::os::raw::c_char) -> AIErr>,
    #[doc = " Halts any text reflow for all text objects in the current document.\nMatch this call with a call to \\c #ResumeTextReflow().\n\nIf you manipulate \\c #kTextFrameArt objects and do not need text reflow\nafter each access, this speeds up the manipulation process.\nSome functions that causes text reflow are:  <br>\n\\c #ATE::ITextRange::InsertAfter(), \\c #ATE::ITextRange::InsertBefore()\t<br>\n\\c #ATE::ITextRange::SetLocalCharFeatures(), \\c #ATE::ITextRange::SetLocalParaFeatures() <br>\n\\c #ATE::ITextRange::Remove()\n\n@return The error \\c #kNoDocumentErr if no document is open."]
    pub SuspendTextReflow: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "  Resumes text reflow. Reflows any text objects that modified after the\ncall to \\c #SuspendTextReflow().\n@return The error \\c #kNoDocumentErr if no document is open."]
    pub ResumeTextReflow: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves the text selection object for the current document.\nYou must release the object when it is no longer needed.\nIt is recommended that you use \\c ITextRanges to wrap this object,\nwhich takes care of memory management. For example:\n@code\nATE::TextRangesRef selectionRef = NULL;\nsAIDocument->GetTextSelection(&selectionRef);\n{\nITextRanges mySelection(selectionRef);\n...\n}\n@endcode\nAt this point \\c selectionRef is released.The reference is invalid, and you must\ncall \\c #GetTextSelection() again to get a valid object.\n\nThe text selection can describe multiple discontiguous ranges of text across multiple art objects.\n\\li If the document is in text editing mode, the result is a range representing the caret\nor the user selection.\n\\li If the document is not in text editing mode, there are multiple ranges\nfor the selected text frame objects.\n\n@param pTextSelection [out] A buffer in which to return the text selection object."]
    pub GetTextSelection: ::std::option::Option<
        unsafe extern "C" fn(pTextSelection: *mut *mut ATE__TextRanges) -> AIErr,
    >,
    #[doc = " Reports whether the current document is in text editing mode.\n@param focus [out] A buffer in which to return true if the document has the text focus."]
    pub HasTextFocus: ::std::option::Option<unsafe extern "C" fn(focus: *mut AIBoolean) -> AIErr>,
    #[doc = " Reports whether the current document is in text editing mode and the caret\nis blinking (as opposed to a range of text being selected).\n@param caret [out] A buffer in which to return true if the document has\nthe text focus and the caret is blinking."]
    pub HasTextCaret: ::std::option::Option<unsafe extern "C" fn(caret: *mut AIBoolean) -> AIErr>,
    #[doc = " Retrieves the current story that is in editing mode.\nYou must release the object when it is no longer needed.\nIt is recommended that you use \\c IStory to wrap this object,\nwhich takes care of memory management.\n@param pStory [out] A buffer in which to return the story object,\nor \\c NULL if the current document is not in text editing mode."]
    pub GetTextFocus:
        ::std::option::Option<unsafe extern "C" fn(pStory: *mut *mut ATE__Story) -> AIErr>,
    #[doc = " Sets a story to be in editing mode. The insertion point is positioned at the\nstart of the story.\n@param story The story object."]
    pub SetTextFocus: ::std::option::Option<unsafe extern "C" fn(story: *mut ATE__Story) -> AIErr>,
    #[doc = " Exits text editing mode."]
    pub LoseTextFocus: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves the text resource object for the current document.\nYou must release the object when it is no longer needed.\nIt is recommended that you use \\c IDocumentTextResource to wrap this object,\nwhich takes care of memory management.\n\nThe document text resources object contains various document-wide\nutilities and objects such as the character and paragraph styles.\n\n@param pDocResources [out] A buffer in which to return the text resources object.\n@see \\c ATE suites and \\c IText.h."]
    pub GetDocumentTextResources: ::std::option::Option<
        unsafe extern "C" fn(pDocResources: *mut *mut ATE__DocumentTextResources) -> AIErr,
    >,
    #[doc = " @deprecated Does nothing in AI13 (CS3)\n\nAttaches a thumbnail of the current document to the resources of the specified file. This\nis the thumbnail displayed in the Finder in Mac OS.\n@param file The file."]
    pub WriteDocumentMacInformationResource:
        ::std::option::Option<unsafe extern "C" fn(file: *const ai_FilePath) -> AIErr>,
    #[doc = " Writes the current document to a file with specified write options,\nwithout modifying the document or changing its modification status.\n@param file The file specification.\n@param fileFormatName The file format name.\n@param fileFormatOptions The write options, a logical OR of \\c #AIFileFormatOptions values.\n@param additionalOptionsDict Additional file format specific options to customize import/export.\n@param askForParms When true, show a dialog to query user for file-format parameters.\nIf no format parameters are available, the function queries the user\neven if this value is false.\n@see \\c #WriteDocument() and \\c #WriteDocumentAsLibrary()"]
    pub WriteDocumentWithOptions: ::std::option::Option<
        unsafe extern "C" fn(
            file: *const ai_FilePath,
            fileFormatName: *const ::std::os::raw::c_char,
            fileFormatOptions: ai_int32,
            additionalOptionsDict: AIDictionaryRef,
            askForParms: AIBoolean,
            mabInfo: *mut AISaveMultipleArtboardsParameters,
        ) -> AIErr,
    >,
    #[doc = " Writes the current document to a file as a library of specified type without modifying the document\nor changing its modification status.\n@param file The file specification.\n@param libraryType The library type. See \\c #AILibraryType for possible values.\n@see \\c #WriteDocument() and \\c #WriteDocumentWithOptions()"]
    pub WriteDocumentAsLibrary: ::std::option::Option<
        unsafe extern "C" fn(file: *const ai_FilePath, libraryType: AILibraryType) -> AIErr,
    >,
    #[doc = " Reports whether rendering the current document according to its current\nview settings requires painting any overprinted objects.\n@param hasOverprint [out] A buffer in which to return true if the\ndocument has overprint."]
    pub DocumentHasOverprint:
        ::std::option::Option<unsafe extern "C" fn(hasOverprint: *mut AIBoolean) -> AIErr>,
    #[doc = " @deprecated\nReports whether a document contains any managed links.\nA managed link is a URL to an Adobe Workgroup Server where\none can share and keep versions of the linked document.\n@param document The document reference.\n@param hasManagedLinks [out] A buffer in which to return true if the document\nhas managed links.\n@see \\c #GetDocumentAssetMgmtInfo(), \\c #GetDocumentURL()\n\n@note In AI 10, only a managed document could have managed links. In later versions,\nnon-managed documents can also have managed links."]
    pub DocumentHasManagedLinks: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, hasManagedLinks: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the spot color mode of a document, which controls the\nappearance definitions of new spot colors that are added to the document.\n@param document The document reference, or \\c NULL for the current document.\n@param mode [out] A buffer in which to return the mode, an \\c #AISpotColorMode value.\n@return The error \\c #kNoDocumentErr if \\c document is \\c NULL and there is no\ncurrent document."]
    pub GetDocumentSpotColorMode: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, mode: *mut AISpotColorMode) -> AIErr,
    >,
    #[doc = " Sets the spot color mode of a document, which controls the appearance\ndefinitions of new spot colors that are added to the document.\n@param document The document reference, or \\c NULL for the current document.\n@param mode The new mode, an \\c #AISpotColorMode value.\n@param convert When true, converts existing spot color definitions to the new mode.\n@param converted [out] Optional. A buffer in which to return true if any colors\nwere actually modified.\n@return The error \\c #kNoDocumentErr if \\c document is \\c NULL and there is no\ncurrent document."]
    pub SetDocumentSpotColorMode: ::std::option::Option<
        unsafe extern "C" fn(
            document: AIDocumentHandle,
            mode: AISpotColorMode,
            convert: AIBoolean,
            converted: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Undoes the most recent undoable transaction. This is the same as the Undo menu command.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub Undo: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Redoes the most recent redoable transaction. This is the same as the Redo menu command.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub Redo: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Reports whether the current document contains any DeviceN or overprinting rasters.\n@param hasDeviceNRasters [out] A buffer in which to return true if the\nthe document has DeviceN rasters.\n@param hasOverprint [out] A buffer in which to return true if the\nthe document has overprinting rasters."]
    pub DocumentRasterAttributes: ::std::option::Option<
        unsafe extern "C" fn(
            hasDeviceNRasters: *mut AIBoolean,
            hasOverprint: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the document startup profile.\n@param document The document reference, or \\c NULL for the current document.\n@param startupProfile [out] A buffer in which to return the document startup profile.\n@return The error \\c #kNoDocumentErr if \\c document is \\c NULL and there is no current document."]
    pub GetDocumentStartupProfile: ::std::option::Option<
        unsafe extern "C" fn(
            document: AIDocumentHandle,
            startupProfile: *mut AIDocumentStartupProfile,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the document's bleed values.\n@param bleedOffset [out] A buffer in which to return the bleed values."]
    pub GetDocumentBleeds:
        ::std::option::Option<unsafe extern "C" fn(bleedOffset: *mut AIRealRect) -> AIErr>,
    #[doc = " Sets the document's bleed values.\n@param bleedOffset A rectangle containing the new bleed values."]
    pub SetDocumentBleeds:
        ::std::option::Option<unsafe extern "C" fn(bleedOffset: *const AIRealRect) -> AIErr>,
    #[doc = " Turns Pixel Perfect mode on or off for the document.\n@param isPixelPerfect True to turn Pixel Perfect mode on, false to turn it off."]
    pub SetDocumentPixelPerfectStatus:
        ::std::option::Option<unsafe extern "C" fn(isPixelPerfect: AIBoolean) -> AIErr>,
    #[doc = " Reports whether the document is currently in Pixel Perfect mode.\n@return True if Pixel Perfect mode is on, false otherwise."]
    pub GetDocumentPixelPerfectStatus: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Deletes the current Selection. This is the same as pressing delete key.\n@note Use only when this plug-in is issuing a command and is entirely\nin control of that command. Do not call when responding to messages\ninvoked by other commands, such as save, close, update, and so on."]
    pub DeleteSelection: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Controls whether UIDs are automatically assigned to art objects of a given type on\ncreation, in the current document.\n@param autoAssignUIDOnArtCreation True to turn behavior on, false to turn it off.\n@param artType The art type.\n@see \\c #AIUIDUtilsSuite::GetArtUID()"]
    pub SetAutoAssignUIDOnArtCreation: ::std::option::Option<
        unsafe extern "C" fn(artType: ai_int16, autoAssignUIDOnArtCreation: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether UIDs are being automatically assigned on creation to art objects of a given type.\n@param artType The art type.\n@param outAutoAssignUIDOnArtCreation [out] A buffer in which to return true if auto-assignment is on\nfor this art type, false otherwise.\n@see \\c #AIUIDUtilsSuite::GetArtUID()"]
    pub GetAutoAssignUIDOnArtCreation: ::std::option::Option<
        unsafe extern "C" fn(
            artType: ai_int16,
            outAutoAssignUIDOnArtCreation: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " returns scale factor applied on the document\nIt considers os scale factor as well as app scale factor\nreturns always integral scale factor."]
    pub GetEffectiveScaleFactor: ::std::option::Option<unsafe extern "C" fn() -> AIReal>,
    #[doc = " With each document there is a scale factor associated with it,\n So for a document with document scale factor X, each object's dimension have to multiplied by X to get the\n correct dimensions of the object in UI\n For example, if document scale factor is X, then  a 10x10 rectangle will actually will be displayed as\n (10*X)x(10*X) rectangle in UI"]
    pub GetDocumentScale:
        ::std::option::Option<unsafe extern "C" fn(docScale: *mut AIReal) -> AIErr>,
    #[doc = "Reports whether the current document is a Cloud AI document.\n(Note that this function returns a constant value, not an error code.)\n@return true if the current document is a Cloud AI document, else false."]
    pub IsCloudAIDocument: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Retrieves the file name associated with the current document.\n@param fileName [out]: A buffer in which to return the file name."]
    pub GetDocumentFileName:
        ::std::option::Option<unsafe extern "C" fn(fileName: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Retrieves the file name associated with the current document without extension\n@param fileName [out]: A buffer in which to return the file name without extension"]
    pub GetDocumentFileNameNoExt:
        ::std::option::Option<unsafe extern "C" fn(fileName: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Retrieves the file name  associated with the given document.\n@param document The document reference.\n@param fileName [out] A buffer in which to return the file name."]
    pub GetDocumentFileNameFromHandle: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, fileName: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the file name  associated with the given document without extension\n@param document The document reference.\n@param fileName [out] A buffer in which to return the file name without extension"]
    pub GetDocumentFileNameNoExtFromHandle: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, fileName: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the file path that was used for last export operation for current file\n@param file [in]  option to know whether export was triggered from Export As, Export for screens or Save for Web.\n@param file [out] A buffer in which to return the file path."]
    pub GetLastExportedFilePath: ::std::option::Option<
        unsafe extern "C" fn(option: AIExportTriggeredFrom, file: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Set file path that was used for last export operation for current file\n@param file [in]  option to know whether export was triggered from Export As, Export for screens or Save for Web.\n@param file [in]  file path used for last export."]
    pub SetLastExportedFilePath: ::std::option::Option<
        unsafe extern "C" fn(option: AIExportTriggeredFrom, file: ai_FilePath) -> AIErr,
    >,
}
#[doc = " Use document (page) coordinate system."]
pub const AICoordinateSystem_kAIDocumentCoordinateSystem: AICoordinateSystem = 0;
#[doc = " Use artboard coordinate system."]
pub const AICoordinateSystem_kAIArtboardCoordinateSystem: AICoordinateSystem = 1;
#[doc = " Use the coordinate system in use for the ruler in the current view."]
pub const AICoordinateSystem_kAICurrentCoordinateSystem: AICoordinateSystem = 2;
#[doc = " Coordinate system used by a particular Illustrator API function."]
pub type AICoordinateSystem = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite provides functions for converting between different coordinate\nsystems used at different levels of Illustrator.\n\nThe geometry of an object is described by coordinates that are relative to\na pair of imaginary axes imposed on the artboard. Illustrator uses two ways of\nplacing these axes; one for storing coordinate information internally, and\nanother for passing coordinate information across the SDK functions.\n\n\\li In the internal coordinate system, the origin is the top left corner of the\nartboard--that is, of the white area that can be seen when zoomed out as far as\npossible. The X axis is horizontal, with the values increasing to the right.\nThe Y axis is vertical, with values increasing downward. Values in this\nsystem are called \\e hard, or \\e artboard coordinates.\n\n\\li In the public coordinate system, the origin is the \\e ruler origin--that is,\nthe point that corresponds to the 0 marks on the ruler when it is visible.\nBy default, it is the bottom left corner of the page, but it can be changed by the\nuser. The X axis is horizontal, with the values increasing to the right.\nThe Y axis is vertical, with values increasing upward. Values in this system\nare called \\e soft, or \\e page coordinates.\n\nMost functions in the SDK use the public system of page coordinates, but\nsome use the internal artboard coordinates. This suite provides functions\nfor mapping between the coordinate systems.\tFor example, if you pass\nthe origin point, [0,0], to \\c #AIRealPointHarden(), the function returns the\nvector from the artboard origin (the top left of the canvas) to the page origin\n(the bottom left of the visible page).\n\n@note These matrix conversion functions do not convert all\ncomponents of translation matrices. To do this, you must understand\nthe details of the two coordinate systems involved and use linear algebra.\nYou must analyzed each case. For example, the matrix stored\nin an \\c #AIPatternStyle maps coordinates from pattern space to internal\nartboard space, whereas the matrix for an image maps from image space to\npublic page space.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIHardSoftSuite and \\c #kAIHardSoftVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIHardSoftSuite {
    #[doc = " Converts a point in public page coordinates to a point in internal\nartboard coordinates.\n@param srcpoint A pointer to the point in public page coordinates.\n@param dstpoint\t[out] A buffer in which to return the point in internal\nartboard coordinates."]
    pub AIRealPointHarden: ::std::option::Option<
        unsafe extern "C" fn(srcpoint: *mut AIRealPoint, dstpoint: *mut AIRealPoint) -> AIErr,
    >,
    #[doc = " Converts a point in internal artboard coordinates to a point in public\npage coordinates.\n@param srcpoint A pointer to the point in internal artboard coordinates.\n@param dstpoint\t[out] A buffer in which to return the point in public\npage coordinates."]
    pub AIRealPointSoften: ::std::option::Option<
        unsafe extern "C" fn(srcpoint: *mut AIRealPoint, dstpoint: *mut AIRealPoint) -> AIErr,
    >,
    #[doc = " Applies \\c #AIRealPointHarden() to the translation\ncomponent of a matrix. This can be used to re-harden a returned\nmatrix that has been incorrectly softened.\n@param matrix [in, out] The translation matrix, which is modified in place."]
    pub AIRealMatrixHarden:
        ::std::option::Option<unsafe extern "C" fn(matrix: *mut AIRealMatrix) -> AIErr>,
    #[doc = " Applies \\c #AIRealPointSoften() to the translation\ncomponent of a matrix. This can be used to pre-soften a matrix being passed\ninto a function that will apply incorrect hardening.\n@param matrix [in, out] The translation matrix, which is\nmodified in place."]
    pub AIRealMatrixSoften:
        ::std::option::Option<unsafe extern "C" fn(matrix: *mut AIRealMatrix) -> AIErr>,
    #[doc = " Applies \\c #AIRealPointHarden() to the translation component\nof a matrix, then negates the \\c b and \\c c components.\n@param matrix [in, out] The translation matrix, which is\nmodified in place."]
    pub AIRealMatrixRealHard:
        ::std::option::Option<unsafe extern "C" fn(matrix: *mut AIRealMatrix) -> AIErr>,
    #[doc = " Applies \\c #AIRealPointSoften() to the translation component\nof a matrix, then negates the \\c b and \\c c components.\n@param matrix [in, out] The translation matrix, which is\nmodified in place."]
    pub AIRealMatrixRealSoft:
        ::std::option::Option<unsafe extern "C" fn(matrix: *mut AIRealMatrix) -> AIErr>,
    #[doc = " Retrieves the coordinate system used by API functions in the current context.\nValid only for the current message call received by a plug-in. The value is reset to\n\\c #kAIDocumentCoordinateSystem each time the app context is popped;\nsee \\c #AIAppContextSuite::PushAppContext() and \\c #AIAppContextSuite::PopAppContext().\n\n@param coordinateSystem [out] A buffer in which to return the\ncurrent coordinate system constant, an \\c #AICoordinateSystem value.\n\n@note It is recommended that you use \\c #ai::AutoCoordinateSystem,\nrather than explicitly calling these get and set functions."]
    pub GetCoordinateSystem:
        ::std::option::Option<unsafe extern "C" fn(coordinateSystem: *mut ai_int32) -> AIErr>,
    #[doc = " Changes the coordinate system used by API functions in the current context.\nMust be set for every message a plug-in receives. The value is reset to\n\\c #kAIDocumentCoordinateSystem each time the app context is popped;\nsee \\c #AIAppContextSuite::PushAppContext() and \\c #AIAppContextSuite::PopAppContext().\n\n@param coordinateSystem [in] The new coordinate system constant, an \\c #AICoordinateSystem value.\n\n\n@note It is recommended that you use \\c #ai::AutoCoordinateSystem,\nrather than explicitly calling these get and set functions.\n"]
    pub SetCoordinateSystem:
        ::std::option::Option<unsafe extern "C" fn(coordinateSystem: ai_int32) -> AIErr>,
    #[doc = "Converts the coordinate system of a single point from one system to another.\n@param point[in,out] The current coordinate of the point, modified in place.\n@param src [in] The source coordinate system, an \\c #AICoordinateSystem value.\n@param dest [in] The destination coordinate system, an \\c #AICoordinateSystem value.\n@param convertForDisplay [in] True to convert Y values if the artboard's ruler origin is set to bottom left (which was the default in CS4).\nIn CS5, the default ruler origin is top left, and Y values increase downward. Set to true for values to be used in the UI."]
    pub ConvertCoordinates: ::std::option::Option<
        unsafe extern "C" fn(
            point: *mut AIRealPoint,
            src: ai_int32,
            dest: ai_int32,
            convertForDisplay: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Converts an AIRealRect to a AIRealRect in internal artboard coordinates space.\n@param inRect  Input rect in public page coordinates.\n@param outRect [out] A rect which shall have the values in  internal\nartboard coordinates."]
    pub AIRealRectHarden: ::std::option::Option<
        unsafe extern "C" fn(inRect: *const AIRealRect, outRect: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Converts an AIRealRect in internal artboard coordinates to a AIRealRect in public\npage coordinates.\n@param inRect  Input rect in internal artboard coordinates.\n@param outRect [out] A rect which shall have the values in public page coordinates"]
    pub AIRealRectSoften: ::std::option::Option<
        unsafe extern "C" fn(inRect: *const AIRealRect, outRect: *mut AIRealRect) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite provides functions to convert legacy text objects (from earlier\nversions of Illustrator) to native text objects.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAILegacyTextConversionSuite and \\c #kAILegacyTextConversionVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILegacyTextConversionSuite {
    #[doc = " Converts a legacy text object to native Illustrator text art objects.\n@param art The legacy text object. This function does not dispose of the object.\n@param paintOrder The position for the new artwork in the\npaint order, relative to the \\c prep object.\nSee \\c AITypes::AIPaintOrder.\n@param prep\tThe prepositional art object.\n@param ret [out] A buffer in which to return a group art object containing art objects\nof type \\c #kTextFrameArt."]
    pub ConvertToNative: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            ret: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Traverses the artwork tree of the current document and converts every\nart object of type \\c #kLegacyTextArt to an object of type \\c #kTextFrameArt.\n@param foundAnyLegacy [out] A buffer in which to return true if any\nlegacy text objects were found the document. May be \\c NULL."]
    pub ConvertAllToNative:
        ::std::option::Option<unsafe extern "C" fn(foundAnyLegacy: *mut AIBoolean) -> AIErr>,
    #[doc = " Reports whether a legacy art object is a copy--that is, the result\nof executing the \"Copy text object\" command, which converts to native art,\nand retains the legacy art behind it, with 40% transparency.\n@param LegacyArt The legacy art object.\n@param aCopy  [out] A buffer in which to return true if\tthe art is a copy."]
    pub IsACopy: ::std::option::Option<
        unsafe extern "C" fn(LegacyArt: AIArtHandle, aCopy: *mut AIBoolean) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LayerList {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a layer list."]
pub type AILayerList = *mut LayerList;
#[doc = " The message data for layer list messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILayerListMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The layer list that is pushed, popped, or deleted."]
    pub list: AILayerList,
    #[doc = " Data passed from \\c #AILayerListSuite::Push() for the\n\\c #kSelectorAIPushLayerList selector."]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " Controls how the contents of a layer list are rendered.\nA logical OR of an \\c #AILayerListModeRenderingOptions value\nand an \\c #AILayerListModePreviewOptions value.\nPredefined combinations are defined by \\c #AILayerListModeValues."]
pub type AILayerListMode = ai_int32;
#[doc = " Mask value to isolate the rendering option bits from the \\c #AILayerListMode."]
pub const AILayerListModeRenderingOptions_kAILayerListRenderMask: AILayerListModeRenderingOptions =
    255;
#[doc = " Render only the selection highlighting on the layer list."]
pub const AILayerListModeRenderingOptions_kAILayerListRenderSelection:
    AILayerListModeRenderingOptions = 1;
#[doc = " Render both the selection highlighting and the previews of the objects\non the layer list."]
pub const AILayerListModeRenderingOptions_kAILayerListRenderPreview:
    AILayerListModeRenderingOptions = 2;
#[doc = " What is rendered when a layer list is drawn.\n@see \\c #AILayerListMode <br> \\c #AILayerListModeValues"]
pub type AILayerListModeRenderingOptions = ::std::os::raw::c_uint;
#[doc = " Mask value to isolate the preview option bits from the \\c #AILayerListMode."]
pub const AILayerListModePreviewOptions_kAILayerListPreviewMask: AILayerListModePreviewOptions =
    3840;
#[doc = " Draw a full color preview."]
pub const AILayerListModePreviewOptions_kAILayerListPreviewColor: AILayerListModePreviewOptions = 0;
#[doc = " Draw a grayscale preview."]
pub const AILayerListModePreviewOptions_kAILayerListPreviewGray: AILayerListModePreviewOptions =
    256;
#[doc = " How previews of objects on a layer list are drawn,\nwhen \\c #AILayerListModeRenderingOptions::kAILayerListRenderPreview is set.\n@see \\c #AILayerListMode <br> \\c #AILayerListModeValues"]
pub type AILayerListModePreviewOptions = ::std::os::raw::c_uint;
#[doc = " Draws neither selection highlighting nor the preview\nof objects."]
pub const AILayerListModeValues_kAILayerListInvisibleMode: AILayerListModeValues = 0;
#[doc = " Draws only the selection highlighting of selected\nobjects in the layer list."]
pub const AILayerListModeValues_kAILayerListSelectionMode: AILayerListModeValues = 1;
#[doc = " Draws both selection highlighting and preview of the\nobjects."]
pub const AILayerListModeValues_kAILayerListPreviewMode: AILayerListModeValues = 3;
#[doc = " Draws both the selection highlighting and a grayscale\npreview of the objects."]
pub const AILayerListModeValues_kAILayerListGrayscaleMode: AILayerListModeValues = 259;
#[doc = " Pre-defined combinations of \\c #AILayerListModeRenderingOptions and\n\\c #AILayerListModePreviewOptions.\n@see \\c #AILayerListMode"]
pub type AILayerListModeValues = ::std::os::raw::c_uint;
#[doc = " Controls the types of editing operations allowed\nfor a layer list, one of the \\c #AILayerListEditabilityModeValues."]
pub type AILayerListEditabilityMode = ai_int32;
#[doc = " Allows all types of edits. Set by default when a new layer list is pushed."]
pub const AILayerListEditabilityModeValues_kAIRegularEditabilityMode:
    AILayerListEditabilityModeValues = 0;
#[doc = " Forces the Layers palette to disable the new layer and new\nsublayer functionality. Transparency mask layer lists use this mode."]
pub const AILayerListEditabilityModeValues_kAINoNewLayersMode: AILayerListEditabilityModeValues = 1;
#[doc = " Layer list editability modes."]
pub type AILayerListEditabilityModeValues = ::std::os::raw::c_uint;
#[doc = "\t@ingroup Suites\nThe artwork in an Illustrator document is contained within layers. A list\nof layers, the \\e document \\e layer \\e list, is saved when a document\nis saved. It is possible to create new layer lists, which are maintained in a stack.\nThe bottommost list on the stack is the document layer list. The topmost list,\ncalled the \\e current layer list, contains artwork that the user is\ncurrently editing.\n\nEditing operations do not normally affect objects in layer lists below\nthe current list.Most functions operate only on layers in the current layer list.\nFor example, the \\c #AILayerSuite allows you to access the layers in a list sequentially, but\nthe functions operate only on the current list. Similarly the \\c #AIMatchingArtSuite\nfunctions operate only on the current layer list.\n\n\\li Each layer list has a \\e display mode, which affects how the contents of the\nlayer list are drawn, and an \\e editability mode, which affects the\nediting operations allowed on the list.\n\n\\li Each layer list is given a \\e tag when it is pushed onto the stack, which\nidentifies the purpose of the list, either \\c #kAIDocumentLayerList\nor \\c #kAITransparencyMaskLayerList.\n\nThere is one notifier associated with the layer lists,\n\\c #kAILayerListChangedNotifier.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAILayerListSuite and \\c #kAILayerListVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILayerListSuite {
    #[doc = " Creates a new layer list and pushes it onto the stack, making it\ncurrent. The plug-in receives the \\c #kSelectorAIPushLayerList\nmessage before the call returns, allowing it to initialize\nthe list.\n@param self This plug-in\n@param tag The type of list, one of \\c #kAIDocumentLayerList\nor \\c #kAITransparencyMaskLayerList.\n@param data A pointer to developer-defined data to be passed\nto \\c #kSelectorAIPushLayerList in \\c #AILayerListMessage::data.\nParameter may be \\c NULL.\n@param mode The display and editability mode of the new layer list.\n@param list [out] A buffer in which to return the new layer list.\nThis memory is not freed until it is no longer needed for undo/redo.\nof push or pop operations. The plug-in must preserve its private data for\nthe list until it receives the \\c #kSelectorAIDeleteLayerList message.\nParameter may be \\c NULL."]
    pub Push: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            tag: *mut ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
            mode: AILayerListMode,
            list: *mut AILayerList,
        ) -> AIErr,
    >,
    #[doc = " Pops the current layer list from the top of the layer list stack. The plug-in\nthat pushed the layer list receives the \\c #kSelectorAIPopLayerList message\nwhich allows it to perform any actions associated with the pop, even if it\ndid not initiate the pop."]
    pub Pop: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves both the layer list and the layer on which an art object resides, if any.\n@param art The art object.\n@param list [out] A buffer in which to return the layer list, or \\c NULL\nif this information is not needed.\n@param layer [out] A buffer in which to return the layer, or \\c NULL\nif this information is not needed."]
    pub GetLayerOfArt: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            list: *mut AILayerList,
            layer: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of layer lists on the stack. Use with \\c #GetFirst()\nand \\c #GetNext() to iterate through lists.\n@param count [out] A buffer in which to return the number of layer lists."]
    pub Count: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves the current layer list (the most recently pushed list at the top\nof the stack).\n@param list [out] A buffer in which to return the layer list."]
    pub GetFirst: ::std::option::Option<unsafe extern "C" fn(list: *mut AILayerList) -> AIErr>,
    #[doc = " Retrieves the document layer list (the bottom of the stack).\n@param list [out] A buffer in which to return the layer list."]
    pub GetLast: ::std::option::Option<unsafe extern "C" fn(list: *mut AILayerList) -> AIErr>,
    #[doc = " Retrieves the next lower layer list in the stack.\n@param list A layer list in the stack.\n@param next [out] A buffer in which to return the next layer list,\nor \\c NULL if this is the lowest list."]
    pub GetNext: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, next: *mut AILayerList) -> AIErr,
    >,
    #[doc = " Gets the number of layers in a layer list. Use with \\c #GetFirstLayer()\nand \\c #GetNextLayer() to iterate through the layers.\n@param list The layer list.\n@param count [out] A buffer in which to return the number of layers."]
    pub CountLayers: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, count: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the topmost layer in the stacking order of a layer list.\n@param list The layer list.\n@param layer [out] A buffer in which to return the layer."]
    pub GetFirstLayer: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, layer: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the bottommost layer in the stacking order of a layer list.\n@param list The layer list.\n@param layer [out] A buffer in which to return the layer."]
    pub GetLastLayer: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, layer: *mut AILayerHandle) -> AIErr,
    >,
    #[doc = " Retrieves the next lower layer in the stacking order of a layer list.\n@param list The layer list.\n@param layer A layer in the list.\n@param layer [out] A buffer in which to return the next lower layer,\nor \\c NULL if this is the lowest layer."]
    pub GetNextLayer: ::std::option::Option<
        unsafe extern "C" fn(
            list: AILayerList,
            layer: AILayerHandle,
            next: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the next higher layer in the stacking order of a layer list.\n@param list The layer list.\n@param layer A layer in the list.\n@param layer [out] A buffer in which to return the next higher layer,\nor \\c NULL if this is the highest layer."]
    pub GetPrevLayer: ::std::option::Option<
        unsafe extern "C" fn(
            list: AILayerList,
            layer: AILayerHandle,
            prev: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Sets the display mode to be used when rendering the layer list.\n@param list The layer list.\n@param mode The new display mode, an \\c #AILayerListModeValues value."]
    pub SetDisplayMode: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, mode: AILayerListMode) -> AIErr,
    >,
    #[doc = " Retrieves the display mode used when rendering the layer list.\n(Note that this function returns a constant value, not an error code.)\n@param list The layer list.\n@return  The display mode, an \\c #AILayerListModeValues value."]
    pub GetDisplayMode:
        ::std::option::Option<unsafe extern "C" fn(list: AILayerList) -> AILayerListMode>,
    #[doc = " Retrieves the tag that identifies the purpose of a layer list.\n(Note that this function returns a constant value, not an error code.)\n@param list The layer list.\n@return  The tag, \\c #kAIDocumentLayerList or \\c #kAITransparencyMaskLayerList."]
    pub GetTag: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Sets the editability mode of a layer list. Use to set non-default\neditability for a transparency-mask layer. It is best to set this immediately\nafter initializing the layer list, while processing the\n\\c #kSelectorAIPushLayerList message. You cannot modify the\neditability mode of the document layer list.\n@param list The layer list.\n@param mode The new editability mode, one of the\n\\c #AILayerListEditabilityModeValues."]
    pub SetEditabilityMode: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList, mode: AILayerListEditabilityMode) -> AIErr,
    >,
    #[doc = " Retrieves the editability mode of a layer list.\n(Note that this function returns a constant value, not an error code.)\n@param list The layer list.\n@return The mode, one of the \\c #AILayerListEditabilityModeValues."]
    pub GetEditabilityMode: ::std::option::Option<
        unsafe extern "C" fn(list: AILayerList) -> AILayerListEditabilityMode,
    >,
}
#[doc = " A filter for matching art objects that contain specific\nproperties. Pass an array of these structures to \\c #AIMatchingArtSuite\nfunctions to specify the art objects that should be returned.\n\nTogether, \\c whichAttr and \\c attr specify an attribute value\nthat an art object of the given \\c type must have to be considered a match.\n\\li \\c whichAttr is the desired attribute, one of the \\c #AIArtUserAttr values.\n\\li \\c attr is a mask for the desired state of the attribute. Pass 0\nto match objects without the attribute. or the attribute constant\nto match objects with that attribute.\n\nFor\texample:\n\\li Specify \\c #kArtSelected for both \\c whichAttr and \\c attr\nto match only art objects that are selected.\n\\li Specify \\c #kArtSelected for \\c whichAttr and 0 for\n\\c attr to match only objects that are \\e not selected.\n\nSome values in \\c #AIArtUserAttr are not art attributes\nbut instead specify additional options to the matching process. To\nuse these options, specify the value in the \\c whichAttr field of one\nspecifications structure. For example, if the  \\c #kMatchDictionaryArt\nflag is set\tin any specification, the search looks in the dictionaries\nof art objects, as well as in the objects themselves."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMatchingArtSpec {
    #[doc = " An \\c  #AIArtType that identifies the types of art objects that match\nthe specification. Use the special type \\c #kAnyArt to match any kind\nof art object."]
    pub type_: ai_int16,
    #[doc = " An attribute and value by which to further filter art of the given type."]
    pub whichAttr: ai_int32,
    #[doc = " An attribute and value by which to further filter art of the given type."]
    pub attr: ai_int32,
}
#[doc = " @ingroup Suites\nThis suite allows you to get lists of art objects that are currently selected,\nor that match specified criteria, from among all available art objects,\nor from artwork in a particular set of layers. It provides an additional\ncollection mechanism to those in the \\c #AIArtSuite and \\c #AIArtSetSuite,\nand is more convenient than traversing the entire artwork tree.\n\nThese functions return art in an array of \\c #AIArtHandle. The suite allocates\na memory block for this array, which you must release using\n#AIMdMemorySuite::MdMemoryDisposeHandle(). Do not free the individual members of the array.\n\nThe functions flatten the requested hierarchy of objects into one art\nobject array, which can contain any combination of atomic objects, such as paths,\nand compound objects, such as groups.\n\nYour plug-in must handle the case of a group that is \\e partially selected--that is,\nsome but not all members are selected. In this case, both the group and some of\nits contained art objects are in the returned object array.\nIf, for example, your plug-in moves the\tobjects in a group,\tyou must\nignore the member objects in the array so that they are not moved twice.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIMatchingArtSuite and \\c #kAIMatchingArtVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMatchingArtSuite {
    #[doc = " Collects all selected art objects in the current layer list of the current document.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.  This may be\n\\c NULL if you do not want the actual matches (but only the\ncount, for instance).\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetSelectedArt: ::std::option::Option<
        unsafe extern "C" fn(
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Collects an array of all art objects in the current layer list of the\ncurrent document that match a set of criteria.\n@param specs An array of match specifications.\n@param numSpecs The number of entries in the \\c specs array.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetMatchingArt: ::std::option::Option<
        unsafe extern "C" fn(
            specs: *mut AIMatchingArtSpec,
            numSpecs: ai_int16,
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Collects all selected art objects in a given layer list of the current document.\n@param list The layer list.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetSelectedArtFromLayerList: ::std::option::Option<
        unsafe extern "C" fn(
            list: AILayerList,
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Collects an array of all art objects in a given layer list of the\ncurrent document that match a set of criteria.\n@param list The layer list.\n@param specs An array of match specifications.\n@param numSpecs The number of entries in the \\c specs array.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetMatchingArtFromLayerList: ::std::option::Option<
        unsafe extern "C" fn(
            list: AILayerList,
            specs: *mut AIMatchingArtSpec,
            numSpecs: ai_int16,
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Collects an array of all art objects in the current layer list of the current\ndocument that are used to determine the current path style, as displayed in the Color palette.\nThe current path style is determined by a combination of the targeted and selected objects.\nThe returned art can include objects inside graphs.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetArtForCurrentPathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Reports whether any art objects (as opposed to text objects)\nare selected in the current layer list of the current document,\nwhen the document is not in text editing mode.\n(Note that this function returns a boolean value, not an error code.)\n@return True if any art objects are selected, false if there is a text\nediting selection or if no objects are selected.\n@note To test whether there is a text editing selection, call\n\\c #AIDocumentSuite::HasTextFocus()."]
    pub IsSomeArtSelected: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Collects an array of all art objects in a given artwork tree\nthat match a set of criteria.  Use to perform a narrower\nsearch, or to search in art that is not part of the regular artwork\ntree, such as definition art for a pattern, brush, or symbol.\n@param searchArt The root art object.\n@param specs An array of match specifications.\n@param numSpecs The number of entries in the \\c specs array.\n@param matches [out] A buffer in which to return a pointer to a\nblock of memory containing the array of matching art objects.\nYou must release the memory block when you no longer\nneed it using #AIMdMemorySuite::MdMemoryDisposeHandle().\nDo not free the individual members of the array.\n@param numMatches [in/out] A buffer in which to pass the size of the\n\\c matches array, and return the number of art objects collected.\nIf no objects are selected, returns 0."]
    pub GetMatchingArtFromArt: ::std::option::Option<
        unsafe extern "C" fn(
            searchArt: AIArtHandle,
            specs: *mut AIMatchingArtSpec,
            numSpecs: ai_int16,
            matches: *mut *mut *mut AIArtHandle,
            numMatches: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Deselects all objects in the current document."]
    pub DeselectAll: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
}
#[doc = " An opaque pointer to a block of memory."]
pub type AIMdMemoryHandle = *mut *mut ::std::os::raw::c_void;
#[doc = " @ingroup Suites\nThis suite provides functions that allocate and dispose of blocks of memory.\nThis memory management scheme is generally deprecated. Do not\nuse it to allocate memory. It is still used, however,\nby the \\c #AIMatchingArtSuite, whose functions return a handle\nthat must be freed by the caller using \\c #MdMemoryDisposeHandle().\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIMdMemorySuite and \\c #kAIMdMemoryVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMdMemorySuite {
    #[doc = " Allocates a memory block.\n@param size The number of bytes.\n@param hMem [out] A buffer in which to return the memory handle."]
    pub MdMemoryNewHandle: ::std::option::Option<
        unsafe extern "C" fn(size: usize, hMem: *mut AIMdMemoryHandle) -> AIErr,
    >,
    #[doc = " Frees the memory associated with a handle.\n@param hMem The memory handle. Upon return, this is no longer valid."]
    pub MdMemoryDisposeHandle:
        ::std::option::Option<unsafe extern "C" fn(hMem: AIMdMemoryHandle) -> AIErr>,
    #[doc = " Reports the size of an allocated memory block.\n@param hMem The memory handle.\n@param size [out] A buffer in which to return the number of bytes."]
    pub MdMemoryGetSize: ::std::option::Option<
        unsafe extern "C" fn(hMem: AIMdMemoryHandle, size: *mut usize) -> AIErr,
    >,
    #[doc = " Reallocates a memory block.\n@param hMem The memory handle.\n@param newSize The new number of bytes."]
    pub MdMemoryResize: ::std::option::Option<
        unsafe extern "C" fn(hMem: AIMdMemoryHandle, newSize: usize) -> AIErr,
    >,
    #[doc = " Locks a memory block, so that the operating system does not move it.\nThis is no longer necessary, as the operating system no longer moves\nmemory blocks.\n@param hMem The memory handle.\n@param lockedPtr [out] A buffer in which to return a pointer\nto the locked memory block."]
    pub MdMemoryLock: ::std::option::Option<
        unsafe extern "C" fn(
            hMem: AIMdMemoryHandle,
            lockedPtr: *mut *mut ::std::os::raw::c_void,
        ) -> AIErr,
    >,
    #[doc = " Unlocks a memory block that was locked with \\c #MdMemoryLock().\nThis is no longer necessary, as the operating system no longer moves\nmemory blocks.\n@param hMem The memory handle."]
    pub MdMemoryUnLock:
        ::std::option::Option<unsafe extern "C" fn(hMem: AIMdMemoryHandle) -> AIErr>,
}
#[doc = " Types\n"]
pub type ASHelpType = ai_uint32;
pub type ASHelpKey = ai_int32;
pub type ASHelpID = ai_int32;
pub const ASHelpCommand_kASHelpCmd_CONTEXTMENU: ASHelpCommand = 10;
pub const ASHelpCommand_kASHelpCmd_FINDER: ASHelpCommand = 11;
pub const ASHelpCommand_kASHelpCmd_WM_HELP: ASHelpCommand = 12;
pub const ASHelpCommand_kASHelpCmd_SETPOPUP_POS: ASHelpCommand = 13;
pub const ASHelpCommand_kASHelpCmd_TCARD: ASHelpCommand = 32768;
pub const ASHelpCommand_kASHelpCmd_TCARD_DATA: ASHelpCommand = 16;
pub const ASHelpCommand_kASHelpCmd_TCARD_OTHER_CALLER: ASHelpCommand = 17;
pub const ASHelpCommand_kASHelpCmd_CONTEXT: ASHelpCommand = 1;
pub const ASHelpCommand_kASHelpCmd_QUIT: ASHelpCommand = 2;
pub const ASHelpCommand_kASHelpCmd_CONTENTS: ASHelpCommand = 3;
pub const ASHelpCommand_kASHelpCmd_HELPONHELP: ASHelpCommand = 4;
pub const ASHelpCommand_kASHelpCmd_SETCONTENTS: ASHelpCommand = 5;
pub const ASHelpCommand_kASHelpCmd_CONTEXTPOPUP: ASHelpCommand = 8;
pub const ASHelpCommand_kASHelpCmd_FORCEFILE: ASHelpCommand = 9;
pub const ASHelpCommand_kASHelpCmd_KEY: ASHelpCommand = 257;
pub const ASHelpCommand_kASHelpCmd_COMMAND: ASHelpCommand = 258;
pub const ASHelpCommand_kASHelpCmd_PARTIALKEY: ASHelpCommand = 261;
pub const ASHelpCommand_kASHelpCmd_MULTIKEY: ASHelpCommand = 513;
pub const ASHelpCommand_kASHelpCmd_SETWINPOS: ASHelpCommand = 515;
pub type ASHelpCommand = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASHelpInitInfo {
    pub version: ai_int32,
    pub appWindow: AIWindowRef,
    pub appPluginRef: SPPluginRef,
    pub helpFolderNameStrID: ASInt16,
    pub appHelpFileNameStrID: ASInt16,
    pub helpFolderNameStrIndex: ASInt16,
    pub appHelpFileNameStrIndex: ASInt16,
}
#[doc = " Suite\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_ASHelpSuite1 {
    pub Init: ::std::option::Option<unsafe extern "C" fn(info: *mut ASHelpInitInfo) -> ASErr>,
    pub Quit: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    pub SetContextHelpMode:
        ::std::option::Option<unsafe extern "C" fn(helpMode: AIBoolean) -> ASErr>,
    pub InContextHelpMode: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    pub Help: ::std::option::Option<
        unsafe extern "C" fn(
            asWinRef: AIWindowRef,
            spFile: *mut SPPlatformFileSpecification,
            asHelpCommand: ASHelpCommand,
            dwData: ai_uint32,
        ) -> ASErr,
    >,
    pub HelpContents: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub SearchHelp: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub HowToUseHelp: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub ContextHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, helpID: ASHelpID) -> ASErr,
    >,
    pub GetHelpID: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            helpType: ASHelpType,
            key1: ASHelpKey,
            key2: ASHelpKey,
            helpID: *mut ASHelpID,
        ) -> ASErr,
    >,
    pub TypedHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            helpType: ASHelpType,
            key1: ASHelpKey,
            key2: ASHelpKey,
        ) -> ASErr,
    >,
    pub MenuHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, commandID: ASHelpKey) -> ASErr,
    >,
    pub DialogHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            dialogID: ASHelpKey,
            itemID: ASHelpKey,
        ) -> ASErr,
    >,
    pub PaletteMenuHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            dialogID: ASHelpKey,
            menuItem: ASHelpKey,
        ) -> ASErr,
    >,
    pub ToolHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, toolName: ASHelpKey) -> ASErr,
    >,
}
#[doc = " Suite\n"]
pub type ASHelpSuite1 = t_ASHelpSuite1;
#[doc = " Suite\n"]
pub type ASHelpSuite = ASHelpSuite1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_ASHelpSuite2 {
    pub Init: ::std::option::Option<unsafe extern "C" fn(info: *mut ASHelpInitInfo) -> ASErr>,
    pub Quit: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    pub SetContextHelpMode:
        ::std::option::Option<unsafe extern "C" fn(helpMode: AIBoolean) -> ASErr>,
    pub InContextHelpMode: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    pub Help: ::std::option::Option<
        unsafe extern "C" fn(
            asWinRef: AIWindowRef,
            spFile: *mut SPPlatformFileSpecification,
            asHelpCommand: ASHelpCommand,
            dwData: ai_uint32,
        ) -> ASErr,
    >,
    pub HelpContents: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub SearchHelp: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub HowToUseHelp: ::std::option::Option<unsafe extern "C" fn(pluginRef: SPPluginRef) -> ASErr>,
    pub ContextHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, helpID: ASHelpID) -> ASErr,
    >,
    pub GetHelpID: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            helpType: ASHelpType,
            key1: ASHelpKey,
            key2: ASHelpKey,
            helpID: *mut ASHelpID,
        ) -> ASErr,
    >,
    pub TypedHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            helpType: ASHelpType,
            key1: ASHelpKey,
            key2: ASHelpKey,
        ) -> ASErr,
    >,
    pub MenuHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, commandID: ASHelpKey) -> ASErr,
    >,
    pub DialogHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            dialogID: ASHelpKey,
            itemID: ASHelpKey,
        ) -> ASErr,
    >,
    pub PaletteMenuHelp: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            dialogID: ASHelpKey,
            menuItem: ASHelpKey,
        ) -> ASErr,
    >,
    pub ToolHelp: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, toolName: ASHelpKey) -> ASErr,
    >,
    pub ContextHelpQRC: ::std::option::Option<
        unsafe extern "C" fn(pluginRef: SPPluginRef, helpID: ASHelpID) -> ASErr,
    >,
}
pub type ASHelpSuite2 = t_ASHelpSuite2;
#[doc = " Option flags that control the behavior of a menu item.\nSee \\c #kMenuItemNoOptions and following."]
pub type AIMenuItemOption = ai_int32;
#[doc = " Option flags that control the behavior of a menu group.\nSee \\c #kMenuGroupNoOptions and following."]
pub type AIMenuGroupOption = ai_int32;
#[doc = " Enables the item if the criteria evaluate to true, disables it otherwise."]
pub const AIAutoMenuUpdateAction_kAutoEnableMenuItemAction: AIAutoMenuUpdateAction = 1;
#[doc = " Puts a check mark by the item if the criteria evaluate to true, removes\nthe check otherwise."]
pub const AIAutoMenuUpdateAction_kAutoCheckMenuItemAction: AIAutoMenuUpdateAction = 2;
#[doc = " The update action to be performed when all criteria are met.\nSpecify only one action. See \\c #AIMenuSuite::UpdateMenuItemAutomatically()."]
pub type AIAutoMenuUpdateAction = ::std::os::raw::c_uint;
#[doc = " Any type of group."]
pub const AIAutoMenuUpdateObjectCriteria_kIfGroup: AIAutoMenuUpdateObjectCriteria = 1;
#[doc = " Any type of path."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPath: AIAutoMenuUpdateObjectCriteria = 2;
#[doc = " An internal object type unavailable to users and plug-ins."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPostscript: AIAutoMenuUpdateObjectCriteria = 4;
#[doc = " A placed object."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPlaced: AIAutoMenuUpdateObjectCriteria = 8;
#[doc = " Any type of text."]
pub const AIAutoMenuUpdateObjectCriteria_kIfText: AIAutoMenuUpdateObjectCriteria = 16;
#[doc = " A path that has text in or on it. Can be set even\nif \\c kIfText is off, when a text path is direct-selected."]
pub const AIAutoMenuUpdateObjectCriteria_kIfTextPath: AIAutoMenuUpdateObjectCriteria = 32;
#[doc = " Obsolete"]
pub const AIAutoMenuUpdateObjectCriteria_kIfTextFlow: AIAutoMenuUpdateObjectCriteria = 64;
#[doc = " Obsolete"]
pub const AIAutoMenuUpdateObjectCriteria_kIfTextRun: AIAutoMenuUpdateObjectCriteria = 128;
#[doc = " Art used as a guide."]
pub const AIAutoMenuUpdateObjectCriteria_kIfGuide: AIAutoMenuUpdateObjectCriteria = 256;
#[doc = " A graph object"]
pub const AIAutoMenuUpdateObjectCriteria_kIfGraphData: AIAutoMenuUpdateObjectCriteria = 512;
#[doc = " Art used as a clipping mask."]
pub const AIAutoMenuUpdateObjectCriteria_kIfMask: AIAutoMenuUpdateObjectCriteria = 1024;
#[doc = " Obsolete"]
pub const AIAutoMenuUpdateObjectCriteria_kIfEndMask: AIAutoMenuUpdateObjectCriteria = 2048;
#[doc = " A simple group."]
pub const AIAutoMenuUpdateObjectCriteria_kIfNormalGroup: AIAutoMenuUpdateObjectCriteria = 4096;
#[doc = " A group that is a compound path."]
pub const AIAutoMenuUpdateObjectCriteria_kIfCompoundGroup: AIAutoMenuUpdateObjectCriteria = 8192;
#[doc = " Obsolete. Do not use."]
pub const AIAutoMenuUpdateObjectCriteria_kIfWrapAroundGroup: AIAutoMenuUpdateObjectCriteria = 16384;
#[doc = " A group with a clipping path."]
pub const AIAutoMenuUpdateObjectCriteria_kIfClipGroup: AIAutoMenuUpdateObjectCriteria = 32768;
#[doc = " Point text."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPointText: AIAutoMenuUpdateObjectCriteria = 65536;
#[doc = " Text in a path."]
pub const AIAutoMenuUpdateObjectCriteria_kIfInPathText: AIAutoMenuUpdateObjectCriteria = 131072;
#[doc = " Text on a path."]
pub const AIAutoMenuUpdateObjectCriteria_kIfOnPathText: AIAutoMenuUpdateObjectCriteria = 262144;
#[doc = " Threaded text."]
pub const AIAutoMenuUpdateObjectCriteria_kIfThreadedText: AIAutoMenuUpdateObjectCriteria = 524288;
#[doc = " Raster art."]
pub const AIAutoMenuUpdateObjectCriteria_kIfRaster: AIAutoMenuUpdateObjectCriteria = 1048576;
#[doc = " Plug-in group (for any platform)."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPluginArt: AIAutoMenuUpdateObjectCriteria = 2097152;
#[doc = " Mesh art."]
pub const AIAutoMenuUpdateObjectCriteria_kIfMesh: AIAutoMenuUpdateObjectCriteria = 4194304;
#[doc = " Styled art."]
pub const AIAutoMenuUpdateObjectCriteria_kIfHasStyledArt: AIAutoMenuUpdateObjectCriteria = 8388608;
#[doc = " Symbol."]
pub const AIAutoMenuUpdateObjectCriteria_kIfSymbol: AIAutoMenuUpdateObjectCriteria = 16777216;
#[doc = " Foreign object."]
pub const AIAutoMenuUpdateObjectCriteria_kIfForeignArt: AIAutoMenuUpdateObjectCriteria = 33554432;
#[doc = " Legacy text."]
pub const AIAutoMenuUpdateObjectCriteria_kIfLegacyTextArt: AIAutoMenuUpdateObjectCriteria =
    67108864;
#[doc = " Path that is not inside a planar group."]
pub const AIAutoMenuUpdateObjectCriteria_kIfClassicPath: AIAutoMenuUpdateObjectCriteria = 134217728;
#[doc = " Path that is inside a planar group. See \\c #AIPlanarObjectSuite."]
pub const AIAutoMenuUpdateObjectCriteria_kIfPlanarPath: AIAutoMenuUpdateObjectCriteria = 268435456;
#[doc = " A path that does not have text in or on it."]
pub const AIAutoMenuUpdateObjectCriteria_kIfNonTextPath: AIAutoMenuUpdateObjectCriteria = 536870912;
#[doc = " Chart."]
pub const AIAutoMenuUpdateObjectCriteria_kIfChartArt: AIAutoMenuUpdateObjectCriteria = 1073741824;
#[doc = " Repeat art."]
pub const AIAutoMenuUpdateObjectCriteria_kIfRepeatArt: AIAutoMenuUpdateObjectCriteria = -2147483648;
#[doc = " Any art."]
pub const AIAutoMenuUpdateObjectCriteria_kIfAnyArt: AIAutoMenuUpdateObjectCriteria = 4294967295;
#[doc = " Types of art objects whose appearance in a document or selection\ncan be considered for automatic menu update.\nSee \\c #AIMenuSuite::UpdateMenuItemAutomatically()."]
pub type AIAutoMenuUpdateObjectCriteria = ::std::os::raw::c_long;
pub const AIAutoMenuUpdatePropertyCriteria_kIfCurrentLayerIsEditable:
    AIAutoMenuUpdatePropertyCriteria = 1;
pub const AIAutoMenuUpdatePropertyCriteria_kIfOpenTextEdit: AIAutoMenuUpdatePropertyCriteria = 2;
pub const AIAutoMenuUpdatePropertyCriteria_kIfAnyPrintingChars: AIAutoMenuUpdatePropertyCriteria =
    4;
pub const AIAutoMenuUpdatePropertyCriteria_kIfAnyHiddenObjects: AIAutoMenuUpdatePropertyCriteria =
    8;
pub const AIAutoMenuUpdatePropertyCriteria_kIfAnyLockedObjects: AIAutoMenuUpdatePropertyCriteria =
    16;
pub const AIAutoMenuUpdatePropertyCriteria_kIfAnyClipPaths: AIAutoMenuUpdatePropertyCriteria = 32;
pub const AIAutoMenuUpdatePropertyCriteria_kIfOpenDocument: AIAutoMenuUpdatePropertyCriteria = 64;
pub const AIAutoMenuUpdatePropertyCriteria_kIfCMYKDocument: AIAutoMenuUpdatePropertyCriteria = 128;
pub const AIAutoMenuUpdatePropertyCriteria_kIfRGBDocument: AIAutoMenuUpdatePropertyCriteria = 256;
pub const AIAutoMenuUpdatePropertyCriteria_kIfCurrentArtStyleIsNamed:
    AIAutoMenuUpdatePropertyCriteria = 512;
pub const AIAutoMenuUpdatePropertyCriteria_kIfHasPluginSelection: AIAutoMenuUpdatePropertyCriteria =
    1024;
#[doc = " Document properties that can be considered for automatic\nmenu update. See \\c #AIMenuSuite::UpdateMenuItemAutomatically()."]
pub type AIAutoMenuUpdatePropertyCriteria = ::std::os::raw::c_uint;
#[doc = " Shift key"]
pub const AIMenuItemModifier_kMenuItemCmdShiftModifier: AIMenuItemModifier = 1;
#[doc = " Option key in Mac OS, Alt key in Windows."]
pub const AIMenuItemModifier_kMenuItemCmdOptionModifier: AIMenuItemModifier = 2;
#[doc = " Command key in Mac OS,  Ctrl key in Windows."]
pub const AIMenuItemModifier_kMenuItemCmdControlModifier: AIMenuItemModifier = 4;
#[doc = " Modifier keys for command characters (keyboard shortcuts).\nSee \\c #AIMenuSuite::SetItemCmd() and \\c #AIMenuSuite::GetItemCmd()."]
pub type AIMenuItemModifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIMenuItemOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a menu item. Never dereferenced.\nAccess with \\c #AIMenuSuite functions."]
pub type AIMenuItemHandle = *mut _t_AIMenuItemOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_MenuGroupOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a menu group. Never dereferenced.\nAccess with \\c #AIMenuSuite functions."]
pub type AIMenuGroup = *mut _t_MenuGroupOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MacMenu_t {
    _unused: [u8; 0],
}
#[doc = " Platform-specific menu reference. \\li In Mac OS, a \\c MenuRef.\n\\li In Windows, cast to \\c HMENU."]
pub type AIPlatformMenuHandle = *mut MacMenu_t;
#[doc = " Menu item definition data."]
#[repr(C)]
#[derive(Debug)]
pub struct AIPlatformAddMenuItemDataUS {
    #[doc = " The menu group to which an item is added. See @ref menuGroups."]
    pub groupName: *const ::std::os::raw::c_char,
    #[doc = " The display label for an item. (To create a menu separator\nset the \\c #kMenuItemIsSeparator options flag and set this\nto \\c NULL.)"]
    pub itemText: ai_UnicodeString,
}
#[doc = " A platform-specific menu structure corresponding to an\nIllustrator menu item.\nSee \\c #AIMenuSuite::GetPlatformMenuItem()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPlatformMenuItem {
    #[doc = " An \\c HMENU in Windows, a \\c MenuRef in Mac OS."]
    pub menu: AIPlatformMenuHandle,
    #[doc = " The index of the item in the platform menu."]
    pub item: ai_int16,
}
#[doc = " Message sent with menu selectors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMenuMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The  menu item object."]
    pub menuItem: AIMenuItemHandle,
}
#[doc = "\t@ingroup Suites\nThis suite provides functions that allow you to add menu items to\nthe Illustrator menu structure.\n\nA menu can be a stand alone interface to a plug-in feature, or\ngroup a number of features together. Plug-ins of all types can have\nan associated plug-in menu item. For instance, if you define a\npalette (non-modal dialog box), you typically add a menu item to the\nWindows menu to hide and show your window.\n\nThis section describes how to install and use plug-in menu items. It discusses\nthe caller, selectors and messages that plug-in menus receive, as well as the\nfunctions provided to add menus, set options, and control menu appearance,\nand to make simple appearance changes automatically based on the changes in\nartwork.\n\nMenu plug-ins are similar to Filter plug-ins (see the \\c #AIFilterSuite),\nbut are different in these ways:\n\\li Filter plug-ins are added to the Filter menu, while menu plug-ins\ncan add commands to any menu.\n\\li Filters have automatic repeat and undo, while menu plug-ins must set\nthe Undo menu item text.\n\\li Menu plug-ins can set command keys and control their appearance.\n\\li Both plug-in types receive a go selector, but Filters also receive\na selector to get parameters.\n\nThis suite is cross-platform (although the functions closely parallel\nthe Mac OS toolbox functions for changing menu appearance).\nIf you must manipulate a menu item directly, use \\c #GetPlatformMenuItem()\nto obtain a platform-specific menu reference.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIMenuSuite and \\c #kAIMenuVersion.\n\n\\section menuSelectors Menu Selectors\n\nThe caller for menu plug-ins is \\c #kCallerAIMenu. Check for the caller and\nthese selectors in the plug-in's main function:\t<br>\n<tt> #kSelectorAIGoMenuItem <br>\n#kSelectorAIUpdateMenuItem \t</tt>  <br>\nThe message data for both selectors is passed in an \\c #AIMenuMessage.\n\n\\section menuNotifiers Menu Notifiers\n\nThe notifier \\c #kAIMenuChangedNotifier\tis sent when a menu is\nmodified.\n\nNotifiers are available before and after menu commmands are executed.\n\n\\li The pre- and post-menu notifiers for Illustrator commands do not have\npredefined constants. Instead, the notification identification string\nis generated dynamically, in the following format:<br><br>\n\"AI Command Notifier: Before \" + \\e menu \\e identifier \\e text <br>\n\"AI Command Notifier: After \" + \\e menu \\e identifier \\e text <br><br>\nThe menu identifiers are defined in \\c AIMenuCommandNotifiers.h.\n\n\n\\section menuGroups Menu Groups\n\nPlug-in menu items are added to menu \\e groups, which are predefined locations\nwithin Illustrator�s menu structure. The complete list of groups is found\nin the \\c AIMenuGroups.h.  Some examples of menu groups are: <br><br>\n\\c #kOpenMenuGroup <br>\n\\c #kArrangeMoveMenuGroup <br>\n\\c #kTypeSizeMenuGroup\n\nThe names describe the menu location. A \\e utilities group is located at\nthe top to a menu group; for instance, the \"Type Size Utilities\"\nmenu group is at the top of the \"Type Size\" submenu.\n\nYou can create new menu groups, to which your plug-in or other plug-ins\ncan add menu items. As a plug-in developer, you are responsible for\ndocumenting any menu groups you add.\n\n\\subsection pluginMenuGroups Plug-in Menu Groups\n\nTo use a menu group added by a plug-in (rather than the application),\nyour plug-in should explicitly add the group, using \\c #AddMenuGroup().\nIf is safe to add a menu group twice;\nthe second call returns the existing group reference.\nThe following predefined groups are added by plug-ins: <br><br>\n\\c #kDocInfoMenuGroup <br>\n\\c #kObjectRasterMenuGroup <br>\n\\c #kArrangeTransformMultipleMenuGroup <br>\n\\c #kATMMenuGroupNearGroup <br>\n\\c #kObjectPathsPopoutPluginMenuGroup <br>\n\\c #kOPPPMenuGroupNearGroup\t<br>\n\\c #kDocumentSupportMenuGroup <br>\n\\c #kAssetMgmtMenuGroup\t<br>\n\\c #kWorkgroupMenuGroup\t<br>\n\\c #kScriptsMenuGroup <br>\n\\c #kWorkspacesMenuGroup <br>\n\\c #kWorkspacesPresetsMenuGroup <br>\n\\c #kWorkspacesCustomMenuGroup\n\n@note The \\c #kFilterUtilities menu is implemented using an\ninternal plug-in. To use it, you must acquire the \\c #AIFilterSuite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMenuSuite {
    #[doc = " Creates and installs a plug-in menu item.\n@param self\tThis plug-in.\n@param inKeyboardShortDictionaryKey A unique identifying name\nfor this item in the \\c keyboardshortcut dictionary, or \\c NULL\nif the item is dynamic or has no shortcut.\n@param data\tThe menu group to which the item is added, and the display\nlabel for the item as a Unicode string.\n@param options Flags that control the item's behavior, a logical OR\nof \\c #AIMenuItemOption values.\n@param menuItem\t[out] A buffer in which to return the menu item object.\nIf your plug-in installs multiple items, store this in \\c globals\nto compare when receiving a notification or selector.\nMay be \\c NULL."]
    pub AddMenuItem: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            inKeyboardShortDictionaryKey: *const ::std::os::raw::c_char,
            data: *mut AIPlatformAddMenuItemDataUS,
            options: AIMenuItemOption,
            menuItem: *mut AIMenuItemHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates and installs a plug-in menu item using a ZString display label.\n@param self\tThis plug-in.\n@param inKeyboardShortDictionaryKey A unique identifying name\nfor this item in the \\c keyboardshortcut dictionary, or \\c NULL\nif the item is dynamic or has no shortcut.\n@param groupName The menu group to which the item is added.\n@param data\tThe ZString display label for the item.\n@param options Flags that control the item's behavior, a logical OR\nof \\c #AIMenuItemOption values.\n@param menuItem\t[out] A buffer in which to return the menu item object.\nIf your plug-in installs multiple items, store this in \\c globals\nto compare when receiving a notification or selector."]
    pub AddMenuItemZString: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            inKeyboardShortDictionaryKey: *const ::std::os::raw::c_char,
            groupName: *const ::std::os::raw::c_char,
            itemText: ZRef,
            options: AIMenuItemOption,
            menuItem: *mut AIMenuItemHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the \\c keyboardshortcut dictionary key of a menu item.\n@param menuItem The menu item object.\n@param outKey [out] A buffer in which to return the\tkey string. Do not modify."]
    pub GetMenuItemKeyboardShortcutDictionaryKey: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            outKey: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a menu item.\n@param menuItem The menu item object.\n@param options [out] A buffer in which to return the options, a logical\nOR of \\c #AIMenuItemOption values."]
    pub GetMenuItemOptions: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, options: *mut AIMenuItemOption) -> AIErr,
    >,
    #[doc = " Set the option flags for a menu item.\n@param menuItem The menu item object.\n@param options The options, a logical OR of \\c #AIMenuItemOption values."]
    pub SetMenuItemOptions: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, options: AIMenuItemOption) -> AIErr,
    >,
    #[doc = " Retrieves the plug-in that installed a menu item.\n@param menuItem The menu item object.\n@param options [out] A buffer in which to return the plug-in object."]
    pub GetMenuItemPlugin: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Gets the number of installed menu items. Use with \\c #GetNthMenuItem()\nto iterate through items.\n@param count [out] A buffer in which to return the number of items.\nMay be \\c NULL."]
    pub CountMenuItems: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves an installed menu item by index position. Use with\n\\c #CountMenuItems() to iterate through items.\n@param n The position index, in the range <code>[0..numItems-1]</code>.\n@param menuItem [out] A buffer in which to return the menu item object."]
    pub GetNthMenuItem: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, menuItem: *mut AIMenuItemHandle) -> AIErr,
    >,
    #[doc = " Retrieves the platform-specific menu item reference associated with a menu item.\n@param menuItem The menu item object.\n@param platformMenuItem [out] A buffer in which to return the\nplatform-specific object. The menu handle\nis a \\c MenuInfo structure in Mac OS, a \\c WinMenu structure in Windows."]
    pub GetPlatformMenuItem: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            platformMenuItem: *mut AIPlatformMenuItem,
        ) -> AIErr,
    >,
    #[doc = " Updates a menu item's appearance automatically when specified conditions\nare met. You can either enable/disable, or check/uncheck the item with one call;\nyou cannot perform both types of update at once.\n\nAll criteria are evaluated and the results combined with a\nlogical AND to decide whether to make the specified appearance modification.\n\\li The results of the positive criteria are combined to produce a\npositive result, which is true if any of the positive criteria are true.\n\\li The results of the negative criteria are combined to produce a\nnegative result, which is true if none of the negative criteria are true.\n\\li The combined result used to perform the update action is true if\nboth the positive and negative results are true--that is, if any of the\ndesired properties are present and none of the undesired properties are\npresent.\n\n@param menuItem The menu item object.\n@param action The action to take when criteria are satisfied.\nAn \\c #AIAutoMenuUpdateAction value.\n@param ifObjectIsInArtwork Update if any object matching any specified type\nappears in the current document's artwork tree. A logical OR of\n\\c #AIAutoMenuUpdateObjectCriteria values.\n@param ifObjectIsNotInArtwork Update if no object matching any specified type\nappears in the current document's artwork tree. A logical OR of\n\\c #AIAutoMenuUpdateObjectCriteria values.\n@param ifObjectIsSelected Update if any object matching any specified type\nappears in the current document's selection. A logical OR of\n\\c #AIAutoMenuUpdateObjectCriteria values.\n@param ifObjectIsNotSelected Update if no object matching any specified type\nappears in the current document's selection. A logical OR of\n\\c #AIAutoMenuUpdateObjectCriteria values.\n@param ifIsTrue\tUpdate if any of the specified document properties are true\nfor the current document. A logical OR of\n\\c #AIAutoMenuUpdatePropertyCriteria values.\n@param ifIsNotTrue Update if none of the specified document properties are true\nfor the current document. A logical OR of\n\\c #AIAutoMenuUpdatePropertyCriteria values."]
    pub UpdateMenuItemAutomatically: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            action: ai_int32,
            ifObjectIsInArtwork: ai_int32,
            ifObjectIsNotInArtwork: ai_int32,
            ifObjectIsSelected: ai_int32,
            ifObjectIsNotSelected: ai_int32,
            ifIsTrue: ai_int32,
            ifIsNotTrue: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves document and artwork state information that you can use\nto update a menu item�s checked or enabled state.\nThis is faster than scanning the artwork tree or getting specific art,\nas Illustrator has already computed the information for automatic\nmenu updates.\n\nCall this only when the \\c #kSelectorAIUpdateMenuItem selector\nis received. The information is invalid if the call is made at any other time.\nThe \\c #kMenuItemWantsUpdateOption option must be set for the\nplug-in to receive this selector.\n@param inArtwork [out] A buffer in which to return a set of flags\nfor types of art that are contained in the current document's\nartwork tree. A logical OR of \\c #AIAutoMenuUpdateObjectCriteria values.\n@param isSelected [out] A buffer in which to return a set of flags\nfor types of art that are contained in the current document's\nselection. A logical OR of \\c #AIAutoMenuUpdateObjectCriteria values.\n@param isTrue [out] A buffer in which to return a set of flags\nfor document properties that are true for the current document.\nA logical OR of \\c #AIAutoMenuUpdatePropertyCriteria values."]
    pub GetUpdateFlags: ::std::option::Option<
        unsafe extern "C" fn(
            inArtwork: *mut ai_int32,
            isSelected: *mut ai_int32,
            isTrue: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Enables a menu item.\n@param menuItem The menu item object."]
    pub EnableItem:
        ::std::option::Option<unsafe extern "C" fn(menuItem: AIMenuItemHandle) -> AIErr>,
    #[doc = " Disables (grays out) a menu item.\n@param menuItem The menu item object."]
    pub DisableItem:
        ::std::option::Option<unsafe extern "C" fn(menuItem: AIMenuItemHandle) -> AIErr>,
    #[doc = " Retrieves the localizable display label of a menu item.\tThis is different\nfrom the unique identifying name returned by\n\\c #GetMenuItemKeyboardShortcutDictionaryKey().\n@param menuItem The menu item object.\n@param itemString [out] A buffer in which to return the label string."]
    pub GetItemText: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            itemString: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Sets the localizable display label of a menu item using a Unicode string.\n@param menuItem The menu item object.\n@param itemString The new label string."]
    pub SetItemText: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            itemString: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Sets the localizable display label of a menu item using a ZString.\n@param menuItem The menu item object.\n@param itemString The new label ZString."]
    pub SetItemTextZString: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, itemString: ZRef) -> AIErr,
    >,
    #[doc = " Sets the checked state of a menu item.\n@param menuItem The menu item object.\n@param bCheckIt True to check the item, false to uncheck it."]
    pub CheckItem: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, bCheckIt: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the menu group to which a menu item belongs.\n@param menuItem The menu item object.\n@param group [out] A buffer in which to return the menu group."]
    pub GetItemMenuGroup: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, group: *mut AIMenuGroup) -> AIErr,
    >,
    #[doc = " Creates a new menu group, to which you can add your plug-in menu items.\nIf the group already exists, returns the group reference. See @ref menuGroups.\n@param name The unique identifying name, which can be passed to \\c #AddMenuItem().\n@param options Flags that control the behavior of the menu group,\na logical OR of \\c #AIMenuGroupOption values.\n@param nearGroup An existing menu group for relative placement of this group.\nThe new group is added below this one, unless the options include\n\\c #kMenuGroupAddAboveNearGroup, in which case it is added above this one.\n\nIf this is a submenu created by \\c #AddMenuGroupAsSubMenu(),\nthe new menu group becomes part of that submenu, and is added above or below\nother menu items or groups that were previously added to the submenu, depending\non the options.\n@param group [out] A buffer in which to return the menu group object.\n@return The error \\c #kBadParameterErr if the relative group does not yet exist.\nThe loading order of plug-ins is indeterminate; if the relative group is\none that might be created by a different plug-in, your plug-in should\ncheck for an error and either create the group or add near a different group.\nIt is all right to add the same group multiple times."]
    pub AddMenuGroup: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            options: AIMenuGroupOption,
            nearGroup: *const ::std::os::raw::c_char,
            group: *mut AIMenuGroup,
        ) -> AIErr,
    >,
    #[doc = " Adds a new menu group as a submenu. A submenu can be updated\nprogrammatically or automatically, like a top-level menu.\nNested submenus are allowed.\n@param name\tThe unique identifying name, which can be passed to \\c #AddMenuItem().\n@param options Flags that control the behavior of the menu group,\na logical OR of \\c #AIMenuGroupOption values.\n@param menuItem\tThe menu item that invokes this submenu.\n@param group [out] A buffer in which to return the menu group object."]
    pub AddMenuGroupAsSubMenu: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            options: AIMenuGroupOption,
            menuItem: AIMenuItemHandle,
            group: *mut AIMenuGroup,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifying name of a menu group.\n@param group The menu group object.\n@param name [out] A buffer in which to return the name string. Do not modify."]
    pub GetMenuGroupName: ::std::option::Option<
        unsafe extern "C" fn(group: AIMenuGroup, name: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a menu group.\n@param group The menu group object.\n@param options [out] A buffer in which to return the options, a\nlogical OR of \\c #AIMenuGroupOption values."]
    pub GetMenuGroupOptions: ::std::option::Option<
        unsafe extern "C" fn(group: AIMenuGroup, options: *mut AIMenuGroupOption) -> AIErr,
    >,
    #[doc = " Sets  the option flags of a menu group.\n@param group The menu group object.\n@param options The new options, a logical OR of \\c #AIMenuGroupOption values."]
    pub SetMenuGroupOptions: ::std::option::Option<
        unsafe extern "C" fn(group: AIMenuGroup, options: AIMenuGroupOption) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the platform-specific menu structure for a menu\nwith the range of items that belong to a menu group.\n@param group The menu group object.\n@param theMenu [out] A buffer in which to return the platform-specific menu information.\nThe menu handle is a \\c MenuInfo structure in Mac OS,\na \\c WinMenu structure in Windows.\n@param firstItem [out] A buffer in which to return the index of the first item\nin the group.\n@param numItems [out] A buffer in which to return the number of items in the group."]
    pub GetMenuGroupRange: ::std::option::Option<
        unsafe extern "C" fn(
            group: AIMenuGroup,
            theMenu: *mut AIPlatformMenuHandle,
            firstItem: *mut ai_int16,
            numItems: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of installed menu groups.  Use with\n\\c #GetNthMenuGroup() to iterate through all menu groups.\n@param count [out] A buffer in which to return the number of groups."]
    pub CountMenuGroups: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a menu group by position index. Use with\n\\c #CountMenuGroups() to iterate through all menu groups.\n@param n The position index, in the range <code>[0..numGroups-1]</code>.\n@param group [out] A buffer in which to return the menu group object."]
    pub GetNthMenuGroup:
        ::std::option::Option<unsafe extern "C" fn(n: ai_int32, group: *mut AIMenuGroup) -> AIErr>,
    #[doc = " Retrieves the command character and modifier keys that act as the\nkeyboard shortcut for a menu item.\n@param menuItem The menu item object.\n@param cmdChar [out] A buffer in which to return the command character (keyboard shortcut).\n@param modifiers [out] A buffer in which to return the command character modifiers,\na logical OR of \\c #AIMenuItemModifier constants.\n@note Submenus created by plug-ins do not support modified command keys."]
    pub GetItemCmd: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            cmdChar: *mut ai_int16,
            modifiers: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Sets the command character and modifier keys that act as the\nkeyboard shortcut for a menu item.\n@param menuItem The menu item object.\n@param cmdChar The command character (keyboard shortcut).\n@param modifiers The command character modifiers, a logical OR of\n\\c #AIMenuItemModifier constants.\n@note Submenus created by plug-ins do not support modified command keys."]
    pub SetItemCmd: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            cmdChar: ::std::os::raw::c_char,
            modifiers: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the function key and modifiers associated\twith a menu item.\n@param menuItem The menu item object.\n@param fkey [out] A buffer in which to return the function key.\n@param modifiers [out] A buffer in which to return the function key modifiers,\na logical OR of \\c #AIMenuItemModifier constants."]
    pub GetItemFunctionKey: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            fkey: *mut ai_int16,
            modifiers: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Sets the function key and modifiers associated with a menu item.\n@param menuItem The menu item object.\n@param fkey The function key, in the range [1..15].\n@param modifiers The function key modifiers, a logical OR of\n\\c #AIMenuItemModifier constants."]
    pub SetItemFunctionKey: ::std::option::Option<
        unsafe extern "C" fn(
            menuItem: AIMenuItemHandle,
            fkey: ai_int16,
            modifiers: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a menu item is enabled.\n@param menuItem The menu item object.\n@param bEnables [out] A buffer in which to return true if the item is enabled, false\nif it is disabled (grayed)."]
    pub IsItemEnabled: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, bEnabled: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a menu item is checked.\n@param menuItem The menu item object.\n@param bCheckIt [out] A buffer in which to return true if the item is checked, false\nif it is unchecked."]
    pub IsItemChecked: ::std::option::Option<
        unsafe extern "C" fn(menuItem: AIMenuItemHandle, bCheckIt: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Deletes a menu item.\n@param menuItem The menu item object. After the call, this reference is invalid."]
    pub RemoveMenuItem:
        ::std::option::Option<unsafe extern "C" fn(menuItem: AIMenuItemHandle) -> AIErr>,
    #[doc = " Sets the header for a menu group. When a menu has a header,\nthe \\c #kMenuGroupHasHeader\toption flag is set for the group, and the\nmenu contains a non-selectable item for which the\n\\c #kMenuItemIsGroupHeader option flag is set. All other items in the group\nare shown below and indented from the header text.\n@param inGroup The menu group object.\n@param inHeader The header string, or an empty string to remove the group header."]
    pub SetMenuGroupHeader: ::std::option::Option<
        unsafe extern "C" fn(inGroup: AIMenuGroup, inHeader: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Programmatically invokes a menu action, as if the user had clicked the menu item.\n@param menuCmdID The command ID for the menu item."]
    pub InvokeMenuAction:
        ::std::option::Option<unsafe extern "C" fn(menuCmdID: AICommandID) -> AIErr>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AINotifierOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a notifier, never dereferenced. See \\c #AINotifierSuite."]
pub type AINotifierHandle = *mut _t_AINotifierOpaque;
#[doc = " The contents of a notifier message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AINotifierMessage {
    #[doc = " The message data"]
    pub d: SPMessageData,
    #[doc = " The notifier handle returned from \\c #AINotifierSuite::AddNotifier(). If more than\none notifier is installed, can be used to determine the instance that should\nhandle the message."]
    pub notifier: AINotifierHandle,
    #[doc = " The type of event for which the plug-in is being notified.\nIf more than one notifier type is installed, can be used alone or\nwith the notifier reference to determine the best way to handle\nthe call."]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = " Data whose type depends on the type of notification\tbeing sent.\nFor instance, notifiers related to plug-in tools receive\nthe \\c #AIToolHandle to which the notifier message refers."]
    pub notifyData: *mut ::std::os::raw::c_void,
}
#[doc = "\t@ingroup Suites\nThis suite provides functions that allow your plug-in to use Illustrator's\nevent notification system.\n\nIllustrator sends a notifier to plug-in to inform it of an events for which\nit has registered an interest. These functions allow you to request particular\nnotifications, turn them on and off, and find out which plug-ins are listening\nto notifications.\n\nNotifiers can be used by themselves as a background process or with other plug-in\ntypes, such as a menus or windows, to learn when an\tupdate is needed.\nSpecific notifier type definitions are not a part of this suite,\nbut are found in the suites to which they are related. For instance, the \\c #AIArtSuite\ndefines the \\c #kAIArtSelectionChangedNotifier and \\c #kAIArtPropertiesChangedNotifier.\n\nIllustrator notifies a plug-in of an event by sending a message to its main entry\npoint with the caller \\c #kCallerAINotify and selector \\c #kSelectorAINotify. The\nmessage data is defined by \\c #AINotifierMessage.\n\nNotifications are sometimes sent during an idle loop, so a plug-in should not rely\non receiving them synchronously with a document state change. Some notifications\nare sent when something might have changed, but do not guarantee that something has\nchanged.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAINotifierSuite and \\c #kAINotifierVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AINotifierSuite {
    #[doc = "  Registers interest in a notification. Use at startup.\n@param self This plug-in.\n@param name The unique identifying name of this plug-in.\n@param type The notification type, as defined in the related suite.\nSee @ref Notifiers.\n@param notifier [out] A buffer in which to return the notifier reference.\nIf your plug-in installs multiple notifications, store this in '\n\\c globals to compare when receiving a notification."]
    pub AddNotifier: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            notifier: *mut AINotifierHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifying name of a notifier.\n@param notifier The notifier reference.\n@param name [out] A buffer in which to return the name. Do not modify this string."]
    pub GetNotifierName: ::std::option::Option<
        unsafe extern "C" fn(
            notifier: AINotifierHandle,
            name: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the type of a notifier.\n@param notifier The notifier reference.\n@param type [out] A buffer in which to return the type. Do not modify this string."]
    pub GetNotifierType: ::std::option::Option<
        unsafe extern "C" fn(
            notifier: AINotifierHandle,
            type_: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a notifier is active. An active notifier can receive events.\n@param notifier The notifier reference.\n@param active [out] A buffer in which to return true if the notifier is active."]
    pub GetNotifierActive: ::std::option::Option<
        unsafe extern "C" fn(notifier: AINotifierHandle, active: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Turns a notifier on or off. When a notifier is active (on) it receives\nnotification of events from Illustrator.\n@param notifier The notifier reference.\n@param active True to turn the notifier on, false to turn it off."]
    pub SetNotifierActive: ::std::option::Option<
        unsafe extern "C" fn(notifier: AINotifierHandle, active: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the plug-in that installed a notifier. You can pass this\nreference to functions in the \\c #AIPluginSuite.\n@param notifier The notifier reference.\n@param plugin [out] A buffer in which to return the plug-in reference."]
    pub GetNotifierPlugin: ::std::option::Option<
        unsafe extern "C" fn(notifier: AINotifierHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Gets the number of installed notifiers. Use this with \\c #GetNthNotifier()\nto iterate through notifiers.\n@param count [out] A buffer in which to return the number of notification registrations."]
    pub CountNotifiers: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a notifier by index position. Use this with \\c #CountNotifiers()\nto iterate through notifiers.\n@param n The 0-based position index of the notifier.\n@param notifier [out] A buffer in which to return the notifier reference."]
    pub GetNthNotifier: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, notifier: *mut AINotifierHandle) -> AIErr,
    >,
    #[doc = " Broadcasts a notification to all the plug-ins that have subscribed to the\nspecified type. Use this mechanism for communicating with other plug-ins.\n@param type\tThe notification type, as defined in the related suite.\nSee @ref Notifiers.\n@param notifyData Type-specific data to pass to the notification."]
    pub Notify: ::std::option::Option<
        unsafe extern "C" fn(
            type_: *const ::std::os::raw::c_char,
            notifyData: *mut ::std::os::raw::c_void,
        ) -> AIErr,
    >,
}
#[doc = " Same slope, but opposite side of p0"]
pub const AIAdjustThroughPointResult_kAIBezierAdjustReflectedp1: AIAdjustThroughPointResult = 1;
#[doc = " Same slope, but opposite side of p3"]
pub const AIAdjustThroughPointResult_kAIBezierAdjustReflectedp2: AIAdjustThroughPointResult = 2;
#[doc = " Different slope for p0 to p1"]
pub const AIAdjustThroughPointResult_kAIBezierAdjustRotatedp1: AIAdjustThroughPointResult = 4;
#[doc = " Different slope for p3 to p2"]
pub const AIAdjustThroughPointResult_kAIBezierAdjustRotatedp2: AIAdjustThroughPointResult = 8;
#[doc = " Return values for \\c #AIRealBezierSuite::AdjustThroughPoint()."]
pub type AIAdjustThroughPointResult = ::std::os::raw::c_uint;
#[doc = " A cubic Bezier, defined by its four control points."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRealBezier {
    pub p0: AIRealPoint,
    pub p1: AIRealPoint,
    pub p2: AIRealPoint,
    pub p3: AIRealPoint,
}
#[doc = " A cubic Bezier, defined by its four control points."]
pub type AIRealBezierPtr = *mut AIRealBezier;
#[doc = " @ingroup Suites\nThis suite provides utilities for working with cubic Beziers curves.\n\nMost of the functions in this suite do not return \\c #AIErr values.\nFor the most part, they return nothing, or return the result of the operation.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIRealBezierSuite and \\c #kAIRealBezierVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRealBezierSuite {
    #[doc = " Sets the four control points that define a cubic Bezier.\n@param b The Bezier object.\n@param p0 The first point.\n@param p1 The second point.\n@param p2 The third point.\n@param p3 The fourth point."]
    pub Set: ::std::option::Option<
        unsafe extern "C" fn(
            b: *mut AIRealBezier,
            p0: *mut AIRealPoint,
            p1: *mut AIRealPoint,
            p2: *mut AIRealPoint,
            p3: *mut AIRealPoint,
        ),
    >,
    #[doc = " Translates a cubic Bezier by a vector.\n@param b The Bezier object.\n@param dh The horizontal vector value.\n@param dv The vertical vector value."]
    pub Offset:
        ::std::option::Option<unsafe extern "C" fn(b: *mut AIRealBezier, dh: AIReal, dv: AIReal)>,
    #[doc = " Applies a transformation matrix to a cubic Bezier.\n@param b The Bezier object.\n@param m The transformation matrix."]
    pub Transform:
        ::std::option::Option<unsafe extern "C" fn(b: *mut AIRealBezier, m: *mut AIRealMatrix)>,
    #[doc = " Finds a point for a given input to a cubic Bezier.\n@param b The Bezier object.\n@param t The input value.\n@param p [out] A buffer in which to return the corresponding point."]
    pub Evaluate: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, t: AIReal, p: *mut AIRealPoint),
    >,
    #[doc = " Finds a tangent for a given input to a cubic Bezier.\n@param b The Bezier object.\n@param t The input value.\n@param v [out] A buffer in which to return the corresponding tangent."]
    pub Tangent: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, t: AIReal, v: *mut AIRealPoint),
    >,
    #[doc = " Finds the normal for a given input to a cubic Bezier.\n@param b The Bezier object.\n@param t The input value.\n@param v [out] A buffer in which to return the corresponding normal."]
    pub Normal: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, t: AIReal, v: *mut AIRealPoint),
    >,
    #[doc = " Splits a cubic Bezier at a point that results from a given input value.\nEither \\c b1 or \\c b2 may be null.\n@param b The Bezier object.\n@param t The input value for the point at which to split.\n@param b1 [out] A buffer in which to return the cubic Bezier for the first half.\n@param b2 [out] A buffer in which to return the cubic Bezier for the second half."]
    pub Divide: ::std::option::Option<
        unsafe extern "C" fn(
            b: *mut AIRealBezier,
            t: AIReal,
            b1: *mut AIRealBezier,
            b2: *mut AIRealBezier,
        ),
    >,
    #[doc = " Reports whether a cubic Bezier intersects a rectangle. Draws the Bezier\ncurve into a bitmap, and tests whether any of the marked pixels are\ncontained within the supplied rectangle.\n(Note that this function returns a boolean value, not an error code.)\n@param b The Bezier object.\n@param r The rectangle.\n@param scale The scale factor for bitmap resolution, a percentage\nvalue where 1.0 (100%) is 72 DPI.\n@return True if the bezier intersects the rectangle, false otherwise."]
    pub IntersectsRect: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, r: *mut AIRealRect, scale: AIReal) -> AIBoolean,
    >,
    #[doc = " Calculates the length of a cubic Bezier curve.\n(Note that this function returns a numeric value, not an error code.)\n@param b The Bezier object.\n@param flatness The accuracy with which to approximate the curve.\nA number of document points that is the maximum allowed distance\nof any line segment, at its furthest point, from the curve it\napproximates.\n@return The length in document points."]
    pub Length: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, flatness: AIReal) -> AIReal,
    >,
    #[doc = " Finds the point and tangent for a given input to a cubic Bezier.\nThis convenience function is the same as calling both\n\\c #Evaluate() and \\c #Tangent().\n@param b The Bezier object.\n@param t The input value.\n@param p [out] A buffer in which to return the point.\n@param v [out] A buffer in which to return the tangent."]
    pub PointAndTangent: ::std::option::Option<
        unsafe extern "C" fn(
            b: *mut AIRealBezier,
            t: AIReal,
            p: *mut AIRealPoint,
            v: *mut AIRealPoint,
        ),
    >,
    #[doc = " Adjusts a cubic Bezier such that it passes through a given input value.\n(Note that this function returns a constant value, not an error code.)\n@param b The Bezier object.\n@param p The point.\n@param t The input value.\n@return An \\c #AIAdjustThroughPointResult value that indicates\nhow the Bezier was adjusted."]
    pub AdjustThroughPoint: ::std::option::Option<
        unsafe extern "C" fn(b: *mut AIRealBezier, p: *mut AIRealPoint, t: AIReal) -> ai_uint16,
    >,
    #[doc = " Finds the input value to a cubic Bezier that results in a point\nat a given distance along the curve.\n@param bez The Bezier object.\n@param length The distance in points, must be less than the total length\nof the curve.\n@param total_length\tthe total length of the curve. See \\c #Length().\n@param flatness The accuracy with which to approximate the curve.\nA value of 1e-2 is suggested.\n@param t [out] A buffer in which to return the input value."]
    pub TAtLength: ::std::option::Option<
        unsafe extern "C" fn(
            bez: *mut AIRealBezier,
            length: AIReal,
            total_length: AIReal,
            flatness: AIReal,
            t: *mut AIReal,
        ) -> AIErr,
    >,
}
pub const AIPathSegementSelectionState_kSegmentNotSelected: AIPathSegementSelectionState = 0;
pub const AIPathSegementSelectionState_kSegmentPointSelected: AIPathSegementSelectionState = 1;
pub const AIPathSegementSelectionState_kSegmentInSelected: AIPathSegementSelectionState = 2;
pub const AIPathSegementSelectionState_kSegmentOutSelected: AIPathSegementSelectionState = 3;
pub const AIPathSegementSelectionState_kSegmentInAndOutSelected: AIPathSegementSelectionState = 4;
#[doc = " Selection states for path segments."]
pub type AIPathSegementSelectionState = ::std::os::raw::c_uint;
#[doc = "\tDefines a path segment. See \\c #AIPathSuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPathSegment {
    pub p: AIRealPoint,
    pub in_: AIRealPoint,
    pub out: AIRealPoint,
    pub corner: AIBoolean,
}
#[doc = " @ingroup Suites\nThis suite provides functions that allow you to examine and manipulate\n\\e paths, which are art objects of type \\c #kPathArt.\n\nThe shape of a path is defined by one or more path \\e segments.\nEvery segment of a path corresponds to an \\e anchor \\e point, which is\nthe handle shown when the path is selected. The number of anchor points\non a path, or \\e segment \\e count, includes the two at each end.\nA segment is defined by the \\c #AIPathSegment structure. Segment\nindex numbers begin at zero. A path can have a single anchor point.\n\nThe \\e in and \\e out points of a segment define the tangent of the curve\nat a point \\e p. The in point is not used for the initial and final segments\nof an open path. A segment can be a \\e corner point or a \\e smooth point.\nFor a corner, the in and out points can be anywhere. To make a straight line,\nplace the in and out points of each end on their p points.\n\nA path can be can be \\e closed or \\e open.\nIf a path is open, it is defined only by its segments. If it is closed,\nIllustrator draws a segment between the first and last anchor points,\nwhich uses the out tangent of the last segment and the in tangent of the first.\n\nSome paths are also used as \\e guides. In all other respects they are paths,\nwith the same contents and attributes. Paint attributes are associated with\na path through a \\e path \\e style. See the \\c #AIPathStyleSuite.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPathSuite and \\c #kAIPathVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPathSuite {
    #[doc = " Gets the number of anchor points on a path, including the two at each\nend.\n@param path The path object.\n@param count [out] A buffer in which to return the number of segments."]
    pub GetPathSegmentCount: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, count: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Removes segments from or appends segments to the end of a path.\nIf the count is increased, new segments\tare initialized to default values,\nwhich are not guaranteed to always be the same.\n@param path The path object.\n@param count The new segment count.\n@return The error \\c #kTooManySegmentsErr if the new count exceeds\nthe maximum number of path segments,\n\n@note When \\c #AIArtSuite::NewArt() creates a path, it initially allocates space\nfor 32 segments. When creating many small paths, this can waste memory.\nUse this function to free the memory of unused path segments immediately."]
    pub SetPathSegmentCount:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle, count: ai_int16) -> AIErr>,
    #[doc = " Retrieves a set of segments from a path.\n@param path The path object.\n@param segNumber The 0-based index of the first segment.\n@param count The number of segments to retrieve.\n@param segments [out] An array in which to return the segments. You must allocate an array of \\c #AIPathSegment\nthe size of \\c count."]
    pub GetPathSegments: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            count: ai_int16,
            segments: *mut AIPathSegment,
        ) -> AIErr,
    >,
    #[doc = " Adds or updates segments in a path. If segments are removed from a closed path,\nthe path remains closed.\n@param path The path object.\n@param segNumber The 0-based index of the first segment.\n@param count The number of segments to add.\n@param segments An array of new segments. You must allocate and\nfill an array of \\c #AIPathSegment the size of \\c count.\n@return The error \\c #kTooManySegmentsErr if the new segment count exceeds\nthe maximum number of path segments."]
    pub SetPathSegments: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            count: ai_int16,
            segments: *const AIPathSegment,
        ) -> AIErr,
    >,
    #[doc = " Inserts segments into a path.\n@param path The path object.\n@param segNumber The 0-based index of an existing segment in the path.\nThe new segments are inserted after this one.\n@param count The number of segments to insert.\n@param segments An array of new segments. You must allocate and\nfill an array of \\c #AIPathSegment the size of \\c count.\n@return The error \\c #kTooManySegmentsErr if the new segment count exceeds\nthe maximum number of path segments."]
    pub InsertPathSegments: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            count: ai_int16,
            segments: *const AIPathSegment,
        ) -> AIErr,
    >,
    #[doc = " Deletes segments from a path. If you delete segments from a closed path,\nthe path remains closed.\n@param path The path object.\n@param segNumber The 0-based index of the first segment.\n@param count The number of segments to delete."]
    pub DeletePathSegments: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, segNumber: ai_int16, count: ai_int16) -> AIErr,
    >,
    #[doc = " Reports whether a path is closed.\n@param path The path object.\n@param closed [out] A buffer in which to return true if the path is closed,\nfalse if it is open."]
    pub GetPathClosed: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, closed: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Opens or closes a path. When you close a path, an additional segment is\ndrawn between the last segment and the first segment. This is often the\nlast step in creating a new path.\n@param path The path object.\n@param closed True to close the path, false to open it.\n"]
    pub SetPathClosed:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle, closed: AIBoolean) -> AIErr>,
    #[doc = " Reports whether a path is used as a guide.\n@param path The path object.\n@param isGuide [out] A buffer in which to return true if the path is a guide"]
    pub GetPathGuide: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, isGuide: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether a path is used as a guide.\n@param path The path object.\n@param isGuide True if the path is to be used as a guide, false if it is not."]
    pub SetPathGuide:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle, isGuide: AIBoolean) -> AIErr>,
    #[doc = " Reports whether any part of a path segment is selected.\n@param path The path object.\n@param segNumber The 0-based index of the segment.\n@param selected [out] A buffer in which to return the selection state of the\nsegment, an \\c #AIPathSegementSelectionState value."]
    pub GetPathSegmentSelected: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            selected: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Reports selection state of path segments.\n@param path The path object.\n@param segNumber The 0-based index of the first segment.\n@param count The number of segments whose selection state is desired.\n@param selected [out] An array in which to return the selection state\nof the segments, \\c #AIPathSegementSelectionState values.\nYou must allocate an array of \\c #ai::int16 the size of \\c count."]
    pub GetPathSegmentsSelected: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            count: ai_int16,
            selected: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Sets the selection state for a segment.\n@param path The path object.\n@param segNumber The 0-based index of the segment.\n@param selected The new selection state of the segment,\nan \\c #AIPathSegementSelectionState value.\n\n@note Modifying the selection state of one segment can affect\nadjacent segments. For example, if the out direction of one segment\nis selected, the in direction of the following segment is also selected."]
    pub SetPathSegmentSelected: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, segNumber: ai_int16, selected: ai_int16) -> AIErr,
    >,
    #[doc = " Sets the selection state for path segments.\n@param path The path object.\n@param segNumber The 0-based index of the first segment.\n@param count The number of segments whose selection state is to be changed.\n@param selected An array of new selection state for the segments,\n\\c #AIPathSegementSelectionState values.\nYou must allocate and fill an array of \\c #ai::int16 the size of \\c count.\n\n@note Modifying the selection state of one segment can affect\nadjacent segments. For example, if the out direction of one segment\nis selected, the in direction of the following segment is also selected."]
    pub SetPathSegmentsSelected: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            count: ai_int16,
            selected: *const ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Reverses the order of segments in a path.\nThe winding order is significant if the path is a subpath of a\ncompound path. It controls the insideness of the compound path.\nThis changes the appearance of the path if variable width, arrowheads,\ncertain kind of brushes etc. are applied.\n@param path The path object."]
    pub ReversePathSegments:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle) -> AIErr>,
    #[doc = " Reverses the direction of a path.\nFor open paths this works the same as \\c #ReversePathSegments().\nFor closed paths the transformation on segments is as follows:\n[0,1,2,...,n-2,n-1] => [0,n-1,n-2,...,2,1].\nThis changes the appearance of the path if variable width, arrowheads,\ncertain kind of brushes etc. are applied.\n@param path The path object."]
    pub ReversePathDirection:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle) -> AIErr>,
    #[doc = " Calculates the area of a path. A pathﾒs winding order is\ndetermined by the sign of area. If the area is negative,\nthe path is wound counter-clockwise. Self-intersecting paths\ncan contain sub-areas that cancel each other out. This makes\nit possible for the function to return zero for a path that\ndoes have area.\n@param path The path object.\n@param area [out] A buffer in which to return the area, in\nsquare points."]
    pub GetPathArea:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle, area: *mut AIReal) -> AIErr>,
    #[doc = " Calculates the length of the perimeter of a path measured in points.\n@param path The path object.\n@param length [out] A buffer in which to return the length, in points.\n@param flatness Not used."]
    pub GetPathLength: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, length: *mut AIReal, flatness: AIReal) -> AIErr,
    >,
    #[doc = " Calculates the bezier values of a path segment.\n\\li For the last anchor point of an open path, wraps to the beginning.\n\\li  For the last anchor point of a closed path, all four bezier points are\nequal--that is, the outgoing control point is ignored, so that the visible\nbounding box, length, and other function treat it correctly.\n\n@param path The path object.\n@param segNumber The 0-based index of the segment.\n@param bezier [out] A buffer in which to return the bezier values."]
    pub GetPathBezier: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segNumber: ai_int16,
            bezier: *mut AIRealBezier,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a path has length. This is more efficient than checking\nwhether \\c #GetPathLength() != 0.\n@param path The path object.\n@param hasLength [out] A buffer in which to return true if the path length\nis not zero."]
    pub PathHasLength: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, hasLength: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether a path is a clipping path. The path can be a compound path.\nTo be a clipping object a path must have at least two segments.\nTo make a path into a clipping path use \\c #AIArtSuite::SetArtUserAttr()\n@param path The path object.\n@param isClip [out] A buffer in which to return true if the path is a clipping path."]
    pub GetPathIsClip: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, isClip: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether all segments of a path are selected.\n@param path The path object.\n@param selected [out] A buffer in which to return true if the path is fully selected."]
    pub GetPathAllSegmentsSelected: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, selected: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the selection state for all segments of a path.\n@param path The path object.\n@param selected The new selection state of the segments,\nan \\c #AIPathSegementSelectionState value.\n\n@note Modifying the selection state of one segment can affect\nadjacent segments. For example, if the out direction of one segment\nis selected, the in direction of the following segment is also selected."]
    pub SetPathAllSegmentsSelected:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle, selected: ai_int16) -> AIErr>,
    #[doc = " Retrieves path object and segment number of the key anchor point (that is,\nthe one to which other anchor points are aligned). The key anchor point\nis usually the last anchor point selected with the direct select tool.\n@param path [out] A buffer in which to return the path object.\n@param segmentNumber [out] A buffer in which to return the segment number."]
    pub GetKeySegment: ::std::option::Option<
        unsafe extern "C" fn(path: *mut AIArtHandle, segmentNumber: *mut ai_int16) -> AIErr,
    >,
    #[doc = " @deprecated. use \\c SetKeySegment() intsead.\nClears the key anchor point (the one to which other anchor points are aligned).\nThis is usually the last anchor point selected with the direct select tool."]
    pub CancelKeySegment: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Reports whether a path is 9-slice splitter; that is, a guide that defines\na line splitting the art board into 9 regions.\n@param path The path object.\n@return True if the path is 9-slice splitter, false if not, or if the\npath is not used as a guide.\n@see \\c #GetPathGuide()"]
    pub IsPath9SliceSplitter:
        ::std::option::Option<unsafe extern "C" fn(path: AIArtHandle) -> AIBoolean>,
    #[doc = " Sets the key anchor point of an art object.\nThe key is the one to which other anchor points are aligned.\nSetting a new anchor point as key replaces the previous one.\n@param path [in] The art object that contains the new anchor point,\nor NULL to reset the key anchor of the selected art object\nto the currently selected point.\n@param segmentNumber [in] The 0-based segment index of the anchor point\nin the specified art object to be set as key anchor point. Ignored\nif no art object is specified.\n@return The error \\c #kBadParameterErr if no anchor point is selected and\nno art object is specified."]
    pub SetKeySegment: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, segmentNumber: ai_int16) -> AIErr,
    >,
    #[doc = " Measures the lengths of the segments of a path. Storage is managed by the client, as for \\c #GetPathSegments().\n@param path\t\t\tThe path object.\n@param startSeg\t\tThe 0-based index of the first segment to be measured.\n@param count\t\tThe number of segments to measure.\n@param pieceLengths\t[out] A buffer in which to return the lengths of each bezier segment looking forward;\nthat is, \\c pieceLength[i] is the length of the bezier from anchor point i to anchor point i+1.\nIf i is the last segment of a closed path, it wraps around and reports the distance\nfrom anchor point i to anchor point 0.\nCan be a null pointer if only the accumulated lengths are needed.\n@param accumulatedLengths\t[out] A buffer in which to return the length of the path from the starting point\nthrough anchor point i. Can be a null pointer if only the individual lengths are needed.\nIf \\c startSeg is 0, then \\c accumulatedLengths(i) is the sum from j = 0 to i-1\nof \\c pieceLengths(j). So strictly\tspeaking, it is redundant, but for repeated operations it\nmay be more efficient to sum the partial lengths once instead of each time they are needed."]
    pub MeasureSegments: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            startSeg: ai_int16,
            count: ai_int16,
            pieceLengths: *mut AIReal,
            accumulatedLengths: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Computes the segment index and the parametric bezier t value of the point\nthat is a given fraction of the path length\talong a path.\n(See \\c #AIRealBezierSuite for a discussion of bezier t values.)\nYou can optionally pass segment length measurements, to improve performance when calling\nthis function repeatedly at multiple locations along the same path.\n@param path\t\t\t\tThe path object.\n@param lengthFraction\tThe fraction of the total path length at which to calculate the position.\n@param segIndex\t\t\t[out] A buffer in which to return the 0-based index of the segment that contains the position.\n@param t\t\t\t\t[out] A buffer in which to return the bezier parametric t value of splitting the segment at that position.\n@param pieceLengths\t\t[in] Optional, the piece-lengths result of a call to \\c #MeasureSegments() for the same path.\n@param accumulatedLengths [in] Optional, the accumulated-lengths result of a call to \\c #MeasureSegments() for the same path."]
    pub LengthFractionToBezierPos: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            lengthFraction: AIReal,
            segIndex: *mut ai_int16,
            bezierT: *mut AIReal,
            pieceLengths: *const AIReal,
            accumulatedLengths: *const AIReal,
        ) -> AIErr,
    >,
    #[doc = " Computes the fraction of the total path length corresponding to a position along the path expressed as a segment\nindex and a parametric bezier t value into that segment. (See \\c #AIRealBezierSuite for a discussion of bezier t values.)\nYou can optionally pass segment length measurements, to improve performance when calling\nthis function repeatedly at multiple locations along the same path.\n@param path\t\t\t\tThe path object.\n@param segIndex\t\t\tThe 0-based index of a segment in the path.\n@param t\t\t\t\tA bezier parametric t value at which to split the segment.\n@param lengthFraction\t[out] A buffer in which to return the fraction of the path length at which the given position falls\n@param pieceLengths\t\t[in] Optional, the piece-lengths result of a call to \\c #MeasureSegments() for the same path.\n@param accumulatedLengths [in] Optional, the accumulated-lengths result of a call to \\c #MeasureSegments() for the same path."]
    pub BezierPosToLengthFraction: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segIndex: ai_int16,
            bezierT: AIReal,
            lengthFraction: *mut AIReal,
            pieceLengths: *const AIReal,
            accumulatedLengths: *const AIReal,
        ) -> AIErr,
    >,
    #[doc = " Converts from a parametric bezier t value to a fraction of the segment length.\n(See \\c #AIRealBezierSuite for a discussion of bezier t values.)\nYou can optionally pass segment length measurements, to improve performance when calling\nthis function repeatedly at multiple locations along the same path.\n@param path\t\tThe path object.\n@param segIndex\tThe 0-based index of the segment.\n@param t\t\tThe parametric t value of a point along the path.\n@param segLength\t[optional, in/out] If positive on input, the length of the bezier segment\nas calculated by \\c #MeasureSegments(). (Do not use \\c #AIRealBezierSuite::Length()\nto measure the length; the flatness might be different, causing an inaccurate  result.)<br/>\nIf negative or 0 on input, this function\nmeasures the segment length and returns it here on output.\n@param segLengthFraction [out] A buffer in which to return the ratio between the whole segment length\nand the length of the shorter segment obtained by splitting the bezier at the t value."]
    pub BezierPosToAnchoredPos: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segIndex: ai_int16,
            t: AIReal,
            segLength: *mut AIReal,
            segLengthFraction: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Computes the endpoints of line segments perpendicular (normal) to a path at a position expressed as a segment index\nand a parametric bezier t value. (See \\c #AIRealBezierSuite for a discussion of bezier t values.)\n@param path\t\t\tThe path object.\n@param segIndex\t\tThe 0-based index of the segment.\n@param t\t\t\tThe bezier parametric t value at which to calculate the normals.\n@param leftDistance\tThe distance between \\c pointOnPath and \\c leftPoint. Must be non-negative.\n@param rightDistance The distance between \\c pointOnPath and \\c rightPoint. Must be non-negative.\n@param pointOnPath\t[out] A buffer in which to return the point along the path at the requested position.\n@param leftPoint\t[out] A buffer in which to return the point normal to the path at a distance of\n\\c leftDistance on the left side (as going from start to end point)\nCan be null if this point is not needed.\n@param rightPoint\t[out] A buffer in which to return the point normal to the path at a distance of\n\\c rightDistance on the right side (as going from start to end point)\nCan be null if this point is not needed."]
    pub PerpendicularsAtBezierT: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            segIndex: ai_int16,
            t: AIReal,
            leftDistance: AIReal,
            rightDistance: AIReal,
            pointOnPath: *mut AIRealPoint,
            leftPoint: *mut AIRealPoint,
            rightPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
}
#[doc = " Butt line caps"]
pub const AILineCap_kAIButtCap: AILineCap = 0;
#[doc = " Round line caps"]
pub const AILineCap_kAIRoundCap: AILineCap = 1;
#[doc = " Projecting line caps"]
pub const AILineCap_kAIProjectingCap: AILineCap = 2;
#[doc = " Types of line caps for strokes."]
pub type AILineCap = ::std::os::raw::c_uint;
#[doc = " Miter line joins"]
pub const AILineJoin_kAIMiterJoin: AILineJoin = 0;
#[doc = " Round line joins"]
pub const AILineJoin_kAIRoundJoin: AILineJoin = 1;
#[doc = " Bevel line joins"]
pub const AILineJoin_kAIBevelJoin: AILineJoin = 2;
#[doc = " Types of line joins for strokes."]
pub type AILineJoin = ::std::os::raw::c_uint;
#[doc = " Describes how to fill a path.\nA \\c #AIPathStyle::fill value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIFillStyle {
    #[doc = " Fill color"]
    pub color: AIColor,
    #[doc = " When true, print any art beneath this, then print the fill of this object over it.\nWhen false, knock out art beneath this art at print time"]
    pub overprint: AIBoolean,
}
#[doc = " The fields of an \\c #AIFillStyle that are specified by a partial\nstyle. An \\c #AIPathStyleMap::fill value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIFillStyleMap {
    pub color: AIColorMap,
    pub overprint: AIBoolean,
}
#[doc = " Describes a dash pattern for stroking a path.\nAn \\c #AIStrokeStyle::dash value.\n@see PostScript documentation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDashStyle {
    #[doc = " The number of valid values in the dash array, 0 if solid"]
    pub length: ai_int16,
    #[doc = " Dash offset"]
    pub offset: AIFloat,
    #[doc = " Dash array"]
    pub array: [AIFloat; 6usize],
}
#[doc = " The fields of an \\c #AIDashStyle that are specified by a partial\nstyle. An \\c #AIStrokeStyleMap::dash value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDashStyleMap {
    pub length: AIBoolean,
    pub offset: AIBoolean,
    pub array: [AIBoolean; 6usize],
}
#[doc = " Describes how to stroke a path.\nAn \\c #AIPathStyle::stroke value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIStrokeStyle {
    #[doc = " Stroke color"]
    pub color: AIColor,
    #[doc = " Overprint - not meaningful if the color is a pattern"]
    pub overprint: AIBoolean,
    #[doc = " Line width in points"]
    pub width: AIReal,
    #[doc = " Stroke dash"]
    pub dash: AIDashStyle,
    #[doc = " Line cap"]
    pub cap: AILineCap,
    #[doc = " Line join"]
    pub join: AILineJoin,
    #[doc = " Line miter limit"]
    pub miterLimit: AIReal,
}
#[doc = " The fields of an \\c #AIStrokeStyle that are specified by a partial\nstyle. An \\c #AIPathStyleMap::stroke value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIStrokeStyleMap {
    pub color: AIColorMap,
    pub overprint: AIBoolean,
    pub width: AIBoolean,
    pub dash: AIDashStyleMap,
    pub cap: AIBoolean,
    pub join: AIBoolean,
    pub miterLimit: AIBoolean,
}
#[doc = " Describes how to paint the fill and stroke of a path.\n\\li A full style completely specifies the paint information.\n\\li A \\e partial style can specify a subset\nof the painting information. It can be used to represent\nthe common paint attributes of a selection, for instance,\nor to modify a subset of attributes without affecting the others.\nIn this case the path style is paired with a style \\e map,\nan \\c #AIPathStyleMap specifying the subset of attributes that have\nvalid values.\n\nBe careful not to pass partial styles to functions that require\nfull styles; unspecified fields can contain invalid values."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIPathStyle {
    #[doc = " Whether or not to fill the path."]
    pub fillPaint: AIBoolean,
    #[doc = " Whether or not to stroke the path"]
    pub strokePaint: AIBoolean,
    #[doc = " Fill style, if fillPaint is true"]
    pub fill: AIFillStyle,
    #[doc = " Stroke style, if strokePaint is true"]
    pub stroke: AIStrokeStyle,
    #[doc = " @deprecated. Use \\c #AIArtSuite::SetArtUserAttr().\nWhether or not to use this as a clipping path"]
    pub clip: AIBoolean,
    #[doc = " @deprecated. Use \\c #AIArtSuite::SetArtUserAttr().\nWhether or not to lock the clipping path"]
    pub lockClip: AIBoolean,
    #[doc = " When true, use the even-odd rule to determine path insideness"]
    pub evenodd: AIBoolean,
    #[doc = " Path's resolution"]
    pub resolution: AIReal,
}
#[doc = " A true value indicates a field of a partial style that contains\na valid value in an accompanying \\c #AIPathStyle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIPathStyleMap {
    pub fillPaint: AIBoolean,
    pub strokePaint: AIBoolean,
    pub fill: AIFillStyleMap,
    pub stroke: AIStrokeStyleMap,
    pub clip: AIBoolean,
    pub lockClip: AIBoolean,
    pub evenodd: AIBoolean,
    pub resolution: AIBoolean,
}
#[doc = " @ingroup Suites\nThis suite provides functions to access or set stroke and fill paint style information\nfor art objects.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPathStyleSuite and \\c #kAIPathStyleVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPathStyleSuite {
    #[doc = " Retrieves the path style used to fill and/or stroke a path art object.\n@param path The art object.\n@param style [out] A buffer in which to return the style.\n@param outHasAdvFill : Set to 'true' if there is advance fill applied on path e.g. smooth style shading.\n@return The error \\c #kBadParameterErr if the art object is not an\nallowed type."]
    pub GetPathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            style: *mut AIPathStyle,
            outHasAdvFill: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the path style used to fill and/or stroke a path art object, if\nthe object is one of these types:\n<br> \\c #kPathArt\n<br> \\c #kCompoundPathArt\n<br> \\c #kRasterArt\n<br> \\c #kMeshArt\n<br> \\c #kPlacedArt\n<br> \\c #kTextFrameArt\n\nFor group types, (\\c #kGroupArt, \\c #kPluginArt, \\c #kSymbolArt),\nmodifies the existing fill or stroke. If there is no existing fill or\nstroke value, has no effect. Use the \\c #AIArtStyleSuite to add a new\nfill or stroke to a group object.\n\n@param path The art object.\n@param style The new style.\n@return The error \\c #kBadParameterErr if the art object is not an\nallowed type (\\c #kForeignArt, \\c #kLegacyTextArt, \\c #kUnknownArt)."]
    pub SetPathStyle: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, style: *const AIPathStyle) -> AIErr,
    >,
    #[doc = " Retrieves the common attributes of the current selected objects\n@param style [out] A buffer in which to return the partial style containing\nthe common attributes.\n@param stylemap [out] A buffer in which to return the map indicating which\nfields of the partial style contain valid values.\n@param outHasAdvFill : Set to 'true' if there is advance fill applied on path e.g. smooth style shading.\n@param advStrokeParams [out, optional] A pointer to a dictionary ref which may be created\nand populated with common advanced stroke parameters."]
    pub GetCurrentPathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            style: *mut AIPathStyle,
            stylemap: *mut AIPathStyleMap,
            advStrokeParams: *mut AIDictionaryRef,
            outHasAdvFill: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Applies a path style to any currently selected and paint-targeted objects.\nFor this function to apply, a targeted object must be a path or compound path,\nor have a style that already contains a fill or stroke.\nIf a targeted object has an active style, the new style is merged\ninto the focal fill and stroke filters. Any effects and non-focal fills\nand strokes remain unmodified.\n@param style The new partial style.\n@param stylemap The map indicating which fields of the partial style\ncontain valid values.\n@param advStrokeParams [optional] A dictionary ref containing advanced stroke\nparameters, may be null.\n@note To completely replace active styles, use\n\\c #SetCurrentPathStyleForceSimple()"]
    pub SetCurrentPathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            style: *mut AIPathStyle,
            stylemap: *mut AIPathStyleMap,
            advStrokeParams: ConstAIDictionaryRef,
        ) -> AIErr,
    >,
    #[doc = " Imports styles from a file, and creates a new document containing the styles.\nUse the \\c #AIArtStyleSuite and \\c #AISwatchListSuite to access the information.\nFor\tinstance, use \\c #AISwatchListSuite::GetSwatchList to import colors from\nthe document.\n@param source The file that contains the styles.\n@param newdoc [out] A buffer in which to return the new document."]
    pub ImportStyles: ::std::option::Option<
        unsafe extern "C" fn(source: *const ai_FilePath, newdoc: *mut AIDocumentHandle) -> AIErr,
    >,
    #[doc = " Imports mixed-colorspace styles from a file, and creates a new document\ncontaining the styles. Rarely needed; use only to allow a mixed colorspace\nin a swatch library. Mixed colorspaces are not allowed in artwork.\n(\\c #ImportStyles() always converts to a single colorspace.)\n@param source The file that contains the styles.\n@param newdoc [out] A buffer in which to return the new document."]
    pub ImportStylesMixedColorSpace: ::std::option::Option<
        unsafe extern "C" fn(source: *const ai_FilePath, newdoc: *mut AIDocumentHandle) -> AIErr,
    >,
    #[doc = " Applies a color to the stroke or fill of an art object. Generally\ndoes what you would want to do when applying a color. It sets the\ngradient vector to the default, handles compound paths, and so on.\nFor example, if you have an object that is stroked with a dashed line\nand you pass in a new color with \\c onStroke true, the old\ndash pattern is retained. If the object did not have a stroke before, the\nfunction looks for one in the current paint style. If the current paint style\ndoes not have a stroke, it uses a sensible default.\n@param art The art object.\n@param color The new color.\n@param onStroke True to apply the color only to strokes, false to apply only to fill.\n@note The function enumerates container objects. Do not call\non both a container and its children."]
    pub SetObjectAIColor: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, color: *const AIColor, onStroke: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether and how a path style makes use of a specific color in its\nfill or stroke.\n@param pathStyle The full or partial path style.\n@param psMap The map indicating which fields of the partial style\ncontain valid values, or \\c NULL for a full style.\n@param color The color.\n@param matchTint When false, the tint percentage for spot and\nglobal process colors is not considered.\n@param lookForIndirectUsage When true, and if the path style is a pattern,\nsearches the pattern definition for the color.\n@param usage [out] A buffer in which to return the result."]
    pub PathStyleUsesAIColor: ::std::option::Option<
        unsafe extern "C" fn(
            pathStyle: *const AIPathStyle,
            psMap: *const AIPathStyleMap,
            color: *const AIColor,
            matchTint: AIBoolean,
            lookForIndirectUsage: AIBoolean,
            usage: *mut AIColorUsedHow,
        ) -> AIErr,
    >,
    #[doc = "\tApplies a color to a path style in a typical way, as for the Swatch palette.\n\\li If the new color is a gradient or pattern, ignores its vector and\ntransform. If the path style is of the same type, retains its vector\nand transform. Otherwise, uses default values.\n\\li If the new color is a spot color, uses the tint.\n\\li Uses reasonable defaults when changing from one kind of color\nto another (such as solid to pattern or gradient) or when\nassigning color to a fill or stroke that was previously unpainted.\n\n@param pathStyle The full or partial path style. Modified in place.\n@param psMap The map indicating which fields of the partial style\ncontain valid values, or \\c NULL for a full style.\n@param newColor The new color.\n@param matchColor Optional. If supplied, \\c onStroke is ignored and the\nnew color is applied to the stroke or fill that matches this color.\nMatching is exact, including color space. Never assigns paint to an\nunpainted stroke or fill unless the value is \\c #kNoneColor.\n@param onStroke\tIf \\c matchColor is \\c NULL, then when true, applies the\nnew color to stroke, and when false, applies it to fill. To apply\nto both, you must call the function twice.\n@param useOldTint When true, and the new color and match color are\nboth custom colors, uses the tint from the match color. When false,\nuses the tint from the new color.\n@param destination The art object that uses the style, Used if a bounding\nbox is needed to calculate a gradient vector. If it is a compound path,\ncalculates bounds from the entire compound group.\n@param whatChanged [out] Optional. A buffer in which to return a structure\nindicating what part of the path style was changed."]
    pub ApplyAIColorToPathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            pathStyle: *mut AIPathStyle,
            psMap: *mut AIPathStyleMap,
            newColor: *const AIColor,
            matchColor: *const AIColor,
            onStroke: AIBoolean,
            useOldTint: AIBoolean,
            destination: AIArtHandle,
            whatChanged: *mut AIColorUsedHow,
        ) -> AIErr,
    >,
    #[doc = " Reports whether and how an art object uses a color.\n@param art The art object. Can be of any type.\n@param targetColor The color.\n@param matchTint When false, the tint percentage for spot and\nglobal process colors is not considered.\n@param lookForIndirectUsage When true, checks for a match\ninside patterns, gradients, and graph designs. When false,\nstill checks inside the graph style change records of graph\nobjects, but not in patterns, gradients, or graph designs.\n@param usage [out] A buffer in which to return the result."]
    pub ObjectUsesAIColor: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            targetColor: *const AIColor,
            matchTint: AIBoolean,
            lookForIndirectUsage: AIBoolean,
            usage: *mut AIColorUsedHow,
        ) -> AIErr,
    >,
    #[doc = " Replaces one color with another in an art object.\n\nFor direct usage of the old color (that is, a stroke or fill, including inside graph\npath style change records), calls \\c #SetObjectAIColor() to set the new color.\nDoes not replace indirectly used colors--that is, those inside patterns, gradients,\nor graph designs used by the art object.\n\nYou can replace pattern or gradient colors by defining a new\npattern or gradient, then calling this function for the pattern or gradient\nobject itself, with the new replacement object.\n@param art The art object, or \\c NULL to replace the color in\nall art in the current document. Can be any type except \\c #kPlacedArt,\nincluding those that are reported as \\c #kMysteryPathArt\n(paths inside text paths and graphs), and those that are\nreported as \\c #kUnknownArt, such as graphs and layer masks.\n@param oldColor The color to replace.\n@param newColor The new color.\n@param useOldTint When true, and both colors are custom colors, uses\nthe tint from the old color. When false, uses the tint from the\nnew color.\n@param madeReplacement [out] Optional. A buffer in which to return\ntrue if a replacement was made."]
    pub ReplaceObjectAIColor: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            oldColor: *const AIColor,
            newColor: *const AIColor,
            useOldTint: AIBoolean,
            madeReplacement: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the default path style that tools should use when creating new objects other\nthan text objects.\n@param style [out] A buffer in which to return the path style."]
    pub GetInitialPathStyle:
        ::std::option::Option<unsafe extern "C" fn(style: *mut AIPathStyle) -> AIErr>,
    #[doc = " Sets the default path style that tools should use when creating new objects other\nthan text objects.\n@param style The new path style."]
    pub SetInitialPathStyle:
        ::std::option::Option<unsafe extern "C" fn(style: *const AIPathStyle) -> AIErr>,
    #[doc = " Retrieves the default path style that tools should use when creating text objects.\n@param style [out] A buffer in which to return the path style."]
    pub GetInitialTextStyle:
        ::std::option::Option<unsafe extern "C" fn(style: *mut AIPathStyle) -> AIErr>,
    #[doc = " Sets the default path style that tools should use when creating text objects.\n@param style The new path style."]
    pub SetInitialTextStyle:
        ::std::option::Option<unsafe extern "C" fn(style: *const AIPathStyle) -> AIErr>,
    #[doc = " Makes a color appropriate for the artwork in the current document.\nFor example, if it uses a pattern that is not available, replaces it\nwith an equivalent pattern that is available.\n@param color The color (typically from clipboard artwork)."]
    pub RetargetForCurrentDoc:
        ::std::option::Option<unsafe extern "C" fn(color: *mut AIColor) -> AIErr>,
    #[doc = " Applies a path style to any currently selected and paint-targeted objects.\nFor this function to apply, a targeted object must be a path or compound path,\nor have a style that already contains a fill or stroke.\nWhen a selected object has an active style, merges the input style values\nonly with the paint attributes, and gives the object that simple style.\nCompare \\c #SetCurrentPathStyle().\n@param style The new partial style, or \\c NULL to replace all\nselected active styles with the simple style corresponding to their focal\nfill and/or stroke filters.\n@param stylemap The map indicating which fields of the partial style\ncontain valid values, or \\c NULL if style is not supplied."]
    pub SetCurrentPathStyleForceSimple: ::std::option::Option<
        unsafe extern "C" fn(style: *mut AIPathStyle, stylemap: *mut AIPathStyleMap) -> AIErr,
    >,
    #[doc = " Applies a path style to a path object. When the path has an active style,\nmerges the input style values only with the paint attributes, and gives\nthe object that simple style. Compare \\c #SetPathStyle().\n@param path\tThe path object.\n@param style The new style, or \\c NULL to replace the\nactive style with the simple style corresponding to the focal\nfill and/or stroke filters."]
    pub SetPathStyleForceSimple: ::std::option::Option<
        unsafe extern "C" fn(path: AIArtHandle, style: *const AIPathStyle) -> AIErr,
    >,
    #[doc = " Interpolates a new style between two path styles.\n@param style0 The first path style object.\n@param style1 The second path style object.\n@param styleOut [out] A buffer in which to return the new path style.\n@param percent The distance from the source styles. 0 to return the first\nstyle, 1 to return the second style, or an interpolation point\nbetween the two.\n@see\\c #AIPathInterpolateSuite."]
    pub InterpolatePathStyle: ::std::option::Option<
        unsafe extern "C" fn(
            style0: *const AIPathStyle,
            style1: *const AIPathStyle,
            styleOut: *mut AIPathStyle,
            percent: AIReal,
        ) -> AIErr,
    >,
    #[doc = " Interpolates a color between two colors.\n@param color0 The first color.\n@param color1 The second color.\n@param colorOut [out] A buffer in which to return the new color.\nIf the colors are of incompatible types, such as two patterns,\nreturns the first color.\n@see \\c #AIPathInterpolateSuite"]
    pub InterpolateAIColor: ::std::option::Option<
        unsafe extern "C" fn(
            color0: *const AIColor,
            color1: *const AIColor,
            colorOut: *mut AIColor,
            fraction: AIReal,
        ) -> AIErr,
    >,
    #[doc = " Sets the synchronization state for the initial path style. When synchronization\nis on (which it usually is) Illustrator synchronizes the initial path style\nwith the current path style whenever the selection changes, and\twhen calls\nare made to \\c #GetCurrentPathStyle(), \\c #SetCurrentPathStyle(),\n\\c #GetInitialPathStyle() or \\c #SetInitialPathStyle().\nThe Swatches palette, Color palette, and Toolbox all show the\ncurrent path style.\n\nWhen synchronization is off, the initial path style and the current path style\nbecome independent. In this mode, getting or setting the current path style does not\naffect the initial path style, and getting or setting the initial path style does not affect\nthe current path style or the current selection. The palettes and Toolbox show\nthe initial path style rather than the current path style.\n@param syncInitialPathStyle \\li True to turn synchronization on, false to\nturn it off.\n@note You might want to maintain a tool-specific style that is not\nmodified when the selection changes. This allows the user to have a selection,\nchoose a specific tool and color, and not have the color apply to the current\nselection. This is used by the paintbucket tool, for example.\nTo get this behavior, turn synchronization off, then get and set the\ninitial style (rather than the current style) while the tool is selected."]
    pub SetSyncInitialPathStyle:
        ::std::option::Option<unsafe extern "C" fn(syncInitialPathStyle: AIBoolean) -> AIErr>,
    #[doc = " Reports the synchronization state for the initial path style.\n(Note that this function returns a boolean value, not an error code.)\n@return True if synchronization is on.\n@see \\c #SetSyncInitialPathStyle()"]
    pub GetSyncInitialPathStyle: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Examines or modifies colors in an object by calling a developer-defined callback function.\n@param art The art object, or \\c NULL to iterate through the entire art tree of\nthe current document.\n@param adjustColorCallback The developer-defined callback procedure.\n@param clientData Optional developer-defined data to pass through to the callback.\n@param controlFlags Options for how colors are enumerated to the callback,\na logical OR of \\c #VisitAIColorFlagValues.\n@param madeReplacement [out] Optional, a buffer in which to return true if any\ncolors were replaced.\n@note You can use this to simply visit all the colors used in a document or in the selection,\nfor static purposes such as building up a collection of colors or compiling statistics on them.\nYou could iterate twice, once to collect statistics and again to make changes, for example\nto average colors or to posterize art based on a histogram of the colors that it uses."]
    pub AdjustObjectAIColors: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            adjustColorCallback: AIAdjustColorFunc,
            clientData: *mut ::std::os::raw::c_void,
            controlFlags: VisitAIColorFlags,
            madeReplacement: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the path style used to fill and/or stroke a path art object and\nthe visibility of fill and stroke.\n@param path The art object.\n@param style [out] A buffer in which to return the style.\n@param fillVisible [out] A buffer in which to return true if fill is visible.\n@param strokeVisible [out] A buffer in which to return true if stroke is visible.\n@return The error \\c #kBadParameterErr if the art object is not an\nallowed type."]
    pub GetPathStyleEx: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            style: *mut AIPathStyle,
            fillVisible: *mut AIBoolean,
            strokeVisible: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the path style used to fill and/or stroke a path art object\nand the visibility of fill and stroke, if the object is one of these types:\n<br> \\c #kPathArt\n<br> \\c #kCompoundPathArt\n<br> \\c #kRasterArt\n<br> \\c #kMeshArt\n<br> \\c #kPlacedArt\n<br> \\c #kTextFrameArt\n\nFor group types, (\\c #kGroupArt, \\c #kPluginArt, \\c #kSymbolArt),\nmodifies the existing fill or stroke. If there is no existing fill or\nstroke value, has no effect. Use the \\c #AIArtStyleSuite to add a new\nfill or stroke to a group object.\n\n@param path The art object.\n@param style The new style.\n@return The error \\c #kBadParameterErr if the art object is not an\nallowed type (\\c #kForeignArt, \\c #kLegacyTextArt, \\c #kUnknownArt)."]
    pub SetPathStyleEx: ::std::option::Option<
        unsafe extern "C" fn(
            path: AIArtHandle,
            style: *const AIPathStyle,
            fillVisible: AIBoolean,
            strokeVisible: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the common attributes of the current selected objects\n@param style [out] A buffer in which to return the partial style containing\nthe common attributes.\n@param stylemap [out] A buffer in which to return the map indicating which\nfields of the partial style contain valid values."]
    pub GetCurrentPathStyleEx: ::std::option::Option<
        unsafe extern "C" fn(
            style: *mut AIPathStyle,
            stylemap: *mut AIPathStyleMap,
            fillVisible: *mut AIBoolean,
            strokeVisible: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Applies a path style to any currently selected and paint-targeted objects.\nFor this function to apply, a targeted object must be a path or compound path,\nor have a style that already contains a fill or stroke.\nIf a targeted object has an active style, the new style is merged\ninto the focal fill and stroke filters. Any effects and non-focal fills\nand strokes remain unmodified.\n@param style The new partial style.\n@param stylemap The map indicating which fields of the partial style\ncontain valid values.\n@param fillVisible True if fill should be visible.\n@param strokeVisible True if stroke should be visible.\n@note To completely replace active styles, use\n\\c #SetCurrentPathStyleForceSimple()"]
    pub SetCurrentPathStyleEx: ::std::option::Option<
        unsafe extern "C" fn(
            style: *mut AIPathStyle,
            stylemap: *mut AIPathStyleMap,
            fillVisible: AIBoolean,
            strokeVisible: AIBoolean,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nUse these functions to work with fixed-point numbers. These\nexist primarily for use by older plug-ins that were fixed-point based. Modern\nplug-ins should use the \\c #AIRealMathSuite.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFixedMathSuite and \\c #kAIFixedMathVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFixedMathSuite {
    pub FixedAdd: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFixed>,
    pub FixedMul: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFixed>,
    pub FractMul: ::std::option::Option<unsafe extern "C" fn(a: AIFract, b: AIFract) -> AIFract>,
    pub FractFixedMul:
        ::std::option::Option<unsafe extern "C" fn(a: AIFract, b: AIFixed) -> AIFixed>,
    pub FixedDiv: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFixed>,
    pub FractDiv: ::std::option::Option<unsafe extern "C" fn(a: AIFract, b: AIFract) -> AIFract>,
    pub ShortRatio:
        ::std::option::Option<unsafe extern "C" fn(a: ai_int16, b: ai_int16) -> AIFixed>,
    pub FixedRatio: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFract>,
    pub FractRatio: ::std::option::Option<unsafe extern "C" fn(a: AIFract, b: AIFract) -> AIFixed>,
    pub FixedMulAdd: ::std::option::Option<
        unsafe extern "C" fn(a: AIFixed, b: AIFixed, c: AIFixed, d: AIFixed) -> AIFixed,
    >,
    pub FixedMultiple: ::std::option::Option<
        unsafe extern "C" fn(a: AIFixed, multiple: AIFixed, ceiling: AIBoolean) -> AIFixed,
    >,
    pub FixedSin: ::std::option::Option<unsafe extern "C" fn(a: AIFixed) -> AIFract>,
    pub FixedCos: ::std::option::Option<unsafe extern "C" fn(a: AIFixed) -> AIFract>,
    pub FixedATan: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFixed>,
    pub DegreeToRadian: ::std::option::Option<unsafe extern "C" fn(degree: AIFixed) -> AIFixed>,
    pub RadianToDegree: ::std::option::Option<unsafe extern "C" fn(radian: AIFixed) -> AIFixed>,
    pub FractSqrt: ::std::option::Option<unsafe extern "C" fn(a: AIUFract) -> AIUFract>,
    pub FixedLength: ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed) -> AIFixed>,
    pub FixedInterpolate:
        ::std::option::Option<unsafe extern "C" fn(a: AIFixed, b: AIFixed, t: AIFixed) -> AIFixed>,
    pub FixedToFloat: ::std::option::Option<unsafe extern "C" fn(a: AIFixed) -> AIFloat>,
    pub FloatToFixed: ::std::option::Option<unsafe extern "C" fn(a: AIFloat) -> AIFixed>,
    pub FractToFloat: ::std::option::Option<unsafe extern "C" fn(a: AIFract) -> AIFloat>,
    pub FloatToFract: ::std::option::Option<unsafe extern "C" fn(a: AIFloat) -> AIFract>,
    pub FixedPointAdd: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedPoint, result: *mut AIFixedPoint),
    >,
    pub FixedPointSubtract: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedPoint, result: *mut AIFixedPoint),
    >,
    pub FixedPointEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedPoint) -> AIBoolean,
    >,
    pub FixedPointClose: ::std::option::Option<
        unsafe extern "C" fn(
            a: *mut AIFixedPoint,
            b: *mut AIFixedPoint,
            tolerance: AIFixed,
        ) -> AIBoolean,
    >,
    pub FixedPointAngle: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedPoint) -> AIFixed,
    >,
    pub FixedPointLength: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedPoint) -> AIFixed,
    >,
    pub FixedPointLengthAngle: ::std::option::Option<
        unsafe extern "C" fn(length: AIFixed, angle: AIFixed, result: *mut AIFixedPoint),
    >,
    pub FixedPointInterpolate: ::std::option::Option<
        unsafe extern "C" fn(
            a: *mut AIFixedPoint,
            b: *mut AIFixedPoint,
            t: AIFixed,
            result: *mut AIFixedPoint,
        ),
    >,
    pub FixedRectSet: ::std::option::Option<
        unsafe extern "C" fn(
            a: *mut AIFixedRect,
            left: AIFixed,
            top: AIFixed,
            right: AIFixed,
            bottom: AIFixed,
        ),
    >,
    pub FixedRectEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedRect, b: *mut AIFixedRect) -> AIBoolean,
    >,
    pub FixedRectEmpty:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIFixedRect) -> AIBoolean>,
    pub FixedRectInset:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIFixedRect, h: AIFixed, v: AIFixed)>,
    pub FixedRectOffset:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIFixedRect, h: AIFixed, v: AIFixed)>,
    pub FixedRectUnion: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedRect, b: *mut AIFixedRect, result: *mut AIFixedRect),
    >,
    pub FixedPointUnion: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedRect, result: *mut AIFixedRect),
    >,
    pub FixedRectOverlap: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedRect, b: *mut AIFixedRect) -> AIBoolean,
    >,
    pub FixedRectIntersect: ::std::option::Option<
        unsafe extern "C" fn(
            a: *mut AIFixedRect,
            b: *mut AIFixedRect,
            result: *mut AIFixedRect,
        ) -> AIBoolean,
    >,
    pub FixedRectInFixedRect: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedRect, b: *mut AIFixedRect) -> AIBoolean,
    >,
    pub FixedPointInFixedRect: ::std::option::Option<
        unsafe extern "C" fn(a: *mut AIFixedPoint, b: *mut AIFixedRect) -> AIBoolean,
    >,
    pub FixedRectAlign:
        ::std::option::Option<unsafe extern "C" fn(a: *mut AIFixedRect, result: *mut AIFixedRect)>,
    pub FixedMatrixSet: ::std::option::Option<
        unsafe extern "C" fn(
            m: *mut AIFixedMatrix,
            a: AIFixed,
            b: AIFixed,
            c: AIFixed,
            d: AIFixed,
            tx: AIFixed,
            ty: AIFixed,
        ),
    >,
    pub FixedMatrixSetIdentity: ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix)>,
    pub FixedMatrixEqual: ::std::option::Option<
        unsafe extern "C" fn(m: *mut AIFixedMatrix, n: *mut AIFixedMatrix) -> AIBoolean,
    >,
    pub FixedMatrixIdentity:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix) -> AIBoolean>,
    pub FixedMatrixSingular:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix) -> AIBoolean>,
    pub FixedMatrixSetTranslate: ::std::option::Option<
        unsafe extern "C" fn(m: *mut AIFixedMatrix, tx: AIFixed, ty: AIFixed),
    >,
    pub FixedMatrixSetScale:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix, h: AIFixed, v: AIFixed)>,
    pub FixedMatrixSetRotate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix, angle: AIFixed)>,
    pub FixedMatrixConcatTranslate: ::std::option::Option<
        unsafe extern "C" fn(m: *mut AIFixedMatrix, tx: AIFixed, ty: AIFixed),
    >,
    pub FixedMatrixConcatScale:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix, h: AIFixed, v: AIFixed)>,
    pub FixedMatrixConcatRotate:
        ::std::option::Option<unsafe extern "C" fn(m: *mut AIFixedMatrix, angle: AIFixed)>,
    pub FixedMatrixConcat: ::std::option::Option<
        unsafe extern "C" fn(
            m: *mut AIFixedMatrix,
            n: *mut AIFixedMatrix,
            result: *mut AIFixedMatrix,
        ),
    >,
    pub FixedMatrixInvert: ::std::option::Option<
        unsafe extern "C" fn(m: *mut AIFixedMatrix) -> ::std::os::raw::c_short,
    >,
    pub FixedMatrixXformPoint: ::std::option::Option<
        unsafe extern "C" fn(
            m: *mut AIFixedMatrix,
            a: *mut AIFixedPoint,
            result: *mut AIFixedPoint,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIPreferenceItemGroupOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a preference item group, never dereferenced.\nAccess with \\c #AIPreferenceSuite"]
pub type AIPreferenceItemGroupHandle = *mut _t_AIPreferenceItemGroupOpaque;
#[doc = " Type for a date/time value stored in preferences,"]
pub type AIPreferenceDateTime = ai_uint32;
#[doc = " Message sent by the preference selectors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPreferencePanelMessage {
    #[doc = " Message data"]
    pub d: SPMessageData,
    #[doc = " The preference item group"]
    pub itemGroup: AIPreferenceItemGroupHandle,
}
#[doc = " @ingroup Suites\nThis suite provides cross-platform access to Illustrator\npreferences. It allows you to store your plug-in�s preferences,\nsave them at shutdown, and restore them at startup. The suite also\nallows you to access Illustrator application preferences at any time.\n\nIllustrator reads the preferences file from disk only once, when the\napplication is first launched, and writes it only once, when the\napplication quits. The Preference suite functions interact with\nthe preferences stored in memory, not with the preferences file on disk.\n\n@section PluginPrefs Accessing Plug-in Preferences\n\nThis suite also allows you to add your plug-in preferences to the\nPreferences dialog box. Generally, your plug-in reads its own\npreferences during the startup message action and writes them at shutdown.\n\nYou get and set values according to their data type. The suite provides\naccessors (get and put functions) for each of the basic data types:\nboolean, integer, real, C string, block, fixed, fract, Pascal string,\ndate/time stamp, point, rect, and file spec.\n\nEach function in the suite takes three arguments:\n\\li The \\e prefix, which is generally your plug-in�s name.\n\\li The \\e suffix, which is the name of a specific preference\nitem in your plug-in.\n\\li The \\e value, which is the new value to be associated with\nthe named preference (for put) or a buffer in which to return\nits current value (for get). If a get function does not find\nthe prefix/suffix pair in the preferences file, the value\nargument remains unchanged; you should preset the buffer\nto the default value for the preference you are retrieving.\n\nFor predefined prefixes and suffixes of application and Adobe plug-in\npreferences, see \\c AIPreferenceKeys.h.\n\nThis example saves and retrieves preferences for a window position\nand visibility status:\n\\verbatim\n// save preferences for plug-in dialog\nerror = sPref->PutBooleanPreference(kPluginName, \"dialogShowing\", g->dialogShowing);\nerror = sPref->PutPointPreference(kPluginName, \"dialogPosition\", &g->dialogPosition);\n//retrieve preferences for plug-in dialog\ng->dialogShowing = false; // default is not visible\nerror = sPref->GetBooleanPreference(kPluginName, \"dialogShowing\", &g->dialogShowing);\ng->dialogPosition = { 100 , 100 }; // default position\nerror = sPref->GetPointPreference(kPluginName, \"dialogPosition\", &g->dialogPosition);\n\\endverbatim\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPreferenceSuite and \\c #kAIPreferenceVersion.\n\n@section AppPrefs Accessing Application Preferences\n\nApplication preferences are predefined. You can examine the preferences\nfile to find their names.\n\\li To specify an application preference, use \\c NULL for the prefix.\nFor the suffix, use a path derived from the preference file without\nthe leading slash character. See also predefined suffixes in\n\\c AIPreferenceKeys.h.\n\\li There is no direct way to determine the data type of an application\npreference. You must determine the data type based on your knowledge\nof Illustrator and the appearance of the value in the preference file.\n\nFor example, the constrain angle used by the Illustrator tools is an application\npreference. It is stored in the preference file at follows:\n\\verbatim\n/constrain {\n/sin 0.0\n/cos 16.0\n/angle 0.0\n}\n\\endverbatim\n\nThese values are real numbers. To retrieve the value of \\c sin,\nuse the accessor for the \\c AIReal type:\n\\verbatim\nAIReal r;\nerror = sPref->GetRealPreference(nullptr, \"constrain/sin\", &r);\n\\endverbatim\n\nThe snap-to-point option is displayed as a checkbox in the General Preferences\ndialog, which implies that it has a boolean value. It is stored in the file as follows:\n\\verbatim\n/snapToPoint 1\n\\endverbatim\n\nTo retrieve the setting, use the boolean accessor:\n\\verbatim\nAIBoolean snap;\nerror = sPref->GetBooleanPreference(nullptr, \"snapToPoint\", &snap);\n\\endverbatim"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPreferenceSuite {
    #[doc = " Retrieves a boolean preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetBooleanPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets a boolean preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutBooleanPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves an integer preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetIntegerPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Sets an integer preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutIntegerPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a real-number preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetRealPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut f64,
        ) -> AIErr,
    >,
    #[doc = " Sets a real-number preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutRealPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: f64,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a C-string preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetStringPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Sets a C-string preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutStringPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a Unicode string preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetUnicodeStringPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Sets a Unicode string preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutUnicodeStringPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a block preference created with \\c #PutBlockPreference().\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param address [out] A buffer in which to return the value.\n@param size The number of bytes allocated at \\c address."]
    pub GetBlockPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            address: *mut ::std::os::raw::c_void,
            size: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Sets a block preference.  Use this to store data that does\nnot fit one of the basic types. For example, you could store\na color value as a single block preference rather than\nthree or four separate integer preferences.\n\nThe preference file is a human-readable (and editable) ASCII file, and\nyou should  respect this in block data that you create. For example,\nwrite out color values as ASCII strings, not as binary values.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param address A buffer containing the new value.\n@param size The number of bytes allocated at \\c address."]
    pub PutBlockPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            address: *mut ::std::os::raw::c_void,
            size: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a fixed-number preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetFixedPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIFixed,
        ) -> AIErr,
    >,
    #[doc = " Sets a fixed-number preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutFixedPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIFixed,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a fractional preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetFractPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIFract,
        ) -> AIErr,
    >,
    #[doc = " Sets a fractional preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutFractPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIFract,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a Pascal-string preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetPascalPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_uchar,
        ) -> AIErr,
    >,
    #[doc = " Sets a Pascal-string preference. (For compatibility with AI7 and earlier.)\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutPascalPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_uchar,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a date-time preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetDateTimePreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIPreferenceDateTime,
        ) -> AIErr,
    >,
    #[doc = " Sets a date-time preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutDateTimePreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIPreferenceDateTime,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a point preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetPointPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Sets a point preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutPointPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a rectangle preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetRectPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Sets a rectangle preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutRectPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a file path specification preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetFilePathSpecificationPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Sets a file path specification preference.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutFilePathSpecificationPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *const ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Deletes a preference that was defined by your plug-in.\nDo not attempt to remove any other preferences.\n@param prefix The name of the plug-in.\n@param suffix The name of the preference."]
    pub RemovePreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Adds a panel to the Preferences dialog, using a dialog you define to\nquery the user for your plug-in preferences. Adds a menu item for your panel\nto the Preferences submenu, creating and returning the menu item object.\n@param pluginRef The plug-in object.\n@param itemText The localizable string that appears in the Preferences submenu\nand in the Preferences dialog pop-up menu.\n@param dialogID The unique identifier of the dialog you have defined in your\nplug-in resources. The elements are added to the Preferences dialog\nas an item group. See \\c #ADMDialogSuite10 and \\c #ADMItemSuite9.\n@param options Not used. Pass 0.\n@param prefItemGroup [out] A buffer in which to return the new dialog item-group\nreference for the panel. This panel object is passed back as part of the\n\\c #AIPreferencePanelMessage when the panel is shown in the dialog. Use it\nwith \\c #GetPreferencePanelBaseItemIndex()\nto access the dialog items when the panel is displayed.\n@param menuItem [out] A buffer in which to return the new menu item reference."]
    pub AddPreferencePanel: ::std::option::Option<
        unsafe extern "C" fn(
            pluginRef: SPPluginRef,
            itemText: *mut ::std::os::raw::c_uchar,
            dialogID: ai_int32,
            options: ai_int32,
            prefItemGroup: *mut AIPreferenceItemGroupHandle,
            menuItem: *mut AIMenuItemHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the index position of the base item from a preference item group.\nAll identifiers for items in your Preferences panel are offset by this value.\nThe call is only valid when the Preferences dialog is displayed.\n@param prefItemGroup TThe panel item-group object, as returned by\n\\c #AddPreferencePanel().\n@param baseIndex [out] A buffer in which to return the 0-based position\nindex of the base item."]
    pub GetPreferencePanelBaseItemIndex: ::std::option::Option<
        unsafe extern "C" fn(
            prefItemGroup: AIPreferenceItemGroupHandle,
            baseIndex: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Displays a plug-in-defined panel in the Preferences dialog.\tCalled\nby the menu item that was created by \\c #AddPreferencePanel().\n@param prefItemGroup The panel item-group object, as returned by\n\\c #AddPreferencePanel()."]
    pub ShowPreferencePanel: ::std::option::Option<
        unsafe extern "C" fn(prefItemGroup: AIPreferenceItemGroupHandle) -> AIErr,
    >,
    #[doc = " Retrieves an integer preference for 64 bit data type.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value [out] A buffer in which to return the value."]
    pub GetLargeIntegerPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ai_int64,
        ) -> AIErr,
    >,
    #[doc = " Sets an integer preference for 64 bit data type.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param value The new value."]
    pub PutLargeIntegerPreference: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: ai_int64,
        ) -> AIErr,
    >,
    #[doc = " Checks if a Preference Exists.\n@param prefix The name of the plug-in, or \\c NULL for an application preference.\n@param suffix The name of the preference.\n@param doesExist[out] A buffer in which to return whether the preference exists or not."]
    pub PreferenceExists: ::std::option::Option<
        unsafe extern "C" fn(
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            doesExist: *mut AIBoolean,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AITimerOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a timer, never dereferenced. Access with \\c #AITimerSuite"]
pub type AITimerHandle = *mut _t_AITimerOpaque;
#[doc = " The contents of a timer message, sent with \\c #kSelectorAIGoTimer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AITimerMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The timer plug-in receiving the message."]
    pub timer: AITimerHandle,
}
#[doc = " @ingroup Suites\nThese functions allow you to schedule events by registering timer plug-ins.\nUse these functions to add timers, turn timers on and\noff, and enumerate and access the installed timer plug-ins.\n\nIllustrator notifies registered timer plug-ins when a specified period of\ntime has passed.  It sends a message to the plug-in's main entry point\nwith caller \\c #kCallerAITimer and selector \\c #kSelectorAIGoTimer.\n\nTimer periods are specified in clock ticks. There are \\c #kTicksPerSecond\nticks in a second.\n\nTimers are typically used in conjunction with other plug-ins, such as\nmenus or windows, which determine when an update is\tneeded.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAITimerSuite and \\c #kAITimerVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AITimerSuite {
    #[doc = " Adds a timer plug-in to Illustrator. Use at startup.\n@param self This plug-in.\n@param name The unique identifying name of the timer.\n@param period The time period for notification, the number of\nclock ticks that should pass before the timer is notified.\nFor seconds, multiply the number of seconds by \\c #kTicksPerSecond.\n@param timer [out] A buffer in which to return the timer reference.\nIf you install more than one timer plug-in, save to compare\nto the reference passed in the \\c #AITimerMessage to determine\nwhich action to take.\n\nThis call requests notification once a second:\n@code\nAIErr error;\nerror = sTimer->AddTimer( message->d.self, \"Time for Timer\", kTicksPerSecond, &g->secondTimer );\n@endcode"]
    pub AddTimer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            period: ai_int32,
            timer: *mut AITimerHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the name string of a timer.\n@param time The timer reference.\n@param name [out] A buffer in which to return the name string.\nDo not modify this string."]
    pub GetTimerName: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, name: *mut *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Reports whether a timer is active. An active timer receives\nperiodic notifications.\n@param time The timer reference.\n@param active [out] A buffer in which to return true if\nthe timer is active."]
    pub GetTimerActive: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, active: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Activates or deactivates a timer. You must deactivate timers\nas part of terminating the plug-in.\n@param time The timer reference.\n@param active True to activate the timer, false to deactivate it."]
    pub SetTimerActive: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, active: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the notification interval for a timer.\n@param time The timer reference.\n@param period [out] A buffer in which to return the\ninterval, in clock ticks. ."]
    pub GetTimerPeriod: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, period: *mut ai_int32) -> AIErr,
    >,
    #[doc = "  Sets the notification interval for a timer.\n@param time The timer reference.\n@param period The new interval, in clock ticks. For seconds,\nmultiply the number of seconds by \\c #kTicksPerSecond."]
    pub SetTimerPeriod: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, period: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the plug-in that installed a timer, to\nuse with the \\c #AIPluginSuite.\n@param time The timer reference.\n@param plugin [out] A buffer in which to return the\nplug-in reference."]
    pub GetTimerPlugin: ::std::option::Option<
        unsafe extern "C" fn(timer: AITimerHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Counts the number of timers available. Use with \\c #GetNthTimer()\nto iterate through installed timers.\n@param count [out] A buffer in which to return the number\nof installed timers."]
    pub CountTimers: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a timer by position index. Use with \\c #CountTimers()\nto iterate through installed timers.\n@param n The 0-based position index.\n@param timer [out] A buffer in which to return the timer reference."]
    pub GetNthTimer: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, timer: *mut AITimerHandle) -> AIErr,
    >,
}
#[doc = " Modifier keys for an event. See \\c #AIEventModifersValue.\nUsed in the \\c #AIToolSuite and \\c #AICursorSnapSuite."]
pub type AIEventModifiers = ASUInt16;
#[doc = " Not used."]
pub const AIEventModifersValue_aiEventModifiers_activeFlag: AIEventModifersValue = 1;
#[doc = " Mask. Main mouse button down."]
pub const AIEventModifersValue_aiEventModifiers_btnState: AIEventModifersValue = 128;
#[doc = " Mask. Either Cmd key is pressed in Mac OS, or the Ctrl key in Windows."]
pub const AIEventModifersValue_aiEventModifiers_cmdKey: AIEventModifersValue = 256;
#[doc = " Mask. Either Shift key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_shiftKey: AIEventModifersValue = 512;
#[doc = " Not used."]
pub const AIEventModifersValue_aiEventModifiers_alphaLock: AIEventModifersValue = 1024;
#[doc = " Mask. The Alt or Option key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_optionKey: AIEventModifersValue = 2048;
#[doc = " Mask. The Ctrl key is pressed in Mac OS. Not used in Windows."]
pub const AIEventModifersValue_aiEventModifiers_controlKey: AIEventModifersValue = 4096;
#[doc = " Mask. The right Shift key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_rightShiftKey: AIEventModifersValue = 8192;
#[doc = " Mask. The right Alt or Option key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_rightOptionKey: AIEventModifersValue = 16384;
#[doc = " Mask. The right Ctrl key is pressed in Mac OS. Not used in Windows."]
pub const AIEventModifersValue_aiEventModifiers_rightControlKey: AIEventModifersValue = 32768;
#[doc = " Not used."]
pub const AIEventModifersValue_aiEventModifiers_activeFlagBit: AIEventModifersValue = 0;
#[doc = " Bit flag. When set, the main mouse button is down."]
pub const AIEventModifersValue_aiEventModifiers_btnStateBit: AIEventModifersValue = 7;
#[doc = " Bit flag. When set, either the Cmd key is pressed in Mac OS, or the Ctrl key in Windows."]
pub const AIEventModifersValue_aiEventModifiers_cmdKeyBit: AIEventModifersValue = 8;
#[doc = " Bit flag. When set, either Shift key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_shiftKeyBit: AIEventModifersValue = 9;
#[doc = " Not used."]
pub const AIEventModifersValue_aiEventModifiers_alphaLockBit: AIEventModifersValue = 10;
#[doc = " Bit flag. When set, the Alt or Option key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_optionKeyBit: AIEventModifersValue = 11;
#[doc = " Bit flag. The Ctrl key is pressed in Mac OS. Not used in Windows."]
pub const AIEventModifersValue_aiEventModifiers_controlKeyBit: AIEventModifersValue = 12;
#[doc = " Bit flag. When set, the right Shift key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_rightShiftKeyBit: AIEventModifersValue = 13;
#[doc = " Bit flag. When set, the right Alt or Option key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_rightOptionKeyBit: AIEventModifersValue = 14;
#[doc = " Bit flag. When set, the right Ctrl key is pressed in Mac OS. Not used in Windows."]
pub const AIEventModifersValue_aiEventModifiers_rightControlKeyBit: AIEventModifersValue = 15;
#[doc = " Mask. Space bar is pressed."]
pub const AIEventModifersValue_aiEventModifiers_spaceKey: AIEventModifersValue = 2;
#[doc = " Mask. Tab key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_tabKey: AIEventModifersValue = 4;
#[doc = " Mask. Caps Lock is on."]
pub const AIEventModifersValue_aiEventModifiers_capsLockOn: AIEventModifersValue = 8;
#[doc = " Mask. Double click."]
pub const AIEventModifersValue_aiEventModifiers_doubleClick: AIEventModifersValue = 16;
#[doc = " Mask. Triple click."]
pub const AIEventModifersValue_aiEventModifiers_tripleClick: AIEventModifersValue = 32;
#[doc = " Bit flag. When set, the space bar is pressed."]
pub const AIEventModifersValue_aiEventModifiers_spaceKeyBit: AIEventModifersValue = 1;
#[doc = " Bit flag. When set, the tab key is pressed."]
pub const AIEventModifersValue_aiEventModifiers_tabKeyBit: AIEventModifersValue = 2;
#[doc = " Bit flag. When set, Caps Lock is on."]
pub const AIEventModifersValue_aiEventModifiers_capsLcokBit: AIEventModifersValue = 3;
#[doc = " Bit flag. When set, there was a double click."]
pub const AIEventModifersValue_aiEventModifiers_doubleClickBit: AIEventModifersValue = 4;
#[doc = " Bit flag. When set, there was a triple click."]
pub const AIEventModifersValue_aiEventModifiers_tripleClickBit: AIEventModifersValue = 5;
#[doc = " Event modifier key masks and bit flags, used in deprecated ADM functions.\nUse masks to check values, bit flags to bit-shift values to a position."]
pub type AIEventModifersValue = ::std::os::raw::c_uint;
#[doc = " Set to receive \\c #kSelectorAITrackToolCursor, which allows you to\ncontrol the cursor for your too. When off (the default), a standard arrow\ncursor is used for the tool."]
pub const AIToolOptions_kToolWantsToTrackCursorOption: AIToolOptions = 1;
#[doc = " Set to disable automatic scrolling. When off (the default), the Illustrator window\nscrolls when a tool reaches the edge. For tools that manipulate artwork,\nautoscroll is useful. Set this to turn autoscroll off for a tool that\ndraws to the screen directly, like the built-in Brush tool."]
pub const AIToolOptions_kToolDoesntWantAutoScrollOption: AIToolOptions = 2;
#[doc = "\tSet to buffer the drag selectors and messages and send all of them\nto the tool at once. Useful if a tool is calculation intensive.  The effect\nis no longer real-time, but has a smoother final output.\nWhen off (the default), the tool processes drag selectors and returns frequently,\nresulting in near real-time feedback. If there are intensive calculations\nduring the drag selector, the tool could miss drag notifications, resulting in rougher\ntracking."]
pub const AIToolOptions_kToolWantsBufferedDraggingOption: AIToolOptions = 4;
#[doc = " Set to maintain the edit context when this tool is selected. For art objects,\nkeeps all current points and handles selected. For text, keeps the insertion\npoint in the current location. Set this option for navigational tools like\nthe Zoom and Scroll tools."]
pub const AIToolOptions_kToolMaintainEditContextOption: AIToolOptions = 8;
#[doc = " Set to maintain the text edit context when the tool is selected,\nif \\c #kToolMaintainEditContextOption is also set."]
pub const AIToolOptions_kToolIsTextToolOption: AIToolOptions = 16;
#[doc = " Set to receive \\c #kSelectorAIToolDecreaseDiameter and\n\\c #kSelectorAIToolIncreaseDiameter. Use if the tool needs to change\ndiameter when either '[' or ']' is pressed."]
pub const AIToolOptions_kToolWantsToChangeDiameterOption: AIToolOptions = 32;
#[doc = " Set to allow switching to an alternate selection tool when user presses Ctrl (in Windows) or Cmd (in Mac OS).\nThis option can be set for any plug-in tool. Set the preferred alternate selection tool\nusing \\c #AIToolSuite::SetAlternateSelectionToolName().\nBy default, the alternate tool is \\c #kSelectTool(), \\c #kDirectSelectTool(), or \\c #kDirectObjectSelectTool()"]
pub const AIToolOptions_kToolWantsAlternateSelectionTool: AIToolOptions = 64;
#[doc = " Set to hide a plugin toolset in the tool box. Hidden tools can still be used through shortcuts\nor through suite APIs, but are not shown in the tool box.\nMust be set or cleared on creation; you cannot change the hidden status with \\c #AIToolSuite::SetToolOptions().\nSetting this option for a single tool in a toolset has no effect unless it is set for all tools in the toolset.\nIt is recommended that you create a set of hidden tools, then show and hide individual tools by adding them to\nor removing them from the hidden set."]
pub const AIToolOptions_kToolWantsHiddenToolOption: AIToolOptions = 128;
#[doc = " Indicates that the tool does not support soft selection modes, when used with the tablet/pen. \\c #AIToolSuite::SetSoftSelectedTool().\nThe inverted tablet pen tool will still function as the original tool."]
pub const AIToolOptions_kToolDoesntWantSoftSelectionOption: AIToolOptions = 256;
#[doc = " Indicates that tool does want OS to draw its wet ink and provide its final Ink points to render rather than listening to mouse events"]
pub const AIToolOptions_kToolWantsOSHandleInk: AIToolOptions = 512;
#[doc = " Indicates that the tool has a double-click action associated with it."]
pub const AIToolOptions_kToolHasAlternateAction: AIToolOptions = 1024;
#[doc = "  Indicates that the tool wants to handle radial device events such as rotate and click"]
pub const AIToolOptions_kToolWantsRadialDeviceEvents: AIToolOptions = 2048;
#[doc = "\t Indicates that the tool does not want art style execution suspension while in drag loop"]
pub const AIToolOptions_kToolDoesntWantArtStyleExecutionSuspender: AIToolOptions = 4096;
#[doc = "\t Indicates that the tool handles its own drag loop and don't use the default toolDragLoop"]
pub const AIToolOptions_kToolHasItsOwnDragLoop: AIToolOptions = 8192;
#[doc = "  Bit flags for options that can be set by a plug-in tool when it is installed\nwith \\c #AIToolSuite::AddTool(), or later with \\c #AIToolSuite::SetToolOptions()."]
pub type AIToolOptions = ::std::os::raw::c_uint;
pub const AIToolInfoVariable_kInfoPageX: AIToolInfoVariable = 0;
pub const AIToolInfoVariable_kInfoPageY: AIToolInfoVariable = 1;
pub const AIToolInfoVariable_kInfoSizeX: AIToolInfoVariable = 2;
pub const AIToolInfoVariable_kInfoSizeY: AIToolInfoVariable = 3;
pub const AIToolInfoVariable_kInfoDistance: AIToolInfoVariable = 4;
pub const AIToolInfoVariable_kInfoVectorAngle: AIToolInfoVariable = 5;
pub const AIToolInfoVariable_kInfoScaleX: AIToolInfoVariable = 6;
pub const AIToolInfoVariable_kInfoScaleY: AIToolInfoVariable = 7;
pub const AIToolInfoVariable_kInfoZoom: AIToolInfoVariable = 8;
pub const AIToolInfoVariable_kInfoCornerRoundness: AIToolInfoVariable = 9;
pub const AIToolInfoVariable_kInfoRotAngle: AIToolInfoVariable = 10;
pub const AIToolInfoVariable_kInfoShearAngle: AIToolInfoVariable = 11;
pub const AIToolInfoVariable_kInfoFontAndSize: AIToolInfoVariable = 12;
pub const AIToolInfoVariable_kInfoTrackOrKern: AIToolInfoVariable = 13;
pub const AIToolInfoVariable_kInfoRawRotAngle: AIToolInfoVariable = 14;
pub const AIToolInfoVariable_kInfoDocX: AIToolInfoVariable = 15;
pub const AIToolInfoVariable_kInfoDocY: AIToolInfoVariable = 16;
pub const AIToolInfoVariable_kInfoText1: AIToolInfoVariable = 17;
pub const AIToolInfoVariable_kInfoText2: AIToolInfoVariable = 18;
pub const AIToolInfoVariable_kInfoText3: AIToolInfoVariable = 19;
pub const AIToolInfoVariable_kInfoText4: AIToolInfoVariable = 20;
pub const AIToolInfoVariable_kInfoText5: AIToolInfoVariable = 21;
pub const AIToolInfoVariable_kInfoText6: AIToolInfoVariable = 22;
pub const AIToolInfoVariable_kInfoLongText3: AIToolInfoVariable = 23;
pub const AIToolInfoVariable_kInfoArea: AIToolInfoVariable = 24;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextX: AIToolInfoVariable = 25;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextY: AIToolInfoVariable = 26;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextW: AIToolInfoVariable = 27;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextH: AIToolInfoVariable = 28;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoNumVars: AIToolInfoVariable = 29;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoBlank: AIToolInfoVariable = 30;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode1: AIToolInfoVariable = 31;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode2: AIToolInfoVariable = 32;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode3: AIToolInfoVariable = 33;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode4: AIToolInfoVariable = 34;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode5: AIToolInfoVariable = 35;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoTextUnicode6: AIToolInfoVariable = 36;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoLongTextUnicode1: AIToolInfoVariable = 37;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoLongTextUnicode2: AIToolInfoVariable = 38;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoLongTextUnicode3: AIToolInfoVariable = 39;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoLongText1: AIToolInfoVariable = 12;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoLongText2: AIToolInfoVariable = 13;
#[doc = " Pass Custom String for: X Y W H display in info palette"]
pub const AIToolInfoVariable_kInfoEndOfList: AIToolInfoVariable = -1;
#[doc = " Tool information values. See \\c #AIToolSuite::SetToolInfoVars().\nAll values are real numbers, except these string values,\nwhich are  platform-encoded strings passed as \\c char*:\n<br> \\c kInfoFontAndSize\n<br> \\c kInfoTrackOrKern\n<br> \\c kInfoText1-6 and \\c kInfoLongText1-3\n<br><br> \\c kInfoTextUnicode1-6 and \\c kInfoLongTextUnicode1-3 refer to the\nsame Info palette slots as \\c kInfoText1-6 and \\c kInfoLongText1-3, but\nvalues are \\c ai::UnicodeString*, which is treated as \\c const."]
pub type AIToolInfoVariable = ::std::os::raw::c_int;
#[doc = " A tool number used to indicate a tool group or toolset.\nSee @ref Toolsets and \\c #AIToolSuite::GetToolNumberFromName()"]
pub type AIToolType = ai_int16;
pub type AIToolTime = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIToolOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a tool plug-in, never dereferenced.\nAccess with \\c #AIToolSuite."]
pub type AIToolHandle = *mut _t_AIToolOpaque;
#[doc = " Information about the change that caused a\n\\c #kAIEffectiveToolChangedNotifier notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIEffectiveToolChangeData {
    #[doc = " Name of currently effective tool."]
    pub currentToolName: *const ::std::os::raw::c_char,
    #[doc = " Name of previous effective tool."]
    pub lastToolName: *const ::std::os::raw::c_char,
    #[doc = " True if tool change is temporary, false if it\nis permanent. Temporary changes occur when user\npresses a modifier key such as Cmd or Space."]
    pub isToolChangeTemporary: AIBoolean,
    #[doc = " Tool handle for current effective tool.\nCan be null in case of select or direct-select tool."]
    pub currentToolHandle: AIToolHandle,
    #[doc = " Tool handle for previous effective tool.\nCan be null if previous tool was select or direct-select,\nor if tool has not yet been changed since app launch."]
    pub lastToolHandle: AIToolHandle,
    #[doc = " Tool number of the currently effective tool."]
    pub currentToolNum: AIToolType,
    #[doc = " Tool number of the previously effective tool."]
    pub lastToolNum: AIToolType,
}
#[doc = " Information needed to add a tool using \\c #AIToolSuite::AddTool()."]
#[repr(C)]
#[derive(Debug)]
pub struct AIAddToolData {
    #[doc = " Display name for tool."]
    pub title: ai_UnicodeString,
    #[doc = " Short descriptive string shown when tool is activated."]
    pub tooltip: ai_UnicodeString,
    #[doc = " The icon shown in the Tools palette; must be of type 'PNGI'"]
    pub normalIconResID: ai_uint32,
    #[doc = " The icon shown in the Tools palette in dark mode; must be of type 'PNGI'"]
    pub darkIconResID: ai_uint32,
    #[doc = " The Tools palette group to which this tool belongs.\nA tool number or \\c #kNoTool to create a new group.\nSee @ref Toolsets."]
    pub sameGroupAs: AIToolType,
    #[doc = " The Tools palette toolset to which this tool belongs.\nA tool number or \\c #kNoTool to create a new toolset.\nSee @ref Toolsets."]
    pub sameToolsetAs: AIToolType,
    pub iconType: ai_IconType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIDataStack {
    _unused: [u8; 0],
}
#[doc = " For internal use only."]
pub type AIDataStackRef = *mut _AIDataStack;
#[doc = " For internal use only."]
#[repr(C)]
#[derive(Debug)]
pub struct AIAddToolDataPrivate {
    #[doc = " Display name for tool."]
    pub title: ai_UnicodeString,
    #[doc = " Short descriptive string shown when tool is activated."]
    pub tooltip: ai_UnicodeString,
    #[doc = " @deprecated Obsolete. Do not use."]
    pub iconResourceDictionary: AIDataStackRef,
    #[doc = " The Tools palette group to which this tool belongs.\nA tool number or \\c #kNoTool to create a new group.\nSee @ref Toolsets."]
    pub sameGroupAs: AIToolType,
    #[doc = " The Tools palette toolset to which this tool belongs.\nA tool number or \\c #kNoTool to create a new toolset.\nSee @ref Toolsets."]
    pub sameToolsetAs: AIToolType,
    pub iconType: ai_IconType,
}
#[doc = " An \\c #AIToolTabletPointerTypeValue describing a type of pointing device.\nUsed with a pressure-sensitive input device, such as a graphic tablet."]
pub type AIToolTabletPointerType = ai_int16;
pub const AIToolTabletPointerTypeValue_kAIToolTabletPointerTypeUnknown:
    AIToolTabletPointerTypeValue = 0;
#[doc = " Pen end of a stylus."]
pub const AIToolTabletPointerTypeValue_kAIToolTabletPointerTypePen: AIToolTabletPointerTypeValue =
    1;
#[doc = " Mouse or other non-pressure-sensitive pointer device."]
pub const AIToolTabletPointerTypeValue_kAIToolTabletPointerTypeCursor:
    AIToolTabletPointerTypeValue = 2;
#[doc = " Eraser end of a stylus."]
pub const AIToolTabletPointerTypeValue_kAIToolTabletPointerTypeEraser:
    AIToolTabletPointerTypeValue = 3;
#[doc = " \\c #AIToolTabletPointerType constants that describe the type of\ninput being received from input devices."]
pub type AIToolTabletPointerTypeValue = ::std::os::raw::c_uint;
#[doc = " An \\c #AIToolPressureValue indicating the amount of force being\napplied with a pressure-sensitive input device, such as a graphic tablet."]
pub type AIToolPressure = ai_int16;
#[doc = " The maximum pressure applied by a tool"]
pub const AIToolPressureValue_kAIMaxToolPressure: AIToolPressureValue = 255;
#[doc = " The minimal pressure applied by a tool"]
pub const AIToolPressureValue_kAIMinToolPressure: AIToolPressureValue = 0;
#[doc = " A default value for when there is no pressure data."]
pub const AIToolPressureValue_kAINormalToolPressure: AIToolPressureValue = 127;
#[doc = " \\c #AIToolPressure constants that indicate an amount of force applied to a\npressure-sensitive input device."]
pub type AIToolPressureValue = ::std::os::raw::c_uint;
#[doc = " An \\c #AIToolAngleValue describing values of an input device\nsuch as tilt, rotation and bearing of a pen on a graphic tablet."]
pub type AIToolAngle = ai_int16;
#[doc = " Angle constants in degrees"]
pub const AIToolAngleValue_kAIToolAngle0: AIToolAngleValue = 0;
#[doc = " Angle constants in degrees"]
pub const AIToolAngleValue_kAIToolAngle90: AIToolAngleValue = 90;
#[doc = " Angle constants in degrees"]
pub const AIToolAngleValue_kAIToolAngleNegative179: AIToolAngleValue = -179;
#[doc = " Angle constants in degrees"]
pub const AIToolAngleValue_kAIToolAngle180: AIToolAngleValue = 180;
#[doc = " Angle constants in degrees"]
pub const AIToolAngleValue_kAIToolAngle360: AIToolAngleValue = 360;
#[doc = " Bearing ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolMinBearing: AIToolAngleValue = -179;
#[doc = " Bearing ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolMaxBearing: AIToolAngleValue = 180;
#[doc = " Bearing ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolNormalBearing: AIToolAngleValue = 0;
#[doc = " Rotation ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolMinRotation: AIToolAngleValue = -179;
#[doc = " Rotation ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolMaxRotation: AIToolAngleValue = 180;
#[doc = " Rotation ranges from -179 to 180 where 0 is up"]
pub const AIToolAngleValue_kAIToolNormalRotation: AIToolAngleValue = 0;
#[doc = " Tilt ranges from 0 to 90 where 0 means that the pen barrel is perpendicular to the tablet's plane\nand 90 means that the pen barrel is parallel to the tablet's plane."]
pub const AIToolAngleValue_kAIToolMinTilt: AIToolAngleValue = 0;
#[doc = " Tilt ranges from 0 to 90 where 0 means that the pen barrel is perpendicular to the tablet's plane\nand 90 means that the pen barrel is parallel to the tablet's plane."]
pub const AIToolAngleValue_kAIToolMaxTilt: AIToolAngleValue = 90;
#[doc = " Tilt ranges from 0 to 90 where 0 means that the pen barrel is perpendicular to the tablet's plane\nand 90 means that the pen barrel is parallel to the tablet's plane."]
pub const AIToolAngleValue_kAIToolNormalTilt: AIToolAngleValue = 0;
#[doc = " \\c #AIToolAngle constants that describe values of an input device\nsuch as tilt, rotation and bearing of a pen on a graphic tablet."]
pub type AIToolAngleValue = ::std::os::raw::c_int;
pub const AITabletCapabilities_kXCoordinate: AITabletCapabilities = 1;
pub const AITabletCapabilities_kYCoordinate: AITabletCapabilities = 2;
pub const AITabletCapabilities_kZCoordinate: AITabletCapabilities = 4;
pub const AITabletCapabilities_kNormalPressure: AITabletCapabilities = 8;
pub const AITabletCapabilities_kTangentPressure: AITabletCapabilities = 16;
pub const AITabletCapabilities_kAltitudeOrientation: AITabletCapabilities = 32;
pub const AITabletCapabilities_kAzimuthOrientation: AITabletCapabilities = 64;
pub const AITabletCapabilities_kTwistOrientation: AITabletCapabilities = 128;
#[doc = " \\c #AITabletCapabilities constants that describe the hardware capabilities of a graphic tablet/ Integrated digitizer."]
pub type AITabletCapabilities = ::std::os::raw::c_uint;
pub const AIToolMessageFlags_kAIToolMsgInkSimulationFlag: AIToolMessageFlags = 1;
pub const AIToolMessageFlags_kAIToolMsgModifierKeyPressedDuringInk: AIToolMessageFlags = 2;
pub const AIToolMessageFlags_kAIToolMsgIsDragOver: AIToolMessageFlags = 4;
pub type AIToolMessageFlags = ::std::os::raw::c_uint;
#[doc = " History Data associated with an Event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIEventHistoryData {
    #[doc = " The location of the event"]
    pub position: AIPoint,
    #[doc = " For graphic tablets, tangential pressure on the finger wheel of the airbrush tool."]
    pub stylusWheel: AIToolPressure,
    #[doc = " How the tool is angled, also called altitude or elevation."]
    pub tilt: AIToolAngle,
    #[doc = " The direction of tilt, measured clockwise in degrees around the Z axis, also called azimuth,"]
    pub bearing: AIToolAngle,
    #[doc = "  Rotation of the tool, measured clockwise in degrees around the tool's barrel."]
    pub rotation: AIToolAngle,
}
#[doc = " The contents of a tool message."]
#[repr(C)]
#[derive(Debug)]
pub struct AIToolMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The tool plug-in receiving the message.\nIf the plug-in has more than one tool installed, it can\ndetermine which one was selected by comparing this handle\nto those it has saved in the \\c globals variable."]
    pub tool: AIToolHandle,
    #[doc = " The location of the mouse cursor in page coordinates."]
    pub cursor: AIRealPoint,
    #[doc = " The amount of force being applied to a pressure-sensitive input device,\nsuch as a graphics tablet.  Use \\c #AIToolSuite::SystemHasPressure()\nto determine if such a device is in use."]
    pub pressure: AIToolPressure,
    #[doc = " For mouse selectors, the ADM event record for the mouse event,\ncontaining additional information about the event. (ADM is no longer supported)."]
    pub event: *mut AIEvent,
    #[doc = " For graphic tablets, tangential pressure on the finger wheel of the airbrush tool."]
    pub stylusWheel: AIToolPressure,
    #[doc = " How the tool is angled, also called altitude or elevation."]
    pub tilt: AIToolAngle,
    #[doc = " The direction of tilt, measured clockwise in degrees around the Z axis, also called azimuth,"]
    pub bearing: AIToolAngle,
    #[doc = "  Rotation of the tool, measured clockwise in degrees around the tool's barrel."]
    pub rotation: AIToolAngle,
    #[doc = " To give more information to listeners of AIToolMessage, it will be composed of values from AIToolMessageFlags"]
    pub flags: ai_int32,
    #[doc = " The history data associated with the event"]
    pub eventHistoryData: ai_AutoBuffer<AIEventHistoryData, ::std::os::raw::c_ulong>,
}
#[doc = " The content of a radial device message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRadialDeviceMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The tool plug-in receiving the message.\nIf the plug-in has more than one tool installed, it can\ndetermine which one is selected by comparing this handle\nto those it saves in the \\c globals variable."]
    pub tool: AIToolHandle,
    #[doc = " Rotation value"]
    pub rotation: AIReal,
}
#[doc = " The contents of a tool notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIToolNotifyData {
    #[doc = " The tool plug-in receiving the notification. If you install more than one tool,\ncompare to your saved reference to decide how to handle the notification."]
    pub tool: AIToolHandle,
}
#[doc = " The contents of an eyedropper drag notification, \\c #kAIEyedropperDragNotifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIEyedropperDragNotifyData {
    #[doc = " The ADM event record for the mouse event. (ADM is no longer supported)."]
    pub event: AIEvent,
    #[doc = " True if the path style has changed as a result of the drag event."]
    pub pathStyleChanged: AIBoolean,
}
#[repr(C)]
pub struct AIDocumentInkParams {
    pub fShape: AIDocumentInkParams_PenTipShape,
    pub fColor: AIColor,
    pub fSize: AIPoint,
    pub fModifiersList: ai_AutoBuffer<ai_uint32, ::std::os::raw::c_ulong>,
    pub fRotation: AIReal,
    pub fSupportPressure: AIBoolean,
    pub fCustomModifierHandling: AIBoolean,
    pub fPressureBasedVariants: ai_int32,
}
pub const AIDocumentInkParams_PenTipShape_kPenTipShapeCircle: AIDocumentInkParams_PenTipShape = 0;
pub const AIDocumentInkParams_PenTipShape_kPenTipShapeRectangle: AIDocumentInkParams_PenTipShape =
    1;
pub type AIDocumentInkParams_PenTipShape = ::std::os::raw::c_uint;
pub const AIDocumentInkParams_PressureBasedVariant_kPressuteBasedVariantNone:
    AIDocumentInkParams_PressureBasedVariant = 1;
pub const AIDocumentInkParams_PressureBasedVariant_kPressuteBasedVariantDia:
    AIDocumentInkParams_PressureBasedVariant = 2;
pub const AIDocumentInkParams_PressureBasedVariant_kPressuteBasedVariantRoundness:
    AIDocumentInkParams_PressureBasedVariant = 4;
pub const AIDocumentInkParams_PressureBasedVariant_kPressuteBasedVariantAngle:
    AIDocumentInkParams_PressureBasedVariant = 8;
pub type AIDocumentInkParams_PressureBasedVariant = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentInkPoint {
    pub fLocation: AIRealPoint,
    pub fPressure: AIToolPressure,
    pub fStylusWheel: AIToolPressure,
    pub fRotation: AIToolAngle,
    pub fBearing: AIToolPressure,
    pub fTilt: AIToolPressure,
}
#[doc = " The contents of a tool message."]
#[repr(C)]
#[derive(Debug)]
pub struct AIToolDryInkMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " To give more information to the listeners of AIToolDryInkMessage, it will be composed of values from AIToolMessageFlags"]
    pub flags: ai_int32,
    #[doc = " The tool plug-in receiving the message.\nIf the plug-in has more than one tool installed, it can\ndetermine which one was selected by comparing this handle\nto those it has saved in the \\c globals variable."]
    pub tool: AIToolHandle,
    #[doc = " Future use We might need this for modifiers"]
    pub event: *mut AIEvent,
    pub inkStrokes: ai_AutoBuffer<AIDocumentInkPoint, ::std::os::raw::c_ulong>,
}
#[doc = "\t@ingroup Suites\nThis suite allows you to provide plug-in tools for Illustrator.\nPlug-in tools can work on existing artwork or create new objects.\nTools that you add appear in the Illustrator Tool palette in their own set,\nor as part of an existing tool set. Use the functions in this suite\nto add tools, set options, and control the tool's appearance in the palette.\n\nTypically, you set the options that control the behavior of a plug-in tool\nwhen you install the tool with \\c #AIToolSuite::AddTool(). You can modify\nthem later with \\c #AIToolSuite::SetToolOptions().\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIToolSuite and \\c #kAIToolVersion.\n\n@section Toolsets Toolsets and Groups in the Tools Palette\n\nIn the Tools palette, \\e a toolset is a collection related tools.\nWhen there is more than one tool in a toolset, only the frontmost tool's\nicon is shown in the palette, with a triangle in the lower left corner\nto indicate the presence of additional tools. The entire toolset\nis shown when the user holds the mouse button down on the topmost tool.\n\nA \\e group is a collection of toolsets. Groups are separated by vertical\nspace in the palette.\n\nTo create a new group or toolset, pass \\c #kNoTool for\n\\c #AIAddToolData::sameGroupAs or \\c #AIAddToolData::sameToolsetAs.\nFor example, to create a new tool group:\n@code\ntoolData.title = \"MyTool1\";\ntoolData.tooltip = \"MyTool1 Tooltip\";\ntoolData.sameGroupAs = kNoTool;\ntoolData.sameToolsetAs = kNoTool;\n@endcode\n\nTo add a new toolset to this group:\n@code\ntoolData.title = \"MyTool2\";\ntoolData.tooltip = \"MyTool2 Tooltip\";\nerror = sTool->GetToolNumberFromName(\"MyTool1\", &toolData.sameGroupAs);\ntoolData.sameToolsetAs = kNoTool;\n@endcode\n\nTo add tools to this toolset:\n@code\ntoolData.title = \"MyTool2a\";\ntoolData.tooltip = \"Tool2a Tooltip\";\nerror = sTool->GetToolNumberFromName(\"MyTool1\",\t&toolData.sameGroupAs);\nerror = sTool->GetToolNumberFromName(\"MyTool2\", &toolData.sameToolsetAs);\n@endcode\n\n@section ToolBehavior Tool Behavior\n\nImplement tool behavior by defining handlers for the caller/selector pairs\nand messages that plug-in tools receive, particularly the mouse selectors.\nCheck for selectors in the plug-in's main function.\n\nYour mouse selector handlers can create or modify art objects directly.\nA tool can select and work on several art objects at once.\nThe application updates the window between calls to the plug-in, so the\nnew or changed artwork appears as the mouse moves.\nUse \\c #AIUndoSuite::UndoChanges() before processing the tool drag,\nin order to maintain a known artwork state from which to redraw changes.\n\nBecause multiple  plug-ins can be running at once,\nthe artwork state can change in the course of using your tool.\nTo verify that a specific artwork state exists, you can use a plug-in\nnotifier to indicate that the artwork selection or properties\nhave been changed. See the \\c #AINotifierSuite.\n\nThe caller for tool plug-ins is \\c #kCallerAITool.\n\nThese selectors are sent:\n<br> \\c #kSelectorAIEditToolOptions\n<br> \\c #kSelectorAITrackToolCursor\n<br> \\c #kSelectorAIToolMouseDown\n<br> \\c #kSelectorAIToolMouseDrag\n<br> \\c #kSelectorAIToolMouseUp\n<br> \\c #kSelectorAISelectTool\n<br> \\c #kSelectorAIDeselectTool\n<br> \\c #kSelectorAIReselectTool\n\nThese notifiers are related to tools:\n<br> \\c #kAIUserToolChangedNotifier\n<br> \\c #kAIToolSelectedNotifier\n<br> \\c #kAIToolDeselectedNotifier\n<br> \\c #kAIToolClearStateNotifier\n<br> \\c #kAIToolTitleChangedNotifier\n<br> \\c #kAIToolTooltipChangedNotifier\n<br> \\c #kAIToolChangedNotifier\n<br> \\c #kAIToolWindowChangedNotifier\n<br> \\c #kAIToolSuspendNotifier\n<br> \\c #kAIToolResumeNotifier\n<br> \\c #kAIEyedropperDragNotifier\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIToolSuite {
    #[doc = " Installs a plug-in tool. Use at startup.\n@param self This plug-in.\n@param name The unique name of this tool.\n@param data\tInformation on how to display this tool in the Tool palette.\n@param options Option flags that control the tool's behavior, a logical OR\nof \\c #AIToolOptions constants.\n@param tool\t[out] A buffer in which to return the tool reference. If you\ninstall multiple tools, save to compare to the tool reference in tool\nmessage data."]
    pub AddTool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            data: *const AIAddToolData,
            options: ai_int32,
            tool: *mut AIToolHandle,
        ) -> AIErr,
    >,
    #[doc = " For internal use only"]
    pub AddToolPrivate: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            data: *const AIAddToolDataPrivate,
            options: ai_int32,
            tool: *mut AIToolHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifying name of a tool.\nTo get the localizable title that appears in the UI, use \\c #GetToolTitle().\n@param tool The tool reference.\n@param name [out] A pointer to point to the name string. Do\nnot modify this string.\n@note\tIt is more efficient to work with tool numbers rather than\nnames. See \\c #GetToolNumberFromHandle()."]
    pub GetToolName: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, name: *mut *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a tool. To retain the existing flags when\nsetting options with \\c #SetToolOptions(), obtain them with this function\nand do a logical OR with the new flags.\n@param tool The tool reference.\n@param options [out] A buffer in which to return the options value, a logical\nOR of \\c #AIToolOptions constants."]
    pub GetToolOptions: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the option flags of a tool. To retain the existing flags when\nsetting options, obtain them with \\c #GetToolOptions()\nand do a logical OR with the new flags.\n@param tool The tool reference.\n@param options The new options value, a logical OR of \\c #AIToolOptions constants."]
    pub SetToolOptions:
        ::std::option::Option<unsafe extern "C" fn(tool: AIToolHandle, options: ai_int32) -> AIErr>,
    #[doc = " Retrieves the plug-in that installed a tool.\n@param tool The tool reference.\n@param plugin [out] A buffer in which to return the\tplug-in reference,\nwhich can be used with \\c #AIPluginSuite functions."]
    pub GetToolPlugin: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Retrieves the currently selected plug-in tool. If the current tool\nis a built-in tool, returns NULL.\nSee \\c #AIToolboxSuite::GetCurrentToolType() or \\c #GetCurrentToolName()\nfor retrieving the current tool including built-in tools.\n@param tool\t[out] A buffer in which to return the tool reference."]
    pub GetSelectedTool:
        ::std::option::Option<unsafe extern "C" fn(tool: *mut AIToolHandle) -> AIErr>,
    #[doc = " Selects a plug-in tool programmatically. This is the same as the user\nselecting the tool in the Tool palette.\nTo select built-in tools, see \\c #SetSelectedToolByName()\n@param tool The tool reference."]
    pub SetSelectedTool: ::std::option::Option<unsafe extern "C" fn(tool: AIToolHandle) -> AIErr>,
    #[doc = " Gets the number of installed plug-in tools. Use with \\c #GetNthTool()\nto iterate through plug-in tools.\n@param count [out] A buffer in which to return the number of tools."]
    pub CountTools: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a tool by index position. Use with \\c #CountTools()\nto iterate through plug-in tools.\n@param n The 0-based position index.\n@param tool\t[out] A buffer in which to return the tool reference."]
    pub GetNthTool:
        ::std::option::Option<unsafe extern "C" fn(n: ai_int32, tool: *mut AIToolHandle) -> AIErr>,
    #[doc = " Retrieves a plug-in tool by its tool number, as assigned when it is created\nwith \\c #AddTool(), and obtained by calling \\c #GetToolNumberFromHandle.\nSee @ref Toolsets.\nIf the toolNum is the number of a built-in tool, returns NULL, since\nbuilt-in tools do not have an AIToolHandle.\n@param toolNum The tool number.\n@param tool\t[out] A buffer in which to return the tool reference."]
    pub GetToolHandleFromNumber: ::std::option::Option<
        unsafe extern "C" fn(toolNum: AIToolType, tool: *mut AIToolHandle) -> AIErr,
    >,
    #[doc = " Retrieves a tool number from a tool's unique name. Use to find the numbers of\nbuilt-in tools, in order to place your tool in an existing group or toolset.\nSee @ref Toolsets.\n@param name The tool name. The names of Illustrator's built-in tools\ncan be found in \\c AIToolNames.h.\n@param toolNum [out] A buffer in which to return the tool number."]
    pub GetToolNumberFromName: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            toolNum: *mut AIToolType,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a tool number for a tool. Use to find the numbers of\nplug-in tools, in order to place your tool in an existing group or toolset.\nSee @ref Toolsets.\n@param tool The tool reference.\n@param toolNum [out] A buffer in which to return the tool number."]
    pub GetToolNumberFromHandle: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, toolNum: *mut AIToolType) -> AIErr,
    >,
    #[doc = " Retrieves the unique name of a tool from its number. To get the localizable\ntitle that appears in the UI, use \\c #GetToolTitle().\n@param toolNum The tool number.\n@param name\t[out] A pointer to point to the name string. Do not modify\nthis string. Copy it immediately to use it."]
    pub GetToolNameFromNumber: ::std::option::Option<
        unsafe extern "C" fn(toolNum: AIToolType, name: *mut *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the localizable title of a tool, which appears in the UI.\nTo get the unique, identifying name, use \\c #GetToolName().\n@param tool The tool reference.\n@param title [out] A pointer to point to the title string. Do not modify\nthis string."]
    pub GetToolTitle: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, title: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets the localizable title of a tool, which appears in the UI.\n@param tool The tool reference.\n@param title The new title string."]
    pub SetToolTitle: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, title: ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the tooltip string for a tool.\n@param tool The tool reference.\n@param tooltip [out] A pointer to point to the tooltip string. Do not modify\nthis string."]
    pub GetTooltip: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, tooltip: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets the tooltip string for a tool.\n@param tool The tool reference.\n@param tooltip The new tooltip string."]
    pub SetTooltip: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, tooltip: ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Determines which labeled fields are displayed in the Info palette for a tool.\nTypically called once at startup to initialize the Info palette.\n@param tool The tool reference.\n@param infoVars A pointer to the first member of an array of\ninformation variables, which correspond to labeled fields\nin Illustrator's Info palette, as defined in \\c #AIToolInfoVariable.\nOnly the fields included in this array are shown for the tool.\nTo initialize or set the values in the fields, use \\c #SetToolInfoVarValues()."]
    pub SetToolInfoVars: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, infoVars: *const ai_int32) -> AIErr,
    >,
    #[doc = " Sets field values in the Info palette. Only those fields specified by\n\\c #SetToolInfoVars() are displayed in the palette.\n@param infoVars A pointer to the first member of an array of\ninformation variables, which correspond to labeled fields\nin Illustrator'AITs Info palette. This is the same array specified\nby \\c #SetToolInfoVars().\n@param values A pointer to the first member of an array of values,\nwhose positions match those in the \\c infoVars array.\n\n\\b Example:\n@code\nAIErr UpdateInfoPalette( AIToolHandle tool, AIRealPoint origin, AIArtHandle art )\n{\nASErr error = kNoErr;\nif (art) {\nstatic const long infoVars = { kInfoDocX, kInfoDocY, kInfoSizeX, kInfoSizeY, kInfoEndOfList };\nAIReal *infoValues[4];\nAIReal temp[2];\nAIRealRect artBounds;\nerror = sAIArt->GetArtTransformBounds( art,0, kStroke, &artBounds);\nif ( error )\nreturn error;\ntemp[0] = artBounds.right - artBounds.left;\ntemp[1] = artBounds.bottom - artBounds.top;\ninfoValues[0] = &origin.h;\ninfoValues[1] = &origin.v;\ninfoValues[2] = temp;\ninfoValues[3] = temp +1;\nerror = sAITool->SetToolInfoVarValues( infoVars, (void**)infoValues);\nif ( error )\nreturn error;\n}\n}\n@endcode"]
    pub SetToolInfoVarValues: ::std::option::Option<
        unsafe extern "C" fn(
            infoVars: *const ai_int32,
            values: *mut *mut ::std::os::raw::c_void,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a pressure-sensitive device such as a graphics tablet\nwas available on application startup.\n@param hasPressure [out] A buffer in which to return true if\na pressure-sensitive device is in use."]
    pub SystemHasPressure:
        ::std::option::Option<unsafe extern "C" fn(hasPressure: *mut AIBoolean) -> AIErr>,
    #[doc = " @deprecated Obsolete. Do not use."]
    pub GetToolNullEventInterval: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, outTime: *mut AIToolTime) -> AIErr,
    >,
    #[doc = " @deprecated Obsolete. Do not use."]
    pub SetToolNullEventInterval: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, inTime: AIToolTime) -> AIErr,
    >,
    #[doc = " Selects a plug-in tool, but does not highlight\nit in the palette or show its tool name in the status bar of the document\nwindow. Indicates this \\e soft selection by setting the \\c isSoftMode flag.\n\\c #SetSelectedTool() turns this flag off.\n@param tool The tool reference."]
    pub SetSoftSelectedTool:
        ::std::option::Option<unsafe extern "C" fn(tool: AIToolHandle) -> AIErr>,
    #[doc = " Reports whether there is currently a \\e soft tool selection.\nSoft mode is entered when a tool, such as the rectangle tool, is\nselected and the user implicitly overrides this by drawing with the eraser\nend of a tablet stylus.\n@param isSoftMode [out] A buffer in which to return true if there is a\nsoft tool selection."]
    pub IsSoftModeSelection:
        ::std::option::Option<unsafe extern "C" fn(isSoftMode: *mut AIBoolean) -> AIErr>,
    #[doc = " Retrieves the name of the tool that will be temporarily selected  by pressing Ctrl (in Windows)\nor Cmd (in MacOS) key while using this tool.\nEffective only if the tool has set the option \\c #kToolWantsAlternateSelectionTool.\n@param tool This tool.\n@param name A buffer in which to return the name of the alternate selection tool."]
    pub GetAlternateSelectionToolName: ::std::option::Option<
        unsafe extern "C" fn(tool: AIToolHandle, name: *mut *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Sets the tool that will be temporarily selected by pressing Ctrl (in Windows)\nor Cmd (in Mac OS) key while using this tool.\nEffective only if the tool has set the option \\c #kToolWantsAlternateSelectionTool.\n@param tool This tool.\n@param name The name of the alternate selection tool."]
    pub SetAlternateSelectionToolName: ::std::option::Option<
        unsafe extern "C" fn(
            tool: AIToolHandle,
            alternateTool: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique name of the currently selected tool. This is the same\nname you get from calling \\c #AIToolboxSuite::GetCurrentToolType()\nfollowed by \\c #GetToolNameFromNumber().\n@param name\t[out] A pointer to point to the name string. Do not modify\nthis string. Copy it immediately to use it.\n@note\tIt is more efficient to work with tool numbers rather than\nnames. See \\c #GetCurrentToolNumber()."]
    pub GetCurrentToolName: ::std::option::Option<
        unsafe extern "C" fn(name: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the number of the currently selected tool.\n@param toolNum [out] A buffer in which to return the tool number."]
    pub GetCurrentToolNumber:
        ::std::option::Option<unsafe extern "C" fn(toolNum: *mut AIToolType) -> AIErr>,
    #[doc = " Retrieves the currently active plug-in tool. If the currently active\ntool is a built-in tool, returns NULL. This is the same value you get\nfrom \\c #currentToolHandle in \\c #AIEffectiveToolChangeData.\nSee \\c #GetCurrentEffectiveToolNumber() or \\c #GetCurrentEffectiveToolName()\nfor retrieving the current effective tool including built-in tools.\n@param tool\t[out] A buffer in which to return the tool reference.\n@note\tIt is more efficient to work with tool numbers rather than\nnames."]
    pub GetCurrentEffectiveTool:
        ::std::option::Option<unsafe extern "C" fn(tool: *mut AIToolHandle) -> AIErr>,
    #[doc = " Retrieves the unique name of the currently active tool. This is the same\nvalue you get from \\c #currentToolName in \\c #AIEffectiveToolChangeData.\n@param name\t[out] A pointer to point to the name string. Do not modify\nthis string. Copy it immediately to use it.\n@note\tIt is more efficient to work with tool numbers rather than\nnames. See \\c #GetCurrentEffectiveToolNumber()."]
    pub GetCurrentEffectiveToolName: ::std::option::Option<
        unsafe extern "C" fn(name: *mut *const ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the number of the currently active tool. This is the same\nvalue you get from \\c #currentToolNum in \\c #AIEffectiveToolChangeData.\n@param toolNum [out] A buffer in which to return the tool number."]
    pub GetCurrentEffectiveToolNumber:
        ::std::option::Option<unsafe extern "C" fn(toolNum: *mut AIToolType) -> AIErr>,
    #[doc = " Retrieves the numerical identifier of the most recently used built-in selection tool,\nand optionally retrieves the unique name of the tool, from \\c AIToolNames.h.\n(Note that this function returns an \\c #AIToolType, not an error code.)\n@param name     [out][optional] A buffer in which to return the name string.\nDo not modify this string. Copy it immediately to use it.\n@return The numerical identifier."]
    pub GetLastUsedSelectionTool: ::std::option::Option<
        unsafe extern "C" fn(name: *mut *const ::std::os::raw::c_char) -> AIToolType,
    >,
    #[doc = " Select a tool by its unique name identifier. Can be either the name of a plug-in tool,\nreturned by \\c #GetToolName(), or one of the tool name constants from \\c AIToolNames.h.\n@param name The name of the tool to be selected.\n@note\tIt is more efficient to work with tool numbers rather than\nnames. See \\c #SetSelectedToolByNumber()."]
    pub SetSelectedToolByName:
        ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> AIErr>,
    #[doc = " Select a tool using its tool number.\n@param toolNum The tool number."]
    pub SetSelectedToolByNumber:
        ::std::option::Option<unsafe extern "C" fn(toolNum: AIToolType) -> AIErr>,
    #[doc = " Reports the hardware capabilities of a graphical tablet or integrated digitizer.\n@param hardwareCapabilities     [out] A buffer in which to return a\nlogical OR of \\c #AITabletCapabilities constants."]
    pub GetTabletHardwareCapabilities:
        ::std::option::Option<unsafe extern "C" fn(hardwareCapabilities: *mut ai_int32) -> AIErr>,
    #[doc = " Sets tool icons to be used with light and dark UI themes.\n@param tool[in] The tool reference.\n@param normalIconResource[in] Base file name (without extension) of the PNG icon resource for the light UI theme.\n@param darkNormalIconResource[in] Base file name (without extension) of the PNG icon resource for the dark UI theme."]
    pub SetToolIcons: ::std::option::Option<
        unsafe extern "C" fn(
            tool: AIToolHandle,
            normalIconResourceName: *const ::std::os::raw::c_char,
            darkNormalIconResourceName: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = "Retrieves the base filenames (without extension) of the PNG icon resources associated with a tool.\n@param tool[in] The tool reference.\n@param normalIconResource[out] A buffer in which to return the resource name for light UI theme icon.\n@param darkNormalIconResource[out]  A buffer in which to return the resource name for dark UI theme icon."]
    pub GetToolIcons: ::std::option::Option<
        unsafe extern "C" fn(
            tool: AIToolHandle,
            normalIconResourceName: *mut *mut ::std::os::raw::c_char,
            darkNormalIconResourceName: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    pub SetDocumentInkParams: ::std::option::Option<
        unsafe extern "C" fn(
            tool: AIToolHandle,
            inDocInkParams: *const AIDocumentInkParams,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the options associated with the tool corresponding to the given tool number.\n@param options [out] A buffer in which to return the options value."]
    pub GetToolOptionsFromNumber: ::std::option::Option<
        unsafe extern "C" fn(toolNum: AIToolType, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the options associated with the tool corresponding to the given tool name.\n@param options [out] A buffer in which to return the options value.\n@note\tIt is more efficient to work with tool numbers rather than\nnames. See \\c #GetToolOptionsFromNumber()."]
    pub GetToolOptionsFromName: ::std::option::Option<
        unsafe extern "C" fn(
            toolName: *const ::std::os::raw::c_char,
            options: *mut ai_int32,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nProvides cross-platform file referencing.  Use the \\c ai::FilePath\nwrapper class rather than calling these functions directly.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFilePathSuite and \\c #kAIFilePathVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFilePathSuite {
    #[doc = " Creates a new, empty file path object.\n@param path [out] A buffer in which to return the\nfile path object."]
    pub NewFilePath: ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath) -> AIErr>,
    #[doc = " Disposes of a file path object. Does not affect the referenced file.\n@param path The file path object."]
    pub DeleteFilePath:
        ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath) -> AIErr>,
    #[doc = " Copies a file path object. Does not affect the referenced file.\n@param src The file path object to copy.\n@param dest  [out] A buffer in which to return the\nnew file path object, which references the same file."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(src: *const ai_FilePath, dest: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Reports whether a file path object references a file.\n(Note that this function returns a boolean value, not an error code.)\n@param path The file path object.\n@return True if the object is empty (does not reference a file)."]
    pub IsEmpty: ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> AIBool8>,
    #[doc = " Sets a file path object to reference a null path.\n(Note that this function has no return value.)\n@param path The file path object."]
    pub MakeEmpty: ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath)>,
    #[doc = " Reports whether two file path object reference the same file,\nregardless of whether that file exists.\n(Note that this function returns a boolean value, not an error code.)\n@param a The first file path object.\n@param b The second file path object.\n@param resolveLinks When true, determine if the two objects refer to the\nsame file through links, aliases, or shortcuts by querying the\nfile system.\n@return True if the objects are identical, or if \\c resolveLinks is true\nand the objects reference the same file.\n<br> False if \\c resolveLinks is false and the objects are not identical,\nor if \\c resolveLinks is true and the objects reference different files,"]
    pub Equal: ::std::option::Option<
        unsafe extern "C" fn(
            a: *const ai_FilePath,
            b: *const ai_FilePath,
            resolveLinks: AIBool8,
        ) -> AIBool8,
    >,
    #[doc = " Reports whether one file path string is before another, alphabetically.\n(Note that this function returns a boolean value, not an error code.)\n@param a The first file path object.\n@param b The second file path object.\n@return True if a < b in a string comparison of file path names."]
    pub LessThan: ::std::option::Option<
        unsafe extern "C" fn(a: *const ai_FilePath, b: *const ai_FilePath) -> AIBool8,
    >,
    #[doc = " Reports whether a file path string starts with a delimiter.\n(Note that this function returns a boolean value, not an error code.)\n@param path The file path object.\n@return True if the file path name starts with a delimiter."]
    pub StartsWithDelimiter:
        ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> AIBool8>,
    #[doc = "  Reports whether a file path string ends with a delimiter.\n@param path The file path object.\n@return True if the file path name ends with a delimiter."]
    pub EndsWithDelimiter:
        ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> AIBool8>,
    #[doc = " Adds a component to the path of a file path object, inserting the appropriate\ndelimiter character as necessary. Does not add a delimiter at the end\nunless it is explicitly specified in the \\c addend string.\n@param addend The component to  add.\n@param augend [in, out] The file path object."]
    pub AddComponent: ::std::option::Option<
        unsafe extern "C" fn(addend: *const ai_UnicodeString, augend: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Removes the end component from the path of a file path object.\n(Note that this function has no return value.)\n@param path The file path object."]
    pub RemoveComponent: ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath)>,
    #[doc = " Adds a file extension to the path of a file path object.\nAdds or ignores dots as needed so that one dot appears before the extension.\n(Note that this function has no return value.)\n@param ext The extension string.\n@param path [in, out] The file path object."]
    pub AddExtension: ::std::option::Option<
        unsafe extern "C" fn(ext: *const ai_UnicodeString, path: *mut ai_FilePath),
    >,
    #[doc = " Removes the file extension from the path of a file path object.\n(Note that this function has no return value.)\n@param path [in, out] The file path object."]
    pub RemoveExtension: ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath)>,
    #[doc = " Reports whether the file or directory referenced by a file path object\nexists in the file system.\n(Note that this function returns a boolean value, not an error code.)\n\n@param path\t\t\tThe file path object.\n@param resolveLinks\tWhen true, resolve links, aliases, and shortcuts for \\c longPath.\n@param longPath\t\t[out] Optional. A buffer in which to return a full long, Unicode version\nof the path. Use to convert short path names to their long counterparts. Can be null.\nReturns undefined if the file or directory does not exist.\n@param isFile\t\t[out] Optional. A buffer in which to return true if the object\nreferences an existing file, false if it references an existing directory. Can be null.\nReturns undefined if the file or directory does not exist.\n@return True if the referenced file or directory exists."]
    pub Exists: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            resolveLinks: AIBool8,
            longPath: *mut ai_UnicodeString,
            isFile: *mut AIBool8,
        ) -> AIBool8,
    >,
    #[doc = "\tResolves an alias or shortcut by querying the file system.\nThe referenced file or directory must exist.\n@param path [in, out] The file path object to resolve and return.\nUpon return, the path object points directly to the target file."]
    pub Resolve: ::std::option::Option<unsafe extern "C" fn(path: *mut ai_FilePath) -> AIErr>,
    #[doc = " Sets a file path from a Unicode string.\n@param pathString The new path, can be a path native to Windows, UNIX, or Mac OS, or a URL.\n@param expandName When true, the function attempts to expand the\nprovided path string into a full name (for example, for\ta short,\ntruncated name in Windows).\n@param dontStripTrailingSpace When true, the function will not strip any\ntrailing whitespace in the provided path string\n@param path The file path object."]
    pub Set: ::std::option::Option<
        unsafe extern "C" fn(
            pathString: *const ai_UnicodeString,
            expandName: AIBool8,
            dontStripTrailingSpace: AIBool8,
            path: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Sets a file path from a file specification.\n@param file The new file.\n@param path The file path object."]
    pub SetFromSPFileRef: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const SPPlatformFileReference, path: *mut ai_FilePath),
    >,
    #[doc = " Sets a file path from a \\c CFString string specification (in Mac OS only).\n@param string The new path.\n@param path The file path object."]
    pub SetFromCFString: ::std::option::Option<
        unsafe extern "C" fn(arg1: CFStringRef, path: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Sets a file path from an \\c CFURL URL specification (in Mac OS only).\n@param url The new URL.\n@param path The file path object."]
    pub SetFromCFURL:
        ::std::option::Option<unsafe extern "C" fn(arg1: CFURLRef, path: *mut ai_FilePath)>,
    #[doc = "\tRetrieves the file name from a file path object. Includes the extension, if any, but\ndoes not include the path.\n@param path\t\t\tThe file path object\n@param displayName\tWhen true, get the display name. Attempts to translate a\ntruncated short name to the full name.\n@param fileName\t\t[out] A buffer in which to return the file name string."]
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            displayName: AIBool8,
            fileName: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the file name from a file path object, without any extension or path.\n@param path\t\t\tThe file path object\n@param fileNameNoExt [out] A buffer in which to return the file name string."]
    pub GetFileNameNoExt: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            fileNameNoExt: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the file extension from a file path object. Does not include the dot.\n@param path\t\tThe file path object\n@param ext\t\t[out] A buffer in which to return the file extension string."]
    pub GetFileExtension: ::std::option::Option<
        unsafe extern "C" fn(path: *const ai_FilePath, ext: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = "\tRetrieves the full path from a file path object, in platform-specific notation.\n@param path\t\t\tThe file path object\n@param displayName\tWhen true, get the display name. Attempts to translate a\ntruncated short name to the full name.\n@param fullPath\t\t[out] A buffer in which to return the path string."]
    pub GetFullPath: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            displayName: AIBool8,
            fullPath: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the directory or folder from a file path object, in platform-specific notation.\nThe string ends with a delimiter. If the path represents a directory or folder, this\nresult is the same as for \\c #GetFullPath().\n@param path\t\t\tThe file path object\n@param displayName\tWhen true, get the display name. Attempts to translate a\ntruncated short name to the full name.\n@param directory\t[out] A buffer in which to return the directory name string."]
    pub GetDirectory: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            displayName: AIBool8,
            directory: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the short version of the path from a file path object, in platform-specific notation.\nThe referenced file or folder must exist.\n@param path\t\t\tThe file path object\n@param shortPath\t[out] A buffer in which to return the path string, or an\nempty string in case of error..\n\\li In Windows, conforms to 8.3 format.\n\\li In Mac OS X, name can be truncated and a file ID appended.\nIf the file ID is needed, the path is not valid across processes."]
    pub GetShortPath: ::std::option::Option<
        unsafe extern "C" fn(path: *const ai_FilePath, shortPath: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = "\tRetrieves the parent directory or folder for a file path object, as a file path object.\nIf the path is a directory, retrieves its parent directory. Does not access the file system.\nUse \\c #Exists() or \\c #Resolve() to ensure a path is valid.\n@param path\t\tThe file path object.\n@param parent\t[out] A buffer in which to return the path object for the parent.\nCan be the same instance passed in, in which case it is modified to\nreference the parent. Returns an empty path if the given path is\nfor a top-level volume."]
    pub GetParent: ::std::option::Option<
        unsafe extern "C" fn(path: *const ai_FilePath, parent: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = "\tRetrieves the path component delimiter for the current platform.\n(Note that this function returns a character, not an error code.\n@return The delimiter character (\"/\" or \"\\\"),"]
    pub GetDelimiter: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_char>,
    #[doc = " Retrieves the file creator and type of a file path as a four-character code\n(in Mac OS only, outside Illustrator core).\n@param path The file path object.\n@param creator [out] A buffer in which to return the creator code.\n@param type [out] A buffer in which to return the type code."]
    pub GetCreatorAndType: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            creator: *mut ai_uint32,
            type_: *mut ai_uint32,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the path as a URL from a file path object. The URL contains only ASCII characters\nand special characters escaped with URL percent (\\\\%) encoding.\n@param path\t\tThe file path object\n@param displayName\tWhen true, get the display name. Attempts to translate a\ntruncated short name to the full name.\n@param url\t\t[out] A buffer in which to return the URL string."]
    pub GetAsURL: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            displayName: AIBool8,
            url: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the path as a file specification from a file path object.\n@param path\tThe file path object\n@param spPlatformFileSpec [out] A buffer in which to return the file specification."]
    pub GetAsSPPlatformFileRef: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ai_FilePath,
            spPlatformFileRef: *mut SPPlatformFileReference,
        ) -> AIErr,
    >,
    #[doc = "\tRetrieves the path as a file specification from a file path object.\n@param path\tThe file path object\nreturn if file path is on network or not."]
    pub IsOnNetwork:
        ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> AIBoolean>,
    #[doc = " Retrieves a file path as a \\c CFString string specification (in Mac OS only).\n(Note that this function returns a string value, not an error code.)\n@param path The file path object.\n@return The path string. The caller is responsible for releasing it."]
    pub GetAsCFString:
        ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> CFStringRef>,
    #[doc = " Retrieves a file path as a \\c CFURL specification (in Mac OS only).\n(Note that this function returns a string value, not an error code.)\n@param path The file path object.\n@return The URL specification."]
    pub GetAsCFURL:
        ::std::option::Option<unsafe extern "C" fn(path: *const ai_FilePath) -> CFURLRef>,
    #[doc = " Resets the volume cache. Does not return an error code."]
    pub ResetVolumeCache: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DataFilter {
    _unused: [u8; 0],
}
#[doc = "\tTypes\n\n/\n/** Opaque reference to a data filter."]
pub type AIDataFilter = DataFilter;
#[doc = " This structure allows a plug-in to implement a stream by supplying\nthe stream methods. A method can be \\c NULL. If a null method is\ninvoked, the calling function returns \\c #kDataFilterErr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIPluginStream {
    #[doc = " Reads data from a stream. Reads up to \\c count bytes into \\c buffer,\nreturning the number of bytes that were read.\n@param stream The stream.\n@param buffer [out] A buffer in which to return the data.\n@param count [in, out] A pointer to the maximum number of bytes to read.\nReturns the number of bytes actually read."]
    pub ReadProc: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut _t_AIPluginStream,
            buffer: *mut ::std::os::raw::c_char,
            count: *mut usize,
        ) -> AIErr,
    >,
    #[doc = " Writes data to a stream.\n@param stream The stream.\n@param buffer A buffer containing the data.\n@param count The number of bytes in \\c buffer."]
    pub WriteProc: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut _t_AIPluginStream,
            buffer: *const ::std::os::raw::c_char,
            count: usize,
        ) -> AIErr,
    >,
    #[doc = " Seeks to a position in a stream.\n@param stream The stream.\n@param count The offset into the stream."]
    pub SeekProc: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut _t_AIPluginStream, count: ai_sizediff_t) -> AIErr,
    >,
    #[doc = " Marks the current position in a stream\n@param stream The stream.\n@param count [out] A buffer in which to return the offset into the stream."]
    pub MarkProc: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut _t_AIPluginStream, count: *mut ai_sizediff_t) -> AIErr,
    >,
    #[doc = " Terminates a stream.\n@param The stream."]
    pub TerminateProc:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut _t_AIPluginStream) -> AIErr>,
}
#[doc = " This structure allows a plug-in to implement a stream by supplying\nthe stream methods. A method can be \\c NULL. If a null method is\ninvoked, the calling function returns \\c #kDataFilterErr."]
pub type AIPluginStream = _t_AIPluginStream;
#[doc = " @ingroup Suites\nA data filter is an object that bytes of data can be read from or written to.\nThe filter usually does something interesting with those bytes. For example,\nit might write them to a disk file, send them over a network or it could\nperform JPEG encoding and decoding.\n\nThis suite provides functions to create filters that read and write files, buffers,\nor memory blocks, and that encode/decode and compress/decompress data.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIDataFilterSuite and \\c #kAIDataFilterVersion.\n\nData filters can be linked together. Each filter in the linked chain gets data from\nor puts data to the previous filter. A file filter could, for example, be linked\nto an ASCII encoding filter which is in turn linked to a binary compression filter.\nThe result is a composite filter that compresses and ASCII-encodes data before writing\nit to a file.\n\nThe following code shows how to set up a data filter that performs buffered\nwrites to a file. Note that \\c #LinkDataFilter() must be called even for the\nfirst filter as it initializes the filter.\n@code\nAIErr result = kNoErr;\nAIDataFilter* dstfilter = NULL;\nAIDataFilter* filter;\nif (!result)\nresult = sAIDataFilter->NewFileDataFilter(file, \"write\", 'ART5', 'TEXT', &filter);\nif (!result) {\nresult = sAIDataFilter->LinkDataFilter(dstfilter, filter);\ndstfilter = filter;\n}\nif (!result)\nresult = sAIDataFilter->NewBufferDataFilter(32*1024, &filter);\nif (!result) {\nresult = sAIDataFilter->LinkDataFilter(dstfilter, filter);\ndstfilter = filter;\n}\n@endcode\n\nWhen you have finished with a filter, you can use the following code to close it.\n@code\nAIErr result = kNoErr;\nwhile (dstfilter)  {\nAIErr tmpresult = sAIDataFilter->UnlinkDataFilter(dstfilter, &dstfilter);\nif (!result)\nresult = tmpresult;\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDataFilterSuite {
    #[doc = " Initializes a filter and links it to the previous filter for input\nor output.\n@param prev A pointer to the previous filter (the source or\ndestination of data read or written by this filter). Can be\nnull for the first filter in a chain, or a filter that is not linked.\n@param next A pointer to the filter to initialize and link."]
    pub LinkDataFilter: ::std::option::Option<
        unsafe extern "C" fn(prev: *mut AIDataFilter, next: *mut AIDataFilter) -> AIErr,
    >,
    #[doc = " Terminates a filter. If the filter is writing, flushes any writes.\n@param next A pointer to the filter to terminate.\n@param prev [out] A buffer in which to return a pointer to the\nprevious linked filter, which contains any data written\nbefore termination."]
    pub UnlinkDataFilter: ::std::option::Option<
        unsafe extern "C" fn(next: *mut AIDataFilter, prev: *mut *mut AIDataFilter) -> AIErr,
    >,
    #[doc = " Reads data from the filter's source stream.\n@param filter A pointer to the filter.\n@param store [out] A buffer in which to return the data.\n@param count [in, out] A pointer to the maximum number of bytes to read.\nReturns the number of bytes actually read, 0 if the stream\nis exhausted."]
    pub ReadDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            filter: *mut AIDataFilter,
            store: *mut ::std::os::raw::c_char,
            count: *mut usize,
        ) -> AIErr,
    >,
    #[doc = " Writes data to the filter's destination stream.\n@param filter A pointer to the  filter.\n@param store A buffer containing the data.\n@param count A pointer to the number of bytes in \\c store."]
    pub WriteDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            filter: *mut AIDataFilter,
            store: *const ::std::os::raw::c_char,
            count: *mut usize,
        ) -> AIErr,
    >,
    #[doc = " Seeks to a position in a filter's stream, as returned by \\c #MarkDataFilter().\nNot all data filters support random access.\n@param filter A pointer to the  filter.\n@param count A pointer to the new position, an offset into the stream."]
    pub SeekDataFilter: ::std::option::Option<
        unsafe extern "C" fn(filter: *mut AIDataFilter, count: *mut ai_sizediff_t) -> AIErr,
    >,
    #[doc = " Reports the current position in a filter's stream.\n@param filter A pointer to the  filter.\n@param count [out] A buffer in which to return the position, an offset\ninto the stream."]
    pub MarkDataFilter: ::std::option::Option<
        unsafe extern "C" fn(filter: *mut AIDataFilter, count: *mut ai_sizediff_t) -> AIErr,
    >,
    #[doc = " Creates a new file data filter that reads to or writes from a file.\n@param spec The file associated with the filter.\n@param mode How the filter is used, one of \\c \"read\", \\c \"write\",\nor \\c \"append\".\n@param creator The file creator (for Mac OS)\n@param type The file type (for Mac OS)\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewFileDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            spec: *const ai_FilePath,
            mode: *const ::std::os::raw::c_char,
            creator: usize,
            type_: ai_int32,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new buffer data filter that reads from or writes to a\nlinked filter, buffering data into chunks of a specified size.\n@param size The number of bytes to read or write at a time.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewBufferDataFilter: ::std::option::Option<
        unsafe extern "C" fn(size: usize, filter: *mut *mut AIDataFilter) -> AIErr,
    >,
    #[doc = " Creates a new ASCIIHEX data filter that encodes or decodes data from a linked\nfilter using ASCII Hex. That is, it uses the characters 0-9 and A-F to represent\nhexadecimal numbers. The resulting sequence of characters is broken up\ninto lines by inserting line break characters as needed. Each line can\nadditionally be preceded by a number of tab characters.\n@param state Whether the filter is encoding or decoding, one of:\n\\li \\c \"write\" (encoding)\n\\li \\c \"read\" (decoding)\n\n@param shift The number of tab characters to insert before each line.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewHexdecDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            state: *const ::std::os::raw::c_char,
            shift: ai_int32,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new block data filter that reads from and writes to\na specified block of memory.\n@param address The address of the block.\n@param size The number of bytes in the block.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewBlockDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut ::std::os::raw::c_void,
            size: usize,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new random access data filter that reads from and writes to\nIllustrator's virtual memory. Use to create a temporary file that is\npaged to and from memory as needed.\n@param initialsize The end of the initial stream, a number of bytes.\nIf \\c NULL, the initial stream is empty.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewVMDataFilter: ::std::option::Option<
        unsafe extern "C" fn(initialsize: usize, filter: *mut *mut AIDataFilter) -> AIErr,
    >,
    #[doc = " Creates a new ASCII85 data filter that encodes or decodes data from\na linked filter. The resulting sequence of characters is broken up\ninto lines by inserting line break characters as needed. Each line can\nadditionally be preceded by a prefix string.\n@param statestr Whether the filter is encoding or decoding, one of:\n\\li \\c \"write\" (encoding)\n\\li \\c \"read\" (decoding)\n\n@param prefix The string to insert at the start of each line.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewA85DataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            statestr: *const ::std::os::raw::c_char,
            prefix: *const ::std::os::raw::c_char,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new ZLib data filter that compresses or decompresses data from a linked filter.\n@param statestr Whether the filter is compressing or decompressing, one of:\n\\li \\c \"write\" (compressing)\n\\li \\c \"read\" (decompressing)\n\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewZDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            statestr: *const ::std::os::raw::c_char,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new Zstandard data filter that compresses or decompresses data from a linked filter.\n@param statestr Whether the filter is compressing or decompressing, one of:\n\\li \\c \"write\" (compressing)\n\\li \\c \"read\" (decompressing)\n\n@param compressionLevel The compression level to be used by Zstandard library.\nRefer Zstandard library documentation for list of supported values.\nHigher value attempts to provide better compression ratio but will take more time and memory.\nUse \\c ai::DataFilter::kAIZstdDefaultCompressionLevel for specifying default compression level.\nThis parameter is ignored for decompresson.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewZStdDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            statestr: *const ::std::os::raw::c_char,
            compressionLevel: ai_int32,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new data filter for a stream with specified methods.\nIt is typically at one end of a filter chain, to act as a data source or\nsink.\n@param stream The stream, which you have initialized with\na set of data-handling procedures.\n@param filter  [out] A buffer in which to return the new filter reference, ."]
    pub NewPluginStream: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut AIPluginStream, filter: *mut *mut AIDataFilter) -> AIErr,
    >,
    #[doc = " Creates a data filter for streaming data from a plug-in resource.\nSearches for a resource of a given type in the plug-in's resource file.\nIdentify the specific resource using either a numeric ID or name string.\nThe type, ID, and name are defined by the plug-in that owns the resource\n@param plugin The plug-in object for the plug-in that owns the resource.\n@param type The resource type constant, a 4-byte value.\n@param id The unique resource identifier.\n@param name The resource name.\n@param filter  [out] A buffer in which to return the new filter reference, ."]
    pub NewResourceDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            plugin: SPPluginRef,
            type_: ai_int32,
            id: ai_int32,
            name: *const ::std::os::raw::c_char,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Creates a new Asnyc data filter that Takes a AIDataFilter *asyncFilter and runs it on Background thread.\nexecution of asyncFilter should be possible on a background thread\n@param [in] asyncFilter the filters that will be running on a background thread.This filter should not be linked to any other filter.\nasyncFilter's ownership will be with the filter returned by this API\n@param statestr [in] Whether the filter is compressing or decompressing, one of:\n\\li \\c \"write\" (compressing) [Not Supported for this version]\n\\li \\c \"read\" (decompressing)\n\n@param prefetchSize [in] size of a buffer typically fetched from the next filter(next of the filter returned by this API).\n@param outputSize   [in] size of a buffer typically asked from this filter.\n@param filter [out] A buffer in which to return the new filter reference."]
    pub NewAsyncDataFilter: ::std::option::Option<
        unsafe extern "C" fn(
            statestr: *const ::std::os::raw::c_char,
            asyncFilter: *mut AIDataFilter,
            prefetchSize: ai_uint32,
            outputSize: ai_uint32,
            filter: *mut *mut AIDataFilter,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringPool {
    _unused: [u8; 0],
}
#[doc = "\tTypes\n"]
pub type AIStringPool = StringPool;
#[doc = "\t@ingroup Suites\nThis suite provides functions for working with \\e string \\e pools.\nA string pool contains a collection of NULL-terminated character sequences. No\nsingle string appears in the pool more than once. You can compare two strings\nfrom the pool for equality by comparing their addresses. You can obtain the application\nstring pool using \\c #AIRuntimeSuite::GetAppStringPool(), or you can use these\nfunctions to create your own string pool.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIStringPoolSuite and \\c #kAIStringPoolVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIStringPoolSuite {
    #[doc = " Creates a new string pool. The plug-in is responsible for freeing the\npool when it is no longer needed.\n@param pool [out] A buffer in which to return the new string pool object."]
    pub AllocateStringPool:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut *mut AIStringPool) -> AIErr>,
    #[doc = " Disposes of a string pool that was created with \\c #AllocateStringPool().\n@param pool The string pool object."]
    pub DisposeStringPool:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut AIStringPool) -> AIErr>,
    #[doc = " Retrieves a string entry from a string pool, or creates it and adds it\nto the pool if it is not already there.\n@param pool The string pool object.\n@param string The string value of the matching or new pool entry.\n@param wstring [out] A buffer in which to return the pool entry."]
    pub MakeWString: ::std::option::Option<
        unsafe extern "C" fn(
            pool: *mut AIStringPool,
            string: *const ::std::os::raw::c_char,
            wstring: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NameSpace {
    _unused: [u8; 0],
}
#[doc = " Opaque namespace reference. See \\c #AINameSpaceSuite."]
pub type AINameSpace = NameSpace;
#[doc = "\t@ingroup Suites\nThis suite provides functions that allow you to create and manage namespaces.\nA namespace is essentially a global dictionary that is not associated with any particular\ndocument. Its keys are strings called \\e paths and the associated values can be of these\ntypes and values:\n\\li  \\c integer (value: \\c long )\n\\li  \\c real (value: \\c double )\n\\li  \\c string (value: <code> char *</code> )\n\\li  \\c raw (length: \\c long, value: <code> char *</code> )\n\\li  \\c unicodeString (value: <code> #ai::UnicodeString *</code>)\n\nUnlike dictionaries, the contents of a namespace have a hierarchical organization.\nThe hierarchy of keys is like that of directory paths in a file system, with\nlevels divided by '/' separators. For example the key \"/root/entry\" has two\ncomponents, \"root\" and \"entry\".\n\nYou can specify partial paths, and refer to all keys that are prefixed with that path.\nA partial path is specified with a trailing '/' separator. The path \"/\" refers\nto the root.\n\nA path can contain a maximum of 505 characters. Each component of a path (excluding\nseparators) can have a maximum of 100 characters.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAINameSpaceSuite and \\c #kAINameSpaceVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AINameSpaceSuite {
    #[doc = " Creates a new namespace.\n@param pool The string pool from which to allocate the path component\nstring, or \\c NULL to use the global string pool, If supplied,\nthe caller must dispose of the string pool after freeing the namespace.\nSee \\c #AIStringPoolSuite.\n@param space A buffer in which to return the namespace reference."]
    pub AllocateNameSpace: ::std::option::Option<
        unsafe extern "C" fn(pool: *mut AIStringPool, space: *mut *mut AINameSpace) -> AIErr,
    >,
    #[doc = "  Frees a namespace. If you supplied a string pool, you must free it after\nfreeing the namespace.\n@param The namespace. Upon return, this reference is invalid."]
    pub DisposeNameSpace:
        ::std::option::Option<unsafe extern "C" fn(space: *mut AINameSpace) -> AIErr>,
    #[doc = " Sets the value stored at a point in a namespace.\n@param The namespace.\n@param path The path.\n@param type The new type. Types are:\n\\li  \\c integer (value: \\c long )\n\\li  \\c real (value: \\c double )\n\\li  \\c string (value: <code> char *</code> )\n\\li  \\c raw (length: \\c long, value: <code> char *</code> )\n\\li  \\c unicodeString (value: <code> #ai::UnicodeString *</code>)\n@param length For type \\c raw only, the length of the value.\n@param value The new value, of the appropriate type."]
    pub SetValue: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            ...
        ) -> AIErr,
    >,
    #[doc = " Retrieves Sets the value stored at a point in a namespace.\n@param The namespace.\n@param path The path.\n@param type [out] A buffer in which to return the type. Types are:\n\\li  \\c integer (value: \\c long )\n\\li  \\c real (value: \\c double )\n\\li  \\c string (value: <code> char *</code> )\n\\li  \\c raw (length: \\c long, value: <code> char *</code> )\n\\li  \\c unicodeString (value: <code> #ai::UnicodeString *</code>)\n@param length [out] For type \\c raw only, a buffer in which to return the length of the value.\n@param value [out] A buffer in which to return the value, of the appropriate type."]
    pub GetValue: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            ...
        ) -> AIErr,
    >,
    #[doc = " Retrieves the type of the value stored at a point in a namespace.\n@param The namespace.\n@param path The path.\n@param type [out] A buffer in which to return the type. Types are:\n\\li  \\c integer (value: \\c long )\n\\li  \\c real (value: \\c double )\n\\li  \\c string (value: <code> char *</code> )\n\\li  \\c raw (length: \\c long, value: <code> char *</code> )\n\\li  \\c unicodeString (value: <code> #ai::UnicodeString *</code>)"]
    pub GetType: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            type_: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Reports the number of times the value stored at a point in a\nnamespace has been changed. Each time the value is set, the change count is incremented.\n@param The namespace.\n@param path The path. If this is an intermediate node in the namespace, the count is\nthe number of times all values stored under that node have changed.\n@param count [out] A buffer in which to return the change count."]
    pub GetChangeCount: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            count: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Removes the value stored at a point in a namespace.\n@param The namespace.\n@param path The path. If this is a partial path, all values under it are removed."]
    pub RemoveValue: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Reports the number of unique components that can be appended to a path to\nproduce paths or partial paths in the namespace. (This is like the number of\nentries in a directory.)\n@param The namespace.\n@param path The base path.\n@param count [out] A buffer in which to return the component count."]
    pub CountPaths: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            count: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a unique component that can be appended to a given path to produce a new\npath or partial path in the namespace.\n@param The namespace.\n@param path The base path.\n@param n The index position of the component.\n@param nthPath [out] A buffer in which to return the component,\nwhich includes the trailing separator if it identifies a partial path."]
    pub GetNthPath: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            n: ai_int32,
            nthPath: *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Reads namespace data that was written to a file using \\c #FlushValue() into a namespace,\nunder a given base path.\n@param The namespace.\n@param path The base path, used as a prefix.\n@param filter The file filter with which to read the data. This does not need\nto be the same filter used to serialize the keys."]
    pub ParseValue: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            filter: *mut AIDataFilter,
        ) -> AIErr,
    >,
    #[doc = " Writes data from a namespace to a filter, serializing the namespace entries identified\nby a partial path to a data filter.\tWrites only the path after the base and the\nkey/value pairs, not the base path.\n\nUse \\c #ParseValue() to read data in from the resulting file to a new path prefix.\n@param The namespace.\n@param path The base path for the data.\n@param filter The file filter with which to serialize the keys."]
    pub FlushValue: ::std::option::Option<
        unsafe extern "C" fn(
            space: *const AINameSpace,
            path: *const ::std::os::raw::c_char,
            filter: *mut AIDataFilter,
        ) -> AIErr,
    >,
}
pub type ASUTF16 = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __AIFontKey {
    _unused: [u8; 0],
}
#[doc = " Opaque font key; see \\c #AIFontSuite"]
pub type AIFontKey = *mut __AIFontKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AITypefaceKey {
    _unused: [u8; 0],
}
#[doc = " Opaque typeface (font family) key; see \\c #AIFontSuite"]
pub type AITypefaceKey = *mut _t_AITypefaceKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIGlyphSet {
    _unused: [u8; 0],
}
#[doc = " Opaque glyph set; see \\c #AIFontSuite"]
pub type AIGlyphSet = *mut _t_AIGlyphSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIGlyphInfo {
    _unused: [u8; 0],
}
#[doc = " Opaque glyph information; see \\c #AIFontSuite"]
pub type AIGlyphInfo = *mut _t_AIGlyphInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIFontInst {
    _unused: [u8; 0],
}
#[doc = " Opaque font instance; see \\c #AIFontSuite"]
pub type AIFontInst = *mut _t_AIFontInst;
#[doc = " Opaque glyph identifier; see \\c #AIFontSuite"]
pub type AIGlyphID = ::std::os::raw::c_int;
#[doc = " Opaque byte code; see \\c #AIFontSuite"]
pub type AIByteCode = ::std::os::raw::c_uchar;
#[doc = " Opaque character code; see \\c #AIFontSuite"]
pub type AICharCode = ai_uint16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIFaceMetrics {
    _unused: [u8; 0],
}
#[doc = " Opaque font face metrics; see \\c #AIFontSuite"]
pub type AIFaceMetrics = *mut _t_AIFaceMetrics;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_LOGFONTA {
    _unused: [u8; 0],
}
#[doc = " Not used."]
pub type AILOGFONTA = *mut _t_LOGFONTA;
pub type AIMacFontRef = ai_uint32;
pub const AIFaceFormat_kUnknownFormat: AIFaceFormat = -1;
pub const AIFaceFormat_kTypeOneFormat: AIFaceFormat = 0;
pub const AIFaceFormat_kTrueTypeFormat: AIFaceFormat = 1;
#[doc = " Font family format types"]
pub type AIFaceFormat = ::std::os::raw::c_int;
pub const AIFaceEncoding_kUnknownEncoding: AIFaceEncoding = -1;
pub const AIFaceEncoding_kDontCareEncoding: AIFaceEncoding = 0;
pub const AIFaceEncoding_kStandardEncoding: AIFaceEncoding = 1;
pub const AIFaceEncoding_kSpecialEncoding: AIFaceEncoding = 2;
#[doc = " Type face encodings"]
pub type AIFaceEncoding = ::std::os::raw::c_int;
pub const AIFaceScript_kNativeAIScript: AIFaceScript = -2;
pub const AIFaceScript_kUnknownAIScript: AIFaceScript = -1;
pub const AIFaceScript_kRomanAIScript: AIFaceScript = 0;
pub const AIFaceScript_kJapaneseAIScript: AIFaceScript = 1;
pub const AIFaceScript_kTraditionalChineseAIScript: AIFaceScript = 2;
pub const AIFaceScript_kKoreanAIScript: AIFaceScript = 3;
pub const AIFaceScript_kArabicAIScript: AIFaceScript = 4;
pub const AIFaceScript_kHebrewAIScript: AIFaceScript = 5;
pub const AIFaceScript_kGreekAIScript: AIFaceScript = 6;
pub const AIFaceScript_kCyrillicAIScript: AIFaceScript = 7;
pub const AIFaceScript_kDevanagariAIScript: AIFaceScript = 9;
pub const AIFaceScript_kGurmukhiAIScript: AIFaceScript = 10;
pub const AIFaceScript_kGujaratiAIScript: AIFaceScript = 11;
pub const AIFaceScript_kOriyaAIScript: AIFaceScript = 12;
pub const AIFaceScript_kBengaliAIScript: AIFaceScript = 13;
pub const AIFaceScript_kTamilAIScript: AIFaceScript = 14;
pub const AIFaceScript_kTeluguAIScript: AIFaceScript = 15;
pub const AIFaceScript_kKannadaAIScript: AIFaceScript = 16;
pub const AIFaceScript_kMalayalamAIScript: AIFaceScript = 17;
pub const AIFaceScript_kSinhaleseAIScript: AIFaceScript = 18;
pub const AIFaceScript_kBurmeseAIScript: AIFaceScript = 19;
pub const AIFaceScript_kKhmerAIScript: AIFaceScript = 20;
pub const AIFaceScript_kThaiAIScript: AIFaceScript = 21;
pub const AIFaceScript_kLaotianAIScript: AIFaceScript = 22;
pub const AIFaceScript_kSimplifiedChineseAIScript: AIFaceScript = 25;
pub const AIFaceScript_kEastEuropeanRomanAIScript: AIFaceScript = 29;
pub const AIFaceScript_kSymbolAIScript: AIFaceScript = 32;
pub const AIFaceScript_kEmojiAIScript: AIFaceScript = 33;
pub const AIFaceScript_kTurkishAIScript: AIFaceScript = 81;
pub const AIFaceScript_kBalticAIScript: AIFaceScript = 85;
#[doc = " Type face language scripts"]
pub type AIFaceScript = ::std::os::raw::c_int;
pub const AIMojiZumeType_kMojiZumeNone: AIMojiZumeType = 0;
pub const AIMojiZumeType_kMojiZumeGXTrueType: AIMojiZumeType = 1;
pub const AIMojiZumeType_kMojiZumePageMakerJ: AIMojiZumeType = 2;
pub const AIMojiZumeType_kMojiZumeSfntATM: AIMojiZumeType = 3;
#[doc = " MojiZume types"]
pub type AIMojiZumeType = ::std::os::raw::c_uint;
#[doc = " Font style"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFontStyle {
    #[doc = " Font retrieval key"]
    pub fontKey: AIFontKey,
    #[doc = " Font family format"]
    pub format: AIFaceFormat,
    #[doc = " Font face encoding"]
    pub encoding: AIFaceEncoding,
    #[doc = " Font face script"]
    pub script: AIFaceScript,
    #[doc = " When true, this is the original encoding"]
    pub originalEncoding: AIBoolean,
    #[doc = " When true, the font family is installed"]
    pub familyInstalled: AIBoolean,
    #[doc = " Not used."]
    pub strikeInstalled: AIBoolean,
    #[doc = " When true, the font is fauxed for a missing font"]
    pub fauxedInstalled: AIBoolean,
    #[doc = " When true, the font is a Character ID-keyed font"]
    pub isCID: AIBoolean,
    #[doc = " The MojiZume type of the font"]
    pub mojiZumeType: AIMojiZumeType,
    #[doc = " When true, this is an Open Type font"]
    pub isOTF: AIBoolean,
    #[doc = " When true, this is a bitmap font"]
    pub isBitmapFont: AIBoolean,
    #[doc = "  When true, this is an Original Composite Format font"]
    pub isOCF: AIBoolean,
    #[doc = "  When true, this is an Adobe Type Composer font"]
    pub isATC: AIBoolean,
    #[doc = "  When true, this is an Adobe Multiple Master font"]
    pub isMultipleMaster: AIBoolean,
}
pub const AIMetricOrientation_kAIUnknownMetricOrientation: AIMetricOrientation = 0;
pub const AIMetricOrientation_kAIHorizontalMetricOrientation: AIMetricOrientation = 1;
pub const AIMetricOrientation_kAIVerticalMetricOrientation: AIMetricOrientation = 2;
#[doc = " Font orientations (writing directions)."]
pub type AIMetricOrientation = ::std::os::raw::c_uint;
#[doc = " Font metrics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFontMetrics {
    #[doc = " Leading space in points"]
    pub leading: AIReal,
    #[doc = " Ascent in points"]
    pub ascent: AIReal,
    #[doc = " descent in points"]
    pub descent: AIReal,
    #[doc = " Character bounding box"]
    pub bbox: AIRealRect,
}
pub const AITextOrientation_kHorizontalTextOrientation: AITextOrientation = 0;
pub const AITextOrientation_kVerticalTextOrientation: AITextOrientation = 1;
#[doc = " Text orientation"]
pub type AITextOrientation = ::std::os::raw::c_uint;
pub const AIFontTechnology_kAIUnknownFontTechnology: AIFontTechnology = 0;
pub const AIFontTechnology_kAIAnyFontTechnology: AIFontTechnology = 1;
pub const AIFontTechnology_kAIAdobeFontTechnology: AIFontTechnology = 100;
pub const AIFontTechnology_kAITrueTypeFontTechnology: AIFontTechnology = 101;
#[doc = " Font technologies."]
pub type AIFontTechnology = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite provides functions to access the set of fonts that is\navailable to Illustrator documents, and provide information about\nindividual fonts.\n\nThe set of available fonts includes those from the operating\nsystem, those installed with Illustrator, and substitute fonts for\nmissing fonts in open documents. The set of fonts can change during\na session as fonts are activated or deleted, and as documents are\nopened or closed.\n\nThere are several different types of font names:\n\\li The PostScript name is a unique, ASCII name that can\nbe stored in files to identify a font. For multiple master\ninstances, it includes the specific design axis values.\n\\li The Illustrator PostScript name is the PostScript name with\na suffix identifying the encoding. It can also be stored in\na file to identify a font.\n\\li A user name is a display name, which can be in ASCII or\na localized encoding. There can be several such names; for\nexample a full name describing the font, and the font family name.\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFontSuite and \\c #kAIFontVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFontSuite {
    #[doc = " Gets the total number of available fonts. Variations, such as\n\"Times Roman Regular\" and \"Times Roman Italic\" are counted as\ndistinct fonts. Use with \\c #IndexFontList() to iterate through\navailable fonts.\n@param count [out] A buffer in which to return the number of fonts."]
    pub CountFonts: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a font by index position. Use with \\c #CountFonts() to\niterate through available fonts. Font indices can change as\nfonts are added and removed.\n@param index The 0-based position index.\n@param fontKey [out] A buffer in which to return the font key."]
    pub IndexFontList: ::std::option::Option<
        unsafe extern "C" fn(index: ai_int32, fontKey: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Gets the total number of font families. Variants, such as italic\nand bold, are counted as a single family. Use with \\c #IndexTypefaceList() to\niterate through available font families.\n@param count [out] A buffer in which to return the number of font families."]
    pub CountTypefaces: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a font family by index position. Use with \\c #CountTypefaces() to\niterate through available font families. Indices can change as\nfonts are added and removed.\n@param index The 0-based position index.\n@param typeFaceKey [out] A buffer in which to return the font family key."]
    pub IndexTypefaceList: ::std::option::Option<
        unsafe extern "C" fn(index: ai_int32, typeFaceKey: *mut AITypefaceKey) -> AIErr,
    >,
    #[doc = " Gets the total number of variants (such as bold and italic) of a font family.\nUse with \\c #IndexTypefaceStyleList() to iterate through variants.\n@param typeface The font family, as returned by \\c #IndexTypefaceList().\n@param count [out] A buffer in which to return the number of variants."]
    pub CountTypefaceStyles: ::std::option::Option<
        unsafe extern "C" fn(typeface: AITypefaceKey, count: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a variant of a font family by index position. Use with\n\\c #CountTypefaceStyles() to iterate through variants.\n@param typeface The font family, as returned by \\c #IndexTypefaceList().\n@param index The 0-based position index.\n@param fontKey [out] A buffer in which to return the font key."]
    pub IndexTypefaceStyleList: ::std::option::Option<
        unsafe extern "C" fn(
            typeface: AITypefaceKey,
            index: ai_int32,
            fontKey: *mut AIFontKey,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the family and variant of a font.\n@param theKey The font key.\n@param typefaceResult [out] A buffer in which to return the font family key.\n@param styleResult [out] A buffer in which to return the index position\nof the family variant (such as bold or italic)."]
    pub TypefaceAndStyleFromFontKey: ::std::option::Option<
        unsafe extern "C" fn(
            theKey: AIFontKey,
            typefaceResult: *mut AITypefaceKey,
            styleResult: *mut ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Finds a font matching specific criteria.\n@param postscriptName The PostScript font name, such as \"Times-Roman\",\nor Illustrator PostScript font name.\n@param fontTechnology The font type, such as Adobe or TrueType, an \\c #AIFontTechnology value.\n@param script The language for which the font was designed; an \\c #AIFaceScript value.\n@param substituteFlag When true, returns a substitute if an exact match is not found.\n@param result [out] A buffer in which to return the font key."]
    pub FindFont: ::std::option::Option<
        unsafe extern "C" fn(
            postscriptName: *const ::std::os::raw::c_char,
            fontTechnology: AIFontTechnology,
            script: AIFaceScript,
            substituteFlag: AIBoolean,
            result: *mut AIFontKey,
        ) -> AIErr,
    >,
    #[doc = " Finds an Illustrator font matching a Mac OS system font.\n@param fontRef The Mac OS ATS font ref\n@param result [out] A buffer in which to return the font key."]
    pub FindMacFontFromMacFontRef: ::std::option::Option<
        unsafe extern "C" fn(macFontRef: AIMacFontRef, result: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Not implemented."]
    pub FindWinFont: ::std::option::Option<
        unsafe extern "C" fn(logFont: *mut AILOGFONTA, result: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Retrieves the Mac OS ATS font ref for an Illustrator font. If the given font does not\ncorrespond to a system font, gets the default system font.\n@param fontKey The font key.\n@param macFontRef [out] A buffer in which to return the Mac OS ATS font ref."]
    pub GetMacFontRef: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, macFontRef: *mut AIMacFontRef) -> AIErr,
    >,
    #[doc = " Retrieves typeface name of a font, or the system name for a system font in Windows.\n@param fontKey The font key.\n@param result [out] A buffer in which to return the typeface name, or,\nin Windows only, the face name of the WindowsLogFont if the font is a system font..\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetSystemFontName: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            result: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Sets the character widths for a fauxed, single-byte, horizontal font.\n@param fontKey The font key.\n@param charWidths A pointer to the new array of width values, in points.\nThis is an array of 256 values where each entry is the advance override\nfor the corresponding glyph."]
    pub SetCharWidths: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, charWidths: *mut AIReal) -> AIErr,
    >,
    #[doc = " Retrieves the font information for a font.\n@param theKey The font key.\n@param result [out] A buffer in which to return the font information structure."]
    pub GetFontInfo: ::std::option::Option<
        unsafe extern "C" fn(font: AIFontKey, result: *mut AIFontStyle) -> AIErr,
    >,
    #[doc = " Retrieves the font metrics for a font.\n@param theKey The font key.\n@param result [out] A buffer in which to return the font metrics structure."]
    pub GetFontMetrics: ::std::option::Option<
        unsafe extern "C" fn(font: AIFontKey, result: *mut AIFontMetrics) -> AIErr,
    >,
    #[doc = " Retrieves the default pen displacement for a glyph in a given orientation,\nfor a 1-point font.\n@param font The font key.\n@param glyphID The glyph identifier.\n@param orientation The text orientation (horizontal or vertical).\n@param hResult  [out] A buffer in which to return the horizontal displacement, in points,\nor \\c NULL if the orientation is vertical.\n@param vResult  [out] A buffer in which to return the vertical displacement, in points,\nor \\c NULL if the orientation is horizontal."]
    pub GetGlyphDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            glyphID: AIGlyphID,
            orientation: AIMetricOrientation,
            hResult: *mut AIReal,
            vResult: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the default pen displacement for a UTF8-encoded character\nin a given orientation, for a 1-point font.\n@param font The font key.\n@param charPtr A pointer to the platform-encoded character.\n@param orientation The text orientation (horizontal or vertical).\n@param hResult  [out] A buffer in which to return the horizontal displacement, in points,\nor 0 if the orientation is vertical.\n@param vResult  [out] A buffer in which to return the vertical displacement, in points,\nor 0 if the orientation is horizontal."]
    pub GetCharDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            charPtr: *const ::std::os::raw::c_char,
            orientation: AIMetricOrientation,
            hResult: *mut AIReal,
            vResult: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the default font for a language script.\n@param script The language script.\n@param result [out] A buffer in which to return the font key."]
    pub GetDefaultFont: ::std::option::Option<
        unsafe extern "C" fn(script: AIFaceScript, result: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Retrieves the PostScript name of a font, with the encoding\ninformation that Illustrator appends. This name is always encoded in ASCII.\n@param font The font key.\n@param fontName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFullFontName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            fontName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the Illustrator PostScript name of a font (with encoding information\nappended). This uniquely identifies a font, for example, in a file.\nThis name is always encoded in ASCII.\n@param font The font key.\n@param postScriptFontName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetPostScriptFontName: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            postScriptFontName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the ASCII-encoded name for the variant of a font (for example, \"Bold Italic\")\n@param font The font key.\n@param styleName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFontStyleName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            styleName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the display name for the family of a font (for example, \"Times Roman\").\nThe name is encoded either in ASCII or in the encoding of the font,\ndepending on the preference setting for using English font names.\n@param font The font key.\n@param familyName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFontFamilyUIName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            familyName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the display name for the variant of a font (for example, \"Bold Italic\").\nThe name is encoded either in ASCII or in the encoding of the font,\ndepending on the preference setting for using English font names.\n@param font The font key.\n@param styleName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFontStyleUIName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            styleName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the ASCII-encoded name for a font family (for example, \"Times Roman\").\n@param typeface The font family key.\n@param name [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetTypefaceName: ::std::option::Option<
        unsafe extern "C" fn(
            typeface: AITypefaceKey,
            name: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the full ASCII-encoded name for a font (for example, \"Times Roman Bold Italic\").\nThe name is always encoded in ASCII.\n@param font The font key.\n@param userfontName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetUserFontName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            userfontName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the full display name for a font (for example, \"Times Roman Bold Italic\")\nThe name is encoded either in ASCII or in the encoding of the font,\ndepending on the preference setting for using English font names.\n@param font The font key.\n@param userfontName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetUserFontUIName: ::std::option::Option<
        unsafe extern "C" fn(
            font: AIFontKey,
            userfontName: *mut ::std::os::raw::c_char,
            maxName: ai_int16,
        ) -> AIErr,
    >,
    #[doc = " Converts an Illustrator font key to an Adobe Text Engine (ATE)\nfont reference, for use with ATE functions.\n@param font The font key.\n@param result [out] A buffer in which to return the ATE font reference.\n@see \\c ATETypes.h"]
    pub FontFromFontKey: ::std::option::Option<
        unsafe extern "C" fn(font: AIFontKey, result: *mut *mut ATE__Font) -> AIErr,
    >,
    #[doc = " Converts an Adobe Text Engine (ATE) font reference to an Illustrator font key.\n@param font The ATE font reference.\n@param result [out] A buffer in which to return the font key.\n@see \\c ATETypes.h"]
    pub FontKeyFromFont: ::std::option::Option<
        unsafe extern "C" fn(font: *mut ATE__Font, result: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Retrieves whether a font is substituted or not.\n@param fontKey The font key.\n@param outIsSubstituted [out] A buffer in which to return the boolean value."]
    pub GetFontIsSubstituted: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, outIsSubstituted: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves a glyph set, which contains information about alternate\nglyphs within an OpenType font.\n@param theFont An OpenType font.\n@param otFeature When zero, gets information about all glyphs. Otherwise,\nspecify the feature of interest, as a 4-byte character sequence (in a \\c ai::int32)\nfor\tan OpenType feature tag.\n@param result [out] A buffer in which to return the glyph set. You must release\nthis object using \\c #ReleaseGlyphSet() when it is no longer needed.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetGlyphSet: ::std::option::Option<
        unsafe extern "C" fn(
            theFont: AIFontKey,
            otFeature: ai_int32,
            result: *mut AIGlyphSet,
        ) -> AIErr,
    >,
    #[doc = " Disposes of a glyph set object.\n@param theSet The object, as returned by \\c #GetGlyphSet()."]
    pub ReleaseGlyphSet: ::std::option::Option<unsafe extern "C" fn(theSet: AIGlyphSet) -> AIErr>,
    #[doc = " Gets the number of glyphs within a glyph set. Use with \\c #GetGlyphInfo() to iterate\nthrough glyphs.\n@param theSet The glyph set object.\n@param glyphCountResult [out] A buffer in which to return the number of glyphs."]
    pub CountGlyphs: ::std::option::Option<
        unsafe extern "C" fn(
            theSet: AIGlyphSet,
            glyphCountResult: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves information about a specific glyph. Use with \\c #CountGlyphs() to iterate\nthrough glyphs.\n@param theSet The glyph set object.\n@param glyphIndex The index position of the glyph, in the range <code>[1..numGlyphs]</code>.\n@param glyphInfoResult [out] A buffer in which to return the glyph information."]
    pub GetGlyphInfo: ::std::option::Option<
        unsafe extern "C" fn(
            theSet: AIGlyphSet,
            glyphIndex: ai_int32,
            glyphInfoResult: *mut AIGlyphInfo,
        ) -> AIErr,
    >,
    #[doc = " Gets the ordinal position of a given glyph within a glyph set.\n@param theSet The glyph set object.\n@param glyphID The unique identifier of the glyph.\n@param glyphIndex [out] A buffer in which to return the index position\nof the glyph, in the range <code>[1..numGlyphs]</code>."]
    pub GlyphIDToIndex: ::std::option::Option<
        unsafe extern "C" fn(
            theSet: AIGlyphSet,
            glyphID: AIGlyphID,
            glyphIndexResult: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves all OpenType features supported by a particular font.\n@param theFont The font key.\n@param featureList [in, out] An array of OpenType features of length \\c featureCount.\nEach value is a 4-byte character sequence (in a \\c ai::int32) representing\nan OpenType feature tag.\nCaller must provide the array. Pass NULL to obtain the size of the array required.\n@param featureCount [out] A buffer in which to return the size of array required for\n\\c featureList.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetOTFeatures: ::std::option::Option<
        unsafe extern "C" fn(
            theFont: AIFontKey,
            featureList: *mut ai_int32,
            featureCount: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Reports whether there are any glyphs for a given Open Type feature in a given font, or retrieves\nthe glyph set containing the glyphs, if any.\n(Note that this function returns a numeric value, not an error code.)\n@param theFeature The feature, a 4-byte character sequence (in a \\c ai::int32) representing\nan OpenType feature tag.\n@param fontKey The font key.\n@param existFlag When true, the function reports on whether the font contains any glyphs\nfor the feature. A font can define an OpenType feature, but assign no\nglyphs to that feature. Use this assure that at least one glyph is present.\n<br>When false, the function retrieves the glyph set\ncontaining the glyphs (if any). This is the same as using \\c #GetGlyphSet().\n@param result [out] A buffer in which to return the glyph set. You must release\nthis object using \\c #ReleaseGlyphSet() when it is no longer needed.\n@return Non-zero (true) if the font contains at least one glyph for the given feature,\nzero (false) otherwise.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetGlyphsForFeatureAccessInfo: ::std::option::Option<
        unsafe extern "C" fn(
            theFeature: ai_int32,
            fontKey: AIFontKey,
            existFlag: AIBoolean,
            glyphSet: *mut AIGlyphSet,
        ) -> ai_int32,
    >,
    #[doc = " Retrieves the font that contains a glyph set.\n@param glyphSetOpaque The glyph set.\n@param result [out] A buffer in which to return the font object."]
    pub GetFontInstance: ::std::option::Option<
        unsafe extern "C" fn(glyphSetOpaque: AIGlyphSet, result: *mut *mut AIFontInst) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifier of a glyph.\n@param glyphInfo The glyph information, as returned by \\c #GetGlyphInfo().\n@param result [out] A buffer in which to return the glyph identifier."]
    pub GetGlyphID: ::std::option::Option<
        unsafe extern "C" fn(glyphInfo: AIGlyphInfo, result: *mut AIGlyphID) -> AIErr,
    >,
    #[doc = " Retrieves the set of alternate glyphs for a given glyph.\n@param glyphInfo The glyph information, as returned by \\c #GetGlyphInfo().\n@param result [out] A buffer in which to return the alternative glyph set."]
    pub GetAlternateGlyphs: ::std::option::Option<
        unsafe extern "C" fn(glyphInfo: AIGlyphInfo, result: *mut AIGlyphSet) -> AIErr,
    >,
    #[doc = " Retrieves the OpenType features associated with a given glyph.\n@param glyphInfo The glyph information, as returned by \\c #GetGlyphInfo().\n@param otFeatures [out] A buffer in which to return the features. Do not modify the returned\ncharacter array (which is not a null-terminated string). The array contains\na set of 4-character feature codes; for example\t\"vertswsh\" for a glyph\nto which 'vert' and 'swsh' features can be applied.\n@param otFeatureCount [out] A buffer in which to return the number of features in \\c otFeatures.\n@param otFeatureIndex [out] A buffer in which to return an array of length\n\\c otFeatureCount containing the number of alternates available for each\nfeature listed in the \\c otFeatures array."]
    pub GetGlyphOTFeatures: ::std::option::Option<
        unsafe extern "C" fn(
            glyphInfo: AIGlyphInfo,
            otFeatures: *mut *const ::std::os::raw::c_char,
            otFeatureCount: *mut ai_int32,
            otFeatureIndex: *mut *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the Unicode character for a given glyph in a given font, with information about\nwhat OpenType features were applied.\n@param mGlyphID The glyph identifier.\n@param fontKey The font key.\n@param desiredOTFeature\tA string containing the OpenType features of interest. See\n\\c #GetGlyphOTFeatures(). The mapping of glyphs and feature sets to characters\nis not 1:1, so the returned character can have a different set of features than those\nrequested.\n@param theChar [out] A buffer in which to return the Unicode character.\n@param resultLength [out] A buffer in which to return the number of features in \\c theChar.\n@param otFeatures [out] A buffer in which to return the\tOpenType features set that was\napplied to \\c theChar. See \\c #GetGlyphOTFeatures(). You must release this memory with\n\\c #SPBasicSuite::FreeBlock() when it is no longer needed.\n@param otFeatureCount [out] A buffer in which to return the\tnumber of features in \\c otFeatures.\n@param otFeatureIndex [out] A buffer in which to return an array of length\n\\c otFeatureCount containing the number of alternates available for each\nfeature listed in the \\c otFeatures array.\nYou must release this memory with \\c #SPBasicSuite::FreeBlock() when it is no longer needed."]
    pub GetGlyphUnicodeValue: ::std::option::Option<
        unsafe extern "C" fn(
            mGlyphID: AIGlyphID,
            fontKey: AIFontKey,
            desiredOTFeature: *const ::std::os::raw::c_char,
            theChar: *mut ASUnicode,
            resultLength: *mut ::std::os::raw::c_int,
            otFeatures: *mut *mut ::std::os::raw::c_char,
            otFeatureCount: *mut ai_int32,
            otFeatureIndex: *mut *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the font for a glyph.\n@param theGlyphInfo\tThe glyph information, as returned by \\c #GetGlyphInfo().\n@param result [out] A buffer in which to return the font key."]
    pub GetGlyphFontKey: ::std::option::Option<
        unsafe extern "C" fn(theGlyphInfo: AIGlyphInfo, result: *mut AIFontKey) -> AIErr,
    >,
    #[doc = " Retrieves the number of alternate glyphs for a given glyph.\n@param theGlyphInfo\tThe glyph information, as returned by \\c #GetGlyphInfo().\n@param result [out] A buffer in which to return the number of alternative glyphs."]
    pub GetGlyphAlternateCount: ::std::option::Option<
        unsafe extern "C" fn(
            theGlyphInfo: AIGlyphInfo,
            result: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the \\e undefined glyph for a glyph set. Each font has one undefined glyph, but not every\nglyph set contains one. Use \\c #HasUndefinedGlyph() to check.\n@param theSet The glyph set.\n@param undefinedGlyphIDResult [out] A buffer in which to return the glyph identifier."]
    pub GetUndefinedGlyphID: ::std::option::Option<
        unsafe extern "C" fn(theSet: AIGlyphSet, undefinedGlyphIDResult: *mut AIGlyphID) -> AIErr,
    >,
    #[doc = " Reports whether a glyph set contains an undefined glyph. Each font has one undefined glyph,\nbut not every glyph set contains one. Use \\c #GetUndefinedGlyphID to retrieve it if there is one.\n(Note that this function returns a boolean value, not an error code.)\n@param theSet The glyph set.\n@return True if the set contains an undefined glyph."]
    pub HasUndefinedGlyph:
        ::std::option::Option<unsafe extern "C" fn(theSet: AIGlyphSet) -> AIBoolean>,
    #[doc = " Imports composite fonts from an AI or ATC file into the current document.\n@param source The AI or ATC file path."]
    pub ImportCompositeFonts:
        ::std::option::Option<unsafe extern "C" fn(source: *const ai_FilePath) -> AIErr>,
    #[doc = " Translates a character value to a single glyph in a given font.\n@param fontKey The font key.\n@param ch A string containing the character. Extracts at most\none glyph, using as many bytes as needed to form one glyph,\nstarting with the first byte pointed to by \\c ch.\nDerives the encoding from the font.\n@param srcLen The number of bytes in \\c ch.\n@param orientation The text orientation, vertical or horizontal.\n@param glyphID [out] A buffer in which to return the glyph identifier, or\nundefined glyph for the font if a glyph is not defined for this character.\n@return The error \\c #kGlyphNotDefinedErr if a glyph is not defined for\nthis character."]
    pub ConvertCharacterToGlyphID: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            ch: *const ::std::os::raw::c_char,
            srcLen: ai_int32,
            orientation: AIMetricOrientation,
            glyphID: *mut AIGlyphID,
        ) -> AIErr,
    >,
    #[doc = " Translates a Unicode character value to a single glyph in a given font.\n@param fontKey The font key.\n@param ch A UTF16-encoded string containing the character. Extracts at most\none glyph, using as many characters as needed to form one glyph,\nstarting with the first character pointed to by \\c ch.\n@param srcLen The number of \\c ASUnicode characters (not bytes) in \\c ch.\n@param orientation The text orientation, vertical or horizontal.\n@param glyphID [out] A buffer in which to return the glyph identifier, or\nundefined glyph for the font if a glyph is not defined for this character.\n@return The error \\c #kGlyphNotDefinedErr if a glyph is not defined for\nthis character."]
    pub ConvertUnicodeToGlyphID: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            ch: *const ASUnicode,
            srcLen: ai_int32,
            orientation: AIMetricOrientation,
            glyphID: *mut AIGlyphID,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the full display name for a font (for example, \"Times Roman Bold Italic\")\nin Unicode (UTF16).\nThe name is either in English or the native language of the font depending on the\nsetting of the preference to use English font names.\n@param fontKey The font key.\n@param userfontName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetUserFontUINameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            userfontName: *mut ASUnicode,
            maxName: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the display name for the family of a font (for example, \"Times Roman\")\nin Unicode (UTF16).\nThe name is either in English or the native language of the font depending on the\nsetting of the preference to use English font names.\n@param fontKey The font key.\n@param familyName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFontFamilyUINameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            familyName: *mut ASUnicode,
            maxName: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the display name for the variant of a font (for example, \"Bold Italic\")\nin Unicode (UTF16).\nThe name is either in English or the native language of the font depending on the\nsetting of the preference to use English font names.\n@param fontKey The font key.\n@param styleName [out] A buffer in which to return the name.\n@param maxName The number of characters in the name string buffer. The name string,\nincluding the \\c NULL terminator, is truncated to this size if necessary."]
    pub GetFontStyleUINameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            styleName: *mut ASUnicode,
            maxName: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the ideographic character face (IFC) bounds of a font.\nThe ICF-box is the maximum bounding box of the ideographic portion of a CJK font,\nusually centered within the em-box. The value is also defined also for non-CJK fonts.\nThe coordinate values are relative to the font coordinate system's origin.\nX values increase to the right and Y values increase downward.\n@param fontKey The font key.\n@param icfBox [out] A buffer in which to return the bounding box\n@see Baseline tags \\c icfb and \\c icft in the OpenType tag registry."]
    pub GetICFBox: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, icfBox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Retrieves the version string for a font file. If the font object is fauxed,\ngets version information for the underlying font.\nYou can check whether the font is fauxed using \\c #GetFontInfo().\n@param fontKey The font key.\n@param versionString [out] A buffer in which to return the version string."]
    pub GetVersionString: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, versionString: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Reports how many files constitute a font. For example, a Windows Type 1 font has a PFB\nand a PFM file, and a Mac Type 1 font has a suitcase and an outline file, but an OpenType\nfont has only a single file. Use with \\c #GetNthFilePath() to access the files.\n\nIf the font is fauxed, returns the information for the underlying font used to faux\nthe missing font. Check whether the font is fauxed using \\c #GetFontInfo().\n@param fontKey The font key.\n@param count [out] A buffer in which to return the number of files.\nThis can be 0 for some fonts; see \\c #GetNthFilePath().\n@note This function does not distinguish between two identical font files\nand two different files for the same font."]
    pub GetFontFilePathCount: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, count: *mut ai_uint32) -> AIErr,
    >,
    #[doc = " Retrieves a file path associated with a font. Use with \\c #GetFontFilePathCount()\nto access font files.\n\nThis method does not work for fonts whose paths Illustrator does not know,\nsuch as Windows bitmap fonts, and Mac OS bitmap-only fonts. For an ATC font,\ngets the location of the top-level rearrangement file only.\nTo get the paths of component fonts, iterate over the component dictionaries.\n\nIf the font is fauxed, returns the information for the underlying font used to faux\nthe missing font. Check whether the font is fauxed using \\c #GetFontInfo().\n\n@param fontKey The font key.\n@param n The position index of the file path, the range <code>[0..pathCount-1]</code>.\n@param filePath [out] A buffer in which to return the path."]
    pub GetNthFilePath: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, n: ai_uint32, filePath: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Gets the number of ATC components for a font. If the font is fauxed,\nreturns the information for the underlying font used to faux\nthe missing font. Check whether the font is fauxed, and that it\nis an ATC font, using \\c #GetFontInfo().\n@param fontKey The font key.\n@param count [out] A buffer in which to return the number of ATC components.\nThis is 0 for a non-ATC font."]
    pub GetNumATCComponents: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, count: *mut ai_uint32) -> AIErr,
    >,
    #[doc = " Retrieves a component for an ATC font, by position index. Use with\n\\c #GetNumATCComponents() to access font components.\n\nIf the font is fauxed, returns the information for the underlying font used to faux\nthe missing font. Check whether the font is fauxed, and that it\nis an ATC font, using \\c #GetFontInfo().\n\n@param fontKey The font key.\n@param n The position index of the component, the range <code>[0..numATCComponents-1]</code>.\n@param componentFontKey [out] A buffer in which to return the component font key."]
    pub GetNthATCComponent: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            n: ai_uint32,
            componentFontKey: *mut AIFontKey,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the full user name for a font (for example, \"Times Roman Bold Italic\").\nThis might not be the same as the display name; retrieve the display name with\n\\c #GetUserFontUINameUnicode().\n@param fontKey The font key.\n@param name [out] A buffer in which to return the name string.\n@param native True to get the name in the native language of the font, false\nto get the name in English, regardless of the font's language."]
    pub GetUserFontNameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            name: *mut ai_UnicodeString,
            native: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the user name for the family of a font (for example, \"Times Roman\").\nThis might not be the same as the display name; retrieve the display name with\n\\c #GetFontFamilyUINameUnicode().\n@param fontKey The font key.\n@param name [out] A buffer in which to return the name string.\n@param native True to get the name in the native language of the font, false\nto get the name in English, regardless of the font's language."]
    pub GetFontFamilyNameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            name: *mut ai_UnicodeString,
            native: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the user name for the style of a font (for example, \"Bold Italic\").\nThis might not be the same as the display name; retrieve the display name with\n\\c #GetFontStyleUINameUnicode().\n@param fontKey The font key.\n@param name [out] A buffer in which to return the name string.\n@param native True to get the name in the native language of the font, false\nto get the name in English, regardless of the font's language."]
    pub GetFontStyleNameUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            fontKey: AIFontKey,
            name: *mut ai_UnicodeString,
            native: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the ideographic em-box of a font, also known as an ideographic font's design space.\nThis defines a standard monospaced escapement around the glyphs of the font, for both horizontal and\nvertical writing modes. It is one em high and one em wide unless the vendor explicitly indicates\notherwise in the font. The OpenType specification strongly recommends against this being other than an\nem wide, but there are legitimate reasons for it to be other than one em high: some fonts used in\nJapanese newspaper layout, for example, have a vertically compressed ideographic em-box.\n\nThe returned value, an array with the left, top, right, and bottom edges\n(in horizontal writing mode) of the ideographic em-box of a 1-unit-em font,\nis defined for every font (including non-CJK fonts, where it can be used to em-box-align\nthese fonts alongside CJK fonts).\n\nThe coordinate values are relative to the font coordinate system's origin.\nX values increase to the right and Y values increase downward.\n@param fontKey The font key.\n@param ideoEmBox [out] A buffer in which to return the bounding box,\n@see Baseline tag \\c ideo in the OpenType tag registry for more information."]
    pub GetIdeoEmBox: ::std::option::Option<
        unsafe extern "C" fn(fontKey: AIFontKey, ideoEmBox: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Retrieves a font from a given family that is the closest match for a given font from\nanother family. If the same style is present in the new family, it is selected; otherwise,\nselects the closest match from the new family.\n@param old_Family The typeface of a previously selected font family.\n@param old_style The 0-based index of the font style to match within the old family.\n@param new_Family The typeface of a new font family, in which to find a match.\n\n@param new_style [out] A bufffer in which to return the 0-based index of the best-match font in the new family."]
    pub GetCloselyMatchingFontStyle: ::std::option::Option<
        unsafe extern "C" fn(
            old_Family: AITypefaceKey,
            old_Style: *mut ::std::os::raw::c_short,
            new_Family: AITypefaceKey,
            new_Style: *mut ::std::os::raw::c_short,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a font family by index position, from the list of all available font families.\nUse with \\c #CountTypefaces() to iterate through available font families. Indices can change as fonts are added and removed.\n@param index The 0-based position index.\n@param typeFaceKey [out] A buffer in which to return the font family key."]
    pub IndexTypefaceListSortedByDefaultScript: ::std::option::Option<
        unsafe extern "C" fn(typeface: *mut AITypefaceKey, index: ai_int32) -> AIErr,
    >,
    pub GetTypefaceUnicodeMenuName: ::std::option::Option<
        unsafe extern "C" fn(typeface: AITypefaceKey, typefaceName: *mut ai_UnicodeString) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMEFontSuite {
    #[doc = " Retrieves a glyph set, which contains information about alternate\nglyphs within an OpenType font.\n@param theFont An OpenType font.\n@param AILanguage The language code for the current system language.\n@param otFeature When zero, gets information about all glyphs. Otherwise,\nspecify the feature of interest, as a 4-byte character sequence (in a \\c ai::int32)\nfor\tan OpenType feature tag.\n@param result [out] A buffer in which to return the glyph set. You must release\nthis object using \\c #ReleaseGlyphSet() when it is no longer needed.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetGlyphSet: ::std::option::Option<
        unsafe extern "C" fn(
            theFont: AIFontKey,
            AILanguage: ::std::os::raw::c_int,
            otFeature: ai_int32,
            result: *mut AIGlyphSet,
        ) -> AIErr,
    >,
    #[doc = " Retrieves all OpenType features supported by a particular font.\n@param theFont The font key.\n@param AILanguage The language code for the current system language.\n@param featureList [in, out] An array of OpenType features of length \\c featureCount.\nEach value is a 4-byte character sequence (in a \\c ai::int32) representing\nan OpenType feature tag.\nCaller must provide the array. Pass NULL to obtain the size of the array required.\n@param featureCount [out] A buffer in which to return the size of array required for\n\\c featureList.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetOTFeatures: ::std::option::Option<
        unsafe extern "C" fn(
            theFont: AIFontKey,
            AILanguage: ::std::os::raw::c_int,
            featureList: *mut ai_int32,
            featureCount: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Reports whether there are any glyphs for a given Open Type feature in a given font, or retrieves\nthe glyph set containing the glyphs, if any.\n(Note that this function returns a numeric value, not an error code.)\n@param theFeature The feature, a 4-byte character sequence (in a \\c ai::int32) representing\nan OpenType feature tag.\n@param fontKey The font key.\n@param AILanguage The language code for the current system language.\n@param existFlag When true, the function reports on whether the font contains any glyphs\nfor the feature. A font can define an OpenType feature, but assign no\nglyphs to that feature. Use this assure that at least one glyph is present.\n<br>When false, the function retrieves the glyph set\ncontaining the glyphs (if any). This is the same as using \\c #GetGlyphSet().\n@param result [out] A buffer in which to return the glyph set. You must release\nthis object using \\c #ReleaseGlyphSet() when it is no longer needed.\n@return Non-zero (true) if the font contains at least one glyph for the given feature,\nzero (false) otherwise.\n@see For the set of registered features tags,\n\\c  https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags"]
    pub GetGlyphsForFeatureAccessInfo: ::std::option::Option<
        unsafe extern "C" fn(
            theFeature: ai_int32,
            fontKey: AIFontKey,
            AILanguage: ::std::os::raw::c_int,
            existFlag: AIBoolean,
            glyphSet: *mut AIGlyphSet,
        ) -> ai_int32,
    >,
    #[doc = " Retrieves the Unicode character for a given glyph in a given font, with information about\nwhat OpenType features were applied.\n@param mGlyphID The glyph identifier.\n@param fontKey The font key.\n@param AILanguage The language code for the current system language.\n@param desiredOTFeature\tA string containing the OpenType features of interest. See\n\\c #GetGlyphOTFeatures(). The mapping of glyphs and feature sets to characters\nis not 1:1, so the returned character can have a different set of features than those\nrequested.\n@param theChar [out] A buffer in which to return the Unicode character.\n@param resultLength [out] A buffer in which to return the number of features in \\c theChar.\n@param otFeatures [out] A buffer in which to return the\tOpenType features set that was\napplied to \\c theChar. See \\c #GetGlyphOTFeatures(). You must release this memory with\n\\c #SPBasicSuite::FreeBlock() when it is no longer needed.\n@param otFeatureCount [out] A buffer in which to return the\tnumber of features in \\c otFeatures.\n@param otFeatureIndex [out] A buffer in which to return an array of length\n\\c otFeatureCount containing the number of alternates available for each\nfeature listed in the \\c otFeatures array.\nYou must release this memory with \\c #SPBasicSuite::FreeBlock() when it is no longer needed."]
    pub GetGlyphUnicodeValue: ::std::option::Option<
        unsafe extern "C" fn(
            mGlyphID: AIGlyphID,
            fontKey: AIFontKey,
            AILanguage: ::std::os::raw::c_int,
            desiredOTFeature: *const ::std::os::raw::c_char,
            theChar: *mut ASUnicode,
            resultLength: *mut ::std::os::raw::c_int,
            otFeatures: *mut *mut ::std::os::raw::c_char,
            otFeatureCount: *mut ai_int32,
            otFeatureIndex: *mut *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the language code for the current system language.\n(Note that this function returns a numeric value, not an error code.)\n@return The language code."]
    pub GetCurrentLanguage: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    #[doc = " Converts an Adobe Text Engine language object to an Illustrator language code.\n(Note that this function returns a numeric value, not an error code.)\n@param sloLang The Adobe Text Engine language object.\n@return The language code."]
    pub SLOLanguageToAILanguage:
        ::std::option::Option<unsafe extern "C" fn(sloLang: ATE_Language) -> ::std::os::raw::c_int>,
    #[doc = "  Retrieves the language from a glyph-information structure.\n@param glyphInfo The glyph-information structure.\n@param result [out] A buffer in which to return the language code.\n"]
    pub GetGlyphLanguage: ::std::option::Option<
        unsafe extern "C" fn(glyphInfo: AIGlyphInfo, result: *mut ::std::os::raw::c_int) -> AIErr,
    >,
}
#[doc = " @ingroup Notifiers\nSent when the application is activated."]
pub const kAIApplicationActivatedNotifier: &[u8; 34] = b"AI Application Activated Notifier\0";
#[doc = " @ingroup Notifiers\nSent when the application is deactivated."]
pub const kAIApplicationDeactivatedNotifier: &[u8; 36] = b"AI Application Deactivated Notifier\0";
#[doc = " @ingroup Notifiers\nSent when the application or system/OS is going to sleep."]
pub const kAIApplicationSuspendedNotifier: &[u8; 34] = b"AI Application Suspended Notifier\0";
#[doc = " @ingroup Notifiers\nSent when the application or system/OS is awaking from sleep."]
pub const kAIApplicationResumedNotifier: &[u8; 32] = b"AI Application Resumed Notifier\0";
#[doc = " Application name"]
pub type AIAppName = *const ::std::os::raw::c_char;
#[doc = " Application version"]
pub type AIAppVersion = *const ::std::os::raw::c_char;
#[doc = " User name, as registered for the application."]
pub type AIUserName = *const ::std::os::raw::c_char;
#[doc = " User organization, as registered for the application."]
pub type AIUserOrganization = *const ::std::os::raw::c_char;
#[doc = " User serial number, as registered for the application."]
pub type AIUserSerialNumber = *const ::std::os::raw::c_char;
#[doc = " @ingroup Suites\nThis suite provide functions that allow you to obtain information\nabout the name and version number of the plug-in host application.\nYou can access application instances of the name space and string\npool data structures, and the user name, organization, and serial\nnumber registered for the application.\n\nThe following notifiers are associated with the runtime suite:\n<br> \\c #kAIApplicationStartedNotifier\n<br> \\c #kAIApplicationShutdownNotifier\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIRuntimeSuite and \\c #kAIRuntimeVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIRuntimeSuite {
    #[doc = " Retrieves the name of the host application running the plug-in.\nYou can use the name to verify that your plug-in is running in\na supported host application. You can also use the name and\nserial number to key your plug-in to an installed application.\n@param name [out] A buffer in which to return the name,\nas a C-string from the application string pool.\nDo not modify the returned string."]
    pub GetAppName: ::std::option::Option<unsafe extern "C" fn(name: *mut AIAppName) -> AIErr>,
    #[doc = " Retrieves the file specification of the host application running the plug-in.\n@param name [out] A buffer in which to return the file specification."]
    pub GetAppFileSpecification:
        ::std::option::Option<unsafe extern "C" fn(file: *mut ai_FilePath) -> AIErr>,
    #[doc = " Retrieves the user name, as registered with the application when\nit was installed.\n@param name [out] A buffer in which to return the name,\nas a C-string from the application string pool.\nDo not modify the returned string."]
    pub GetUserName: ::std::option::Option<unsafe extern "C" fn(name: *mut AIUserName) -> AIErr>,
    #[doc = " Retrieves the user organization, as registered with the application when\nit was installed.\n@param organization [out] A buffer in which to return the organization,\nas a C-string from the application string pool.\nDo not modify the returned string."]
    pub GetUserOrganization:
        ::std::option::Option<unsafe extern "C" fn(organization: *mut AIUserOrganization) -> AIErr>,
    #[doc = " Retrieves the user serial number, as registered with the application when\nit was installed.\n@param serialNumber [out] A buffer in which to return the serial number,\nas a C-string from the application string pool.\nDo not modify the returned string."]
    pub GetUserSerialNumber:
        ::std::option::Option<unsafe extern "C" fn(serialNumber: *mut AIUserSerialNumber) -> AIErr>,
    #[doc = " Retrieves a reference to the namespace of the host application\nrunning the plug-in.\n\nA plug-in can create its own namespace in which to store arbitrary data,\nbut it can also use this function to access the applications namespace.\nThe application preferences (among other things) are stored in the\napplication namespace.\n\nYour plug-in should not modify the applications existing namespace data\ndirectly, but it can create new data within the application namespace.\n@param space [out] A buffer in which to return the namespace reference."]
    pub GetAppNameSpace:
        ::std::option::Option<unsafe extern "C" fn(space: *mut *mut AINameSpace) -> AIErr>,
    #[doc = " Retrieves a reference to the string pool of the host application\nrunning the plug-in.\n\nIllustrator maintains a string pool which any plug-in can access.\nRuntime data for a host is stored in this string pool, and the strings\nreturned by functions in this suite belong to the application string pool.\nThese references point to the C-string data in the pool, and should\nnot be modified. If you need to modify such a string, copy it to\nlocal storage. See \\c #AIStringPoolSuite.\n@param pool [out] A buffer in which to return the string-pool reference."]
    pub GetAppStringPool:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut *mut AIStringPool) -> AIErr>,
    #[doc = "\tGets the amount of physical RAM on the computer, which you can use\nas an estimate of free application memory available.\n(Note that this function returns a numeric value, not an error code.)\n@return The number of bytes of RAM."]
    pub GetAppFreeMem: ::std::option::Option<unsafe extern "C" fn() -> usize>,
    #[doc = " Shows the about box for the application."]
    pub ShowAppAboutBox: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves the version of the operating system the application is running on.\n(Note that this function returns a constant value, not an error code.)\n@return An integer value of the form: (majorVersion * 100 + minorVersion)."]
    pub GetSystemVersion: ::std::option::Option<unsafe extern "C" fn() -> ai_int32>,
    #[doc = " Reports whether the operating system is Mac OS X.\n@return True if the operating system is Mac OS X."]
    pub GetIsSystemMacOSX: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Retrieves the major version number of the application\n(X where the version number is X.Y.Z).\n(Note that this function returns a numeric value, not an error code.)\n@return The major version number."]
    pub GetAppMajorVersion: ::std::option::Option<unsafe extern "C" fn() -> ai_int32>,
    #[doc = " Retrieves the minor version number of the application\n(Y where the version number is X.Y.Z).\n(Note that this function returns a numeric value, not an error code.)\n@return The minor version number."]
    pub GetAppMinorVersion: ::std::option::Option<unsafe extern "C" fn() -> ai_int32>,
    #[doc = " Retrieves the revision number of the application\n(Z where the version number is X.Y.Z).\n(Note that this function returns a numeric value, not an error code.)\n@return The revision number."]
    pub GetAppRevisionVersion: ::std::option::Option<unsafe extern "C" fn() -> ai_int32>,
    #[doc = " Retrieves the Unicode name of the host application running the plug-in.\n@param name [out] A buffer in which to return the name,\nas a Unicode string."]
    pub GetAppNameUS:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Retrieves the Unicode user name, as registered with the application when\nit was installed.\n@param name [out] A buffer in which to return the name,\nas a Unicode string."]
    pub GetUserNameUS:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Retrieves the Unicode organization name, as registered with the application when\nit was installed.\n@param organization [out] A buffer in which to return the name,\nas a Unicode string."]
    pub GetUserOrganizationUS:
        ::std::option::Option<unsafe extern "C" fn(organization: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Retrieves the default script for the application.\n@param script [out] A buffer in which to return the\tscript reference."]
    pub GetDefaultScript:
        ::std::option::Option<unsafe extern "C" fn(script: *mut AIFaceScript) -> AIErr>,
    #[doc = " Used internally."]
    pub GetIsHonestyBuild: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = "  Used internally."]
    pub GetIsProductTryAndDie: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Used internally. Reports whether this is an executable build."]
    pub GetIsExeBuild: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Launches the Adobe Help Viewer and shows an Illustrator help page.\n@param pageID  A null terminated UTF-8 string for the help page ID,\nor a NULL pointer to bring up the default help page."]
    pub ShowAdobeHelp:
        ::std::option::Option<unsafe extern "C" fn(pageID: *const ::std::os::raw::c_char) -> AIErr>,
    #[doc = " Retrieves the application build number.\n\n@param isDebug [out] A buffer in which to return a flag, or NULL if flag is not needed.\nReturns true if this is a debug build, false if this is a release build.\n@returns the revision number."]
    pub GetAppBuildNumber:
        ::std::option::Option<unsafe extern "C" fn(isDebug: *mut AIBoolean) -> ai_int32>,
    #[doc = "\tRetrieves Adobe user's GUID and AdobeID.\n\n@returns 0 if fails"]
    pub GetUserAdobeID: ::std::option::Option<
        unsafe extern "C" fn(
            userGUID: *mut *const ::std::os::raw::c_char,
            userAdobeID: *mut *const ::std::os::raw::c_char,
        ) -> ai_int32,
    >,
    #[doc = " Returns true, if the application is AIRobin instead of Illustrator.\nAIRobin is the background helper process of Illustrator.\n@returns true, if application is AIRobin."]
    pub IsAIRobin: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    pub PostQuit: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "Pauses the Idle events suppression when the app is in background. This will allow plugins to perform and receive idle notifications\nEven when the app is in background. This must be turned back on by calling ResumeIdleEventSuspensionInBackground"]
    pub PauseIdleEventSuspensionInBackground:
        ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "Resumes the Idle events suppression when the app is in the background. This must be called after PauseIdleEventSuspensionInBackground"]
    pub ResumeIdleEventSuspensionInBackground:
        ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "Pauses the idle event suppression when the app is in the background for a specified number of seconds. It will automatically resume\nafter the time have elapsed after calling the API. There is no need for specifically resuming when calling this API."]
    pub PauseIdleEventSuspensionInBackgroundFor:
        ::std::option::Option<unsafe extern "C" fn(seconds: ai_uint32) -> AIErr>,
    #[doc = " Returns true if Idle events processing is suspended when the app is in the background."]
    pub AreIdleEventsSuspendedInBackground:
        ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
}
#[doc = " A standard context results in the addition of a new transaction which\ncan be undone/redone by the user"]
pub const AIUndoContextKind_kAIStandardUndoContext: AIUndoContextKind = 0;
#[doc = " A silent context does not cause redos to be discarded and\nis skipped over when undoing and redoing. An example is a selection change."]
pub const AIUndoContextKind_kAISilentUndoContext: AIUndoContextKind = 1;
#[doc = " An appended context is like a standard context, except that\nit is combined with the preceding transaction. It does not\nappear as a separate transaction. Used, for example, to\ncollect sequential changes to the color of an object into a\nsingle undo/redo transaction."]
pub const AIUndoContextKind_kAIAppendUndoContext: AIUndoContextKind = 2;
#[doc = " Undo context types. See \\c #AIUndoSuite."]
pub type AIUndoContextKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUndoNotificationParameters {
    pub fNoOfTransactions: ai_int32,
    pub fDocument: AIDocumentHandle,
}
#[doc = " @ingroup Suites\nThis suites provides access to the Undo/Redo mechanism. Use these\nfunctions to revert the artwork state to what it was when your\nplug-in was called, or to set the text of the Undo/Redo menus.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUndoSuite and \\c #kAIUndoVersion.\n\n@section UndoContext Undo API Contexts\n\nThe \\c AIUndoSuite allows you to manipulate the undo \\e context for your plug-in.\nGenerally, each time Illustrator sends a plug-in a selector, it creates\nan undo context. The record is created before the plug-in is called and\nclosed when the plug-in finishes running. The changes made by the plug-in\nare accumulated in this record and make up the undo context. When the user\nchooses Undo from the Edit menu, the changes of the last complete context\nare undone. Redo restores the context changes.\n\nYou can use \\c #UndoChanges() to programmatically undo the changes within\nthe context Illustrator has made for your plug-in. It cannot undo changes\noutside of this context.\n\nFor plug-in tools, Illustrator handles undo contexts a little differently.\nInstead of generating a context for each selector, it bundles the mouse\nselectors into a single context. This allows a plug-in to undo changes\nit made last time and then modify the document in response to the\ncurrent mouse position. Illustrator then redraws the document when the plug-in\nreturns control.\n\nThere are three types of undo context, defined by \\c #AIUndoContextKind.\nIllustrator normally establishes a \\c #kAIStandardUndoContext, but notifications\nare sent in a \\c #kAISilentUndoContext. A plug-in can change the undo context\ntype with \\c #SetSilent() and \\c #SetKind(), but only if the plug-in is \\e not\noperating in a nested context (that is, a context created when another plug-in\nis executing). This prevents a plug-in in a nested context from\nmodifying the behavior of the outer context.\n\nUndo entries can be tagged with a string and/or an integer. Only standard\ncontexts can be tagged."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUndoSuite {
    #[doc = " Specifies the localizable text(Unicode String) for Undo and Redo menu items. Illustrator\nuses these strings for the menus as needed.\n@note Illustrator automatically handles the undo mechanism for\nplug-in filters. Filters should not use this function.\n@param undoText\tUnicode String text for the Undo menu.\n@param redoText\tUnicode String text for the Redo menu."]
    pub SetUndoTextUS: ::std::option::Option<
        unsafe extern "C" fn(
            undoText: *const ai_UnicodeString,
            redoText: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Specifies the localizable text(Unicode String) for Undo, Redo, and History Panel  menu items.\nIllustrator uses these strings for the menus and history panel as needed.\n@note Illustrator automatically handles the undo mechanism for\nplug-in filters. Filters should not use this function.\n@param undoText\tUnicode String text for the Undo menu.\n@param redoText\tUnicode String text for the Redo menu.\n@param cmdText\tUnicode String text for history panel"]
    pub SetUndoRedoCmdTextUS: ::std::option::Option<
        unsafe extern "C" fn(
            undoText: *const ai_UnicodeString,
            redoText: *const ai_UnicodeString,
            cmdText: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Undo \"N\" changes from the past.\n@param n\tThe no. of transactions to be undone."]
    pub MultiUndoTransaction: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, n: ai_int32) -> AIErr,
    >,
    #[doc = " Redo \"N\" changes from the future.\n@param n\tThe no. of transactions to be redone."]
    pub MultiRedoTransaction: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, n: ai_int32) -> AIErr,
    >,
    #[doc = " Undoes changes in the current undo context. Clears any changes made\nto the artwork since the undo context of the plug-in was created."]
    pub UndoChanges: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Undoes changes in the Action palette. Clears any changes made\nto the Action palette  since the undo context of the plug-in was created."]
    pub SetActionPaletteUndo: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "\tUndoes and forgets the last transaction.\nAny redos available at this point are also forgotten.\nThis decreases the available undo transactions by one.\nChanges made in the last transaction are no longer available for redo."]
    pub RevertAndForgetLastTransaction: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "\tForgets all redoable transactions.\nAny redos available at this point are forgotten.\nThis decreases the available redo transactions to 0.\n@param document The document on which to perform the operation.."]
    pub ForgetRedos:
        ::std::option::Option<unsafe extern "C" fn(document: AIDocumentHandle) -> AIErr>,
    #[doc = "\tForgets all future transactions and commits all\ncurrent and past transactions. Post this the transaction\nqueue is empty."]
    pub ClearHistory:
        ::std::option::Option<unsafe extern "C" fn(document: AIDocumentHandle) -> AIErr>,
    #[doc = " Marks or unmarks the current API context as being silent for undo purposes.\nSee @ref UndoContext.\n@param silent True to set the context to \\c #kAISilentUndoContext,\nfalse to set it to \\c #kAIStandardUndoContext."]
    pub SetSilent: ::std::option::Option<unsafe extern "C" fn(silent: AIBoolean) -> AIErr>,
    #[doc = " Sets the type of the current undo context, but only if the plug-in is \\e not\noperating in a nested context (that is, a context created when another plug-in\nis executing). See @ref UndoContext.\n@param kind The new context type, an \\c #AIUndoContextKind constant."]
    pub SetKind: ::std::option::Option<unsafe extern "C" fn(kind: ai_int32) -> AIErr>,
    #[doc = " Counts the number of undo and redo transactions that a user can\nperform. Does not count silent or appended transactions. Use with\n\\c #GetNthTransactionTag() to iterate through transactions in the\ncurrent undo context.\n@param past [out] A buffer in which to return the number of undo transactions.\n@param future [out] A buffer in which to return the number of redo transactions.\n"]
    pub CountTransactions: ::std::option::Option<
        unsafe extern "C" fn(past: *mut ai_int32, future: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Reports whether the current API context is marked as silent for undo purposes.\nIf the current context is nested, this can return true while the outer\ncontext is not silent. See @ref UndoContext.\n@param silent [out] A buffer in which to return true if the current undo context\nis silent."]
    pub IsSilent: ::std::option::Option<unsafe extern "C" fn(silent: *mut AIBoolean) -> AIErr>,
    #[doc = " Sets a Unicode tag string and integer for the undo transaction that is generated\nby the current API context.\tAffects only standard undo contexts; see @ref UndoContext.\n@param tagString A descriptive Unicode string.\n@param tagInteger An identifying number."]
    pub SetTagUS: ::std::option::Option<
        unsafe extern "C" fn(tagString: *const ai_UnicodeString, tagInteger: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a Unicode tag string and integer for the undo transaction that is generated\nby the current API context.\tWorks only standard undo contexts; see @ref UndoContext.\n@param tagString [out] A buffer in which to return the descriptive Unicode string.\n@param tagInteger [out] A buffer in which to return the identifying number."]
    pub GetTagUS: ::std::option::Option<
        unsafe extern "C" fn(tagString: *mut ai_UnicodeString, tagInteger: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets a transaction tag (a Unicode string) by position index for the current undo/redo context.\nUse with \\c #CountTransactions() to iterate through transactions in the\ncurrent standard undo context.\n@param n The position index. Positive values indicate redo transactions,\nnegative values indicate undo transactions. No transaction is at index 0.\n@param tagString A descriptive Unicode string.\n@param tagInteger An identifying number."]
    pub SetNthTransactionTagUS: ::std::option::Option<
        unsafe extern "C" fn(
            n: ai_int32,
            tagString: *const ai_UnicodeString,
            tagInteger: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a transaction tag (a Unicode string) by position index from the current undo/redo context.\nUse with \\c #CountTransactions() to iterate through transactions in the\ncurrent standard undo context.\n@param n The position index. Positive values indicate redo transactions,\nnegative values indicate undo transactions. No transaction is at index 0.\n@param tagString [out] A buffer in which to return the descriptive Unicode string.\n@param tagInteger [out] A buffer in which to return the identifying number."]
    pub GetNthTransactionTagUS: ::std::option::Option<
        unsafe extern "C" fn(
            n: ai_int32,
            tagString: *mut ai_UnicodeString,
            tagInteger: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " For internal use only.\nSuspend/Resume undo recording."]
    pub SetRecordingSuspended:
        ::std::option::Option<unsafe extern "C" fn(inSuspend: AIBoolean) -> AIErr>,
    #[doc = " For internal use only.\nReports if undo recording is suspended."]
    pub IsRecordingSuspended:
        ::std::option::Option<unsafe extern "C" fn(outIsSuspended: *mut AIBoolean) -> AIErr>,
}
#[doc = " The same as a Macintosh GWorldPtr. Applies only to version 2 of this suite."]
pub type AIDocumentPlatformViewBitmap = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIDocumentViewOpaque {
    _unused: [u8; 0],
}
#[doc = " An opaque reference for a document view."]
pub type AIDocumentViewHandle = *mut _t_AIDocumentViewOpaque;
#[doc = " Null mode, used only when there is no visible document"]
pub const AIScreenMode_kNoScreenMode: AIScreenMode = 0;
#[doc = " The normal display mode. Multiple windows are visible."]
pub const AIScreenMode_kNormalScreenMode: AIScreenMode = 1;
#[doc = " A single view takes up the whole screen but the menu is visible."]
pub const AIScreenMode_kFullScreenWithMenuMode: AIScreenMode = 2;
#[doc = " A single view takes up the whole screen, the menu is not visible."]
pub const AIScreenMode_kFullScreenNoMenuMode: AIScreenMode = 3;
#[doc = " A single artboard takes up the whole screen, annotations are not visible."]
pub const AIScreenMode_kAIPresentationMode: AIScreenMode = 4;
#[doc = " Large dummy value ensures enum is 32-bits."]
pub const AIScreenMode_kDummyWindowMode: AIScreenMode = 4294967295;
#[doc = " Screen mode values, see \\c #AIDocumentViewSuite::GetScreenMode(),\n\\c #AIDocumentViewSuite::SetScreenMode()"]
pub type AIScreenMode = ::std::os::raw::c_uint;
#[doc = " The page tiling structure that describes how artwork is printed\non one or more pages. See \\c #AIDocumentViewSuite::GetPageTiling().\nTiling operates on an \\e art \\e piece, which can be a set of art objects,\nthe entire art board, or a crop box."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPageTiling {
    #[doc = " Horizontal and vertical number of page tiles on the art piece. A tile counts\nif and only if some of its imageable area intersects the art piece bounds."]
    pub tilesPerArt: AIPoint,
    #[doc = " The total number of page tiles, <code>tilesPerArt.x * tilesPerArt.y</code>"]
    pub tilesPerArtPiece: ASInt16,
    #[doc = " The bounds of the artboard, whose dimensions are configured when\ncreating a new document or through document setup.\nPage tiles may extend beyond these bounds, but they must intersect it."]
    pub bounds: AIRealRect,
    #[doc = " Size of paper, in points."]
    pub paperSize: AIRealPoint,
    #[doc = " Top left of first piece of paper, in page coordinates."]
    pub paperOrigin: AIRealPoint,
    #[doc = " Size of imageable page area, in points"]
    pub imageSize: AIRealPoint,
    #[doc = " Top left of first imageable page area, in page coordinates."]
    pub imageOrigin: AIRealPoint,
    #[doc = " Unused. Art size plus gap"]
    pub pieceDelta: AIRealPoint,
    pub showTiling: AIBoolean,
}
#[doc = " @ingroup Suites\nUse these functions to get and set properties of a document view,\nincluding the bounds, center, zoom, and screen mode.\n\nTo operate on the current view, you can usually pass \\c NULL for\nthe \\c view parameter. To get a view reference for the current\nview, pass 0 to \\c #AIDocumentViewSuite::GetNthDocumentView().\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIDocumentViewSuite and \\c #kAIDocumentViewVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIDocumentViewSuite {
    #[doc = " Retrieves the bounds of a document view in artwork coordinates (that is,\nthe portion of the artboard that is visible in the window).\n@param view The view reference, or \\c NULL for the current view.\n@param bounds [out] A buffer in which to return the bounding box."]
    pub GetDocumentViewBounds: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, bounds: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Retrieves the center of a document view in artwork coordinates (that is, the\npoint of the artboard that maps to the center of the window).\n@param view The view reference, or \\c NULL for the current view.\n@param center [out] A buffer in which to return the center point."]
    pub GetDocumentViewCenter: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, center: *mut AIRealPoint) -> AIErr,
    >,
    #[doc = " Sets the point of the artboard that maps to the center of the window for a view.\n@param view The view reference, or \\c NULL for the current view.\n@param center The new center point."]
    pub SetDocumentViewCenter: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, center: *const AIRealPoint) -> AIErr,
    >,
    #[doc = " Retrieves the zoom factor for a view that the user is seeing. This is the zoom value that\nthe user is seeing on the status bar.\n@param view The view reference, or \\c NULL for the current view.\n@param zoom [out] A buffer in which to return the zoom factor, a percentage\nvalue where 1 is 100% (actual size), 0.5 is 50% and 2 is 200%."]
    pub GetDocumentViewUserVisibleZoom: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, zoom: *mut AIReal) -> AIErr,
    >,
    #[doc = " Retrieves the zoom factor for a view. This is the scale factor from artwork\ncoordinates to window coordinates.\n@param view The view reference, or \\c NULL for the current view.\n@param zoom [out] A buffer in which to return the zoom factor, a percentage\nvalue where 1 is 100% (actual size), 0.5 is 50% and 2 is 200%."]
    pub GetDocumentViewZoom: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, zoom: *mut AIReal) -> AIErr,
    >,
    #[doc = " Sets the scale factor from artwork coordinates to window coordinates for a view.\nThe scale factor is silently clamped to lie between the minimum and maximum values\nsupported (currently between 1/32 and 64). After adjusting the zoom, the document view\ncenter remains unchanged.\n@param view The view reference, or \\c NULL for the current view.\n@param zoom The new zoom factor, a percentage value where\n1 is 100% (actual size), 0.5 is 50% and 2 is 200%."]
    pub SetDocumentViewZoom: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, zoom: AIReal) -> AIErr,
    >,
    #[doc = " Sets the zoom factor of the view that the user is seeing on the status bar.\nThe scale factor is silently clamped to lie between the minimum and maximum values\nsupported (currently between 1/32 and 64). After adjusting the zoom, the document view\ncenter remains unchanged.\n@param view The view reference, or \\c NULL for the current view.\n@param zoom The new zoom factor, a percentage value where\n1 is 100% (actual size), 0.5 is 50% and 2 is 200%."]
    pub SetDocumentViewUserVisibleZoom: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, zoom: AIReal) -> AIErr,
    >,
    #[doc = " Converts a point from artwork coordinates to view (window) coordinates. The resulting\nview coordinate is rounded to the nearest pixel.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkPoint The point to convert, in artwork coordinates.\n@param viewPoint [out] A buffer in which to return the converted point, in window coordinates.\n@see \\c #FixedArtworkPointToViewPoint() (does not round)"]
    pub ArtworkPointToViewPoint: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkPoint: *const AIRealPoint,
            viewPoint: *mut AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a point from view coordinates to artwork coordinates.\n@param view The view reference, or \\c NULL for the current view.\n@param viewPoint The point to convert, in window pixel coordinates.\n@param artworkPoint [out] A buffer in which to return the converted point, in artboard coordinates.\n@see \\c #FixedViewPointToArtworkPoint() (takes floating-point coordinate values)"]
    pub ViewPointToArtworkPoint: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewPoint: *const AIPoint,
            artworkPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of open views for the current document. Use with\n\\c #GetNthDocumentView() to iterate through views.\n@param count [out] A buffer in which to return the number of views."]
    pub CountDocumentViews:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a document view for the current document by position index. Use with\n\\c #CountDocumentViews() to iterate through views.\n@param n The index, in the range <code>[1..numViews]</code>, or 0 to get the current view.\n@param view [out] A buffer in which to return the view reference."]
    pub GetNthDocumentView: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, view: *mut AIDocumentViewHandle) -> AIErr,
    >,
    #[doc = " Converts a point from artwork coordinates to view (window) coordinates. Does \\e not round\nthe result.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkPoint The point to convert, in artwork coordinates.\n@param viewPoint [out] A buffer in which to return the converted point, in window coordinates.\n@see \\c #ArtworkPointToViewPoint() (rounds result to nearest pixel)"]
    pub FixedArtworkPointToViewPoint: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkPoint: *const AIRealPoint,
            viewPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a point from view coordinates to artwork coordinates.\n@param view The view reference, or \\c NULL for the current view.\n@param viewPoint The point to convert, in window floating-point coordinates.\n@param artworkPoint [out] A buffer in which to return the converted point, in artboard coordinates.\n@see \\c #ViewPointToArtworkPoint() (takes pixel coordinate values)"]
    pub FixedViewPointToArtworkPoint: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewPoint: *const AIRealPoint,
            artworkPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Sets the screen mode of a view. In the UI, the screen mode is\nselected with icons at the bottom of the Tool palette.\n@param view The view reference, or \\c NULL for the current view.\n@param mode The new screen mode."]
    pub SetScreenMode: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, mode: AIScreenMode) -> AIErr,
    >,
    #[doc = " Retrieves the screen mode of a view. In the UI, the screen mode is\nshown by icons at the bottom of the Tool palette.\n@param view The view reference, or \\c NULL for the current view.\n@param mode [out] A buffer in which to return the screen mode."]
    pub GetScreenMode: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, mode: *mut AIScreenMode) -> AIErr,
    >,
    #[doc = " Retrieves the page tiling information that describes how the artwork is printed\nonto one or more pages.\n@param pageTiling [out] A buffer in which to return the tiling information."]
    pub GetPageTiling:
        ::std::option::Option<unsafe extern "C" fn(pageTiling: *mut AIPageTiling) -> AIErr>,
    #[doc = " Reports whether there is a visible template layer.\n@param view The view reference, or \\c NULL for the current view.\n@param visible [out] A buffer in which to return true if the template layer is shown."]
    pub GetTemplateVisible: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, visible: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Scrolls a document window.\n@param view The view reference, or \\c NULL for the current view.\n@param delta The vector by which to scroll, a horizontal and vertical\ndistance in points."]
    pub DocumentViewScrollDelta: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, delta: *mut AIRealPoint) -> AIErr,
    >,
    #[doc = " Retrieves a rectangle that encloses (at least) the portions of the viewed\ndocument that have been changed and so need to be redrawn. This rectangle is reset to\nbe empty each time the \\c #kAIDocumentViewInvalidRectChangedNotifier is sent.\n@param view The view reference, or \\c NULL for the current view.\n@param invalidRect [out] A buffer in which to return the invalid area, in artwork coordinates."]
    pub GetDocumentViewInvalidRect: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, invalidRect: *mut AIRealRect) -> AIErr,
    >,
    #[doc = " Sets the invalid rectangle for a view. This is the area that encloses\n(at least) the portions of the viewed document that have been changed\nand so need to be redrawn in the given view.\n@param view The view reference, or \\c NULL for the current view.\n@param invalidRect The new area, in artwork coordinates.\n@see \\c #GetDocumentViewInvalidRect(), \\c #SetDocumentViewInvalidDocumentRect()"]
    pub SetDocumentViewInvalidRect: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, invalidRect: *const AIRealRect) -> AIErr,
    >,
    #[doc = " Retrieves the display mode for a view.\n@param view\tThe view reference, or \\c NULL for the current view.\n@param style [out] A buffer in which to return the style, a logical OR of these bit flags:<br>\n\\c #kVsArtwork, \\c #kVsPreview, \\c #kVsRaster, \\c #kVsOpaque, \\c #kVsInk"]
    pub GetDocumentViewStyle: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, style: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Sets the invalid rectangle for all views of a viewed document. This is the area\nthat encloses (at least) the portions of the viewed document that have been\nchanged and so need to be redrawn in all views of that document.\n@param view The view reference, or \\c NULL for the current view.\n@param invalidRect The new area, in artwork coordinates.\n@see \\c #SetDocumentViewInvalidRect()"]
    pub SetDocumentViewInvalidDocumentRect: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, invalidRect: *const AIRealRect) -> AIErr,
    >,
    #[doc = " Reports whether page tiling is shown for the current view. Each view has its own setting.\n@param show [out] A buffer in which to return true if page tiling is shown."]
    pub GetShowPageTiling:
        ::std::option::Option<unsafe extern "C" fn(show: *mut AIBoolean) -> AIErr>,
    #[doc = " Sets the page tiling mode for the current view. Each view has its own setting.\n@param show True to turn page tiling on, false to turn it off."]
    pub SetShowPageTiling: ::std::option::Option<unsafe extern "C" fn(show: AIBoolean) -> AIErr>,
    #[doc = " Retrieves grid options for a view.\n@param view The view reference, or \\c NULL for the current view.\n@param show [out] A buffer in which to return true if the grid is visible.\n@param snap [out] A buffer in which to return true if the snap-to-grid is on."]
    pub GetGridOptions: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            show: *mut AIBoolean,
            snap: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = "  Sets grid options for a view\n@param view The view reference, or \\c NULL for the current view.\n@param show True to make the grid visible, false to hide it.\n@param snap True to turn snap-to-grid on, false to turn it off."]
    pub SetGridOptions: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: AIBoolean, snap: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports whether the transparency grid is shown in a view.\n@param view The view reference, or \\c NULL for the current view.\n@param show [out] A buffer in which to return true if the transparency grid is visible."]
    pub GetShowTransparencyGrid: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets whether the transparency grid is shown in the view.\n@param view The view reference, or \\c NULL for the current view.\n@param show True to make the transparency grid visible, false to hide it."]
    pub SetShowTransparencyGrid: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the document displayed in a view.\n@param view The view reference, or \\c NULL for the current view.\n@param document [out] A buffer in which to return the document reference."]
    pub GetDocumentViewDocument: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, document: *mut AIDocumentHandle) -> AIErr,
    >,
    #[doc = " Forces all document views to not be obscured by the Control palette."]
    pub ForceDocumentViewsOnScreen: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves the visibility state of the guides.\n@param view The view reference, or \\c NULL for the current view.\n@param show [out] A buffer in which to return true if the guides are visible."]
    pub GetShowGuides: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the visibility state of the guides.\n@param view The view reference, or \\c NULL for the current view.\n@param show True to make the guides visible, false to hide them."]
    pub SetShowGuides: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the visibility state of the edges of the selection.\n@param view The view reference, or \\c NULL for the current view.\n@param show True to make the edges visible, false to hide them."]
    pub GetShowEdges: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the visibility state of the edges of the selection.\n@param view The view reference, or \\c NULL for the current view.\n@param show True to make the edges visible, false to hide them."]
    pub SetShowEdges: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, show: AIBoolean) -> AIErr,
    >,
    #[doc = " Captures the contents of the view window (excluding scrollbars, etc.) to\na TIFF file. Artboards are centered in window before capture.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param saveFilename\tFull path and name of TIFF file to create.\n@param windowSize\tSize to set window before capture. Will restore\noriginal window size before returning."]
    pub SaveImage: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            saveFilename: *const ai_UnicodeString,
            windowSize: *const AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Determines the current state of video rulers if they are visible or not.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param visible\t\tTrue if the artboard rulers are visible, false otherwise."]
    pub IsArtboardRulerVisible: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, visible: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the video rulers visibility on or off.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param visible\t\tTrue if artboard ruler visibility is to be turned on, false otherwise."]
    pub SetArtboardRulerVisible: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, visible: AIBoolean) -> AIErr,
    >,
    #[doc = " Returns the number plates in the plate set for the view.  The plate set is only relevant for OPP\nview mode.\n@param view\t\t\t\t\tThe view reference, or \\c NULL for the current view.\n@param count [out]\t\t\tThe number of plates."]
    pub CountOPPPlates: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, count: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Get an identifier for the nth plate in the view's plate set.\n@param view\t\t\t\t\tThe view reference, or \\c NULL for the current view.\n@param plate [out]\t\t\tThe plate identifier."]
    pub GetNthOPPPlate: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            n: ai_int32,
            plate: *mut ai_ColorSpace,
        ) -> AIErr,
    >,
    #[doc = " Get the visibility state for \\c plate in the current view's plate state.  Visibility is only\nrecognized for OPP view mode.\n@param view\t\t\t\t\tThe view reference, or \\c NULL for the current view.\n@param plate\t\t\t\tIdentifier for the plate to get the state of.\n@param isOn [out]\t\t\tThe current visibility state of \\c plate."]
    pub GetOPPPlateState: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            plate: *const ai_ColorSpace,
            isOn: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Set the visibility state for \\c plate in the current view's plate state.  Visibility is only\nrecognized for OPP view mode.  Invalid \\c plate identifiers are ignored.\n@param view\t\t\t\t\tThe view reference, or \\c NULL for the current view.\n@param plate\t\t\t\tIdentifier for the plate to get the state of.\n@param isOn\t\t\t\t\tThe new visibility state of \\c plate."]
    pub SetOPPPlateState: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            plate: *const ai_ColorSpace,
            isOn: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the display mode for a view.  Currently these flags are mostly mutually exclusive. \\c #kVsInk\nonly makes sense combined with \\c #kVsPreview. \\c #kVsArtwork, \\c #kVsPreview, and \\c #kVsRaster are\nmutually exclusive.\n@param view\tThe view reference, or \\c NULL for the current view.\n@param style A logical OR of these bit flags:<br>\n\\c #kVsArtwork, \\c #kVsPreview, \\c #kVsRaster, \\c #kVsOpaque, \\c #kVsInk\n@param mask A logical OR of the same bit values as style indicating which\nbits from style to change."]
    pub SetDocumentViewStyle: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, style: ai_int16, mask: ai_int16) -> AIErr,
    >,
    #[doc = " Determines whether the rulers are shown in Artboard co-ordinates.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param isYes\t\tTrue if the rulers are shown in Artboard co-ordinates, false otherwise."]
    pub IsRulerInArtboardCoordinates: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, isYes: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Sets the rulers to use Artboard co-ordinates.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param state\t\tTrue if the rulers are shown in Artboard co-ordinates, false otherwise."]
    pub UseArtboardCoordinatesInRuler: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, state: ASBoolean) -> AIErr,
    >,
    #[doc = " Returns whether GPU Preview mode is enabled for the view.\n@param view \t\tThe view reference, or \\c NULL for the current view.\n@return\t\t\t\tTrue if Accelerated Preview mode is ON, false if CPU rendering mode is on."]
    pub IsGPUPreviewModeOn:
        ::std::option::Option<unsafe extern "C" fn(view: AIDocumentViewHandle) -> AIBoolean>,
    #[doc = " Returns whether GPU Rendering is enabled for the view.\n@param view \t\tThe view reference, or \\c NULL for the current view.\n@return\t\t\t\tTrue if GPU Rendering is ON, false if CPU rendering mode is on."]
    pub IsGPURenderingOn:
        ::std::option::Option<unsafe extern "C" fn(view: AIDocumentViewHandle) -> AIBoolean>,
    #[doc = " Returns color value of location inside document window.\nIf location or window does not correspond to any document window of AI which is in GPU preview mode, bad parameter error is returned\nOnly implemented for windows platform."]
    pub GetGPUPixel: ::std::option::Option<
        unsafe extern "C" fn(window: AIWindowRef, location: AIPoint, color: *mut AIColor) -> AIErr,
    >,
    #[doc = " Returns the bounds of the area visible to the user, ie after excluding the area covered by ruler and isolation mode UI.\n@param view\t\t\tThe view reference, or \\c NULL for the current view.\n@param bounds [out] A buffer in which to return the bounding box."]
    pub GetDocumentViewVisibleArea: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, bounds: *mut AIRealRect) -> AIErr,
    >,
    #[doc = "Sets whether view should clip objects to Artboards."]
    pub SetClipViewToArtboards: ::std::option::Option<
        unsafe extern "C" fn(view: AIDocumentViewHandle, clipToActiveArtboard: AIBoolean) -> AIErr,
    >,
    #[doc = "Returns whether the view is clipped to artboards."]
    pub GetClipViewToArtboards: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            clipToActiveArtboard: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Captures the contents of the view window (excluding scrollbars, etc.) to\na PNG file.\n@param view\t\t\tThe view reference.\n@param saveFilePath\tFull path along with name of PNG file to create."]
    pub ScreenShot: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            saveFilePath: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Rotates document view, will send kAIDocumentViewChangedNotifier.\n@param view\t\t\tThe view reference.\n@param rotationPoint\tPoint of rotation in artwork coordinates.\n@param rotationAngle    Angle of rotation in degree(angle should be w.r.t horizontal axis)"]
    pub SetDocumentViewRotation: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            rotationPoint: *const AIRealPoint,
            rotationAngle: AIReal,
        ) -> AIErr,
    >,
    #[doc = " Get document view rotation properties.\n@param view\t\t\tThe view reference.\n@param rotationPoint\tPoint of rotation in artwork coordinates.\n@param rotationAngle    Angle of rotation in degree(angle will be w.r.t horizontal axis)"]
    pub GetDocumentViewRotation: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            rotationPoint: *mut AIRealPoint,
            rotationAngle: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Resets document view rotation to 0 degree.\n@param view            The view reference."]
    pub ResetDocumentViewRotation:
        ::std::option::Option<unsafe extern "C" fn(view: AIDocumentViewHandle) -> AIErr>,
    #[doc = " Converts a point from artwork coordinates to view (window) coordinates without taking into account the view rotation.\nThe resulting view coordinate is rounded to the nearest pixel.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkPoint The point to convert, in artwork coordinates.\n@param viewPoint [out] A buffer in which to return the converted point, in window coordinates."]
    pub ArtworkPointToViewPointUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkPoint: *const AIRealPoint,
            viewPoint: *mut AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a point from view coordinates to artwork coordinates without taking into account the view rotation.\n@param view The view reference, or \\c NULL for the current view.\n@param viewPoint The point to convert, in window pixel coordinates.\n@param artworkPoint [out] A buffer in which to return the converted point, in artboard coordinates."]
    pub ViewPointToArtworkPointUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewPoint: *const AIPoint,
            artworkPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a rect from artwork coordinates to view (window) coordinates with rotation. The resulting\nview coordinate is rounded to the nearest pixel.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkRect The rect to convert, in artwork coordinates.\n@param viewRect [out] A buffer in which to return the converted rect, in window coordinates. This will be bounding box rect of points after rotation\n@see \\c #FixedArtworkRectToViewRectUnrotated() (does not round)"]
    pub ArtworkRectToViewRect: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkRect: *const AIRealRect,
            viewRect: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Converts a Rect from view coordinates to artwork coordinates with inverse rotation.\n@param view The view reference, or \\c NULL for the current view.\n@param viewRect The point to convert, in window pixel coordinates.\n@param artworkRect [out] A buffer in which to return the converted point, in artboard coordinates. . This will be bounding box rect of points after inverse rotation\n@see \\c #FixedViewRectToArtworkRectUnrotated() (takes floating-point coordinate values)"]
    pub ViewRectToArtworkRect: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewRect: *const AIRect,
            artworkRect: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Converts a rect from artwork coordinates to view (window) coordinates. The resulting\nview coordinate is rounded to the nearest pixel.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkRect The rect to convert, in artwork coordinates.\n@param viewRect [out] A buffer in which to return the converted rect, in window coordinates.\n@see \\c #FixedArtworkRectToViewRectUnrotated() (does not round)"]
    pub ArtworkRectToViewRectUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkRect: *const AIRealRect,
            viewRect: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Converts a Rect from view coordinates to artwork coordinates.\n@param view The view reference, or \\c NULL for the current view.\n@param viewRect The point to convert, in window pixel coordinates.\n@param artworkRect [out] A buffer in which to return the converted point, in artboard coordinates.\n@see \\c #FixedViewRectToArtworkRectUnrotated() (takes floating-point coordinate values)"]
    pub ViewRectToArtworkRectUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewRect: *const AIRect,
            artworkRect: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Converts a point from artwork coordinates to view (window) coordinates without considering canvas rotation. Does \\e not round\nthe result.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkPoint The point to convert, in artwork coordinates.\n@param viewPoint [out] A buffer in which to return the converted point, in window coordinates.\n@see \\c #ArtworkPointToViewPointUnrotated() (rounds result to nearest pixel)"]
    pub FixedArtworkPointToViewPointUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkPoint: *const AIRealPoint,
            viewPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a point from view coordinates to artwork coordinates without considering canvas rotation. Does \\e not round\nthe result.\n@param view The view reference, or \\c NULL for the current view.\n@param viewPoint The point to convert, in window floating-point coordinates.\n@param artworkPoint [out] A buffer in which to return the converted point, in artboard coordinates.\n@see \\c #ViewPointToArtworkPointUnrotated() (takes pixel coordinate values)"]
    pub FixedViewPointToArtworkPointUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewPoint: *const AIRealPoint,
            artworkPoint: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Converts a Rect from view coordinates to artwork coordinates.\n@param view The view reference, or \\c NULL for the current view.\n@param viewRect The point to convert, in window floating-point coordinates.\n@param artworkRect [out] A buffer in which to return the converted point, in artboard coordinates.\n@see \\c #ViewRectToArtworkRectUnrotated() (takes pixel coordinate values)"]
    pub FixedViewRectToArtworkRectUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            viewRect: *const AIRealRect,
            artworkRect: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Converts a rect from artwork coordinates to view (window) coordinates. Does \\e not round\nthe result.\n@param view The view reference, or \\c NULL for the current view.\n@param artworkRect The point to convert, in artwork coordinates.\n@param viewRect [out] A buffer in which to return the converted point, in window coordinates.\n@see \\c #ArtworkRectToViewRectUnrotated() (rounds result to nearest pixel)"]
    pub FixedArtworkRectToViewRectUnrotated: ::std::option::Option<
        unsafe extern "C" fn(
            view: AIDocumentViewHandle,
            artworkRect: *const AIRealRect,
            viewRect: *mut AIRealRect,
        ) -> AIErr,
    >,
}
pub const AIAnswer_kAIAnswer_No: AIAnswer = 0;
pub const AIAnswer_kAIAnswer_Yes: AIAnswer = 1;
pub const AIAnswer_kAIAnswer_Cancel: AIAnswer = 2;
pub const AIAnswer_kAIAnswer_Invalid: AIAnswer = 4294967295;
#[doc = "Constants for alert button choices.\nSee \\c #AIUserSuite."]
pub type AIAnswer = ::std::os::raw::c_uint;
#[doc = " Callback invoked on entry of a single character in the text field."]
pub const AIValidationStage_kAIValidationStage_interactive: AIValidationStage = 0;
#[doc = " Callback invoked on dismissal of alert dialog with OK button."]
pub const AIValidationStage_kAIValidationStage_onOk: AIValidationStage = 1;
#[doc = "Flag values to determine the stage of input for which\na validation callback has been called.\nSee \\c #AIUserSuite::GetInputFromUser() and \\c #IsValidInputProc."]
pub type AIValidationStage = ::std::os::raw::c_uint;
pub const AIPredefinedCursor_kAIIBeamCursorID: AIPredefinedCursor = -1;
pub const AIPredefinedCursor_kAICrossCursorID: AIPredefinedCursor = -2;
pub const AIPredefinedCursor_kAIWaitCursorID: AIPredefinedCursor = -3;
pub const AIPredefinedCursor_kAIArrowCursorID: AIPredefinedCursor = -4;
#[doc = "Identifiers for predefined cursors.\nSee \\c #AIUserSuite::SetCursor()"]
pub type AIPredefinedCursor = ::std::os::raw::c_int;
#[doc = " Opaque reference to a date-time value. Access with the \\c #AIUserSuite."]
pub type AIUserDateTime = ai_uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_Opaque_AIResourceManagerHandle {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a resource manager handle. See \\c #AIUserSuite::CreateCursorResourceMgr()."]
pub type AIResourceManagerHandle = *mut _t_Opaque_AIResourceManagerHandle;
#[doc = "\tCallback function pointer passed to \\c #AIUserSuite::GetInputFromUser().\nCan be called at either of the two stages: when the OK button in the alert dialog box is pressed (\\c #kAIValidationStage_onOk)\nor when a text character is entered in the text field (\\c #kAIValidationStage_interactive).\nThe function must validate the input string, and return the output as true if the string is valid in the context.\nIf the string fails validation, return false and set the \\c errorStr output parameter to a string\nsuitable for display in the alert dialog as a tool tip."]
pub type IsValidInputProc = ::std::option::Option<
    unsafe extern "C" fn(
        validationStage: AIValidationStage,
        input: *const ai_UnicodeString,
        errorStr: *mut ai_UnicodeString,
        userdata: *mut ::std::os::raw::c_void,
    ) -> AIBoolean,
>;
#[doc = "\tProgress Callback function pointer passed to \\c #AIUserSuite::SetUpdateProgressCallback().\nThis can be used to implement a custom progress handler.\nThe first parameter of the function is \\c current , a number between 0 and \\c max that represents\nhow far the operation has progressed and the second parameter is \\c max , the maximum value,\nrepresenting 100% progress.\nThis progress handler must return the output as:\n-true to cancel further processing\n-false to continue processing"]
pub type UpdateProgressProc =
    ::std::option::Option<unsafe extern "C" fn(current: ai_int32, max: ai_int32) -> AIBoolean>;
#[doc = " Information about the kind of names allowed for a named entity (such as\nlayers, swatches, and styles). Used to generate a legal name, using\n\\c #AIUserSuite::NextName() and AIUserSuite::CopyOfName().\n\nThe following pseudocode indicates how you can create your own AutoNameGenerator class by publicly inheriting AIAutoNameGenerator\nand following the implementation guidelines.\n\n@code\nclass AutoNameGenerator : public AIAutoNameGenerator {\npublic:\n// Constructor for a name generator. Its supplied with the pluginref in\n// case the name generator needs to look in the plugin's resources e.g for\n// the default name. The next new name index is supplied since the plugin\n// probably needs to store this in its globals so that it can be preserved\n// across unload and reload.\nAutoNameGenerator (SPPluginRef pluginref, int nextNameIndex)\n{\n// fill in fDefaultName\nGetDefaultName(pluginref);\n\n// initialize the base members\n// note kMaxCollectionStringLength accounts for null terminator and maximumLength does not\nmaximumLength = kMaxCollectionStringLength-1;\nuniqueNames = true;\nbaseName = fDefaultName;\nnextNewNameIndex = nextNameIndex;\nHasName = sHasName;\n}\n\nprivate:\nvoid GetDefaultName (SPPluginRef pluginref)\n{\n// Somehow initialize fDefaultName with the default name for the\n// collection. The pluginref is probably needed in order to look\n// up the name in the plugin resources.\n}\n\nAIErr hasName (const ai::UnicodeString &name, AIBoolean &hasit)\n{\n// Code to answer the question. When comparing 'name' against\n// names of objects in the collection it's important to use the\n// AIUserSuite::SameName() API. The name generation process does\n// not use a simple string comparison.\n}\n\nstatic AIAPI AIErr sHasName (AIAutoNameGenerator &self, const ai::UnicodeString &name, AIBoolean &hasit)\n{\nreturn static_cast<AutoNameGenerator&>(self).hasName(name, hasit);\n}\n\nai::UnicodeString fDefaultName;\n};\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct AIAutoNameGenerator {
    #[doc = " The maximum length for names in the collection, a number of\n\\c ASUnicode elements. Excludes the null terminator."]
    pub maximumLength: ai_int32,
    #[doc = " True if names in the collection must be unique."]
    pub uniqueNames: AIBoolean,
    #[doc = " A base for generating names, a Unicode-encoded string."]
    pub baseName: ai_UnicodeString,
    #[doc = " The index to use for the next new name generated. Name generation\nfunctions automatically increment the index."]
    pub nextNewNameIndex: ai_int32,
    #[doc = " A callback function to determine whether a given name is already in\nthe set. Use \\c #AIUserSuite::SameName() to compare names, not simple\nstring equality.\n@param self This structure.\n@param name The name to test.\n@param hasit [out] An AIBoolean reference in which to return true if the name is\nalready in the collection.\n@return An error to abort name generation; the error code\nis returned to the caller."]
    pub HasName: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut AIAutoNameGenerator,
            name: *const ai_UnicodeString,
            hasit: *mut AIBoolean,
        ) -> AIErr,
    >,
}
#[doc = "\tThese functions manage a collection of file type specifiers\nfor dialog functions in \\c #AIUserSuite, which show drop-down\nlists for each file type."]
#[repr(C)]
#[derive(Debug)]
pub struct AIFileDialogFilters {
    pub filterStr: ai_UnicodeString,
}
#[doc = "A structure that describes how the result should be returned by \\c #AIUserSuite::EvaluateExpression()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIExpressionOptions {
    #[doc = " The units in which the output value is expressed, one of the distance-measuring\nunits from \\c #AITypes::AIUnits, or the constant \\c #kAINoUnits to indicate an\nabsolute value. Other values cause parameter errors."]
    pub unit: ai_uint32,
    #[doc = " The minimum value to which the result is clipped, expressed in the specified units."]
    pub minValue: AIDouble,
    #[doc = " The maximum value to which the result is clipped, expressed in the specified units."]
    pub maxValue: AIDouble,
    #[doc = " The previous value of control. Can be any valid value. In case of erroneous or unallowed inStringVal,\nfinalValue would be same as old value"]
    pub oldValue: AIDouble,
    #[doc = " The number of digits after the decimal in the result."]
    pub precision: ai_uint32,
}
#[doc = " @ingroup Suites\nThis suite provides utility functions for working with Illustrator,\nincluding unit conversion utilities and a progress bar.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUserSuite and \\c #kAIUserSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUserSuite {
    #[doc = " Reports whether a user has canceled the current operation.\n(Note that this function returns a boolean value, not an error code.)\n@return\tTrue if the user has canceled an operation\nby pressing Command-dot or clicking Cancel or Stop in the\nprogress bar."]
    pub Cancel: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Updates the progress bar.\n(Note that this function does not return an error code.)\n@param current A number between 0 and \\c max that represents\nhow far the operation has progressed.\n@param max The maximum value, representing 100% progress."]
    pub UpdateProgress:
        ::std::option::Option<unsafe extern "C" fn(current: ai_int32, max: ai_int32)>,
    #[doc = " Registers the progress callbacks.\n(Note that this function does not return an error code.)\n@param UpdateProgressProc - A function pointer to progress callback.\nThe first parameter to this call is \\c current , a number between 0 and \\c max that represents\nhow far the operation has progressed and the second parameter is \\c max , the maximum value,\nrepresenting 100% progress."]
    pub SetUpdateProgressCallback:
        ::std::option::Option<unsafe extern "C" fn(func: UpdateProgressProc)>,
    #[doc = "\tSets the text message displayed in the progress bar. If not provided,\nthe text line is blank.\n(Note that this function does not return an error code.)\n@param text The text message."]
    pub SetProgressText: ::std::option::Option<unsafe extern "C" fn(text: *const ai_UnicodeString)>,
    #[doc = " Explicitly close the progress bar if one is currently shown.\n(Note that this function does not return an error code.)"]
    pub CloseProgress: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "\tConverts a number of document points to a Unicode string, using\nthe period as a decimal separator.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4].\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters."]
    pub AIRealToString: ::std::option::Option<
        unsafe extern "C" fn(value: AIReal, precision: ai_int16, string: *mut ai_UnicodeString),
    >,
    #[doc = "\tConverts a Unicode string containing a number to an \\c #AIReal value,\nusing the period as a decimal separator.\n(Note that this function does not return an error code.)\n@param string The string to convert.\n@param value  [out] A buffer in which to return the converted value.\nIf the string is not a number, this is set to \\c #kAIRealUnknown."]
    pub StringToAIReal: ::std::option::Option<
        unsafe extern "C" fn(string: *const ai_UnicodeString, value: *mut AIReal),
    >,
    #[doc = "\tConverts a number of document points to a Unicode string, using the localized\ninternational utilities (IU) decimal separator.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4].\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters."]
    pub IUAIRealToString: ::std::option::Option<
        unsafe extern "C" fn(value: AIReal, precision: ai_int16, string: *mut ai_UnicodeString),
    >,
    #[doc = "\tConverts a number of document points to a Unicode string modified according to the scale of the document, using the localized\ninternational utilities (IU) decimal separator.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4].\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters.\n@param Locale unique identifying code like ai::Locale::kSystem."]
    pub IUAIRealToStringWithLocale: ::std::option::Option<
        unsafe extern "C" fn(
            value: AIReal,
            precision: ai_int16,
            string: *mut ai_UnicodeString,
            locale: ai_LocaleID,
        ),
    >,
    #[doc = "    Converts a number of document points to a Unicode string, using the localized\ninternational utilities (IU) decimal separator.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4].\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters.\n@param Locale unique identifying code like ai::Locale::kSystem."]
    pub IUAIRealToStringWithLocaleWithoutScale: ::std::option::Option<
        unsafe extern "C" fn(
            value: AIReal,
            precision: ai_int16,
            string: *mut ai_UnicodeString,
            locale: ai_LocaleID,
        ),
    >,
    #[doc = "\tConverts a Unicode string containing a number to an \\c #AIReal value,\nusing the localized international utilities (IU) decimal separator.\n(Note that this function does not return an error code.)\n@param string The string to convert.\n@param value  [out] A buffer in which to return the converted value.\nIf the string is not a number, this is set to \\c #kAIRealUnknown."]
    pub IUStringToAIReal: ::std::option::Option<
        unsafe extern "C" fn(string: *const ai_UnicodeString, value: *mut AIReal),
    >,
    #[doc = "\tConverts a number of document points to a formatted Unicode string containing\na number and ruler units modified according to the scale of the document, using the localized international utilities (IU)\ndecimal separator, and the passed preference for precision. If passed precision value is -1\nthen user preference for precision is used.\nUses the currently set ruler units, which can be inches, points, or centimeters.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4]. Pass -1 if user preference for precision should be used.\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters."]
    pub IUAIRealToStringUnits: ::std::option::Option<
        unsafe extern "C" fn(
            value: AIReal,
            precision: ai_int32,
            string: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = "    Converts a number of document points to a formatted Unicode string containing\na number and ruler units, using the localized international utilities (IU)\ndecimal separator, and the passed preference for precision. If passed precision value is -1\nthen user preference for precision is used.\nUses the currently set ruler units, which can be inches, points, or centimeters.\n(Note that this function does not return an error code.)\n@param value The value to convert.\n@param precision The number of digits to the right of the decimal,\nin the range [0..4]. Pass -1 if user preference for precision should be used.\n@param string [out] A buffer in which to return the converted value, at\nleast 12 characters."]
    pub IUAIRealToStringUnitsWithoutScale: ::std::option::Option<
        unsafe extern "C" fn(
            value: AIReal,
            precision: ai_int32,
            string: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Converts a formatted Unicode string containing a number expressed in ruler units\nto an \\c #AIReal value in points according to the current scale of the document. The current ruler units for the artwork\nare used as the original units to scale the result, and the user's\npreferences for precision are applied.\n(Note that this function does not return an error code.)\n@param string The string to convert, which uses the localized international utilities (IU)\ndecimal separator. It can contain a unit specifier, one of \"in\", \"pt\", or \"cm\".\nIf no unit specifier is included, uses the current ruler units.\n@param value [out] A buffer in which to return the converted value.\nIf the string is not a number, this is set to \\c #kAIRealUnknown."]
    pub IUStringUnitsToAIReal: ::std::option::Option<
        unsafe extern "C" fn(string: *const ai_UnicodeString, value: *mut AIReal),
    >,
    #[doc = " Converts a formatted Unicode string containing a number expressed in ruler units\nto an \\c #AIReal value in points {ignores the scale of the document}. The current ruler units for the artwork\nare used as the original units to scale the result, and the user's\npreferences for precision are applied.\n(Note that this function does not return an error code.)\n@param string The string to convert, which uses the localized international utilities (IU)\ndecimal separator. It can contain a unit specifier, one of \"in\", \"pt\", or \"cm\".\nIf no unit specifier is included, uses the current ruler units.\n@param value [out] A buffer in which to return the converted value.\nIf the string is not a number, this is set to \\c #kAIRealUnknown."]
    pub IUStringUnitsToAIRealWithoutScale: ::std::option::Option<
        unsafe extern "C" fn(string: *const ai_UnicodeString, value: *mut AIReal),
    >,
    #[doc = " Retrieves a string representing the current ruler units.\n@param format The format for the result, one of:\n<br> \\c #kShortUnits\n<br> \\c #kLongSingularUnits\n<br> \\c #kLongPluralUnits\n<br> If, for instance, the current unit is inches, the returned string\nwould be \"in\", \"inch\", or \"inches\".\n@param string [out] A buffer in which to return the units string, at least 20 characters."]
    pub GetUnitsString: ::std::option::Option<
        unsafe extern "C" fn(format: ai_int16, string: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = "\tRetrieves the base name of a global object, stripping off any additional\ntoken that was added to make the name unique (by a function such as\n\\c #AICustomColorSuite::NewCustomColorName(), for example).\n@param name [in, out] A string in which to pass a unique name and\nreturn the base name. The string is modified in place."]
    pub GetGlobalObjectDisplayName:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Opens the appropriate application to edit a placed or raster object.\nThis is equivalent to an option-double-click on the object with the selection tool.\n@param art The placed or raster art object.\n@return \\c #kApplicationNotFoundErr error if the application is not found.\n<br> \\c #kObjectNotLinkedErr error if the object is not a placed or raster object."]
    pub EditInOriginalApp: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Runs an \"Idle Event\" that allows the application to do various idle-time things like update its selection view and state.  Can be useful if\nyou have code that has its own message processing."]
    pub AppIdle: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = "\tBuilds a directory menu.  Available only in Mac OS.  Builds a menu consisting of the specified path as well as all parent directories of that path.\n@param menu\t The platform-specific menu object.\n@param fileSpec\tThe file object for the directory."]
    pub BuildDirectoryMenu: ::std::option::Option<
        unsafe extern "C" fn(menu: AIPlatformMenuHandle, fileSpec: *const ai_FilePath) -> AIErr,
    >,
    #[doc = "\tRetrieves a directory.  Available only in Mac OS. Returns a filespec pertaining to the 'index' item inside of the menu returned by BuildDirectoryMenu.\n@param fileSpec The file object for the directory.\n@param index The 0-based index of the directory."]
    pub GetIndexedDirectorySpec: ::std::option::Option<
        unsafe extern "C" fn(fileSpec: *mut ai_FilePath, index: ai_int32) -> AIErr,
    >,
    #[doc = "\tReveals a file in the Finder. Available only in Mac OS.\n@param fileSpec\t The file object for the file."]
    pub RevealTheFile:
        ::std::option::Option<unsafe extern "C" fn(fileSpec: *const ai_FilePath) -> AIErr>,
    #[doc = " Disables (dims) the cancel or stop button in the progress bar.\n(Note that this function does not return an error code.)"]
    pub DisableProgressCancel: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Reports whether it is safe to allocate memory. Calls when a timer\nor other  asynchronous event trigger an action that allocates memory.\nNot needed when handling notifications or user events; the plug-in does not receive\nthese when it is not ok to allocate memory.\n(Note that this function returns a boolean value, not an error code.)\n@param True if it is safe to allocate memory. False if it is not safe; in this case,\nreschedule the action and try again later."]
    pub OKToAllocateMemory: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Retrieves the current date and time.\n@param outValue [out] A buffer in which to return the current date-time value."]
    pub GetDateAndTime:
        ::std::option::Option<unsafe extern "C" fn(outValue: *mut AIUserDateTime) -> AIErr>,
    pub GetDateString: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            formatFlag: ai_int32,
            dateStringUS: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    pub GetTimeString: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            formatFlag: ai_int32,
            dateStringUS: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the year value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetYear: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            year: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the month value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetMonth: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            month: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the day value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetDay: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            day: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the hour value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetHour: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            hour: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the minute value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetMinute: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            minute: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the second value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetSecond: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            second: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the day-of-week value from a date-time.\n@param inValue The date-time value, or \\c NULL to get the current date-time.\n@param year [out] A buffer in which to return the value."]
    pub GetDayOfWeek: ::std::option::Option<
        unsafe extern "C" fn(
            inValue: *const AIUserDateTime,
            dayOfWeek: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = "\tLaunches an application, and optionally opens the current document in it.\n@param spFileSpec The file specification for the application's executable.\n@param openDoc True to open the current document in the new application."]
    pub LaunchApp: ::std::option::Option<
        unsafe extern "C" fn(spFileSpec: *const ai_FilePath, openDoc: ASBoolean) -> AIErr,
    >,
    #[doc = " Generates an appropriate name for a named object, such as\na layer, swatch, or style, according to the naming rules for that\ncollection.\n@param set The naming rules.\n@param name [out] An ai::UnicodeString in which to return the generated name."]
    pub NextName: ::std::option::Option<
        unsafe extern "C" fn(set: *mut AIAutoNameGenerator, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Generates an appropriate name for a copy of a named object, such as\na layer, swatch, or style, according to the naming rules for that\ncollection.\n@param set The naming rules.\n@param original\tOriginal name to copy (may be an empty string).\n@param copy [out] An ai::UnicodeString in which to return the generated name."]
    pub CopyOfName: ::std::option::Option<
        unsafe extern "C" fn(
            set: *mut AIAutoNameGenerator,
            original: *const ai_UnicodeString,
            copy: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Tests for equality of names within a collection of named objects.\nUse in the \\c #AIAutoNameGenerator::HasName() callback function\nto test whether an automatically generated name matches a name\nalready in the collection.\n@param name1 The first name.\n@param name2 The second name.\n@param same [out] An AIBoolean reference in which to return true if the names\nare the same."]
    pub SameName: ::std::option::Option<
        unsafe extern "C" fn(
            name1: *const ai_UnicodeString,
            name2: *const ai_UnicodeString,
            same: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Opens a platform-specific dialog for saving a file.\n@param title Dialog title.\n@param AIFileDialogFilters File types to save. Can be \\c NULL.\n@param defaultName Default file name to appear in dialog. Can be \\c NULL.\n@param ioFilePath [in, out] A buffer in which to pass the directory to browse or \\c NULL, and\nreturn the full path of the file chosen by the user."]
    pub PutFileDialog: ::std::option::Option<
        unsafe extern "C" fn(
            title: *const ai_UnicodeString,
            arg1: *const AIFileDialogFilters,
            defaultName: *const ai_UnicodeString,
            ioFilePath: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Opens a platform-specific dialog for opening a file.\n@param title Dialog title.\n@param AIFileDialogFilters File types to open. Can be \\c NULL.\n@param ioFilePath [in, out] A buffer in which to pass the directory to browse or \\c NULL, and\nreturn the full path of the file chosen by the user."]
    pub GetFileDialog: ::std::option::Option<
        unsafe extern "C" fn(
            title: *const ai_UnicodeString,
            arg1: *const AIFileDialogFilters,
            ioFilePath: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Opens a platform-specific dialog for choosing a folder.\n@param title Dialog title.\n@param ioFilePath [in, out] A buffer in which to pass the folder to browse or \\c NULL, and\nreturn the full path of the folder chosen by the user."]
    pub GetDirectoryDialog: ::std::option::Option<
        unsafe extern "C" fn(title: *const ai_UnicodeString, ioFilePath: *mut ai_FilePath) -> AIErr,
    >,
    #[doc = " Displays an alert dialog with a warning icon and OK and Cancel buttons.\n@param msg The message to display.\n@param defaultOk True to make the OK button the default, false to make Cancel the default.\n@param dontShowKey A preference key to use with the \"Do not show again\" checkbox,\nin which to store the user's choice and save it in the application preferences file.\nWhen \\c NULL, the dialog does not include the checkbox.\n@return True if the dialog was dismissed with the OK button,\nfalse if it was canceled."]
    pub OKCancelAlert: ::std::option::Option<
        unsafe extern "C" fn(
            msg: *const ai_UnicodeString,
            defaultOk: AIBoolean,
            dontShowKey: *const ::std::os::raw::c_char,
        ) -> AIBoolean,
    >,
    #[doc = " Displays an alert dialog with a warning icon and an OK button.\n@param msg The message to display.\n@param dontShowKey A preference key to use with the \"Do not show again\" checkbox,\nin which to store the user's choice and save it in the application preferences file.\nWhen \\c NULL, the dialog does not include the checkbox.\n@return Nothing. It does not return AIErr"]
    pub WarningAlert: ::std::option::Option<
        unsafe extern "C" fn(
            msg: *const ai_UnicodeString,
            dontShowKey: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Displays an modal alert dialog with a warning icon and an OK button which doesnot get dismissed on ESC key.\n@param msg The message to display.\n@param dontShowKey A preference key to use with the \"Do not show again\" checkbox,\nin which to store the user's choice and save it in the application preferences file.\nWhen \\c NULL, the dialog does not include the checkbox.\n@return Nothing. It does not return AIErr"]
    pub MessageAlertEx: ::std::option::Option<
        unsafe extern "C" fn(
            msg: *const ai_UnicodeString,
            dontShowKey: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Displays a predefined dialog with a yes/no question.\nThe dialog displays text specified with a unicodeString, and\nbuttons with default labels Yes, No, and Cancel.\n@param msg The text string.\n@return The \\c #AIAnswer constant for the button pressed to dismiss the dialog,\nor \\c #kAIAnswer_Invalid in case of error.\n@see \\c #ErrorAlert(), \\c #MessageAlert(), \\c #YesNoAlert()"]
    pub QuestionAlert:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ai_UnicodeString) -> AIAnswer>,
    #[doc = " Displays a predefined dialog with a yes/no question.\nThe dialog displays text specified with a unicodeString, and\nbuttons with default labels Yes and No.\n@param msg The text string.\n@return The \\c #AIAnswer constant for the button pressed to dismiss the dialog,\nor \\c #kAIAnswer_Invalid in case of error.\n@see \\c #ErrorAlert(), \\c #MessageAlert(), \\c #QuestionAlert()"]
    pub YesNoAlert:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ai_UnicodeString) -> AIAnswer>,
    #[doc = " Displays a predefined dialog that informs the user that an error occurred.\nThe dialog displays text specified with a unicodeString, with the platform-specific\nerror icon at the left, and an OK button.\n@param msg The text string.\n@return Nothing.It doesnot return an AIErr\n@see \\c #MessageAlert(),  \\c #QuestionAlert(), \\c #YesNoAlert()"]
    pub ErrorAlert: ::std::option::Option<unsafe extern "C" fn(msg: *const ai_UnicodeString)>,
    #[doc = " Displays a predefined dialog with an informational message.\nThe dialog displays text specified with a unicodeString, with the\nplatform-specific message icon at the left, and an OK button.\n@param msg The text string.\n@return Nothing.It doesnot return an AIErr\n@see \\c #ErrorAlert(), \\c #QuestionAlert(), \\c #YesNoAlert()"]
    pub MessageAlert: ::std::option::Option<unsafe extern "C" fn(msg: *const ai_UnicodeString)>,
    #[doc = "\tInvokes the platform-specific color picker dialog.\n@param inLocation[int]\tThe position of the dialog.\t (-1, -1) centers the dialog on the screen.\n@param inColor[in]\tThe initially selected color value.\n@param outColor\t[out] A buffer in which to return the selected color.\n@return True if the user selected a color, false otherwise."]
    pub ChooseFromOSColorPicker: ::std::option::Option<
        unsafe extern "C" fn(
            inLocation: *const AIPoint,
            inColor: *const AIRGBColor,
            outColor: *mut AIRGBColor,
        ) -> AIBoolean,
    >,
    #[doc = " Evaluates a numeric expression to create a formatted string suitable [This had already the document scale  of the document applied] for display.\nCall, for example, when a numeric edit control loses focus or the user presses \"=\".\nIf the result of evaluation is not a valid numeric value as per options specified, it is recommended that\nthe associated control display the last known-good value, or a blank string\naccompanied by a beep or other error indicator.\n\n@param expr [in] The expression to be evaluated (typically entered by the user\nin the control).\n@param options [in] An \\c #AIExpressionOptions structure that determines how\na numeric result is obtained. Specifies the units for the\nresult, a range to which the result is clipped, and the precision.\n@param evaluatedExpr [out] A buffer in which to return the formatted display string.\n@param isChanged [out] A buffer in which to return true if the result of evaluation\nis different from result of user input. Example in case of non numeric input or out of bounds input.\n@param numericValue [out] A buffer in which to return the numeric value, according to the specified options."]
    pub EvaluateExpression: ::std::option::Option<
        unsafe extern "C" fn(
            expr: *const ai_UnicodeString,
            options: *const AIExpressionOptions,
            evaluatedExpr: *mut ai_UnicodeString,
            isChanged: *mut AIBoolean,
            numericValue: *mut AIDouble,
        ) -> AIErr,
    >,
    #[doc = " Evaluates a numeric expression to create a formatted string suitable for display.\nCall, for example, when a numeric edit control loses focus or the user presses \"=\".\nIf the result of evaluation is not a valid numeric value as per options specified, it is recommended that\nthe associated control display the last known-good value, or a blank string\naccompanied by a beep or other error indicator.\n\n@param expr [in] The expression to be evaluated (typically entered by the user\nin the control).\n@param options [in] An \\c #AIExpressionOptions structure that determines how\na numeric result is obtained. Specifies the units for the\nresult, a range to which the result is clipped, and the precision.\n@param evaluatedExpr [out] A buffer in which to return the formatted display string.\n@param isChanged [out] A buffer in which to return true if the result of evaluation\nis different from result of user input. Example in case of non numeric input or out of bounds input.\n@param numericValue [out] A buffer in which to return the numeric value, according to the specified options."]
    pub EvaluateExpressionWithoutScale: ::std::option::Option<
        unsafe extern "C" fn(
            expr: *const ai_UnicodeString,
            options: *const AIExpressionOptions,
            evaluatedExpr: *mut ai_UnicodeString,
            isChanged: *mut AIBoolean,
            numericValue: *mut AIDouble,
        ) -> AIErr,
    >,
    #[doc = " Invokes a modal dialog in which the user must input text. The dialog cannot be dismissed\nuntil text is entered. If default text is provided, however, the user can dismiss the\ndialog without changing that text.\n\n@param title The title for the dialog\n@param messageText A text message to display above the input field, or NULL to display no message.\n@param label The label for the text field.\n@param ioName [in/out] On input, a default string for the text field. This is replaced by text that\nthe user enters, if any.\n@param IsValidInputProc A function pointer to a validation callback that validates the input as typed by the user.\nThe first parameter to this call is a \\c #AIValidationStage constant that reports whether the call is\nmade upon text entry, or upon dismissal of the dialog.\n@param userdata Developer-defined user data to be passed to the validation callback.\n@param maxInputChars The maximum number of characters that user can enter in the text field."]
    pub GetInputFromUser: ::std::option::Option<
        unsafe extern "C" fn(
            title: *const ai_UnicodeString,
            messageText: *const ai_UnicodeString,
            label: *const ai_UnicodeString,
            ioField: *mut ai_UnicodeString,
            validator: IsValidInputProc,
            userdata: *mut ::std::os::raw::c_void,
            maxInputChars: ai_int32,
        ) -> AIErr,
    >,
    #[doc = "  Creates a singleton resource manager instance to be used for cursors.\nCall once for a plugin, after startup is completed.\tDestroy the instance on\napplication shutdown (not plug-in shutdown).\n@param inRscMgr [out] A buffer in which to return the resource-manager handle.\n@see DisposeCursorResourceMgr()"]
    pub CreateCursorResourceMgr: ::std::option::Option<
        unsafe extern "C" fn(arg1: SPPluginRef, inRscMgr: *mut AIResourceManagerHandle) -> AIErr,
    >,
    #[doc = "  Sets the image to be used for the plug-in's cursor.\n@param cursorID The resource ID of the cursor, or a \\c #AIPredefinedCursor\nconstant value to use one of the predefined cursors. Cursor images must be\nin PNG format.\n@param inRscMgr The resource manager, as returned by \\c #CreateCursorResourceMgr()."]
    pub SetCursor: ::std::option::Option<
        unsafe extern "C" fn(cursorID: ai_int32, inRscMgr: AIResourceManagerHandle) -> AIErr,
    >,
    #[doc = "  Sets the SVG image to be used for the plug-in's cursor.\n@param cursorID The resource ID of the cursor. Cursor images must be\nin 2x scaled SVG format.\n@param inRscMgr The resource manager, as returned by \\c #CreateCursorResourceMgr()."]
    pub SetSVGCursor: ::std::option::Option<
        unsafe extern "C" fn(cursorID: ai_int32, inRscMgr: AIResourceManagerHandle) -> AIErr,
    >,
    #[doc = "  Disposes of the plug-in's singleton resource manager. Call once when\n\\c #kAIApplicationShutdownNotifier is received. Do not call as part of plug-in shutdown.\n@param The resource manager handle, as returned on creation."]
    pub DisposeCursorResourceMgr:
        ::std::option::Option<unsafe extern "C" fn(arg1: AIResourceManagerHandle) -> AIErr>,
    #[doc = " Reports the current language in use.\n@param lang [out] A buffer in which to return the language code."]
    pub GetAILanguageCode:
        ::std::option::Option<unsafe extern "C" fn(lang: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Reports the maximum scale factor for all the screens in a Mac OS system,\nor the application's UI scale factor in a Windows system.\n@return The scale factor."]
    pub GetMaximumScaleFactorOnSystem: ::std::option::Option<unsafe extern "C" fn() -> AIReal>,
    #[doc = " Reports the ratio of Art Scale factor and View Scale Factor.\n(ArtScaleFactor/ ViewScaleFactor)"]
    pub GetArtToViewScaleFactor:
        ::std::option::Option<unsafe extern "C" fn(view: AIDocumentViewHandle) -> AIReal>,
    #[doc = " This API returns the actual application scale factor when Illustrator is launched.\nIf the application scale factor preference for the current OS exceeds the maximum application\nscale factor supported by the Illustrator for the current monitor resolution, the application\nscale factor is automatically reset to the maximum scale factor."]
    pub GetAppScaleFactor: ::std::option::Option<unsafe extern "C" fn() -> AIReal>,
    #[doc = " Launches a folder.\n@param folderPath Path of the folder to launch.\n@return \\c #kBadParameterErr if the path object is invalid or references a file rather than a folder."]
    pub LaunchFolder: ::std::option::Option<unsafe extern "C" fn(folderPath: ai_FilePath) -> AIErr>,
    #[doc = " Launches the appropriate application to edit/open file specefied via custom URI scheme\n@param customUri The custom uri\n@param appPath The App Executable location to be used for opening the uri\n@return \\c #kApplicationNotFoundErr error if the application is not found."]
    pub LaunchCustomAppForCustomUri: ::std::option::Option<
        unsafe extern "C" fn(
            customUri: *const ai_UnicodeString,
            appPath: *const ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Opens the appropriate application to edit a placed or raster object.\nThis is equivalent to right click the object and select the app for opening it.\n@param art The placed or raster art object.\n@param appPath The App Executable location to be used for opening the art\n@return \\c #kApplicationNotFoundErr error if the application is not found.\n<br> \\c #kObjectNotLinkedErr error if the object is not a placed or raster object."]
    pub EditInCustomApp: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, appPath: *const ai_FilePath) -> AIErr,
    >,
    #[doc = " Opens a platform-specific dialog for opening a file.\n@param title Dialog title.\n@param AIFileDialogFilters File types to open. Can be \\c NULL.\n@param iFilePath A buffer in which to pass the directory to browse or \\c NULL,\n@param oFilePaths A buffer in which to return the full paths of the files chosen by the user."]
    pub GetFileDialogEx: ::std::option::Option<
        unsafe extern "C" fn(
            title: *const ai_UnicodeString,
            arg1: *const AIFileDialogFilters,
            iFilePath: *const ai_FilePath,
            oFilePaths: *mut ai_AutoBuffer<ai_FilePath, ::std::os::raw::c_ulong>,
        ) -> AIErr,
    >,
}
pub type AIPanelPlatformWindow = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_AIPanel {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a panel. See \\c #AIPanelSuite."]
pub type AIPanelRef = *mut _opaque_AIPanel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_AIPanelFlyoutMenu {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a panel flyout menu. See \\c #AIPanelFlyoutMenuSuite."]
pub type AIPanelFlyoutMenuRef = *mut _opaque_AIPanelFlyoutMenu;
pub const kAIPanelFlyoutMenuItemMark_NONE: _bindgen_ty_1159 = 0;
pub const kAIPanelFlyoutMenuItemMark_CHECK: _bindgen_ty_1159 = 1;
pub const kAIPanelFlyoutMenuItemMark_BULLET: _bindgen_ty_1159 = 2;
pub const kAIPanelFlyoutMenuItemMark_DASH: _bindgen_ty_1159 = 3;
#[doc = " Constants for the glyphs that mark a menu item as selected.\nSee \\c #AIPanelFlyoutMenuSuite."]
pub type _bindgen_ty_1159 = ::std::os::raw::c_uint;
#[doc = " The glyph that marks a menu item as selected.\nSee \\c #AIPanelFlyoutMenuSuite."]
pub type AIPanelFlyoutMenuItemMark = ai_uint32;
#[doc = " A developer-defined data object that can be associated with a panel.\nSee \\c #AIPanelSuite."]
pub type AIPanelUserData = *mut ::std::os::raw::c_void;
#[doc = " Prototype of a function that is called before a panel's flyout menu is made visible.\n@param inPanel The panel object.\n@see \\c #AIPanelFlyoutMenuSuite."]
pub type AIPanelFlyoutMenuPreVisibilityProc =
    ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef)>;
#[doc = " Prototype of a function that is called after a panel's flyout menu has been shown.\n@param inPanel\t\tThe panel object.\n@param itemID\t\tThe selected item ID. Zero value of itemID means user cancelled the menu without selecting any item.\n@see \\c #AIPanelFlyoutMenuSuite."]
pub type AIPanelFlyoutMenuProc =
    ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef, itemID: ai_uint32)>;
#[doc = " Prototype of a function that is called after the visibility of a panel is changed.\n@param inPanel\t\tThe panel object.\n@param isVisible\tThe new visibility of the panel\n@see \\c #AIPanelSuite."]
pub type AIPanelVisibilityChangedNotifyProc =
    ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef, isVisible: AIBoolean)>;
#[doc = " Prototype of a function that is called after the size of a panel is changed.\n@param inPanel\t\tThe panel object.\n@see \\c #AIPanelSuite."]
pub type AIPanelSizeChangedNotifyProc =
    ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef)>;
#[doc = " Prototype of a function that is called after the state of a panel is changed.\n@param inPanel\t\tThe panel object.\n@param newState\t\tThe new panel state\n@see \\c #AIPanelSuite."]
pub type AIPanelStateChangedNotifyProc =
    ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef, newState: ai_int16)>;
#[doc = " Prototype of a function that is called after a panel is closed by clicking on the close button.\n@param inPanel\t\tThe panel object.\n@see \\c #AIPanelSuite."]
pub type AIPanelClosedNotifyProc = ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef)>;
#[doc = "\t@ingroup Suites\nProvides functions for creating and managing panels.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPanelSuite\tand \\c #kAIPanelSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPanelSuite {
    #[doc = " Creates a new panel.\n@param inPluginRef\t\tThe plug-in that creates the panel.\n@param inID\t\t\t\tA unique identifier for the new panel.\n@param inTitle\t\t\tThe title of the panel.\n@param inStateCount \tThe number of host layouts for the panel; must be at least 1.\n@param inMinSize\t\tMinimum size of the panel.\n@param isResizable\t\tTrue to make the panel resizable.\n@param inFlyoutMenu\t\tThe flyout menu for the panel, or NULL to hide the flyout icon.\n@param inUserData\t\tDeveloper-defined data to be associated with the panel.\n@param outPanel\t\t\t[out] A buffer in which to return the new panel object."]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            inPluginRef: SPPluginRef,
            inID: *const ai_UnicodeString,
            inTitle: *const ai_UnicodeString,
            inStateCount: ai_int16,
            inMinSize: *const AISize,
            isResizable: AIBoolean,
            inFlyoutMenu: AIPanelFlyoutMenuRef,
            inUserData: AIPanelUserData,
            outPanel: *mut AIPanelRef,
        ) -> AIErr,
    >,
    #[doc = " Deletes a panel object.\nThis must be called when the plug-in receives \\c #kAIApplicationShutdownNotifier.\n@param inPanel\t\t\tThe panel object."]
    pub Destroy: ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef) -> AIErr>,
    #[doc = " Retrieves the platform-specific window/view used for the panel.\n@param inPanel\t\t\tThe panel object.\n@param outPlatformWindow The platform specific window/view of the panel"]
    pub GetPlatformWindow: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            outPlatformWindow: *mut AIPanelPlatformWindow,
        ) -> AIErr,
    >,
    #[doc = " Shows or hides the panel. If the panel is part of a tab group,\nthe whole group is affected\n@param inPanel\t\t\tThe panel object.\n@param inShow\t\t\tTrue to make panel visible, false to hide it"]
    pub Show: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inShow: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports the effective visibility of a panel.\nIf the panel is part of a tabbed group but is not the frontmost tab,\nit is not considered visible.\n@param inPanel\t\t\tThe panel object.\n@param outIsShown\t\t[out] A buffer in which to return the Boolean output; True if the panel\nis effectively visible, False otherwise."]
    pub IsShown: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outIsShown: *mut AIBoolean) -> AIErr,
    >,
    #[doc = "  Retrieves developer-defined data from a panel.\n@param inPanel\t\t\tThe panel object.\n@param outUserData\t\t[out] A buffer in which to return developer-defined data\nassociated with the panel."]
    pub GetUserData: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outUserData: *mut AIPanelUserData) -> AIErr,
    >,
    #[doc = " Associates developer-defined data with a panel, which can be used\nin developer-defined callbacks.\n@param inPanel\t\t\tThe panel object.\n@param inUserData\t\tThe developer-defined data."]
    pub SetUserData: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inUserData: AIPanelUserData) -> AIErr,
    >,
    #[doc = " Sets a panel title.\n@param inPanel\t\t\tThe panel object.\n@param inTitle\t\t\tThe new title of the panel"]
    pub SetTitle: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inTitle: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the panel title.\n@param inPanel\t\t\tThe panel object.\n@param outTitle\t\t\t[out] A buffer in which to return the title string."]
    pub GetTitle: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outTitle: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets the icon to be used when a panel is collapsed. Only PNG icons can be used.\n@param inPanel\t\t\tThe panel object.\n@param inPNGData\t\tThe PNG resource data for the icon.\n@param inDataSize\t\tThe size of the resource data in bytes.\n@param inPNGDarkData\tThe PNG resource data for an alternate icon, to be used in \"dark\" mode.\n@param inDarkDataSize\tThe size of the alternate resource data in bytes."]
    pub SetIcon: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inPNGData: *const ai_AutoBuffer<*const ai_uint8, ::std::os::raw::c_ulong>,
            inDataSize: *const ai_AutoBuffer<ai_uint32, ::std::os::raw::c_ulong>,
            inPNGDarkData: *const ai_AutoBuffer<*const ai_uint8, ::std::os::raw::c_ulong>,
            inDarkDataSize: *const ai_AutoBuffer<ai_uint32, ::std::os::raw::c_ulong>,
        ) -> AIErr,
    >,
    #[doc = " @deprecated. Use \\c #AIPanelSuite::SetSVGIconResourceID()\nSets the icon to be used when a panel is collapsed, using an existing resource.\nOnly PNG icons can be used.\n@param inPanel\t\t\tThe panel object.\n@param iconResId\t\tThe resource identifier of a PNG icon.\n@param darkIconcResId\tThe resource identifier of an alternate PNG icon for \"dark\" mode."]
    pub SetIconResourceID: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            iconResId: *const ai_AutoBuffer<ai_uint32, ::std::os::raw::c_ulong>,
            darkIconResId: *const ai_AutoBuffer<ai_uint32, ::std::os::raw::c_ulong>,
        ) -> AIErr,
    >,
    #[doc = " Sets the SVG icon to be used when a panel is collapsed, using an existing resource.\n@param inPanel         The panel object.\n@param iconResId\t\tThe resource identifier of a SVG icon in 2x scale factor.\n@param darkIconResId\tThe resource identifier of a SVG icon for \"dark\" mode in 2x scale factor."]
    pub SetSVGIconResourceID: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            iconResId: ai_uint32,
            darkIconResId: ai_uint32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the inner dimensions of the current panel, which excludes the frame, title, and any\nplatform-specific decorations.\n@param inPanel\t\t\tThe panel object.\n@param outSize\t\t\t[out] A buffer in which to return the size value."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outSize: *mut AISize) -> AIErr,
    >,
    #[doc = " Sets the minimum size for a panel's inner dimensions.\n@param inPanel\t\t\tThe panel object.\n@param inMinimumSize\tThe size value."]
    pub SetMinimumSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inMinimumSize: *const AISize) -> AIErr,
    >,
    #[doc = " Retrieves the minimum minimum size for a panel's inner dimensions.\n@param inPanel\t\t\tThe panel object.\n@param outMinimumSize\t[out] A buffer in which to return the size value."]
    pub GetMinimumSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outMinimumSize: *mut AISize) -> AIErr,
    >,
    #[doc = "  Sets the maximum size for a panel's inner dimensions.\n@param inPanel\t\t\tThe panel object.\n@param inMaximumSize\tThe size value."]
    pub SetMaximumSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inMaximumSize: *const AISize) -> AIErr,
    >,
    #[doc = "  Retrieves the maximum size for a panel's inner dimensions.\n@param inPanel\t\t\tThe panel object.\n@param outMaximumSize\t[out] A buffer in which to return the size value."]
    pub GetMaximumSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outMaximumSize: *mut AISize) -> AIErr,
    >,
    #[doc = " Sets both the constrained and unconstrained preferred sizes\nfor a panel's inner dimensions.\nThe constrained size is used when a dialog is frame docked.\nThe unconstrained size is used when the dialog is floating.\n\n@param inPanel\t\t\tThe panel object.\n@param inPreferredSize\tThe new preferred size value."]
    pub SetPreferredSizes: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inPreferredSize: *const AISize) -> AIErr,
    >,
    #[doc = " Sets all sizes at once for a panel's inner dimensions.\n@param inPanel\t\t\t\t\t\t\tThe panel object.\n@param inMinimumSize\t\t\t\t\tMinimum panel size.\n@param inPreferredUnconstrainedSize\t\tPreferred unconstrained panel size.\t\t.\n@param inPreferredConstrainedSize\t\tPreferred constrained panel size.\n@param inMaximumSize\t\t\t\t\tMaximum panel size.\n@return error"]
    pub SetSizes: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inMinimumSize: *const AISize,
            inPreferredUnconstrainedSize: *const AISize,
            inPreferredConstrainedSize: *const AISize,
            inMaximumSize: *const AISize,
        ) -> AIErr,
    >,
    #[doc = " For non-resizable panels, sets the minimum, maximum,\npreferred unconstrained, and preferred constrained sizes\nfor a panel's inner dimensions to a single size value.\nFor resizable panels, sets only the preferred unconstrained and\nconstrained sizes to the given size.\n@param inPanel\t\t\tThe panel object.\n@param inSize\t\t\tThe new size value."]
    pub SetSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inSize: *const AISize) -> AIErr,
    >,
    #[doc = " Retrieves the preferred constrained size for a panel's inner dimensions.\nThe constrained size is used when a dialog is frame docked.\n@param inPanel\t\t\t\t\t\t\tThe panel object.\n@param outPreferredConstrainedSize\t\t[out] A buffer in which to return the size value."]
    pub GetPreferredConstrainedSize: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            outPreferredConstrainedSize: *mut AISize,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the preferred unconstrained size for a panel's inner dimensions.\nThe unconstrained size is used when the dialog is floating.\n@param inPanel\t\t\t\t\t\t\tThe panel object.\n@param outPreferredUnconstrainedSize\t[out] A buffer in which to return the size value."]
    pub GetPreferredUnconstrainedSize: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            outPreferredUnconstrainedSize: *mut AISize,
        ) -> AIErr,
    >,
    #[doc = " Sets the current state of a panel.\n@param inPanel\t\t\tThe panel object.\n@param inCurrentState\tThe new current state, must be at least 1."]
    pub SetCurrentState: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inCurrentState: ai_int16) -> AIErr,
    >,
    #[doc = " Retrieves the current state of a panel\n@param inPanel\t\t\tThe panel object.\n@param outCurrentState\t[out] A buffer in which to return the state value."]
    pub GetCurrentState: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outCurrentState: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Modifies the state count of a panel.\n@param inPanel\t\t\tThe panel object.\n@param inStateCount\t\tThe new state count; must be at least 1"]
    pub SetStateCount: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inStateCount: ai_int16) -> AIErr,
    >,
    #[doc = " Retrieves the state count of a panel\n@param inPanel\t\t\tThe panel object.\n@param outStateCount\t[out] A buffer in which to return the state-count value."]
    pub GetStateCount: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outStateCount: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Sets the vertical step size to use when a resizable panel is resized.\nThe panel height is constrained to be its minimum height plus a multiple\nof the vertical step size. By default, this is 1, making the panel sizable to any height.\n\n@param inPanel\t\t\tThe panel object.\n@param inStepSize\t\tThe new step size."]
    pub SetVerticalStepSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inStepSize: AIReal) -> AIErr,
    >,
    #[doc = " Retrieves the vertical step size for a panel\n@param inPanel\t\t\tThe panel object.\n@param outStepSize\t\t[out] A buffer in which to return the size value."]
    pub GetVerticalStepSize: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outStepSize: *mut AIReal) -> AIErr,
    >,
    #[doc = " Sets the flyout menu for a panel.\n@param inPanel\t\t\tThe panel object.\n@param inFlyoutMenu\t\tThe new menu, or NULL to hide the menu icon.\n@see \\c #AIPanelFlyoutMenuSuite."]
    pub SetFlyoutMenu: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inFlyoutMenu: AIPanelFlyoutMenuRef) -> AIErr,
    >,
    #[doc = " Retrieves the flyout menu for a panel.\n@param inPanel\t\t\tThe panel object.\n@param outFlyoutMenu\t[out] A buffer in which to return the flyout menu object.\n@see \\c #AIPanelFlyoutMenuSuite."]
    pub GetFlyoutMenu: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            outFlyoutMenu: *mut AIPanelFlyoutMenuRef,
        ) -> AIErr,
    >,
    #[doc = " Reports the minimized state of a panel.\nWhen a panel is minimized its content area is  not visible, and the panel\nview has a visible height of 0.\n@param inPanel\t\t\tThe panel object.\n@param outIsMinimized\t[out] A buffer in which to return true if the panel is minimized,\nfalse otherwise."]
    pub IsMinimized: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, outIsMinimized: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Modifies the minimized state of the panel.\n@param inPanel\t\t\tThe panel object.\n@param inIsMinimized\tTrue to minimize the panel, false to return it to the\nunminimized state."]
    pub ChangeIsMinimized: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inIsMinimized: AIBoolean) -> AIErr,
    >,
    #[doc = " Moves a panel to a specific screen location.\nHas no effect if the panel is docked. If the panel is part of a tab group,\nthe whole tab group is moved to the new location.\n@param inPanel\t\t\tThe panel object.\n@param inPoint\t\t\tThe new position in global screen coordinates."]
    pub Move:
        ::std::option::Option<unsafe extern "C" fn(inPanel: AIPanelRef, inPoint: AIPoint) -> AIErr>,
    #[doc = " Sets a callback procedure to be called before the flyout menu for a panel is shown.\n@param inPanel\t\t\t\t\t\tThe panel object.\n@param inFlyoutMenuPreVisProc\t\tThe new callback procedure."]
    pub SetFlyoutMenuPreVisibilityProc: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inFlyoutMenuPreVisProc: AIPanelFlyoutMenuPreVisibilityProc,
        ) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to be called after the flyout menu for a panel has been shown.\n@param inPanel\t\t\t\t\t\tThe panel object.\n@param\tinFlyoutMenuPostVisProc\t\tThe new callback procedure."]
    pub SetFlyoutMenuProc: ::std::option::Option<
        unsafe extern "C" fn(inPanel: AIPanelRef, inFlyoutMenuProc: AIPanelFlyoutMenuProc) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to be called when the visibility of a panel is changed.\n@param inPanel\t\t\t\t\t\t\tThe panel object.\n@param inVisibilityChangedNotifyProc\tThe new callback procedure."]
    pub SetVisibilityChangedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inVisibilityChangedNotifyProc: AIPanelVisibilityChangedNotifyProc,
        ) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to be called when the size of a panel is changed.\n@param inPanel\t\t\t\t\t\tThe panel object.\n@param inSizeChangedNotifyProc\t\tThe new callback procedure."]
    pub SetSizeChangedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inSizeChangedNotifyProc: AIPanelSizeChangedNotifyProc,
        ) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to be called when the state of a panel is changed.\n@param inPanel\t\t\t\t\t\tThe panel object.\n@param inStateChangedNotifyProc\t\tThe new callback procedure."]
    pub SetStateChangedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inStateChangedNotifyProc: AIPanelStateChangedNotifyProc,
        ) -> AIErr,
    >,
    #[doc = " Set a callback procedure to be called when a panel is closed by clicking the close button.\n@param inPanel\t\t\t\t\t\tThe panel object.\n@param inPanelClosedNotifyProc\t\tThe new callback procedure."]
    pub SetClosedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inPanel: AIPanelRef,
            inPanelClosedNotifyProc: AIPanelClosedNotifyProc,
        ) -> AIErr,
    >,
    #[doc = " Get Panel Global Rect.\n@param inPanel                      The panel object.\n@param outRect                      OutRect."]
    pub GetPosition: ::std::option::Option<
        unsafe extern "C" fn(inPanelRef: AIPanelRef, outRect: *mut AIRealRect) -> AIErr,
    >,
}
#[doc = "\t@ingroup Suites\nProvides functions for creating and managing panel flyout menus.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPanelFlyoutMenuSuite\tand \\c #kAIPanelFlyoutMenuSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPanelFlyoutMenuSuite {
    #[doc = " Creates a new panel flyout menu or submenu.\n@param outFlyOutMenu\t\t[out] A buffer in which to return the new panel flyout menu object.\n"]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(outFlyOutMenu: *mut AIPanelFlyoutMenuRef) -> AIErr,
    >,
    #[doc = "  Deletes a panel flyout menu object.\nThis must be called when the plug-in receives \\c #kAIApplicationShutdownNotifier.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object."]
    pub Destroy:
        ::std::option::Option<unsafe extern "C" fn(inFlyOutMenu: AIPanelFlyoutMenuRef) -> AIErr>,
    #[doc = " Retrieves the number of items in a flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param outSize\t\t\t\t[out] A buffer in which to return the number of items."]
    pub Size: ::std::option::Option<
        unsafe extern "C" fn(inFlyOutMenu: AIPanelFlyoutMenuRef, outSize: *mut ai_uint32) -> AIErr,
    >,
    #[doc = " Inserts a new item at the end of a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inNewItemID\t\t\tThe unique non-zero identifier for the new item.\n@param inItemText\t\t\tThe display text for the new item."]
    pub AppendItem: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inNewItemID: ai_uint32,
            inItemText: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Inserts a separator in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inNewItemID\t\t\tThe unique non-zero identifier for the new separator."]
    pub AppendSeparator: ::std::option::Option<
        unsafe extern "C" fn(inFlyOutMenu: AIPanelFlyoutMenuRef, inNewItemID: ai_uint32) -> AIErr,
    >,
    #[doc = " Inserts a new item at a specific relative position in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inBeforeItemID\t\tThe ID of an existing item before which to insert the new item.\n@param inNewItemID\t\t\tThe unique non-zero identifier for the new item.\n@param inItemText\t\t\tTThe display text for the new item."]
    pub InsertItem: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inBeforeItemID: ai_uint32,
            inNewItemID: ai_uint32,
            inItemText: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Inserts a separator at a specific relative position in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inAfterID\t\t\tThe ID of an exsiting item after which to insert the separator,\nor -1 to append the separator to the end of the menu.\n@param inNewItemID\t\t\tThe unique non-zero identifier for the new separator."]
    pub InsertSeparator: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inBeforeItemID: ai_uint32,
            inNewItemID: ai_uint32,
        ) -> AIErr,
    >,
    #[doc = " Removes an item or separator from a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item or separator."]
    pub RemoveItem: ::std::option::Option<
        unsafe extern "C" fn(inFlyOutMenu: AIPanelFlyoutMenuRef, inItemID: ai_uint32) -> AIErr,
    >,
    #[doc = " Enables or disables an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param inEnabled\t\t\tTrue to enable or false to disable the item."]
    pub SetItemEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            inEnabled: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the enabled status of an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param outEnabled\t\t\t[out] A buffer in which to return true if the item is enabled, false otherwise."]
    pub GetItemEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            outEnabled: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets a mark on an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param inItemMark\t\t\tThe mark type constant. Can be check, bullet, dash, or none."]
    pub SetItemMark: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            inItemMark: AIPanelFlyoutMenuItemMark,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the type of mark on an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param outItemMark\t\t\t[out] A buffer in which to return the type constant (check, bullet, dash, or none)."]
    pub GetItemMark: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            outItemMark: *mut AIPanelFlyoutMenuItemMark,
        ) -> AIErr,
    >,
    #[doc = " Sets the display text for an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param inItemText\t\t\tThe new text string."]
    pub SetItemText: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            inItemText: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the display text for an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param outItemText\t\t\t[out] A buffer in which to return the text string."]
    pub GetItemText: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            outItemText: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Reports whether an item in a panel flyout menu is a separator.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemIndex\t\t\tThe 0-based index of the item.\n@param outIsItemSeparator\t[out] A buffer in which to return true if the item is a separator, false otherwise.\n@return\terror"]
    pub IsItemSeparator: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemIndex: ai_uint32,
            outIsItemSeparator: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Associates a submenu with an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param inSubMenu\t\t\tA panel flyout menu object."]
    pub SetItemSubMenu: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            inSubMenu: AIPanelFlyoutMenuRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the submenu associated with an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item.\n@param outSubMenu\t\t\t[out] A buffer in which to return the submenu object."]
    pub GetItemSubMenu: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemID: ai_uint32,
            outSubMenu: *mut AIPanelFlyoutMenuRef,
        ) -> AIErr,
    >,
    #[doc = " Removes any submenu associated with an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemID\t\t\t\tThe unique identifier of the item."]
    pub DetachItemSubMenu: ::std::option::Option<
        unsafe extern "C" fn(inFlyOutMenu: AIPanelFlyoutMenuRef, inItemID: ai_uint32) -> AIErr,
    >,
    #[doc = " Sets the unique identifier of an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemIndex\t\t\tThe 0-based index of the item.\n@param inNewItemID\t\t\tThe new unique non-zero item ID."]
    pub SetItemID: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemIndex: ai_uint32,
            inNewItemID: ai_uint32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifier of an item in a panel flyout menu.\n@param inFlyOutMenu\t\t\tThe panel flyout menu object.\n@param inItemIndex\t\t\tThe 0-based index of the item.\n@param outItemID\t\t\t[out] A buffer in which to return the ID"]
    pub GetItemID: ::std::option::Option<
        unsafe extern "C" fn(
            inFlyOutMenu: AIPanelFlyoutMenuRef,
            inItemIndex: ai_uint32,
            outItemID: *mut ai_uint32,
        ) -> AIErr,
    >,
}
pub const AIAppContextKind_kAIAppContextStandardKind: AIAppContextKind = 0;
pub const AIAppContextKind_kAIAppContextUndoRedoKind: AIAppContextKind = 1;
pub const AIAppContextKind_kAIAppContextBetaUpdateKind: AIAppContextKind = 2;
pub type AIAppContextKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIAppContextOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to the application context. It is never dereferenced."]
pub type AIAppContextHandle = *mut _t_AIAppContextOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AISuspendedAppContextOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an application context stack. It is never dereferenced."]
pub type AISuspendedAppContext = *mut _t_AISuspendedAppContextOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIAppMenuContextOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an application context stack. It is never dereferenced."]
pub type AIAppMenuContext = *mut _t_AIAppMenuContextOpaque;
#[doc = " @ingroup Suites\nUse these functions to manage the application context. The application\ncontext does two things:\n\n\\li It establishes the current document and view. Most SDK\nfunctions do not take a document or a view as a parameter, but\nuse the current document or view as defined by the application context.\n\n\\li It establishes the scope of a single undoable operation. All the\nchanges that occur during a single application context are grouped\ntogether into a single operation, which can then be undone and redone.\n\nMost plug-ins don't need to use these functions, because Illustrator\nmanages the context. In rare situations, however, a plug-in may need\nto make changes to the context. For example, if a plug-in is called directly\nby the operating system, Illustrator has not established the context.\nIf the plug-in wants to make SDK calls in response, it should use\n\\c #PushAppContext() and \\c #PopAppContext().\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIAppContextSuite and \\c #kAIAppContextVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIAppContextSuite {
    #[doc = " Retrieves the parent application window in Windows.\nDoes nothing in Mac OS.\n@param appWindow [out] A buffer in which to return the window reference."]
    pub GetPlatformAppWindow:
        ::std::option::Option<unsafe extern "C" fn(appWindow: *mut AIWindowRef) -> AIErr>,
    #[doc = " Stores an application context for the calling plug-in.\n@param plugin This plug-in.\n@param appContext [out] A buffer in which to return the application\ncontext reference. Pass this to \\c #PopAppContext() upon completion\nof the context-sensitive procedure.\n"]
    pub PushAppContext: ::std::option::Option<
        unsafe extern "C" fn(plugin: SPPluginRef, appContext: *mut AIAppContextHandle) -> AIErr,
    >,
    #[doc = " Restores the previous application context.\n@param appContext The application context reference, as returned by\n\\c #PushAppContext()."]
    pub PopAppContext:
        ::std::option::Option<unsafe extern "C" fn(appContext: AIAppContextHandle) -> AIErr>,
    #[doc = " @deprecated No longer needed."]
    pub MacGetAppQDGlobal: ::std::option::Option<
        unsafe extern "C" fn(appQD: *mut *mut ::std::os::raw::c_void) -> AIErr,
    >,
    #[doc = " Suspends the current application context stack. This is equivalent to popping\nall current open contexts,  except that they can later be restored all at once\nby \\c #ResumeAppContext(). Use before an operation that may change the current document.\n@param appContext [out] A buffer in which to return the application\ncontext stack reference. Pass this to \\c #ResumeAppContext() upon completion\nof the context-sensitive procedure."]
    pub SuspendAppContext: ::std::option::Option<
        unsafe extern "C" fn(appContext: *mut AISuspendedAppContext) -> AIErr,
    >,
    #[doc = " Resumes the application context stack for the document of\nthe frontmost window. This might be a different document from the one\nat the time the context stack was suspended.\n@param appContext The application context stack reference, as returned by\n\\c #SuspendAppContext()."]
    pub ResumeAppContext: ::std::option::Option<
        unsafe extern "C" fn(
            appContext: AISuspendedAppContext,
            document: AIDocumentHandle,
        ) -> AIErr,
    >,
    #[doc = " Allows or disallows plug-ins to operate on artwork within locked and/or hidden\nparent contexts. The call modifies the allow-changes state of the current context. The\nstate persists until you specifically reset it, or until the context is popped.\nThis allows you to make modifications without having to save, set, and restore\nvisibility and locked attributes on the whole parent chain.\n@param allowAllChanges True to allow changes, false to disallow changes.\n@param previousState [out] A buffer in which to return true if changes were previously allowed,\nfalse if they were not."]
    pub AllowAllChanges: ::std::option::Option<
        unsafe extern "C" fn(allowAllChanges: ASBoolean, previousState: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Allows or disallows use of the progress bar for the current context.\n@param showProgress True to show the progress bar, false to hide it."]
    pub AllowProgress: ::std::option::Option<unsafe extern "C" fn(showProgress: bool) -> AIErr>,
    #[doc = " Retrieves the main menu application handle in Windows.\nDoes nothing in Mac OS.\n@param appMenu [out] A buffer in which to return the menu reference."]
    pub GetPlatformAppMenu:
        ::std::option::Option<unsafe extern "C" fn(appMenu: *mut AIAppMenuContext) -> AIErr>,
    #[doc = " Sets the ContextKind for current context.\n@param kind The Context kind can either be <br>\n\\c kAIAppContextStandardKind, \\c kAIAppContextUndoRedoKind, \\c kAIAppContextBetaUpdateKind\nwhich are mutually exclusive. See \\c enum AIAppContextKind"]
    pub SetAppContextKind:
        ::std::option::Option<unsafe extern "C" fn(kind: AIAppContextKind) -> AIErr>,
    #[doc = " Synchronize the current global context and then draws."]
    pub SyncAndDraw: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Get Ruler width for the current document.\n\n Returns width of the vertical ruler and height of the horizontal ruler\n Returns 0 if rulers are hidden"]
    pub GetRulerWidthOffsetOnActiveDocument: ::std::option::Option<
        unsafe extern "C" fn(
            horzRulerBounds: *mut AIRect,
            vertRulerBounds: *mut AIRect,
            cntrRulerBounds: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Tells if Application context is present or not.\n\n @return A buffer returning whether application context is present or not."]
    pub DoesAppContextExist: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Gets the current AppContextKind.\n@param kind [out] A buffer in which to return the kind\n\\c kAIAppContextStandardKind, \\c kAIAppContextUndoRedoKind, \\c kAIAppContextBetaUpdateKind\nwhich are mutually exclusive. See \\c enum AIAppContextKind"]
    pub GetAppContextKind:
        ::std::option::Option<unsafe extern "C" fn(kind: *mut AIAppContextKind) -> AIErr>,
    #[doc = " Tells if kAPIContextShowProgressOption flag is set or not in APIContext options.\nreturns true/false whether progress bar is allowed or not."]
    pub IsProgressBarAllowed:
        ::std::option::Option<unsafe extern "C" fn(result: *mut AIBoolean) -> AIErr>,
}
pub const AIFolderType_kAIApplicationFolderType: AIFolderType = 0;
pub const AIFolderType_kAIPluginsFolderType: AIFolderType = 1;
pub const AIFolderType_kAIPrimaryScratchFolderType: AIFolderType = 2;
pub const AIFolderType_kAISecondaryScratchFolderType: AIFolderType = 3;
pub const AIFolderType_kAIPreferencesFolderType: AIFolderType = 4;
pub const AIFolderType_kAIUserSupportFolderType: AIFolderType = 5;
pub const AIFolderType_kAIUserSupportAIFolderType: AIFolderType = 6;
pub const AIFolderType_kAIUserSupportAIPluginsFolderType: AIFolderType = 7;
pub const AIFolderType_kAIApplicationSupportCommonFolderType: AIFolderType = 8;
pub const AIFolderType_kAIApplicationSupportCommonColorFolderType: AIFolderType = 9;
pub const AIFolderType_kAIApplicationSupportCommonTypeSupportFolderType: AIFolderType = 10;
pub const AIFolderType_kAIApplicationSupportCommonFontsFolderType: AIFolderType = 11;
pub const AIFolderType_kAIApplicationSupportCommonFontsReqrdFolderType: AIFolderType = 12;
pub const AIFolderType_kAIApplicationSupportCommonFontsReqrdCMapsFolderType: AIFolderType = 13;
pub const AIFolderType_kAIRequiredFontsFolderType: AIFolderType = 14;
pub const AIFolderType_kAIFontsFolderType: AIFolderType = 15;
pub const AIFolderType_kAIMyDocumentsFolderType: AIFolderType = 16;
pub const AIFolderType_kAIApplicationSupportCommonWorkflowFolderType: AIFolderType = 17;
pub const AIFolderType_kAIPrinterDescriptionsFolderType: AIFolderType = 18;
pub const AIFolderType_kAIRequiredPluginsFolderType: AIFolderType = 19;
pub const AIFolderType_kAISettingsFolderType: AIFolderType = 20;
pub const AIFolderType_kAIColorTableSettingsFolderType: AIFolderType = 21;
pub const AIFolderType_kAIOptimizeSettingsFolderType: AIFolderType = 22;
pub const AIFolderType_kAIHelpFolderType: AIFolderType = 23;
pub const AIFolderType_kAIRootFolderType: AIFolderType = 24;
pub const AIFolderType_kAIPresetsFolderType: AIFolderType = 25;
pub const AIFolderType_kAIPresetActionsFolderType: AIFolderType = 26;
pub const AIFolderType_kAIPresetBrushesFolderType: AIFolderType = 27;
pub const AIFolderType_kAIPresetGradientsFolderType: AIFolderType = 28;
pub const AIFolderType_kAIPresetKeyboardShortcutsFolderType: AIFolderType = 29;
pub const AIFolderType_kAIPresetPatternsFolderType: AIFolderType = 30;
pub const AIFolderType_kAIPresetScriptsFolderType: AIFolderType = 31;
pub const AIFolderType_kAIPresetStylesFolderType: AIFolderType = 32;
pub const AIFolderType_kAIPresetSwatchesFolderType: AIFolderType = 33;
pub const AIFolderType_kAIDictionariesFolderType: AIFolderType = 34;
pub const AIFolderType_kAILegalFolderType: AIFolderType = 35;
pub const AIFolderType_kAISampleFilesFolderType: AIFolderType = 36;
pub const AIFolderType_kAIUtilitiesFolderType: AIFolderType = 37;
pub const AIFolderType_kAIPackageFolderType: AIFolderType = 38;
pub const AIFolderType_kAIApplicationSupportCommonFontsReqrdBaseFolderType: AIFolderType = 39;
pub const AIFolderType_kAIHelpersFolderType: AIFolderType = 40;
pub const AIFolderType_kAIPreviewInFolderType: AIFolderType = 41;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIStartupFileFolderType: AIFolderType = 42;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRidersFileFolderType: AIFolderType = 43;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIHyphenationDictFolderType: AIFolderType = 44;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonPDFLFolderType: AIFolderType = 45;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonPDFL5FolderType: AIFolderType = 46;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonPDFL5CMapsFolderType: AIFolderType = 47;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonPDFL5FontsFolderType: AIFolderType = 48;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonPrintSupportFolderType: AIFolderType = 49;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonColorProfilesFolderType: AIFolderType = 50;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonColorSettingsFolderType: AIFolderType = 51;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIContentsFolderType: AIFolderType = 52;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIHelpImagesFolderType: AIFolderType = 53;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIFontsCMapsFolderType: AIFolderType = 54;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetSymbolsFolderType: AIFolderType = 55;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAITsumeFolderType: AIFolderType = 56;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISpellingDictFolderType: AIFolderType = 57;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetTemplatesFolderType: AIFolderType = 58;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIFontsCFFolderType: AIFolderType = 59;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonKinsokuSetFolderType: AIFolderType = 60;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonMojikumeSetFolderType: AIFolderType = 61;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetBlankDocumentsFolderType: AIFolderType = 62;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserSupportCommonFontsFolderType: AIFolderType = 63;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIFontsCFTempFolderType: AIFolderType = 64;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAILogsFolderType: AIFolderType = 65;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISampleArtFolderType: AIFolderType = 66;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISampleSVGFolderType: AIFolderType = 67;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISampleGraphDesignsFolderType: AIFolderType = 68;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISampleDataDrivenGraphicsFolderType: AIFolderType = 69;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIWorkspacesFolderType: AIFolderType = 70;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetColorBooksFolderType: AIFolderType = 71;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetLegacyColorBooksFolderType: AIFolderType = 72;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetSwatchExchangeFolderType: AIFolderType = 73;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonLinguisticsFolderType: AIFolderType = 74;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonLinguisticsProvidersFolderType: AIFolderType = 75;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIVersionCueFolderType: AIFolderType = 76;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIDemonstratorFolderType: AIFolderType = 77;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIResourcesFolderType: AIFolderType = 78;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAICoolExtrasFolderType: AIFolderType = 79;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIOutputSettingsFolderType: AIFolderType = 80;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIStartupScriptsFolderType: AIFolderType = 81;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIDesktopFolderType: AIFolderType = 82;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIIllustratorFormatsFolderType: AIFolderType = 83;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIAdditionalAIPluginsFolderType: AIFolderType = 84;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritableStartupFileFolderType: AIFolderType = 85;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetBrushesFolderType: AIFolderType = 86;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetStylesFolderType: AIFolderType = 87;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetSwatchesFolderType: AIFolderType = 88;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetSwatchExchangeFolderType: AIFolderType = 89;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetSymbolsFolderType: AIFolderType = 90;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetFlashPanelsFolderType: AIFolderType = 91;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetKnowhowFolderType: AIFolderType = 92;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetSettingsFolderType: AIFolderType = 93;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetOptimizeSettingsFolderType: AIFolderType = 94;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetOutputSettingsFolderType: AIFolderType = 95;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetColorTableSettingsFolderType: AIFolderType = 96;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRequiredStartupProfilesFolderType: AIFolderType = 97;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetWorkspacesFolderType: AIFolderType = 98;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetKulerFolderType: AIFolderType = 99;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetWelcomeScreenFolderType: AIFolderType = 100;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRequiredFolderType: AIFolderType = 101;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRequiredResourcesFolderType: AIFolderType = 102;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRequiredLocalizedResourcesFolderType: AIFolderType = 103;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIWSMgrCfgFolderType: AIFolderType = 104;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIModifiedWorkspacesFolderType: AIFolderType = 105;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIToolsFolderType: AIFolderType = 106;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPreferencesRootFolderType: AIFolderType = 107;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIRequiredLinguisticsFolderType: AIFolderType = 108;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAITemporayFolder: AIFolderType = 109;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetChartsFolderType: AIFolderType = 110;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIMACSupportFilesFolderType: AIFolderType = 111;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIFrameworksDllsPath: AIFolderType = 112;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserLocalSupportFolderType: AIFolderType = 113;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIAMTParentFolderType: AIFolderType = 114;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonx86FolderType: AIFolderType = 115;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAILibraryHostPluginsFolderType: AIFolderType = 116;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIModifiedPresetsToolsFolderType: AIFolderType = 117;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIPresetToolsFolderType: AIFolderType = 118;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAISubstanceMaterialFolderType: AIFolderType = 119;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIExportPresetFolderType: AIFolderType = 120;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIModifiedPDFPresetFolderType: AIFolderType = 121;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIApplicationSupportCommonIllustratorFolderType: AIFolderType = 122;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIOnDemandModulesRootFolderType: AIFolderType = 123;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kCCXPWelcomeFolderType: AIFolderType = 124;
#[doc = "  LEGACY USE ONLY.  Templates available to developers are now in \\c #kAIUserWritableStartupFileFolderType"]
pub const AIFolderType_kAIUserWritablePresetUserMockupFolderType: AIFolderType = 125;
#[doc = "Identifiers for Illustrator folders. See \\c #AIFoldersSuite."]
pub type AIFolderType = ::std::os::raw::c_uint;
#[doc = " Temporary file"]
pub const AIFileType_kAITemporaryFileType: AIFileType = 1;
#[doc = " Types of files that can be acquired by \\c #AIFoldersSuite::GetFileName()"]
pub type AIFileType = ::std::os::raw::c_uint;
#[doc = "\t@ingroup Suites\nThis suite provides functions to get the locations of the\nstandard folders used by Illustrator.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFoldersSuite and \\c #kAIFoldersVersion.\n\nThe following shows the layout of these folders and the corresponding identifiers.\n\n<b>Local Hierarchy</b>\n\n@verbatim\nAdobe Illustrator x\t\t<- kAIRootFolderType\nAdobe Illustrator x:\t<- kAIPackageFolderType\nContents:\t\t<- kAIContentsFolderType\nWindows/MacOSClassic: <- kAIApplicationFolderType\n+Executable\n+Shared libraries\nHelp:\t\t<- kAIHelpFolderType\n+HTML Help Files\nimages:\t\t<- kAIHelpImagesFolderType\n+Help graphics\nHelpers:\t\t<- kAIHelpersFolderType\nPreview In:\t\t<- kAIPreviewInFolderType\nRequired:\t\t<- kAIRequiredFolderType\n+Required plug-ins\nFonts:\t\t<- kAIRequiredFontsFolderType\n+Required fonts\nStartup Profiles <- kAIRequiredStartupProfilesFolderType\n+Startup files\n\nLegal:\t\t<- kAILegalFolderType\n+EULA\n\nPlug-ins:\t<- kAIPluginsFolderType (user can not change as of AI13)\n(kAIStartupFileFolderType, kAIRidersFileFolderType both point here)\nExtensions:\nIllustrator Filters:\nIllustrator Formats:\t<- kAIIllustratorFormatsFolderType\nPhotoshop Effects:\nPhotoshop Filters:\nPhotoshop Formats:\nText Filters:\nTools:\t<- kAIToolsFolderType\nTsume:\t<- kAITsumeFolderType\n\nPresets:\t<- kAIPresetsFolderType\n(Note: The presets folder and subfolders are in the application directory and may not be writable.\nTo write settings files, use one of the kAIUserSupport folders or the kAIUserWritable folders.)\nActions:\t<- kAIPresetActionsFolderType\nBrushes:\t<- kAIPresetBrushesFolderType\nKeyboard Shortcuts: <- kAIPresetKeyboardShortcutsFolderType\nSave for Web Settings: <- kAISettingsFolderType\nColor Tables: <- kAIColorTableSettingsFolderType\n+Color tables\nOptimize:\t<- kAIOptimizeSettingsFolderType\n+Optimize settings\nOutput Settings:\n+Output settings <- kAIOutputSettingsFolderType\nScripts:\t<- kAIPresetScriptsFolderType\nStyles:\t<- kAIPresetStylesFolderType\nSwatches:\t<- kAIPresetSwatchesFolderType + kAIPresetSwatchExchangeFolderType\nColor Systems: <- kAIPresetColorSystemsFolderType\nColor Books:\t<- kAIPresetColorBooksFolderType\nLegacy:\t<- kAIPresetLegacyColorBooksFolderType\nGradients:\t<- kAIPresetGradientsFolderType\nPatterns:\t<- kAIPresetPatternsFolderType\nSymbols:\t<- kAIPresetSymbolsFolderType\nTemplates:\t<- kAIPresetTemplatesFolderType\nBlank Documents: <- kAIPresetBlankDocumentsFolderType\nFlash Panels: <- kAIPresetFlashPanelsFolderType\nWelcome Screen: <- kAIPresetWelcomeScreenFolderType\nWorkspaces:\t<- kAIPresetWorkspacesFolderType\nTools:\t<- kAIPresetToolsFolderType\n\nFonts:\t\t<- kAIFontsFolderType\nCMaps:\t<- kAIFontsCMapsFolderType\n\nSample Files:\t<- kAISampleFilesFolderType\nGraph Designs: <- kAISampleGraphDesignsFolderType\nSample Art:\t<- kAISampleArtFolderType\nSVG:\t<- kAISampleSVGFolderType\nData-Driven Graphics: <- kAIDataDrivenGraphicsFolderType\n\nStartupScripts:\t<- kAIStartupScriptsFolderType\n\nUtilities:\t<- kAIUtilitiesFolderType\n@endverbatim\n\n<b> System Hierarchies </b>\n\nThe following describes the parts of the Illustrator directory hierarchy\nthat are located under system folders. The platform-specific directory\nnames are shown following.\n\n@verbatim\n[PrimaryScratch]\t<- kAIPrimaryScratchFolderType + primary scratch file location\n[SecondaryScratch]\t<- kAISecondaryScratchFolderType + secondary scratch file location\n[AIPreferences]\t\t<- kAIPreferencesFolderType + preferences file location + plug-in cache file location\n[UserSupport]\t\t<- kAIUserSupportFolderType\nAdobe Illustrator X\t<- kAIUserSupportAIFolderType\nStartup Templates: <- kAIUserWritableStartupFileFolderType\nPlug-ins\t<- kAIUserSupportAIPluginsFolderType + plug-ins available to current user\nComposite Fonts <- kAIFontsCFFolderType\nTemp\t<- kAIFontsCFTempFolderType\nBrushes <- kAIUserWritablePresetBrushesFolderType\nGraphic Styles <- kAIUserWritablePresetStylesFolderType\nSwatches <- kAIUserWritablePresetSwatchesFolderType + kAIUserWritablePresetSwatchExchangeFolderType\nSymbols <- kAIUserWritablePresetSymbolsFolderType\nSave for Web Settings <- kAIUserWritablePresetSettingsFolderType\nColor Tables\t<- kAIUserWritablePresetColorTableSettingsFolderType\nOptimize\t\t<- kAIUserWritablePresetOptimizeSettingsFolderType\nOutput Settings\t<- kAIUserWritablePresetOutputSettingsFolderType\nFonts\t<- kAIUserSupportCommonFontsFolderType\n[ApplicationSupportCommon]\t<- kAIApplicationSupportCommonFolderType\nColor\t<- kAIApplicationSupportCommonColorFolderType\nProfiles\t<- kAIApplicationSupportCommonColorProfilesFolderType\nSettings\t<- kAIApplicationSupportCommonColorSettingsFolderType\ntypeSpt\t<- kAIApplicationSupportCommonTypeSupportFolderType\nKinsoku Sets\t<- kAIApplicationSupportCommonKinsokuSetFolderType\nMojikume Sets\t<- kAIApplicationSupportCommonMojikumeSetFolderType\nFonts\t<- kAIApplicationSupportCommonFontsFolderType\nReqrd\t<- kAIApplicationSupportCommonFontsReqrdFolderType\nBase\t<- kAIApplicationSupportCommonFontsReqrdBaseFolderType\ncmaps\t<- kAIApplicationSupportCommonFontsReqrdCMapsFolderType\nPDFL\t<- kAIApplicationSupportCommonPDFLFolderType\nPDFL5.0\t<- kAIApplicationSupportCommonPDFL5FolderType\ncmaps\t<- kAIApplicationSupportCommonPDFL5CMapsFolderType\nfonts\t<- kAIApplicationSupportCommonPDFL5FontsFolderType\nPrintspt\t<- kAIApplicationSupportCommonPrintSupportFolderType\nWorkflow\t<- kAIApplicationSupportCommonWorkflowFolderType\nLinguistics\t<- kAIApplicationSupportCommonLinguisticsFolderType\nProviders\t<- kAIApplicationSupportCommonLinguisticsProvidersFolderType\nProximity\t<- kAIDictionariesFolderType, kAIHyphenationDictFolderType,kAISpellingDictFolderType (all point at same folder)\n[MyDocuments]\t<- kAIMyDocumentsFolderType + default documents file location\n[PPDs]\t<- kAIPrinterDescriptionsFolderType + PPD location\n[Logs]\t<- kAILogsFolderType\n[AdditionalPlugins]\t<- kAIAdditionalAIPluginsFolderType + additional plug-ins location (new in AI13, user can change in Preferences)\n@endverbatim\n\n<b> Platform-specific Directories </b>\n\n\\li Windows 2000\n@verbatim\nPrimaryScratch = System definition of temporary but can be changed by user\nSecondaryScratch = System definition of temporary but can be changed by user\nAIPreferences = Documents and Settings\\username\\Application Data\\Adobe\\Adobe Illustrator X\nUserSupport = Documents and Settings\\username\\Application Data\\Adobe\nApplicationSupportCommon = Program Files\\Common Files\\Adobe\nMyDocuments = Documents and Settings\\username\\My Documents\nPPDs = unknown\nLogs = Documents and Settings\\username\\Application Data\\Adobe\\Logs\nkAIResourcesFolderType = kAIApplicationFolderType\nkAIDesktopFolderType = CSIDL_DESKTOPDIRECTORY: The file system directory used\nto physically store file objects on the desktop (not to\nbe confused with the desktop folder itself). A typical\npath is C:\\Documents and Settings\\username\\Desktop.\nAdditionalPlugins = Arbitrary location can be specified by user in Preferences\n@endverbatim\n\n\\li Mac OS X\n@verbatim\nPrimaryScratch = System definition of temporary but can be changed by user\nSecondaryScratch = System definition of temporary but can be changed by user\nAIPreferences = ~/Library/Preferences/Adobe Illustrator X\nUserSupport = ~/Library/Application Support/Adobe\nApplicationSupportCommon = /Library/Application Support/Adobe\nMyDocuments = ~/Documents\nPPDs = Libraries/Printers/PPDs\nLogs = ~/Library/Logs/Adobe Illustrator CS\nkAIResourcesFolderType = kAIApplicationFolderType/Resources\nkAIDesktopFolderType = ~/Desktop\nAdditionalPlugins = Arbitrary location can be specified by user in Preferences\n@endverbatim"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFoldersSuite {
    #[doc = " Gets a path for an Illustrator folder.\n@param type The Illustrator folder to find.\n@param createFolder When true, creates a folder of the given type if it\ndoes not already exist.\n@param folder [out] A buffer in which to return the folder path."]
    pub FindFolder: ::std::option::Option<
        unsafe extern "C" fn(
            type_: AIFolderType,
            createFolder: AIBoolean,
            folder: *mut ai_FilePath,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the file-system name of an Illustrator folder.\n@param type The Illustrator folder.\n@param name [out] A buffer in which to return the name of the folder\n(not the full path). Must be of size \\c #kMaxPathLength."]
    pub GetFolderName: ::std::option::Option<
        unsafe extern "C" fn(type_: AIFolderType, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Creates a file path object for a temporary file. Generates a unique,\ntemporary file name. Does not check whether the file exists.\n@param type The file type, must be \\c #kAITemporaryFileType.\n@param file [out] A buffer in which to return the file path."]
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(type_: AIFileType, file: *mut ai_FilePath) -> AIErr,
    >,
}
unsafe extern "C" {
    pub static mut sSPAccess: *mut SPAccessSuite;
}
unsafe extern "C" {
    pub static mut sSPPlugins: *mut SPPluginsSuite;
}
unsafe extern "C" {
    pub static mut sAINotifier: *mut AINotifierSuite;
}
unsafe extern "C" {
    pub static mut sAIAppContext: *mut AIAppContextSuite;
}
unsafe extern "C" {
    pub static mut sAIUser: *mut AIUserSuite;
}
unsafe extern "C" {
    pub static mut sAIFilePath: *mut AIFilePathSuite;
}
unsafe extern "C" {
    pub static mut sAIFolders: *mut AIFoldersSuite;
}
#[repr(C)]
#[derive(Debug)]
pub struct Suites {
    pub fError: ASErr,
    pub fOptionalSuitesTotalCount: ASUInt16,
    pub fRequiredSuitesCount: ASUInt16,
    pub fOptionalSuitesAcquiredCount: ASUInt16,
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Suites14fAcquiredCountE"]
    pub static mut Suites_fAcquiredCount: ASUInt16;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Suites23acquire_Optional_SuitesEv"]
    pub fn Suites_acquire_Optional_Suites(this: *mut Suites);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6SuitesC1Ev"]
    pub fn Suites_Suites(this: *mut Suites);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6SuitesD1Ev"]
    pub fn Suites_Suites_destructor(this: *mut Suites);
}
impl Suites {
    #[inline]
    pub unsafe fn acquire_Optional_Suites(&mut self) {
        Suites_acquire_Optional_Suites(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Suites_Suites(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Suites_Suites_destructor(self)
    }
}
#[doc = " This format knows how to copy to the clipboard."]
pub const AIClipboardFormatOptions_kClipboardCopy: AIClipboardFormatOptions = 2;
#[doc = " This format knows how to paste from the clipboard."]
pub const AIClipboardFormatOptions_kClipboardPaste: AIClipboardFormatOptions = 4;
#[doc = " This format cannot copy data to the clipboard.\nIf set, user cannot enable the preference\nfor copying data on exit. This is needed because\nthe \\c kClipboardCopy flag is also used internally\nto track the state of the user preference."]
pub const AIClipboardFormatOptions_kClipboardCannotCopy: AIClipboardFormatOptions = 8;
#[doc = " Option flags for registering a clipboard format handler with\n\\c #AIClipboardSuite::AddClipboard(), specifies which operations\nare supported."]
pub type AIClipboardFormatOptions = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIClipboardOpaque {
    _unused: [u8; 0],
}
#[doc = " Identifies a registered clipboard format handler."]
pub type AIClipboardHandle = *mut _t_AIClipboardOpaque;
#[doc = " Identifies a resource type."]
pub type DDType = ai_uint32;
#[doc = " Data used to register a clipboard format handler. See\n\\c #AIClipboardSuite::AddClipboard()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIClipboardData {
    #[doc = " The format name, such as \"myCompany File Format\" or \"Rich Text Format\""]
    pub clipboardName: *const ::std::os::raw::c_char,
    #[doc = " In Windows, the OLE data type, such as \\c CF_TEXT or \\c CF_BITMAP"]
    pub OleType: ai_int32,
    #[doc = " In Mac OS, the unique data resource type (\\c ResType),\nsuch as \\c 'TEXT'. Check \\c AIDragDropTypes.h\nto make sure it is unique."]
    pub uniqueType: DDType,
}
#[doc = " The message structure received when the clipboard format handler's main\nentry point receives a message with caller \\c #kCallerAIClipboard"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIClipboardMessage {
    #[doc = " The message data"]
    pub d: SPMessageData,
    #[doc = " The clipboard object."]
    pub Clipboard: AIClipboardHandle,
    #[doc = " The clipboard data"]
    pub ClipboardData: AIStream,
    #[doc = " The supported clipboard operations.\nA logical OR of \\c #AIClipboardFormatOptions values."]
    pub option: ai_int32,
}
#[doc = "\t@ingroup Suites\nThe clipboard suite enables plug-ins to register new clipboard format handlers.\nThe handler's main entry point then receives messages requesting it to\ncopy data to and from the clipboard as needed. The messages have caller\n\\c #kCallerAIClipboard. The possible selectors are:\n\n\\li \\c #kSelectorAIGoClipboard\n\\li \\c #kSelectorAICanCopyClipboard\n\\li \\c #kSelectorAICloneClipboard\n\\li \\c #kSelectorAIDisposeClipboard\n\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIClipboardSuite and \\c #kAIClipboardVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIClipboardSuite {
    #[doc = " Registers a new clipboard format handler.\n@param self The plug-in.\n@param data The types of clipboard data handled.\n@param options The capabilities of the format handler.\nA logical OR of \\c #AIClipboardFormatOptions values.\n@param Clipboard [out] A buffer in which to return the clipboard handler reference."]
    pub AddClipboard: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            data: *mut AIClipboardData,
            options: ai_int32,
            Clipboard: *mut AIClipboardHandle,
        ) -> AIErr,
    >,
    #[doc = " Unregisters a clipboard format handler.\n@param Clipboard The clipboard handler reference."]
    pub RemoveClipboard:
        ::std::option::Option<unsafe extern "C" fn(Clipboard: AIClipboardHandle) -> AIErr>,
    #[doc = " Retrieves the registered name of a clipboard format handler.\n@param Clipboard The clipboard handler reference.\n@param name [out] A buffer in which to return the name."]
    pub GetClipboardName: ::std::option::Option<
        unsafe extern "C" fn(
            Clipboard: AIClipboardHandle,
            name: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves Windows OLE type of the data handled by the format handler.\n@param Clipboard The clipboard handler reference.\n@param OleType [out] A buffer in which to return the OLE data type."]
    pub GetClipboardOleType: ::std::option::Option<
        unsafe extern "C" fn(Clipboard: AIClipboardHandle, OleType: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the plug-in reference for the plug-in supplying the format handler.\n@param Clipboard The clipboard handler reference.\n@param plugin [out] A buffer in which to return the plug-in reference."]
    pub GetClipboardPlugin: ::std::option::Option<
        unsafe extern "C" fn(Clipboard: AIClipboardHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Retrieves Mac OS resource type of the data handled by the format handler.\n@param Clipboard The clipboard handler reference.\n@param uniqueType [out] A buffer in which to return the data resource type."]
    pub GetClipboardType: ::std::option::Option<
        unsafe extern "C" fn(Clipboard: AIClipboardHandle, uniqueType: *mut DDType) -> AIErr,
    >,
    #[doc = " Retrieves the options describing the capabilities of the format handler.\n@param Clipboard The clipboard handler reference.\n@param options [out] A buffer in which to return the capabilities of the\nformat handler. A logical OR of \\c #AIClipboardFormatOptions values."]
    pub GetClipboardOptions: ::std::option::Option<
        unsafe extern "C" fn(Clipboard: AIClipboardHandle, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the options describing the capabilities of the format handler.\n@param Clipboard The clipboard handler reference.\n@param options The capabilities of the format handler.\nA logical OR of \\c #AIClipboardFormatOptions values."]
    pub SetClipboardOptions: ::std::option::Option<
        unsafe extern "C" fn(Clipboard: AIClipboardHandle, options: ai_int32) -> AIErr,
    >,
    #[doc = " Counts the number of registered clipboard format handlers. Use with\n\\c #GetNthClipboard() to iterate through handlers.\n@param count [out] A buffer in which to return the number of handlers."]
    pub CountClipboards: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a clipboard format handler by position index. Use with\n\\c #CountClipboards() to iterate through handlers.\n@param n The index, in the range <code>[0..numHandlers-1]</code> .\n@param Clipboard [out] A buffer in which to return the clipboard handler reference."]
    pub GetNthClipboard: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, Clipboard: *mut AIClipboardHandle) -> AIErr,
    >,
    #[doc = " Update clipboard contents\n@param buffer Contains the data to be set on clipboard.\n@param type Object type of new contents."]
    pub UpdateClipboard: ::std::option::Option<
        unsafe extern "C" fn(
            buffer: *const ai_AutoBuffer<ai_uint8, ::std::os::raw::c_ulong>,
            type_: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Reset the contents on clipboards"]
    pub ResetClipboard: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Get clipboard contents for an object type\n@param buffer [out] in which clipboard contents will be set.\n@param type Object type."]
    pub GetClipboardData: ::std::option::Option<
        unsafe extern "C" fn(
            buffer: *mut ai_AutoBuffer<ai_uint8, ::std::os::raw::c_ulong>,
            type_: *const ai_UnicodeString,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIFilterOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a filter. It is never dereferenced.\nUse the functions in the \\c #AIFilterSuite to access it."]
pub type AIFilterHandle = *mut _t_AIFilterOpaque;
#[doc = " A developer-defined structure that holds parameters required\nfor your filter. It is a platform handle; allocate space with\n\\c #AIMdMemorySuite::MdMemoryNewHandle()."]
pub type PlatformFilterParameters = *mut ::std::os::raw::c_void;
#[doc = " The menu category and display name for a plug-in filter.\nFilters in the same category are added to a submenu of the Filter menu.\n\\li In Windows, either or both can have a keyboard shortcut.\nPrecede the shortcut character with an ampersand (&).\nTake care that the shortcut key does not conflict with\nother menu items."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlatformAddFilterData {
    #[doc = " The menu category (submenu) to which the filter is added,\na Pascal-style string."]
    pub category: *mut ::std::os::raw::c_uchar,
    #[doc = " The display name for the filter's menu item, a Pascal-style string.\nBy convention, the name is a descriptive verb,such as \"Rotate\".\nIf the filter requires parameters, the name should end\nwith three dots."]
    pub title: *mut ::std::os::raw::c_uchar,
}
#[doc = " The message for a filter Get Parameters or Go selector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFilterMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The filter object. If your plug-in defines more than one filter,\nsave the handles in \\c globals and compare to determine which\nwas activated."]
    pub filter: AIFilterHandle,
    #[doc = " The parameter values, in a developer-defined parameter structure.\nFill with values in response to a Get Parameters selector."]
    pub parameters: PlatformFilterParameters,
}
#[doc = " @ingroup Suites\nThis suite provides functions to add and manage menu items in the Filter menu.\nPlug-in filters are added to the Filter menu in a separate section\nfrom native Illustrator filters and Photoshop filters supported by\nIllustrator. You can specify a \\e category, or submenu, for a group of filters.\n\nWhen the user selects a filter, it typically displays an\noptions dialog and then manipulates the artwork in some fashion\naccording to those options.\n\nFilter plug-ins are similar in many ways to the more general\nmenu plug-ins (see \\c #AIMenuSuite). Filters differ in that:\n\\li Filters are added to the Filter menu, while menu plug-ins can\nadd commands to any menu.\n\\li Menu plug-ins can set command keys and control their appearance.\n\\li Both plug-in types receive a Go selector, but filters also receive\n\\c #kSelectorAIGetFilterParameters. The user interface is typically\na modal dialog, while a menu plug-in can interact with other\nplug-in types, or trigger other events.\n\\li Filters automatically set the Repeat and Undo menus, while menu plug-ins\nmust set the Undo menu item text. The filter plug-in must remove\nthe Undo context if the user cancels the action. Use\n\\c #AIUndoSuite::UndoChanges() to remove any changes to\nthe artwork the plug-in made, and do any other necessary clean up,\nsuch as disposing of allocated memory.\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIFilterSuite and \\c #kAIFilterVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIFilterSuite {
    #[doc = " Installs a filter plug-in. Call this during startup to place the name\nof your filter in the Filter menu.\n@param self A reference to this plug-in, which adds the filter.\n@param name\tThe unique name of the new filter. You can use your\ncompany name with a descriptor to make it unique. Not displayed or localized.\n@param data\tThe structure containing the category (submenu) and localizable\nmenu-item label.\n@param options Not currently used. Pass 0.\n@param filter [out] A buffer in which to return the filter reference.\nIf you install multiple filters, store this reference in the\nplug-in�s \\c globals record, so that your plug-in can use it\nto determine which filter command is to be processed."]
    pub AddFilter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *mut ::std::os::raw::c_char,
            data: *mut PlatformAddFilterData,
            options: ai_int32,
            filter: *mut AIFilterHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the unique name of a filter.\n@param filter The filter reference.\n@param name [out] A buffer in which to return the name string, as\noriginally passed to \\c #AddFilter(). Do not modify this string."]
    pub GetFilterName: ::std::option::Option<
        unsafe extern "C" fn(
            filter: AIFilterHandle,
            name: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a filter. (The options flags are not\ncurrently used, and the returned value is always 0).\n@param filter The filter reference.\n@param options [out] A buffer in which to return the options value."]
    pub GetFilterOptions: ::std::option::Option<
        unsafe extern "C" fn(filter: AIFilterHandle, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the option flags of a filter. (The options flags are not\ncurrently used.)\n@param filter The filter reference.\n@param options The options value."]
    pub SetFilterOptions: ::std::option::Option<
        unsafe extern "C" fn(filter: AIFilterHandle, options: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the stored reference to a parameter block for a filter.\nThis block contains the parameter values that were set by the user\nin the most recent call to this filter.\n@param filter The filter reference.\n@param parameters [out] A buffer in which to return the stored parameters block."]
    pub GetFilterParameters: ::std::option::Option<
        unsafe extern "C" fn(
            filter: AIFilterHandle,
            parameters: *mut PlatformFilterParameters,
        ) -> AIErr,
    >,
    #[doc = " Sets the stored reference to a parameter block for a filter. The plug-in manager\nnormally keeps this reference to the parameter values that were set by the user\nin the most recent call to a filter. You can use this function after a call to\n\\c #AIPluginSuite::CallPlugin(), to store a new set of parameters.\n@param filter The filter reference.\n@param parameters The new parameters block.\n@see \\c #GetFilterParameters()"]
    pub SetFilterParameters: ::std::option::Option<
        unsafe extern "C" fn(filter: AIFilterHandle, parameters: PlatformFilterParameters) -> AIErr,
    >,
    #[doc = " Retrieves the menu-item reference for a filter. Your plug-in can then modify\nthe menu item�s appearance using the \\c #AIMenuSuite functions.\n@param filter The filter reference.\n@param menuItem [out] A buffer in which to return the menu item reference."]
    pub GetFilterMenuItem: ::std::option::Option<
        unsafe extern "C" fn(filter: AIFilterHandle, menuItem: *mut AIMenuItemHandle) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the plug-in that installed a filter.\n@param filter The filter reference.\n@param plugin [out] A buffer in which to return the plug-in reference."]
    pub GetFilterPlugin: ::std::option::Option<
        unsafe extern "C" fn(filter: AIFilterHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Gets number of installed filters. Use this with \\c #GetNthFilter()\nto iterate through installed filters.\n@param count [out] A buffer in which to return the number of filters."]
    pub CountFilters: ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a plug-in filter reference by position index. Use with\n\\c #CountFilters() to iterate through all installed filters.\n@param n  The index, in the range <code>[1..numFilters]</code>.\n@param filter [out] A buffer in which to return the filter reference."]
    pub GetNthFilter: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, filter: *mut AIFilterHandle) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite defines the array, a heterogeneous container whose elements are\naccessed by sequential integer indices.\n\nEntries (of type \\c AIEntryRef), can be inserted into and removed\nfrom the array. The AIEntry suite provides methods to construct and\nquery entries of different types. See \\c apiAIEntry.h.\nEntries can be of simple types such as booleans, integers, floats, and strings\nand complex types such as other arrays, dictionaries and references to document\nobjects including art objects, brushes and styles.\nThis makes arrays a very flexible and powerful container.\n\nArrays can themselves be stored in other containers such as other arrays\nor dictionaries. In particular they can be stored in the dictionaries\nattached to art objects and to the document. When an array is stored in\none of these places (directly or indirectly) it is read and written as\na part of the document.\n\n@see AIEntrySuite, AIDictionarySuite, AIArtSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArraySuite and \\c #kAIArrayVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArraySuite {
    #[doc = " Creates a new array.\nArrays are reference counted. Initial reference count is 1.\nUse \\c #AddRef() to increment the count, and \\c #Release() to decrement the count.\n@param array [out] A buffer in which to return the new array reference."]
    pub CreateArray: ::std::option::Option<unsafe extern "C" fn(array: *mut AIArrayRef) -> AIErr>,
    #[doc = " Increments the reference count for an array.\nWhen you create an array, the initial count is 1.\nUse \\c #Release() to decrement the count.\n(Note that this function returns a numeric value, not an error code.)\n@param array The array reference.\n@return The current reference count."]
    pub AddRef: ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef) -> ai_int32>,
    #[doc = "  Decrements the reference count for an array, and\nfrees the memory when the reference count is 0.\nWhen you create an array, the initial count is 1.\nUse \\c #AddRef() to increment the count.\n(Note that this function returns a numeric value, not an error code.)\n@param array The array reference.\n@return The current reference count."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef) -> ai_int32>,
    #[doc = " Makes an exact duplicate of a source array. Performs a deep copy.\n@param src The array reference for the source.\n@param dest [out] buffer in which to return the new array."]
    pub Clone:
        ::std::option::Option<unsafe extern "C" fn(src: AIArrayRef, dst: *mut AIArrayRef) -> AIErr>,
    #[doc = " Makes a copy of a source array by replacing the current contents of the destination array.\n@param array The reference for the array to be replaced.\n@param src The array reference for the source."]
    pub Copy:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, src: AIArrayRef) -> AIErr>,
    #[doc = " Returns the number of entries in an array.\nThe index position of an entry is in the range [0..Size(array) - 1].\nNote this returns a number, not an error code.\n@param array The array reference.\n@return The number of entries in the array."]
    pub Size: ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef) -> ai_int32>,
    #[doc = " Removes an entry from an array.\n@param array The array reference.\n@param i The 0-based index position of the entry."]
    pub DeleteEntry:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, i: ai_int32) -> AIErr>,
    #[doc = " Inserts an entry into an array at the given index.\nThe new entry is assigned an arbitrary initial value.\n@param array The array reference.\n@param i The 0-based index position of the new entry."]
    pub InsertEntry:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, i: ai_int32) -> AIErr>,
    #[doc = " Gets the data type of an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param type [out] A buffer in which to return the type. See \\c apiAIEntry.h."]
    pub GetEntryType: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, type_: *mut AIEntryType) -> AIErr,
    >,
    #[doc = " Copies an entry from one array to another, or to another position in the same array.\n@param array1 The array reference for the source.\n@param array2 The array reference for the destination. Can be the same array, or different one.\n@param position1 The 0-based index position of the source entry.\n@param position2 The 0-based index position of the destination entry.\n"]
    pub CopyEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array1: AIArrayRef,
            array2: AIArrayRef,
            position1: ai_int32,
            position2: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Moves an entry from one array to another, or to another position in the same array.\n@param array1 The array reference for the source.\n@param array2 The array reference for the destination. Can be the same array, or different one.\n@param position1 The 0-based index position of the source entry.\n@param position2 The 0-based index position of the destination entry.\n@param newposition [out] (Optional) A buffer in which to return the position of\nthe entry in \\c array2 after the move."]
    pub MoveEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array1: AIArrayRef,
            array2: AIArrayRef,
            position1: ai_int32,
            position2: ai_int32,
            newposition: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Swaps two entries in two arrays, or in the same array.\n@param array1 The first array reference.\n@param array2 The second array reference. Can be the same array, or different one.\n@param position1 The 0-based index position of the first entry.\n@param position2 The 0-based index position of the second entry."]
    pub SwapEntries: ::std::option::Option<
        unsafe extern "C" fn(
            array1: AIArrayRef,
            array2: AIArrayRef,
            position1: ai_int32,
            position2: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Gets an art-object array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param type [out] A buffer in which to return the entry."]
    pub GetArtEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Sets the value of an array entry to be a new art object of the specified type.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param type The type of art object. See \\c apiAIArt.h."]
    pub NewArtEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, type_: ai_int16) -> AIErr,
    >,
    #[doc = " Moves an art object from the artwork tree into an array.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param art The art object. See \\c apiAIArt.h."]
    pub MoveArtToEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, art: AIArtHandle) -> AIErr,
    >,
    #[doc = " Moves an art object to the artwork tree from an array.\nThe entry is not deleted from the array, but instead is set to an arbitrary value.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param paintOrder The paint order of the art object in the art tree. See \\c apiAIArt.h.\n@param prep The prepositional object for the paint order. See \\c apiAIArt.h.\n@param art The art object. See \\c apiAIArt.h."]
    pub MoveEntryToArt: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Copies an art object from the art tree into an array.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param art The art object. See \\c apiAIArt.h."]
    pub CopyArtToEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, art: AIArtHandle) -> AIErr,
    >,
    #[doc = " Copies an art object from an array into the art tree.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param paintOrder The paint order of the art object in the art tree. See \\c apiAIArt.h.\n@param prep The prepositional object for the paint order. See \\c apiAIArt.h.\n@param art The art object. See \\c apiAIArt.h."]
    pub CopyEntryToArt: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            paintOrder: ai_int16,
            prep: AIArtHandle,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Sets an array entry to refer to the topmost group of a layer.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param layer The layer reference."]
    pub SetEntryToLayer: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, layer: AILayerHandle) -> AIErr,
    >,
    #[doc = " Inserts a new layer in the current document, from a group array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\nMust be an art object, of type \\c #kGroupArt.\n@param paintOrder The paint order of the art object in the art tree. Valid values are\n\\c #kPlaceDefault, \\c #kPlaceAbove, \\c #kPlaceBelow, \\c #kPlaceAboveAll and \\c #kPlaceBelowAll.\n@param prep The prepositional object for the paint order.\n@param layer [out] A buffer in which to return the new layer reference."]
    pub SetLayerToEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            paintOrder: ai_int16,
            prep: AILayerHandle,
            layer: *mut AILayerHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves an array entry by position index.\n(Note this returns an array entry reference, not an error code.)\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@return The array entry, or a null entry if one does not exist."]
    pub Get:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, i: ai_int32) -> AIEntryRef>,
    #[doc = " Adds an array entry at a given position index.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param entry The array entry reference. See \\c apiAIEntry.h.\n@see \\c #AppendEntry()"]
    pub Set: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, entry: AIEntryRef) -> AIErr,
    >,
    #[doc = " Retrieves a boolean value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetBooleanEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut ASBoolean) -> AIErr,
    >,
    #[doc = " Sets a boolean value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetBooleanEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves an integer value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetIntegerEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets an integer  value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetIntegerEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a \\c real value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetRealEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut AIReal) -> AIErr,
    >,
    #[doc = " Sets a \\c real value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetRealEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: AIReal) -> AIErr,
    >,
    #[doc = " Retrieves a string value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            value: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Sets a string value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            value: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a binary value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value.\n@param size [out] The number of bytes in \\c value."]
    pub GetBinaryEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            value: *mut ::std::os::raw::c_void,
            size: *mut ASInt32,
        ) -> AIErr,
    >,
    #[doc = " Sets a binary value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value A pointer to the new value.\n@param size The number of bytes in \\c value."]
    pub SetBinaryEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            value: *mut ::std::os::raw::c_void,
            size: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a dictionary value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetDictEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Sets a dictionary value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetDictEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Retrieves an array value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetArrayEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut AIArrayRef) -> AIErr,
    >,
    #[doc = " Sets an array value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetArrayEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: AIArrayRef) -> AIErr,
    >,
    #[doc = " Retrieves a Unicode string value from an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value [out] A buffer in which to return the value."]
    pub GetUnicodeStringEntry: ::std::option::Option<
        unsafe extern "C" fn(array: AIArrayRef, i: ai_int32, value: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets a Unicode string value for an array entry.\n@param array The array reference.\n@param i The 0-based index position of the entry.\n@param value The new value."]
    pub SetUnicodeStringEntry: ::std::option::Option<
        unsafe extern "C" fn(
            array: AIArrayRef,
            i: ai_int32,
            value: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Adds an entry at the end of an array.\n@param array The array reference.\n@param entry The array entry reference. See \\c apiAIEntry.h.\n@see \\c #Set()"]
    pub AppendEntry:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, entry: AIEntryRef) -> AIErr>,
    #[doc = "  Reserves a minimum length of storage for an array.\n@param array The array reference.\n@param count The number of entries to reserve."]
    pub Reserve:
        ::std::option::Option<unsafe extern "C" fn(array: AIArrayRef, count: ai_int32) -> AIErr>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIXMLNodeList {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an XML node list. Access with \\c #AIXMLNodeListSuite"]
pub type AIXMLNodeListRef = *mut _AIXMLNodeList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIXMLNamedNodeMap {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an XML named node map. Access with \\c #AIXMLNamedNodeMapSuite"]
pub type AIXMLNamedNodeMapRef = *mut _AIXMLNamedNodeMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIXMLName {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an XML name. See \\c #AIXMLNodeSuite::NameFromString(),\n\\c #AIXMLNodeSuite::SetNodeName()."]
pub type AIXMLName = *mut _AIXMLName;
#[doc = " An abstract name that can be converted to or from a\nsimple C string or Unicode string. See \\c #AIXMLNodeSuite."]
pub type AIXMLString = AIEntryRef;
#[doc = " XML node type, an \\c #AIXMLNodeTypeValue. See \\c #AIXMLNodeSuite::GetNodeType(),\n\\c #AIXMLDocumentSuite"]
pub type AIXMLNodeType = ai_int32;
pub const AIXMLNodeTypeValue_kAIXMLUnknownNode: AIXMLNodeTypeValue = 0;
#[doc = " Element. See \\c #AIXMLDocumentSuite::CreateElement()"]
pub const AIXMLNodeTypeValue_kAIXMLElementNode: AIXMLNodeTypeValue = 1;
#[doc = " Attribute. See \\c #AIXMLDocumentSuite::CreateAttribute()"]
pub const AIXMLNodeTypeValue_kAIXMLAttributeNode: AIXMLNodeTypeValue = 2;
#[doc = " Text. See \\c #AIXMLDocumentSuite::CreateTextNode()"]
pub const AIXMLNodeTypeValue_kAIXMLTextNode: AIXMLNodeTypeValue = 3;
#[doc = " CData section. See \\c #AIXMLDocumentSuite::CreateCDATASection()"]
pub const AIXMLNodeTypeValue_kAIXMLCDATASectionNode: AIXMLNodeTypeValue = 4;
#[doc = " Comment. See \\c #AIXMLDocumentSuite::CreateComment()"]
pub const AIXMLNodeTypeValue_kAIXMLCommentNode: AIXMLNodeTypeValue = 5;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLEntityReferenceNode: AIXMLNodeTypeValue = 6;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLEntityNode: AIXMLNodeTypeValue = 7;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLProcessingInstructionNode: AIXMLNodeTypeValue = 8;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLDocumentNode: AIXMLNodeTypeValue = 9;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLDocumentTypeNode: AIXMLNodeTypeValue = 10;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLDocumentFragmentNode: AIXMLNodeTypeValue = 11;
#[doc = " Not supported"]
pub const AIXMLNodeTypeValue_kAIXMLNotationNode: AIXMLNodeTypeValue = 12;
#[doc = " Possible values for \\c #AIXMLNodeType."]
pub type AIXMLNodeTypeValue = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite allows you to create and manipulate XML nodes.\n\nThe XML node suite provides an approximate implementation of the\nXML Level 1 DOM interface for nodes. See\nhttp://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#ID-1950641247\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIXMLNodeSuite and \\c #kAIXMLNodeVersion.\n\nThe values of \"NodeName\", \"NodeValue\", and \"Attributes\" vary according to\nthe node type as follows:\n\n<table>\n<tr><td>\t\t\t\t</td><td>NodeName\t\t\t</td><td>NodeValue\t\t\t</td><td>Attributes</td></tr>\n\n<tr><td>Element\t\t\t</td><td>tag name\t\t\t</td><td>null\t\t\t\t</td><td>NamedNodeMap</td></tr>\n<tr><td>Attr\t\t\t</td><td>attribute name\t\t</td><td>attribute value\t</td><td>null</td></tr>\n<tr><td>Text\t\t\t</td><td>\\#text\t\t\t\t</td><td>text value\t\t\t</td><td>null</td></tr>\n<tr><td>CDATASection\t</td><td>\\#cdata-section\t</td><td>CDATA contents \t</td><td>null</td></tr>\n<tr><td>Comment\t\t\t</td><td>\\#comment\t\t\t</td><td>comment string\t\t</td><td>null</td></tr>\n\n<tr><td>EntityReference\t</td><td>entity ref name\t</td><td>null\t\t\t\t</td><td>null</td></tr>\n<tr><td>Entity\t\t\t</td><td>entity name\t\t</td><td>null\t\t\t\t</td><td>null</td></tr>\n<tr><td>P.Instruction\t</td><td>target name\t\t</td><td>content\t\t\t</td><td>null</td></tr>\n<tr><td>Document\t\t</td><td>\\#document\t\t\t</td><td>null\t\t\t\t</td><td>null</td></tr>\n<tr><td>DocumentType\t</td><td>document type name\t</td><td>null\t\t\t\t</td><td>null</td></tr>\n<tr><td>DocumentFrag\t</td><td>\\#document-fragment </td><td>null\t\t\t\t</td><td>null</td></tr>\n<tr><td>Notation\t\t</td><td>notation name\t\t</td><td>null\t\t\t\t</td><td>null</td></tr>\n</table>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIXMLNodeSuite {
    #[doc = " Increments the reference count for an XML node.\nWhen you create a node, the initial count is 1.\nUse \\c #Release() to decrement the count.\n(Note that this function returns a numeric value, not an error code.)\n@param node The XML node reference.\n@return The current reference count."]
    pub AddRef: ::std::option::Option<unsafe extern "C" fn(node: AIXMLNodeRef) -> ai_int32>,
    #[doc = " Decrements the reference count for an XML node, and\nfrees the memory when the reference count is 0.\nWhen you create a node, the initial count is 1.\nUse \\c #AddRef() to increment the count.\n(Note that this function returns a numeric value, not an error code.)\n@param node The XML node reference.\n@return The current reference count."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(node: AIXMLNodeRef) -> ai_int32>,
    #[doc = " Creates an exact duplicate of an XML node. performing a deep copy.\n@param src The source node.\n@param dst [out] A buffer in which to return the new node."]
    pub Clone: ::std::option::Option<
        unsafe extern "C" fn(src: AIXMLNodeRef, dst: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Copies the contents of an XML node into another existing node.\n@param node The node whose contents are replaced.\n@param src The source node."]
    pub Copy:
        ::std::option::Option<unsafe extern "C" fn(node: AIXMLNodeRef, src: AIXMLNodeRef) -> AIErr>,
    #[doc = " Retrieves the type of an XML node.\n@param node The XML node reference.\n@param type [out] A buffer in which to return the type constant."]
    pub GetNodeType: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, type_: *mut AIXMLNodeType) -> AIErr,
    >,
    #[doc = " Retrieves the name of an XML node.\n@param node The XML node reference.\n@param name [out] A buffer in which to return the name."]
    pub GetNodeName: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, name: *mut AIXMLName) -> AIErr,
    >,
    #[doc = " Sets the name of an XML node.\n@param node The XML node reference.\n@param name The new name."]
    pub SetNodeName:
        ::std::option::Option<unsafe extern "C" fn(node: AIXMLNodeRef, name: AIXMLName) -> AIErr>,
    #[doc = " Retrieves the value of an XML node.\n@param node The XML node reference.\n@param value [out] A buffer in which to return the value."]
    pub GetNodeValue: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, value: *mut AIXMLString) -> AIErr,
    >,
    #[doc = " Sets the value of an XML node.\n@param node The XML node reference.\n@param name The new value."]
    pub SetNodeValue: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, value: AIXMLString) -> AIErr,
    >,
    #[doc = " Retrieves a node list containing the child nodes of an XML node.\n@param node The XML node reference.\n@param nodes [out] A buffer in which to return the node list."]
    pub GetChildNodes: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, nodes: *mut AIXMLNodeListRef) -> AIErr,
    >,
    #[doc = " Retrieves a named node map containing the attributes associated\nwith an XML node.\n@param node The XML node reference.\n@param attributes [out] A buffer in which to return the node map."]
    pub GetAttributes: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, attributes: *mut AIXMLNamedNodeMapRef) -> AIErr,
    >,
    #[doc = " Inserts a new child node in an XML node.\n@param node The XML node reference for the parent node.\n@param newchild The new child node.\n@param refchild An existing child node before which to insert the new child,\nor \\c NULL to insert the new child at the end of the child list."]
    pub InsertBefore: ::std::option::Option<
        unsafe extern "C" fn(
            node: AIXMLNodeRef,
            newchild: AIXMLNodeRef,
            refchild: AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Replaces one child of an XML node with another child node.\n@param node The XML node reference for the parent node.\n@param newchild The new child node.\n@param oldchild An existing child node to replace."]
    pub ReplaceChild: ::std::option::Option<
        unsafe extern "C" fn(
            node: AIXMLNodeRef,
            newchild: AIXMLNodeRef,
            oldchild: AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Removes a child node from an XML node.\n@param node The XML node reference for the parent node.\n@param oldchild An existing child node to remove."]
    pub RemoveChild: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, oldchild: AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Appends a new child node to the child list of an XML node.\n@param node The XML node reference for the parent node.\n@param newchild The new child node."]
    pub AppendChild: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, newchild: AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Reports whether an XML node has any children.\n@param node The XML node reference.\n@param haschildren [out] A buffer in which to return true if the node has children."]
    pub HasChildNodes: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, haschildren: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Converts a C string to an XML node name.\n(Note that this function returns an XML name value, not an error code,)\n@param string The C string.\n@return The XML name."]
    pub NameFromString: ::std::option::Option<
        unsafe extern "C" fn(string: *const ::std::os::raw::c_char) -> AIXMLName,
    >,
    #[doc = " Converts an XML name to a C string.\n(Note that this function returns a string value, not an error code,)\n@param name The XML name.\n@return The C string."]
    pub StringFromName: ::std::option::Option<
        unsafe extern "C" fn(name: AIXMLName) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Converts a Unicode string to an XML node name.\n(Note that this function returns an XML name value, not an error code,)\n@param string The Unicode string.\n@return The XML name."]
    pub NameFromUnicodeString:
        ::std::option::Option<unsafe extern "C" fn(string: *const ai_UnicodeString) -> AIXMLName>,
    #[doc = " Converts an XML name to a Unicode string.\n@param name The XML name.\n@param string [out] A buffer in which to return the Unicode string."]
    pub UnicodeStringFromName: ::std::option::Option<
        unsafe extern "C" fn(name: AIXMLName, string: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " @deprecated. Obsolete, do not use."]
    pub GetData: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, key: AIDictKey, value: *mut AIEntryRef) -> AIErr,
    >,
    #[doc = " @deprecated. Obsolete, do not use."]
    pub SetData: ::std::option::Option<
        unsafe extern "C" fn(node: AIXMLNodeRef, key: AIDictKey, value: AIEntryRef) -> AIErr,
    >,
    #[doc = " @deprecated. Obsolete, do not use."]
    pub RemoveData:
        ::std::option::Option<unsafe extern "C" fn(node: AIXMLNodeRef, key: AIDictKey) -> AIErr>,
    #[doc = " Compares two XML nodes for equality. Nodes are equal if they have\nthe same type, name, and value, and if they each have the same\nattributes with the same values. They are deeply\nequal if their sequences of child nodes are also equal.\nWhen comparing values, the function converts them to real\nnumbers if possible, and otherwise compares the strings.\n@param node1 The first node.\n@param node2 The second node.\n@param deep True to perform a deep comparison.\n@param result [out] A buffer in which to return true (non-zero) if the nodes are equal.\n\n@note This is not a part of the XML DOM specification."]
    pub Compare: ::std::option::Option<
        unsafe extern "C" fn(
            node1: AIXMLNodeRef,
            node2: AIXMLNodeRef,
            deep: AIBoolean,
            result: *mut ai_int32,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nAn Illustrator document can store an XML document element in its dictionary.\nThis suite allows you to create and access the XML document and its\ncontained metadata element.\n\nWhen an Illustrator document is exported to SVG, the metadata element\nis written to the SVG file. Before writing the file, Illustrator sends\nthe \\c #kAIMetadataSyncNotifier to ensure that the metadata is updated.\nWhen Illustrator reads an SVG file, the metadata in the SVG becomes\nthe document metadata element.\n\nThis suite provides an approximate implementation of the\nXML Level 1 DOM interface for documents. See\nhttp://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIXMLDocumentSuite and \\c #kAIXMLDocumentVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIXMLDocumentSuite {
    #[doc = " Retrieves the XML document for the current Illustrator document, creating\none if none exists.\n@param element [out] A buffer in which to return the XML document element.\n@note This is not a part of the XML DOM specification."]
    pub GetDocumentElement:
        ::std::option::Option<unsafe extern "C" fn(element: *mut AIXMLNodeRef) -> AIErr>,
    #[doc = " Retrieves the metadata element from the XML document for the current\nIllustrator document, creating one if none exists.\n@param element [out] A buffer in which to return the metadata element.\n@note This is not a part of the XML DOM specification."]
    pub GetDocumentMetadata:
        ::std::option::Option<unsafe extern "C" fn(element: *mut AIXMLNodeRef) -> AIErr>,
    #[doc = " Creates a new metadata element.\n@param name The element name.\n@param element [out] A buffer in which to return the new element."]
    pub CreateElement: ::std::option::Option<
        unsafe extern "C" fn(name: AIXMLName, element: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Creates a new metadata attribute.\n@param name The attribute name.\n@param value The attribute value.\n@param attribute [out] A buffer in which to return the new attribute."]
    pub CreateAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            name: AIXMLName,
            value: AIXMLString,
            attribute: *mut AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Creates a new metadata text node.\n@param string The text string.\n@param text [out] A buffer in which to return the new text node."]
    pub CreateTextNode: ::std::option::Option<
        unsafe extern "C" fn(string: AIXMLString, text: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Creates a new metadata comment node.\n@param string The comment string.\n@param comment [out] A buffer in which to return the new comment node."]
    pub CreateComment: ::std::option::Option<
        unsafe extern "C" fn(string: AIXMLString, comment: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Creates a new metadata CDATA node.\n@param string The CDATA string.\n@param cdata [out] A buffer in which to return the new CDATA node."]
    pub CreateCDATASection: ::std::option::Option<
        unsafe extern "C" fn(string: AIXMLString, cdata: *mut AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Retrieves XML elements at or under a node that match a name pattern.\nThe matching elements are determined by a pre-order traversal.\n@param node A node at any level of the XML tree.\n@param name The name pattern to match. The special name \"*\" matches all elements.\n@param count [in, out] On input, the maximum number of matches to return.\nOn return, the number of array elements actually filled.\n@param [in, out] An array of nodes of size \\c count, in which to return matching\nnodes.\n@note This implementation differs from the XML DOM specification."]
    pub GetElementsByTagName: ::std::option::Option<
        unsafe extern "C" fn(
            node: AIXMLNodeRef,
            name: AIXMLName,
            count: *mut ai_int32,
            match_: *mut AIXMLNodeRef,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite allows you to access XML metadata attributes.\n\nThis suite provides an approximate implementation of the\nXML Level 1\tDOM interface for elements. See\nhttp://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#ID-745549614\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIXMLElementSuite and \\c #kAIXMLElementVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIXMLElementSuite {
    #[doc = " Retrieves the value of an XML node's named attribute.\n@param element The node.\n@param name The attribute name.\n@param value [out] A buffer in which to return the value."]
    pub GetAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            element: AIXMLNodeRef,
            name: AIXMLName,
            value: *mut AIXMLString,
        ) -> AIErr,
    >,
    #[doc = " Sets the value of an XML node's named attribute.\n@param element The node.\n@param name The attribute name.\n@param value The new value."]
    pub SetAttribute: ::std::option::Option<
        unsafe extern "C" fn(element: AIXMLNodeRef, name: AIXMLName, value: AIXMLString) -> AIErr,
    >,
    #[doc = " Removes a named attribute associated with an XML node.\n@param element The node.\n@param name The attribute name."]
    pub RemoveAttribute: ::std::option::Option<
        unsafe extern "C" fn(element: AIXMLNodeRef, name: AIXMLName) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite allows you to iterate through and manage lists of XML nodes.\n\nThis suite provides an approximate implementation of the\nXML Level 1\tDOM interface for node lists. See\nhttp://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#ID-536297177\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIXMLNodeListSuite and \\c #kAIXMLNodeListVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIXMLNodeListSuite {
    #[doc = " Retrieves the number of items in a node list. Use with \\c #GetItem()\nto iterate through a list.\n@param nodes The XML node list.\n@param length [out] A buffer in which to return the number of items."]
    pub GetLength: ::std::option::Option<
        unsafe extern "C" fn(nodes: AIXMLNodeListRef, length: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves an XML node from a node list by position index.  Use with \\c #GetLength()\nto iterate through a list.\n@param nodes The XML node list.\n@param index The 0-based position index.\n@param node [out] A buffer in which to return the node."]
    pub GetItem: ::std::option::Option<
        unsafe extern "C" fn(
            nodes: AIXMLNodeListRef,
            index: ai_int32,
            node: *mut AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Swaps XML nodes between two node lists.\n@param list1 The first XML node list.\n@param list2 The second XML node list.\n@param position1 The 0-based position index of the node in the first list to move\nto \\c position2 in the second list.\n@param position2 The 0-based position index of the node in the second list to move\nto \\c position1 in the first list.\n@note This is not a part of the XML DOM specification."]
    pub SwapNodes: ::std::option::Option<
        unsafe extern "C" fn(
            list1: AIXMLNodeListRef,
            list2: AIXMLNodeListRef,
            position1: ai_int32,
            position2: ai_int32,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite allows you to access XML named node maps.\n\nThis suite provides an approximate implementation of the\nXML Level 1 DOM interface for named node maps. See\nhttp://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#ID-1780488922\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIXMLNamedNodeMapSuite and \\c #kAIXMLNamedNodeMapSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIXMLNamedNodeMapSuite {
    #[doc = " Retrieves the size of a named node map.\tUse with \\c #GetItem() to iterate\nthrough items in the map.\n@param map The node map.\n@param length [out] A buffer in which to return the number of nodes."]
    pub GetLength: ::std::option::Option<
        unsafe extern "C" fn(map: AIXMLNamedNodeMapRef, length: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves an XML node from a node map by position index.  Use with \\c #GetLength()\nto iterate through a map.\n@param map The node map.\n@param index The 0-based position index.\n@param node [out] A buffer in which to return the node."]
    pub GetItem: ::std::option::Option<
        unsafe extern "C" fn(
            map: AIXMLNamedNodeMapRef,
            index: ai_int32,
            node: *mut AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a node by name from a node map.\n@param map The node map.\n@param name The node name.\n@param node [out] A buffer in which to return the node."]
    pub GetNamedItem: ::std::option::Option<
        unsafe extern "C" fn(
            map: AIXMLNamedNodeMapRef,
            name: AIXMLName,
            node: *mut AIXMLNodeRef,
        ) -> AIErr,
    >,
    #[doc = " Adds a named node to a node map, replacing it if it is already included.\n@param map The node map.\n@param name The node name."]
    pub SetNamedItem: ::std::option::Option<
        unsafe extern "C" fn(map: AIXMLNamedNodeMapRef, node: AIXMLNodeRef) -> AIErr,
    >,
    #[doc = " Removes a named node from a node map. There is no error if the node\nwas not in the map.\n@param map The node map.\n@param name The node name."]
    pub RemoveNamedItem: ::std::option::Option<
        unsafe extern "C" fn(map: AIXMLNamedNodeMapRef, node: AIXMLNodeRef) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AILiveEffectOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a Live Effect. It is never dereferenced."]
pub type AILiveEffectHandle = *mut _t_AILiveEffectOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AILiveEffectParamContext {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a Live Effect parameter context."]
pub type AILiveEffectParamContext = *mut _t_AILiveEffectParamContext;
#[doc = " Defines the menu item for a Live Effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddLiveEffectMenuData {
    #[doc = " The submenu in which the menu item should appear,\nor \\c NULL to place at the top level of the Effects menu."]
    pub category: *mut ::std::os::raw::c_char,
    #[doc = " The localizable display string for the menu item"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = " To add menu item as sub group, pass \\c #kAILiveEffectMenuSubGrou otherwise pass 0."]
    pub options: ai_int32,
}
#[doc = " The parameters for a Live Effect, stored in a dictionary."]
pub type AILiveEffectParameters = AIDictionaryRef;
pub type ConstAILiveEffectParameters = ConstAIDictionaryRef;
#[doc = " Clears all flags."]
pub const AIStyleFilterFlags_kNoFlags: AIStyleFilterFlags = 0;
#[doc = " Applied by default before the object is painted with fill or stroke."]
pub const AIStyleFilterFlags_kPreEffectFilter: AIStyleFilterFlags = 1;
#[doc = "  Applied by default after the object is painted with fill or stroke."]
pub const AIStyleFilterFlags_kPostEffectFilter: AIStyleFilterFlags = 2;
#[doc = " Replaces the default stroke behavior.\nBrushes are an example of an effect of this type."]
pub const AIStyleFilterFlags_kStrokeFilter: AIStyleFilterFlags = 3;
#[doc = " Replaces the default fill behavior."]
pub const AIStyleFilterFlags_kFillFilter: AIStyleFilterFlags = 4;
#[doc = " A mask to OR with the filter-style value to retrieve specific bit flags.\nDo not use with \\c #AILiveEffectSuite::AddLiveEffect()."]
pub const AIStyleFilterFlags_kFilterTypeMask: AIStyleFilterFlags = 65535;
#[doc = " Internal. Do not use."]
pub const AIStyleFilterFlags_kSpecialGroupPreFilter: AIStyleFilterFlags = 65536;
#[doc = " Parameters can be scaled."]
pub const AIStyleFilterFlags_kHasScalableParams: AIStyleFilterFlags = 131072;
#[doc = " Supports automatic rasterization."]
pub const AIStyleFilterFlags_kUsesAutoRasterize: AIStyleFilterFlags = 262144;
#[doc = " Supports the generation of an SVG filter."]
pub const AIStyleFilterFlags_kCanGenerateSVGFilter: AIStyleFilterFlags = 524288;
#[doc = " Has parameters that can be modified by a \\c #kSelectorAILiveEffectAdjustColors message."]
pub const AIStyleFilterFlags_kHandlesAdjustColorsMsg: AIStyleFilterFlags = 1048576;
#[doc = " Handles \\c #kSelectorAILiveEffectIsCompatible messages. If this flag is not set the message will not be sent."]
pub const AIStyleFilterFlags_kHandlesIsCompatibleMsg: AIStyleFilterFlags = 2097152;
#[doc = " Handles \\c #kSelectorAILiveEffectIsCompatible messages. If this flag is not set the message will not be sent."]
pub const AIStyleFilterFlags_kHasDocScaleConvertibleParams: AIStyleFilterFlags = 4194304;
#[doc = " Flag indicating support for parallel execution: This Live Effect plugin is capable of being\ninvoked on non-main threads concurrently for processing multiple art objects within different\nor the same documents. The plugin is responsible for ensuring thread safety by preventing data races,\ndeadlocks, and other concurrency issues when this flag is enabled."]
pub const AIStyleFilterFlags_kParallelExecutionFilter: AIStyleFilterFlags = 8388608;
#[doc = " Bit flags for Live Effect style properties, which specify\nhow the filter is applied and what features it supports.\nAn effect must be registered with exactly one of the\nfirst four values, which denote the filter type. The last\nthree values can be ORed together with the filter type.\nPass to \\c #AILiveEffectSuite::AddLiveEffect()\nin \\c #AILiveEffectData::styleFilterFlags."]
pub type AIStyleFilterFlags = ::std::os::raw::c_uint;
#[doc = " Supports running the effect on all art types and is the default value."]
pub const AIParallelExecutionArtFlags_kNoArtFlags: AIParallelExecutionArtFlags = 0;
#[doc = " Parameter is used to if plgin support outline text for a text art"]
pub const AIParallelExecutionArtFlags_kOutlineTextArt: AIParallelExecutionArtFlags = 1;
#[doc = " Bit flags for Live Parallel Effect Execution Art properties\nspecify the supported art types for a plugin during execution.\nAn effect must be registered with exactly one value representing\na specific art type.The values can be combined using a\nbitwise OR operation with the supported art type.\nPass to \\c #AILiveEffectSuite::AddLiveEffect()\nin \\c #AILiveEffectData::parallelExecutionArtFlags."]
pub type AIParallelExecutionArtFlags = ai_int32;
#[doc = " The \\c #kSelectorAILiveEffectInputType message is sent\nto the plug-in to determine the input type"]
pub const AIStyleFilterPreferredInputArtType_kInputArtDynamic: AIStyleFilterPreferredInputArtType =
    0;
#[doc = " Handles groups."]
pub const AIStyleFilterPreferredInputArtType_kGroupInputArt: AIStyleFilterPreferredInputArtType = 1;
#[doc = " Handles paths."]
pub const AIStyleFilterPreferredInputArtType_kPathInputArt: AIStyleFilterPreferredInputArtType = 2;
#[doc = " Handles compound paths."]
pub const AIStyleFilterPreferredInputArtType_kCompoundPathInputArt:
    AIStyleFilterPreferredInputArtType = 4;
#[doc = " Obsolete"]
pub const AIStyleFilterPreferredInputArtType_kTextInputArtUnsupported:
    AIStyleFilterPreferredInputArtType = 8;
#[doc = " Obsolete"]
pub const AIStyleFilterPreferredInputArtType_kTextPathInputArtUnsupported:
    AIStyleFilterPreferredInputArtType = 16;
#[doc = " Obsolete"]
pub const AIStyleFilterPreferredInputArtType_kTextRunInputArtUnsupported:
    AIStyleFilterPreferredInputArtType = 32;
#[doc = " Handles placed objects."]
pub const AIStyleFilterPreferredInputArtType_kPlacedInputArt: AIStyleFilterPreferredInputArtType =
    64;
#[doc = " Handles mystery paths."]
pub const AIStyleFilterPreferredInputArtType_kMysteryPathInputArt:
    AIStyleFilterPreferredInputArtType = 128;
#[doc = " Handles raster art."]
pub const AIStyleFilterPreferredInputArtType_kRasterInputArt: AIStyleFilterPreferredInputArtType =
    256;
#[doc = " Handles plug-in groups. If not set, the effect receives the result group\ninstead of the plug-in group itself."]
pub const AIStyleFilterPreferredInputArtType_kPluginInputArt: AIStyleFilterPreferredInputArtType =
    512;
#[doc = " Handles meshes."]
pub const AIStyleFilterPreferredInputArtType_kMeshInputArt: AIStyleFilterPreferredInputArtType =
    1024;
#[doc = " Handles text frames."]
pub const AIStyleFilterPreferredInputArtType_kTextFrameInputArt:
    AIStyleFilterPreferredInputArtType = 2048;
#[doc = " Handles symbols."]
pub const AIStyleFilterPreferredInputArtType_kSymbolInputArt: AIStyleFilterPreferredInputArtType =
    4096;
#[doc = " Handles foreign objects."]
pub const AIStyleFilterPreferredInputArtType_kForeignInputArt: AIStyleFilterPreferredInputArtType =
    8192;
#[doc = " Handles legacy text."]
pub const AIStyleFilterPreferredInputArtType_kLegacyTextInputArt:
    AIStyleFilterPreferredInputArtType = 16384;
#[doc = " Handles charts."]
pub const AIStyleFilterPreferredInputArtType_kChartInputArt: AIStyleFilterPreferredInputArtType =
    32768;
#[doc = " Handles any input art."]
pub const AIStyleFilterPreferredInputArtType_kAnyInputArt: AIStyleFilterPreferredInputArtType =
    65535;
#[doc = " Handles any input art other than plug-in groups, which\nare replaced by their result art."]
pub const AIStyleFilterPreferredInputArtType_kAnyInputArtButPluginArt:
    AIStyleFilterPreferredInputArtType = 65023;
#[doc = " Not implemented."]
pub const AIStyleFilterPreferredInputArtType_kOutlinedStrokeInputArt:
    AIStyleFilterPreferredInputArtType = 65536;
#[doc = " Does \\e not handle clipping paths or clipping text.\nNot needed if paths are not handled."]
pub const AIStyleFilterPreferredInputArtType_kNoClipMasksInputArt:
    AIStyleFilterPreferredInputArtType = 131072;
#[doc = " The kinds of objects in input art that an effect can operate on.\nIf input art contains objects the effect does not handle, Illustrator looks for a\nconversion filter to convert the input art to a type that is handled. If no\nsuch filter is available, the input art is passed unchanged. The effect should\npass through unchanged any art that it cannot handle,"]
pub type AIStyleFilterPreferredInputArtType = ::std::os::raw::c_uint;
#[doc = " Append this effect to the current style."]
pub const AILiveEffectMergeAction_kAppendLiveEffectToStyle: AILiveEffectMergeAction = 0;
#[doc = " Replace the current fill style with this effect."]
pub const AILiveEffectMergeAction_kReplaceFillWithLiveEffect: AILiveEffectMergeAction = 1;
#[doc = " Replace the current stroke style with this effect."]
pub const AILiveEffectMergeAction_kReplaceStrokeWithLiveEffect: AILiveEffectMergeAction = 2;
#[doc = " Bit flag can be ORed with replacement styles to send\na \\c #kSelectorAILiveEffectHandleMerge message to handle\nthe parameters of the merge. Not used with \\c #kAppendLiveEffectToStyle"]
pub const AILiveEffectMergeAction_kSendHandleMergeMessage: AILiveEffectMergeAction = 65536;
#[doc = " Ways that a Live Effect can be merged with the existing styles of selected objects."]
pub type AILiveEffectMergeAction = ::std::os::raw::c_uint;
#[doc = " Information supplied when registering a Live Effect\nwith \\c #AILiveEffectSuite::AddLiveEffect()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectData {
    #[doc = " The plug-in that is registering the effect and that\nreceives effect messages."]
    pub self_: SPPluginRef,
    #[doc = " A unique identifying name of the effect, not localized."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A localized display title for the effect."]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = " Major version number of this plug-in."]
    pub majorVersion: ai_int32,
    #[doc = " Minor version number of this plug-in."]
    pub minorVersion: ai_int32,
    #[doc = " The type of art this effect can operation on,\na \\c #AIStyleFilterPreferredInputArtType value."]
    pub prefersAsInput: ai_int32,
    #[doc = " The type and supported features of this effect,\na logical OR of \\c #AIStyleFilterFlags."]
    pub styleFilterFlags: ai_int32,
}
#[doc = " Information supplied when registering a Live Effect for Parallel Execution\nwith \\c #AILiveEffectSuite::AddLiveEffect()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectParallelExecutionData {
    #[doc = " The supported art for this effect for parallel execution,\na logical OR of \\c #AIParallelExecutionArtFlags."]
    pub parallelExecutionArtFlags: ai_int32,
}
#[doc = " Sent when the user chooses your registered effect from the Effects menu,\nafter the Edit parameters message that allows you to collect parameter\nvalues from the user. Also sent when the effect needs to be run in response\nto user edits to the objects.\nThe plug-in should respond by running its effect on the supplied art object\nusing the supplied parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectGoMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The current parameters block, as returned from the Edit parameters message."]
    pub parameters: AILiveEffectParameters,
    #[doc = " [in, out] A set of parameters that the plug-in may have stored\nfrom an earlier invocation on this object."]
    pub instanceInfo: AILiveEffectParameters,
    #[doc = " [in, out] The art object to be edited with this effect.\nYou must not modify any ancestor objects, nor modify the document artwork tree.\nThe plug-in is responsible for proper deletion of objects in source\nart that it removes. You can set this to \\c NULL if the effect\ndoes not return any art; in this case, Illustrator disposes of\nthe input art."]
    pub art: AIArtHandle,
    #[doc = " [in] This is source art on which effect is applied\nThis if for storing any information which needs to be used later after executing the effect"]
    pub srcArt: AIArtHandle,
}
#[doc = " Sent when the user chooses a your registered effect from the Effects menu,\nor when the user later edits the effect using the appearance palette.\n\nThe plug-in can ignore the selector if it does not require user input;\notherwise, it should collect parameter values from the user,\ntypically using a modal dialog. If previews are enabled, it can then\nupdate the artwork using \\c #AILiveEffectSuite::UpdateParameters()\nto preview the results.\nThe plug-in must call \\c #AILiveEffectSuite::UpdateParameters() after\nit finishes collecting user input and updating values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectEditParamMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " [in, out] A set of parameters that the plug-in may have stored\nfrom an earlier invocation. Modify values if desired."]
    pub parameters: AILiveEffectParameters,
    #[doc = " The parameter context, passed to various functions."]
    pub context: AILiveEffectParamContext,
    #[doc = " True if preview is enabled. If it is, the plug-in can call\n\\c #AILiveEffectSuite::UpdateParameters after modifying the parameters,\nto update the associated artwork. The plug-in receives a Go message\nafter updating parameters."]
    pub allowPreview: AIBoolean,
    #[doc = " True if this is the first time this effect is being applied by this plug-in,\nfalse if the effect is being modified (from the Appearance panel, for example)."]
    pub isNewInstance: AIBoolean,
}
#[doc = " Sent when the user chooses to interpolate a new point into the parameter\nset for an effect. This happens when Illustrator attempts to blend two objects\nthat have Live Effects applied to them; for example, if you select two objects\nwith an effect and choose Object>Blend>Make. The intermediate objects between\nthe two blended objects need to have effects applied to them as well, which\nneed to have values that are the interpolated results between the two blended objects.\n\nPass the parameter blocks to \\c #AILiveEffectSuite::InterpolateEffectParameters()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectInterpParamMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " A parameter block indicating a starting point."]
    pub startParams: AILiveEffectParameters,
    #[doc = " A parameter block indicating an ending point."]
    pub endParams: AILiveEffectParameters,
    #[doc = " [out] A parameter block to contain the interpolated point."]
    pub outParams: AILiveEffectParameters,
    #[doc = " A percentage of the distance between \\c startParams\nand \\c endParams, expressed as a value in the range [0..1].\nThe new value is interpolated at this point."]
    pub percent: AIReal,
}
#[doc = " Sent when  the user selects an effect whose input type is\n\\c #kInputArtDynamic. If the type computation depends on input art,\nthe plug-in can examine the passed art object to decide on the type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectInputTypeMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The current parameter block for the effect."]
    pub parameters: AILiveEffectParameters,
    #[doc = " The art object whose type is to be computed."]
    pub inputArt: AIArtHandle,
    #[doc = " [out] The type of art that can be operated on by this effect\nwith this parameter set, an \\c #AIStyleFilterPreferredInputArtType value.\n\\li If the input art is a type that this effect can filter, set to \\c #kAnyInputArt.\n\\li Otherwise, set to the type to which the art should be converted."]
    pub typeMask: ai_int32,
}
#[doc = " Sent with a request to convert any private color data the plug-in\nhas stored in a dictionary to a new color space.\nThis is only for private color information. Normal fill and stroke color\ninformation is automatically converted."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectConvertColorMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The current parameter block for the effect."]
    pub parameters: AILiveEffectParameters,
    #[doc = " The new color space."]
    pub newColorSpace: AIColorTag,
}
#[doc = " Sent with \\c #kSelectorAILiveEffectAdjustColors to allow another plug-in that does\ncolor manipulations to extract and/or modify any private color data that the effect plug-in has\nstored in its parameter dictionary, including colors contained indirectly in art objects, art\nstyles or symbol references. This parameter block contains only private color information\nfor an effect. Normal fill and stroke colors (that is, those which are stored under\n\\c #kFillStyleKey or \\c #kStrokeStyleKey) are adjusted without consulting the effect.\n\nThe color-adjustment callback is supplied by a plug-in other than the one that manages the effect.\nThe initial request is generally initiated by \\c #AIPathStyleSuite::AdjustObjectAIColors(), and\nthe effect that receives this message has been encountered while processing that request.\n\n\n\\li If the parameter dictionary contains private \\c #AIColor values, they should be passed\ndirectly to the color-adjustment callback.\n\n\\li If the parameter dictionary contains art objects that contain meaningful colors, those objects\nshould be passed to \\c #AIPathStyleSuite::AdjustObjectAIColors(), along with this callback function,\nclient data, and control flags.\n\n\\li If the parameter dictionary contains symbol handles or brush pattern handles that contain meaningful\ncolors, the symbol patterns or brush patterns should be passed to the pattern-adjustment callback.\nThese could be, for example, symbols mapped to surfaces by the 3D effect.\nOther symbols can be ignored; for example, symbols that define 3D bevel shapes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectAdjustColorsMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The current parameter block for the effect."]
    pub parameters: AILiveEffectParameters,
    #[doc = " A callback function to adjust colors, supplied by a plug-in\nother than the one that manages the effect.\nSee \\c #AIPathStyleSuite::AdjustObjectAIColors()."]
    pub adjustColorCallback: AIAdjustColorFunc,
    #[doc = " A callback function to adjust patterns, supplied by a plug-in\nother than the one that manages the effect."]
    pub adjustPatternHandleCallback: AIAdjustPatternHandleFunc,
    #[doc = " Developer-defined private data to pass to the callback."]
    pub clientData: *mut ::std::os::raw::c_void,
    #[doc = " A logical OR of bit-flag constants that controls which colors are passed to the callback."]
    pub controlFlags: VisitAIColorFlags,
    #[doc = " [out] Set to true if the handler modified any colors."]
    pub modifiedSomething: AIBoolean,
}
#[doc = " Sent with a request to scale effect parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectScaleParamMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " [in, out] The current parameters for the effect.\nModify values in place."]
    pub parameters: AILiveEffectParameters,
    #[doc = " The factor by which to scale the parameters.\nA percentage value where 1 is 100%."]
    pub scaleFactor: AIReal,
    #[doc = " [out] Set to true to indicate that the effect modified the parameters."]
    pub scaledParams: AIBoolean,
}
#[doc = " Sent to a plug-in that has initiated a merge with\n\\c #AILiveEffectSuite::MergeLiveEffectIntoSelection(),\nso that the plug-in can handle the merge operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectHandleMergeMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The effect object currently in use, if any.\n\\c NULL if replacing a default fill or stroke with an effect."]
    pub oldEffect: AILiveEffectHandle,
    #[doc = " [out] Set to true to prevent the merge."]
    pub dontMerge: AIBoolean,
    #[doc = " [out] Set to true to preserve instance information from the existing\neffect, if any."]
    pub keepInstanceInfo: AIBoolean,
    #[doc = " [in, out] The parameter block for the existing effect, if any. Modify in place.\nIf \\c NULL, the Edit message is sent to collect parameters."]
    pub parameters: AILiveEffectParameters,
}
#[doc = " Sent with a request to obtain an SVG filter representation of an effect.\nSent only if the effect plug-in has indicated that it can generate an SVG filter\nto represent itself.\n\n- In: 'effect' handle returned when the effect was registered.\n- In: 'parameters' handle to live effect parameter set to be used.\n- Out: 'svgFilterUID' return a handle to the UID representing the SVG filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectGetSVGFilterMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " The current parameter block for the effect."]
    pub parameters: AILiveEffectParameters,
    #[doc = " [out] Set to the SVG filter object."]
    pub svgFilter: AISVGFilterHandle,
}
#[doc = "\tSent when saving a file to allow the live effect to make a detailed check for\nlegacy compatibility. This message is only sent if the \\c #kHandlesIsCompatibleMsg\nflag is set. If the flag is not set version compatibility is checked against\nvalues provided by SetLiveEffectAppVersion. The recipient must set the\n'compatible' member below indicate version compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectIsCompatibleMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The effect object."]
    pub effect: AILiveEffectHandle,
    #[doc = " Application version to check compatibility against."]
    pub appVersion: AIVersion,
    #[doc = " The current parameter block for the effect."]
    pub parameters: ConstAILiveEffectParameters,
    #[doc = " [out] Set to true if compatible with appVersion, false otherwise."]
    pub compatible: AIBoolean,
}
#[doc = "\t@ingroup Suites\nThis suite allows your plug-in to implement a Live Effect.\nA Live Effect is a filter that can be attached to an art object as part of\nits style. Any time the art object is changed, the filter is automatically\nre-executed. More than one filter can be attached to an object, which allows\nfilter \\e chains and \\e stacks.\n\\li A chain is a pipeline where the output of one filter\nbecomes the input to the next.\n\\li A stack passes the same input art to a set of filters,\nstacking the output of each filter.\n\nIf a document contains a Live Effect that is not available, the document\ncan be opened, but art with that effect applied cannot be edited.\n\nYour Live Effect plug-in must respond to the caller \\c #kCallerAILiveEffect\nand the following selectors:\n<br> \\c #kSelectorAIEditLiveEffectParameters\n<br> \\c #kSelectorAIGoLiveEffect\n<br> \\c #kSelectorAILiveEffectInterpolate\n<br> \\c #kSelectorAILiveEffectInputType\n<br> \\c #kSelectorAILiveEffectConverColorSpace\n<br> \\c #kSelectorAILiveEffectScaleParameters\n<br> \\c #kSelectorAILiveEffectHandleMerge\n<br> \\c #kSelectorAILiveEffectGetSVGFilter\n\nMost Live Effects have a set of parameters that control their behavior. For\nexample, the Roughen effect has parameters for the size and detail of the roughening.\nYou can store these in the parameter dictionary that is associated with the effect\nin the style.  Use the \\c #AIDictionarySuite to access the contents of the dictionary.\nYou can store any information in the parameter dictionary; however the following keys\nare predefined:\n<br> \\c #kDisplayStringKey\n<br> \\c #kExtraStringKey\n<br> \\c #kFillStyleKey\n<br> \\c #kEvenOddKey\n<br> \\c #kStrokeStyleKey\n<br> \\c #kScaleFactorKey\n<br> \\c #kAILiveEffectParamsExpandBeforeKey\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAILiveEffectSuite and \\c #kAILiveEffectVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILiveEffectSuite {
    #[doc = " Registers a Live Effect.\n@param effectInfo A pointer to the structure that defines the effect. You must\nallocate and fill the structure before making the call.\n@param liveEffectHandle [out] A buffer in which to return the effect object."]
    pub AddLiveEffect: ::std::option::Option<
        unsafe extern "C" fn(
            effectInfo: *mut AILiveEffectData,
            liveEffectHandle: *mut AILiveEffectHandle,
        ) -> AIErr,
    >,
    #[doc = " Adds a menu item for a Live Effect to the Effects menu, using a predefined filter.\n@param liveEffectHandle The effect object.\n@param filterHandle\tThe filter containing the category, title, and options,\nas returned by \\c #AIFilterSuite::AddFilter(). If no filter exists with\nthe correct data, use \\c #AddLiveEffectMenuItem().\n@param menuItem\t[out] A buffer in which to return the new menu item,\nor \\c NULL if you do not need the object.\n@param menuGroup [out] A buffer in which to return the menu group to which the item\nwas added, or \\c NULL if you do not need the object."]
    pub AddLiveEffectFilterItem: ::std::option::Option<
        unsafe extern "C" fn(
            liveEffectHandle: AILiveEffectHandle,
            filterHandle: AIFilterHandle,
            menuItem: *mut AIMenuItemHandle,
            menuGroup: *mut AIMenuGroup,
        ) -> AIErr,
    >,
    #[doc = " Adds a menu item for a Live Effect to the Effects menu.\n@param liveEffectHandle The effect object.\n@param menuName\tThe unique identifying name for the new menu item.\nNot localized.\n@param menuData\tA pointer to the structure that defines the menu.\nYou must allocate and fill the structure before making the call.\nIf a filter already exists with the correct data, use\n\\c #AddLiveEffectFilterItem().\n@param menuItem\t[out] A buffer in which to return the new menu item,\nor \\c NULL if you do not need the object.\n@param menuGroup [out] A buffer in which to return the menu group to which the item\nwas added, or \\c NULL if you do not need the object. Returns \\c NULL if\nthe item was added at the top level of the Effects menu."]
    pub AddLiveEffectMenuItem: ::std::option::Option<
        unsafe extern "C" fn(
            liveEffectHandle: AILiveEffectHandle,
            menuName: *const ::std::os::raw::c_char,
            menuData: *mut AddLiveEffectMenuData,
            menuItem: *mut AIMenuItemHandle,
            menuGroup: *mut AIMenuGroup,
        ) -> AIErr,
    >,
    #[doc = " Not implemented."]
    pub ExecuteLiveEffect: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            parameters: AILiveEffectParameters,
            art: AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " @note Internal. Do not use.\n\nDisplays a dialog box in which the use can enter parameter values.\n@param context [in, out] The parameter context passed in the\n\\c #AILiveEffectEditParamMessage. Modify in place with new values.\n@param enablePreview  True if previews are enabled for this effect.\nWhen true, pass the returned context to \\c #UpdateParameters()\nto update the associated artwork."]
    pub EditParameters: ::std::option::Option<
        unsafe extern "C" fn(context: AILiveEffectParamContext, enablePreview: AIBoolean) -> AIErr,
    >,
    #[doc = " If previews are enabled for an effect, call this after modifying the\nparameters to update the associated artwork. The plug-in receives\nan \\c #AILiveEffectGoMessage after updating parameters.\n@param context The parameter context, as received in\na \\c #AILiveEffectEditParamMessage.\n@see \\c #AILiveEffectInterpParamMessage"]
    pub UpdateParameters:
        ::std::option::Option<unsafe extern "C" fn(context: AILiveEffectParamContext) -> AIErr>,
    #[doc = " Interpolates a point into the current parameter set for an effect.\nSends the plug-in that owns the effect the \\c #AILiveEffectInterpParamMessage.\n@param effect The effect object.\n@param startParams A parameters block for the starting point.\n@param endParams A parameters block for the ending point.\n@param percent A percentage of the distance between\nthe start and end parameters, expressed as a value in the range [0..1].\nThe new value is interpolated at this point.\n@param resultParams\t[out] A parameters block in which the new interpolated point\nis returned."]
    pub InterpolateEffectParameters: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            startParams: AILiveEffectParameters,
            endParams: AILiveEffectParameters,
            percent: AIReal,
            resultParams: AILiveEffectParameters,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of registered effects available to the application.\nUse with \\c #GetNthLiveEffect() to iterate through all installed effects.\n@param count [out] A buffer in which to return the number of registered effects."]
    pub CountLiveEffects:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves an effect reference by position index.\nUse with \\c #CountLiveEffects() to iterate through all installed effects.\n@param n The index, in the range <code>[0..numEffects-1]</code>.\n@param effect [out] A buffer in which to return the effect object."]
    pub GetNthLiveEffect: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, effect: *mut AILiveEffectHandle) -> AIErr,
    >,
    #[doc = " Retrieves the unique identifying name of an effect.\nTo get the localizable display name, use \\c #GetLiveEffectTitle().\n@param effect The effect object.\n@param name [out] A buffer in which to return the name string."]
    pub GetLiveEffectName: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            name: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the localizable display name of an effect.\nTo get the unique identifying name, use \\c #GetLiveEffectName().\n@param effect The effect object.\n@param name [out] A buffer in which to return the display name string."]
    pub GetLiveEffectTitle: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            name: *mut *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the version information for a registered effect.\n@param effect The effect object.\n@param major [out] A buffer in which to return the major version number.\n@param minor [out] A buffer in which to return the minor version number."]
    pub GetLiveEffectVersion: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            major: *mut ai_int32,
            minor: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the preferred input art types of a registered effect.\n@param effect The effect object.\n@param name [out] A buffer in which to return the input art preferences,\na logical OR of \\c #AIStyleFilterPreferredInputArtType values."]
    pub GetInputPreference: ::std::option::Option<
        unsafe extern "C" fn(effect: AILiveEffectHandle, inputPreference: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the style flags of a registered effect.\n@param effect The effect object.\n@param name [out] A buffer in which to return the style flags,\na logical OR of \\c #AIStyleFilterFlags values."]
    pub GetStyleFilterFlags: ::std::option::Option<
        unsafe extern "C" fn(effect: AILiveEffectHandle, styleFilterFlags: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Merges an effect into the existing style of all selected objects.\n@param effect The effect object.\n@param action The merge method (append, or replace fill and/or stroke),\nand whether to send a \\c #kSelectorAILiveEffectHandleMerge message\nto handle the parameters for a replacement method."]
    pub MergeLiveEffectIntoSelection: ::std::option::Option<
        unsafe extern "C" fn(effect: AILiveEffectHandle, action: AILiveEffectMergeAction) -> AIErr,
    >,
    #[doc = " Creates a new art style by merging live effect into an existing art style.\n@param artStyle The input art style.\n@param effect The effect object.\n@param params The Live Effect parameters.\n@param action The merge method (append, or replace fill and/or stroke),\nand whether to send a \\c #kSelectorAILiveEffectHandleMerge message\nto handle the parameters for a replacement method.\n@param newArtStyle [out] A buffer in which to return the new art style reference."]
    pub NewArtStyleByMergingLiveEffect: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            effect: AILiveEffectHandle,
            params: AILiveEffectParameters,
            action: AILiveEffectMergeAction,
            newArtStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " While handling an \\c #AILiveEffectEditParamMessage, retrieves the menu item used\nto invoke the effect.\n(Note that this function returns an object value, not an error code.)\n@param context The parameter context, as passed in the\n\\c #AILiveEffectEditParamMessage.\n@return The menu item object, or \\c NULL if the message was not invoked by a menu item.\nReturns \\c NULL if not called while handling an Edit message."]
    pub GetMenuItem: ::std::option::Option<
        unsafe extern "C" fn(context: AILiveEffectParamContext) -> AIMenuItemHandle,
    >,
    #[doc = " Creates a parameter dictionary to be used in constructing a style with the\n\\c #AIArtStyleParserSuite. Do not use in any other context.\tIf you are using\nthe \\c #AIArtStyleParserSuite to construct a new style from scratch, and you\nneed to create a parameter dictionary for an effect, use this function\nto create the parameter dictionary, rather than\n\\c #AIDictionarySuite::CreateDictionary(). The dictionary created by this\nfunction supports Undo operations, which the generic one does not.\n\nDictionaries are reference counted; the initial reference count for\nthis dictionary is 1. When there are no remaining references,\nfree the associated memory using \\c #AIDictionarySuite::Release().\n@param params [out] A buffer in which to return the new parameters block."]
    pub CreateLiveEffectParameters:
        ::std::option::Option<unsafe extern "C" fn(params: *mut AILiveEffectParameters) -> AIErr>,
    #[doc = " Retrieves the earliest Illustrator version that an effect supports.\nIf you do not use this call, the version defaults to 9 (the first version\nto support Live Effects). If an object with this effect is saved\nto an earlier version, only the styled art is written out. For some effects,\nthe earliest version supported for RGB or for CMYK can be different.\n@param effect The effect object.\n@param appVersionRGB [out] A buffer in which to return the earliest version number\nthat the effect supports for RGB documents. May be \\c NULL.\n@param appVersionCMYK [out] A buffer in which to return the earliest version number\nthat the effect supports for CMYK documents. May be \\c NULL."]
    pub GetLiveEffectAppVersion: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            appVersionRGB: *mut AIVersion,
            appVersionCMYK: *mut AIVersion,
        ) -> AIErr,
    >,
    #[doc = " Sets the earliest Illustrator version that an effect supports. If an object with this\neffect is saved to an earlier version, only the styled art is written out.\nFor some effects, the earliest version supported for RGB or for CMYK\ncan be different. See also \\c #kAILiveEffectParamsExpandBeforeKey for situations where\nthe compatibility decision is dependent upon the effect options.\n@param effect The effect object.\n@param appVersionRGB The earliest version number that the effect supports\nfor RGB documents. Must be 9 or later.\n@param appVersionCMYK The earliest version number that the effect supports\nfor CMYK documents. Must be 9 or later."]
    pub SetLiveEffectAppVersion: ::std::option::Option<
        unsafe extern "C" fn(
            effect: AILiveEffectHandle,
            appVersionRGB: AIVersion,
            appVersionCMYK: AIVersion,
        ) -> AIErr,
    >,
    pub GetLiveEffectHandleByName: ::std::option::Option<
        unsafe extern "C" fn(
            liveEffectName: *const ::std::os::raw::c_char,
            outLiveEffect: *mut AILiveEffectHandle,
        ) -> AIErr,
    >,
    #[doc = " Add data for Parallel Execution.\n@param liveEffectHandle The effect object.\n@param parallelExecutionData Data to customize parallel execution behavior."]
    pub SetLiveEffectParallelExecutionData: ::std::option::Option<
        unsafe extern "C" fn(
            liveEffectHandle: AILiveEffectHandle,
            parallelExecutionData: *const AILiveEffectParallelExecutionData,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AISwatchOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a swatch. See \\c #AISwatchListSuite."]
pub type AISwatchRef = *mut _AISwatchOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AISwatchListOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a swatch list. See \\c #AISwatchListSuite."]
pub type AISwatchListRef = *mut _AISwatchListOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AISwatchGroupOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a swatch group.See \\c #AISwatchGroupSuite."]
pub type AISwatchGroupRef = *mut _AISwatchGroupOpaque;
#[doc = " The group can contain any kind of swatches, and usually has a null name.\nThe first swatch group (index 0) must be of this kind."]
pub const AISwatchGroupKind_kAISGKindGeneric: AISwatchGroupKind = 0;
#[doc = " The group cannot contain patterns or gradients, but can contain\ntints of global colors. Is usually named."]
pub const AISwatchGroupKind_kAISGKindSolidColorsOnly: AISwatchGroupKind = 1;
#[doc = " The group is only allowed to contain pattern swatches. Is usually named."]
pub const AISwatchGroupKind_kAISGKindPatternsOnly: AISwatchGroupKind = 2;
#[doc = " The group is only allowed to contain gradient swatches. Is usually named."]
pub const AISwatchGroupKind_kAISGKindGradientsOnly: AISwatchGroupKind = 3;
#[doc = " Restrictions on the kinds of swatches allowed in a swatch groups.\nSee \\c #AISwatchGroupSuite::NewSwatchGroup(),\n\\c #AISwatchGroupSuite::GetSwatchGroupKind()."]
pub type AISwatchGroupKind = ::std::os::raw::c_uint;
pub const AIRequiredSwatchTypes_kAISolidsOnly: AIRequiredSwatchTypes = 1;
pub const AIRequiredSwatchTypes_kAIPatternsOnly: AIRequiredSwatchTypes = 2;
pub const AIRequiredSwatchTypes_kAIGradientsOnly: AIRequiredSwatchTypes = 4;
pub type AIRequiredSwatchTypes = ai_uint16;
#[doc = " @ingroup Suites\nThis suite provides functions that allow you to access and modify \\e swatches and\n\\e swatch \\e lists.\tEach Illustrator document has an associated swatch list\nwhich contains the document�s color swatches as shown in the Swatches palette.\n\nYou can use \\c #GetSwatchList() or functions from the \\c #AISwatchLibrariesSuite\nto obtain a swatch list reference. Typically, however, you need  only\nthe current document's swatch list, so for convenience all functions that take an\n\\c #AISwatchListRef accept \\c NULL to indicate the current document's\nswatch list.\n\nThe elements in a swatch list are of type \\c #AISwatchRef. A swatch is\nan \\c #AIColor and an associated name. For \\c #AIColor types that are themselves\ndefined by a named object (custom colors, patterns and gradients) the swatch name\nis always the same as the name of the object. For other types of \\c #AIColor,\nthe swatch name is independent.\n\nSwatch lists are hierarchically organized into \\e swatch \\e groups,\nwhich can be named; see the \\c #AISwatchGroupSuite.  In \\c #InsertNthSwatch(), an\nindex of -1 inserts at the end of the general swatches group (group 0).\nAccessor functions in this suite treat groups as if they were flattened,\nso that an index of 0 is the first swatch in the first group, and index numbers\nsimply continue into the next group. An exception is the deprecated \\c #GetNextSwatch(),\nwhich works only within a group. Use \\c #GetNthSwatch() instead for iteration.\n\nThere are three notifiers associated with swatch lists:\n<br> \\c #kAISwatchListChangedNotifier\n<br> \\c #kAISwatchListChangedInternallyNotifier\n<br> \\c #kAISwatchReplaceColorNotifier\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAISwatchListSuite and \\c #kAISwatchListVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AISwatchListSuite {
    #[doc = " Gets the total number of swatches in a swatch list, including those in all groups.\n(Note that this function returns a numeric value, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@return The number of swatches in the list."]
    pub CountSwatches:
        ::std::option::Option<unsafe extern "C" fn(list: AISwatchListRef) -> ai_int32>,
    #[doc = " Retrieves the first swatch in a swatch list.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@return The swatch reference.\n@see \\c #GetNextSwatch()"]
    pub GetFirstSwatch:
        ::std::option::Option<unsafe extern "C" fn(list: AISwatchListRef) -> AISwatchRef>,
    #[doc = " @deprecated Retrieves the next swatch in a swatch group within a swatch list. Use\nto find the swatch following one for which you do not have an index (retrieved,\nfor example, with \\c #AISwatchListSuite::GetSwatchByNameAndType()). Do not use for iteration.\n(Note that this function returns an object, not an error code.)\n@note It is recommended that you use \\c #CountSwatches() and \\c #GetNthSwatch()\nfor iteration. This function cannot be used to iterate through a list\nthat contains multiple groups, and is inefficient for iteration even\nwithin a group. .\n@param prev The previous swatch in the list.\n@return The swatch reference, or \\c NULL if the previous swatch is the last in the group.\n@see \\c #AISwatchGroupSuite::LocateSwatch() to find a swatch with an unknown index."]
    pub GetNextSwatch:
        ::std::option::Option<unsafe extern "C" fn(prev: AISwatchRef) -> AISwatchRef>,
    #[doc = " Retrieves a swatch from a swatch list by position index. Use with \\c #CountSwatches()\nto iterate through swatches. This is more efficient than \\c #GetNextSwatch()\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param index The 0-based position index in the list, disregarding groups.\n@return The swatch reference."]
    pub GetNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, index: ai_int32) -> AISwatchRef,
    >,
    #[doc = " Retrieves a swatch by name from a swatch list.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param name The swatch name.\n@return The swatch reference, or a \\c NULL swatch reference if no such swatch name is found."]
    pub GetSwatchByName: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, name: *const ai_UnicodeString) -> AISwatchRef,
    >,
    #[doc = " Creates a new swatch and inserts it into a swatch list.\nUse \\c #SetSwatchName() and \\c #SetAIColor() to set the name and\ncolor of the swatch after it has been inserted.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param index The 0-based position index for the insertion point, disregarding groups.\n\\li If this is the first position of a named group in the list, the swatch\nis inserted into the preceding group. Use \\c #AISwatchGroupSuite\nto control the group placement explicitly.\n\\li A value of -1 appends the new swatch at the end of the general\nswatches group (group 0).\n\nThe positions of the swatch previously at this index, and of\nall succeeding swatches, are incremented.\n@return The swatch reference for the new swatch."]
    pub InsertNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, index: ai_int32) -> AISwatchRef,
    >,
    #[doc = " Removes a swatch specified by index position from a swatch list. If the swatch is\na custom color swatch and it contains the last reference to that global color\nin the swatch list, then the custom color is also deleted from the document and\nany usages replaced by the equivalent process color.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param index The 0-based position index of the swatch, disregarding groups.\nThe positions of all succeeding swatches, are decremented.\n@return\\c #kCantDeleteSwatchErr if the index is out of range."]
    pub RemoveNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, index: ai_int32) -> ASErr,
    >,
    #[doc = " Retrieves the color definition of a swatch.\n@param swatch The swatch reference.\n@param aicolor [out] A buffer in which to return the color definition.\nCan be any color type supported by Illustrator."]
    pub GetAIColor: ::std::option::Option<
        unsafe extern "C" fn(swatch: AISwatchRef, aicolor: *mut AIColor) -> ASErr,
    >,
    #[doc = " Sets the color definition for a swatch.\n@param swatch The swatch reference.\n@param aicolor The new color definition. Can be any color type supported by Illustrator,\nif the type is allowed in the containing swatch group.\n@return The error \\c #kInvalidSwatchTypeForDest if the color type is not\nallowed in the containing swatch group."]
    pub SetAIColor: ::std::option::Option<
        unsafe extern "C" fn(swatch: AISwatchRef, aicolor: *mut AIColor) -> ASErr,
    >,
    #[doc = " Retrieves the name of a swatch.\n@param swatch The swatch reference.\n@param name [out] A buffer in which to return the name string."]
    pub GetSwatchName: ::std::option::Option<
        unsafe extern "C" fn(swatch: AISwatchRef, name: *mut ai_UnicodeString) -> ASErr,
    >,
    #[doc = " Sets the name of a swatch. If the swatch identifies a custom color, pattern, or gradient,\nalso changes the name of the underlying object.\n@param swatch The swatch reference.\n@param name The new name string.Limit is 31 chars, more than 31 chars will be removed"]
    pub SetSwatchName: ::std::option::Option<
        unsafe extern "C" fn(swatch: AISwatchRef, name: *const ai_UnicodeString) -> ASErr,
    >,
    #[doc = " Retrieves the swatch list for a document.\n@param document The document, or \\c NULL for the current document.\nUse the \\c #AIDocumentListSuite or \\c #AIPathStyleSuite::ImportStyles()\nto obtain a document handle.\n@param list [out] A buffer in which to return the swatch list."]
    pub GetSwatchList: ::std::option::Option<
        unsafe extern "C" fn(document: AIDocumentHandle, list: *mut AISwatchListRef) -> ASErr,
    >,
    #[doc = " Retrieves the first swatch in a list that uses a specified color. For patterns and gradients,\nchecks only that the gradient or pattern objects match, does not check that\nother parameters such as the gradient matrix also match. For all other types,\nchecks all color fields.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param aicolor The color to match.\n@return The matching swatch reference."]
    pub GetSwatchByColor: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, aicolor: *const AIColor) -> AISwatchRef,
    >,
    #[doc = " Retrieves the first swatch in a list with a given name and color type.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param name The color name to match.\n@param type The color type to match.\n@return The matching swatch reference."]
    pub GetSwatchByNameAndType: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            name: *const ai_UnicodeString,
            type_: AIColorTag,
        ) -> AISwatchRef,
    >,
    #[doc = " Removes a specific swatch from a swatch list. This is relatively inefficient, because it must search\nthe entire swatch list for the swatch. If you know the swatch group and index,\nand if it is not a custom color or you want to remove custom colors, then\n\\c #AISwatchGroupSuite::RemoveNthSwatch() is more efficient.\n\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param swatch The swatch reference.\n@param deleteCustomColor When true, and the swatch references a custom color,\nalso deletes the custom color. In this case, objects that use the color are\nconverted to process colors."]
    pub RemoveSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            swatch: AISwatchRef,
            deleteCustomColor: ASBoolean,
        ) -> ASErr,
    >,
}
#[doc = " @ingroup Suites\nSwatch lists are hierarchically organized into \\e swatch \\e groups,\nwhich can be named.\tThis suite provides functions to create, access, and manipulate\nthe groups, and explicitly control the group placement of swatches within the list.\nSwatch groups were introduced in Illustrator 13.\n\nThe first group, called the general swatch group, is typically unnamed and can contain\nany type of swatch. The first swatch group can be named, but cannot be removed or reordered.\nSwatches that are not assigned to a specific group are considered part of the\ngeneral swatch group. If no groups have been defined, all swatches are\nin this group, whose index is 0.\n\nOther groups are explicitly created and named, and can restrict the types of\nswatches that belong to them. The first such group is at index 1.\n\n@see \\c #AISwatchListSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAISwatchGroupSuite and \\c #kAISwatchGroupVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AISwatchGroupSuite {
    #[doc = " Reports the number of swatch groups in a swatch list. There is always at\nleast one, the unnamed general swatch group.\n(Note that this function returns an integer value, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@return The number of swatch groups."]
    pub CountSwatchGroups:
        ::std::option::Option<unsafe extern "C" fn(list: AISwatchListRef) -> ai_int32>,
    #[doc = " Retrieves a swatch group from a swatch list.\n(Note that this function returns an object value, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param index The 0-based position index in the list of groups. The first named\ngroup, if any, is at index 1.\n@return The swatch group reference."]
    pub GetNthSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(list: AISwatchListRef, index: ai_int32) -> AISwatchGroupRef,
    >,
    #[doc = " Retrieves a swatch group by name from a swatch list.  Group names need not\nbe unique with a list; if there is more than one matching group, the first one\nis returned.\n(Note that this function returns an object, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param name The swatch group name.\n@return The swatch group reference, or a \\c NULL swatch reference if no such group name is found."]
    pub GetSwatchGroupByName: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            name: *const ai_UnicodeString,
        ) -> AISwatchGroupRef,
    >,
    #[doc = " Creates a new swatch group in a swatch list. The new group is initially unnamed and\ncontains no swatches. Use \\c #SetSwatchGroupName() to assign a name, and \\c #InsertNthSwatch()\nor \\c #ReorderSwatchBetweenGroups() to add members.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param groupKind The types of swatches that are allowed in the group.\n@param atIndex The group position index at which to insert the group, or -1 to append\nit to the current groups.\n@param swatchGroup [out] A buffer in which to return the new swatch group object.\n@return \\c #kBadParameterErr if index is 0.\n<br> \\c #kTooManySwatchGroupsErr if there are already\n\\c #kMaxNumberSwatchGroups in the swatch list."]
    pub NewSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            groupKind: AISwatchGroupKind,
            atIndex: ai_int32,
            newGroup: *mut AISwatchGroupRef,
        ) -> ASErr,
    >,
    #[doc = " Reports whether a swatch group is in a swatch list.\n(Note that this function returns a boolean value, not an error code.)\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param swatchGroup The swatch group object.\n@param indexFoundAt [out] A buffer in which to return the 0-based index\ninto the swatch list at which the group was found.\n@return True if the group is in the list."]
    pub SwatchGroupIsInList: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            swatchGroup: AISwatchGroupRef,
            indexFoundAt: *mut ai_int32,
        ) -> ASBoolean,
    >,
    #[doc = " Removes a swatch group from a swatch list by index position. You cannot remove\nthe general swatch group (index 0). The index positions of all later groups are decremented.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param index The 0-based index position of the swatch to remove.\n@param deleteSwatches  When false, moves the member swatches into the general group,\nunless a swatch with the same name and definition is already in that group.\nWhen true, deletes the member swatches along with the group.\nIf a member swatch is a custom color swatch and it contains the last reference\nto a global color in the swatch list, the custom color is not deleted from the document.\nUse \\c #AISwatchGroupSuite::RemoveSwatch() to delete the last reference to a spot color.\n@return #kCantDeleteSwatchErr if the index is 0 or greater than\nthe number of swatch groups, or if the swatch group contains an undeletable swatch."]
    pub RemoveNthSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            index: ai_int32,
            deleteSwatches: ASBoolean,
        ) -> ASErr,
    >,
    #[doc = " Removes a specific swatch group from a swatch list.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param swatchGroup The swatch group object.\n@param deleteSwatches  When false, moves the member swatches into the general group,\nunless a swatch with the same name and definition is already in that group.\nWhen true, deletes the member swatches along with the group.\nIf a member swatch is a custom color swatch and it contains the last reference\nto a global color in the swatch list, the custom color is not deleted from the document.\nUse \\c #AISwatchGroupSuite::RemoveSwatch() to delete the last reference to a spot color.\n@return \\c #kBadParameterErr if the swatch group is not in the list.\n@note This function must search the entire list. If you have the index position of the group,\n\\c #RemoveNthSwatchGroup () is more efficient."]
    pub RemoveSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            swatchGroup: AISwatchGroupRef,
            deleteSwatches: ASBoolean,
        ) -> ASErr,
    >,
    #[doc = " Changes the position of a swatch group specified by index within a swatch list.\nOther group index values change accordingly. You cannot move another group to position 0, or move the general\ngroup to any other position.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param fromIndex The current 0-based position index of the group to move.\n@param newIndex The new 0-based position index.\n@return \\c #kBadParameterErr if either index is 0, or is greater than the number of swatch groups.\n<br> If both index values are 0, returns \\c #kNoErr but does nothing."]
    pub ReorderNthSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            fromIndex: ai_int32,
            newIndex: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Changes the position of a swatch group specified by reference within a swatch list.\nOther group index values change accordingly. You cannot move another group to position 0, or move the general\ngroup to any other position.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param swatchGroup The swatch group object.\n@param newIndex The new 0-based position index.\n@return \\c #kBadParameterErr if the new index is 0, or is greater than the number of swatch groups.\nor if the group is not in the list, or is the general group.\n@note This function must search the entire list. If you have the index position of the group,\n\\c #ReorderNthSwatchGroup () is more efficient."]
    pub ReorderSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            swatchGroup: AISwatchGroupRef,
            newIndex: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the name of a swatch group.\n@param swatchGroup The swatch group object.\n@param name [out] A buffer in which to return the name string, or the empty\nstring if no name has been assigned."]
    pub GetSwatchGroupName: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, name: *mut ai_UnicodeString) -> ASErr,
    >,
    #[doc = " Sets the name of a swatch group. Group names need not be unique.\n@param swatchGroup The swatch group object.\n@param name The new name string."]
    pub SetSwatchGroupName: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, name: *const ai_UnicodeString) -> ASErr,
    >,
    #[doc = " Sets the kind of a swatch group.\n@param swatchGroup The swatch group object.\n@param name The new Kind."]
    pub SetSwatchGroupKind: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, groupKind: AISwatchGroupKind) -> ASErr,
    >,
    #[doc = " Reports what kind of swatches a group can contain. This is set on creation and\ncannot be modified.\n(Note that this function returns a constant value, not an error code.)\n@param swatchGroup The swatch group object.\n@return The allowed-swatch-type constant."]
    pub GetSwatchGroupKind: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef) -> AISwatchGroupKind,
    >,
    #[doc = " Reports whether a swatch group allows colors of a specific type.\n(Note that this function returns a boolean value, not an error code.)\n@param swatchGroup The swatch group object.\n@param colorKind The color type constant.\n@return True if the type is allowed."]
    pub AllowsColorKind: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, colorKind: AIColorTag) -> ASBoolean,
    >,
    #[doc = " Moves a swatch to a new position within a swatch group.\n@param swatchGroup The swatch group object.\n@param swatch The swatch object.\n@param toIndex The new 0-based index position, or -1 to move the swatch to the end of\nthe group. Other position index values change accordingly.\n@return \\c #kBadParameterErr if the index is greater than the number of swatches\nin the group, or if the swatch is not in the group."]
    pub ReorderSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            swatch: AISwatchRef,
            toIndex: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Moves a swatch to a new position within a swatch group.\n@param swatchGroup The swatch group object.\n@param fromIndex The current 0-based index position of the swatch.\n@param toIndex The new 0-based index position, or -1 to move the swatch to the end of\nthe group. Other position index values change accordingly.\n@return \\c #kBadParameterErr if either index is greater than the number of swatches\nin the group, or if the from index is less than 0."]
    pub ReorderNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            fromIndex: ai_int32,
            toIndex: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Reports the number of swatches in a swatch group.\n(Note that this function returns an integer value, not an error code.)\n@param swatchGroup The swatch group object.\n@return The number of swatches."]
    pub CountSwatches:
        ::std::option::Option<unsafe extern "C" fn(swatchGroup: AISwatchGroupRef) -> ai_int32>,
    #[doc = " Retrieves a swatch from a swatch group by position index.\n(Note that this function returns an object value, not an error code.)\n@param swatchGroup The swatch group object.\n@param index The 0-based position index.\n@return The swatch object, or a \\c NULL object if the index is invalid."]
    pub GetNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, index: ai_int32) -> AISwatchRef,
    >,
    #[doc = " Retrieves a swatch from a swatch group by name.\n(Note that this function returns an object value, not an error code.)\n@param swatchGroup The swatch group object.\n@param name The swatch name string.\n@return The swatch object, or a \\c NULL object if no matching swatch is found.\n"]
    pub GetSwatchByName: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            name: *const ai_UnicodeString,
        ) -> AISwatchRef,
    >,
    #[doc = " Retrieves the first swatch within a swatch group with a specified color. For patterns and\ngradients, checks that the gradient or pattern objects match, but does not check that\nthe other parameters such as the gradient matrix or pattern matrix also match. For all other types,\nchecks all fields for a match. In particular, spot color and global color swatches check the tint.\n(Note that this function returns an object value, not an error code.)\n@param swatchGroup The swatch group object.\n@param aicolor The color.\n@return The swatch object, or a \\c NULL object if no matching swatch is found."]
    pub GetSwatchByColor: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, aicolor: *const AIColor) -> AISwatchRef,
    >,
    #[doc = " Retrieves the first swatch within a swatch group with a given name and color type.\n(Note that this function returns an object value, not an error code.)\n@param swatchGroup The swatch group object.\n@param name The swatch name string.\n@param type The color type constant.\n@return The swatch object, or a \\c NULL object if no matching swatch is found."]
    pub GetSwatchByNameAndType: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            name: *const ai_UnicodeString,
            type_: AIColorTag,
        ) -> AISwatchRef,
    >,
    #[doc = " Creates a new swatch and inserts it into a swatch group.\n(Note that this function returns an object value, not an error code.)\n@param swatchGroup The swatch group object.\n@param aicolor The color for the new swatch.\n@param index The 0-based index position at which to insert the new swatch, or -1 to\nappend it to the end of the group. The swatch previously at this index\nand all swatches following it in the list are bumped down the list by one position.\n@return The new swatch object, or a \\c NULL object if the index is invalid, there is not\nenough memory, the swatch group already contains \\c #kMaxNumberSwatchesPerGroup,\nor the swatch type is not allowed for this group. See \\c #AISwatchGroupKind."]
    pub InsertNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            aicolor: *mut AIColor,
            index: ai_int32,
        ) -> AISwatchRef,
    >,
    #[doc = " Removes a swatch specified by index position from a swatch group.\n@param swatchGroup The swatch group object.\n@param index The 0-based index position of the swatch in the group. Other swatch\nposition index values are adjusted accordingly.\n@param deleteCustomColor When true, and the swatch is a custom color swatch and\ncontains the last reference to that custom color in the entire swatch list,\nthe custom color is also deleted from the document and any usages replaced by\nthe equivalent process color.\n<br> When false, deletes a custom color only if it is unused. Otherwise, moves\nit to the general group. If this is the general group, the swatch is in use, and\nthis is the only reference in the list,\tthe function returns \\c #kCantDeleteSwatchErr.\n@param swatchNotUsed When true, global colors are not replaced in the document and are forcefully\ndeleted. It should be used, if it is already been ensured that the color is not used anywhere.\n@return \\c #kBadParameterErr if the index is not within the swatch group.\n<br> \\c #kCantDeleteSwatchErr if the swatch cannot be deleted for any reason."]
    pub RemoveNthSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            index: ai_int32,
            deleteCustomColor: ASBoolean,
            swatchNotUsed: bool,
        ) -> ASErr,
    >,
    #[doc = " Removes a specific swatch from a group. Swatch position index values are adjusted accordingly.\n(If the index is known, \\c #RemoveNthSwatch() is more efficient.)\n@param swatchGroup The swatch group object.\n@param swatch The swatch object.\n@param deleteCustomColor When true, and the swatch is a custom color swatch and\ncontains the last reference to that custom color in the entire swatch list,\nthe custom color is also deleted from the document and any usages replaced by\nthe equivalent process color.\n<br> When false, deletes a custom color only if it is unused. Otherwise, moves\nit to the general group. If this is the general group, the swatch is in use, and\nthis is the only reference in the list,\tthe function returns \\c #kCantDeleteSwatchErr.\n@return \\c #kBadParameterErr if the swatch is not in the swatch group.\n<br> \\c #kCantDeleteSwatchErr if the swatch cannot be deleted for any reason."]
    pub RemoveSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            swatch: AISwatchRef,
            deleteCustomColor: ASBoolean,
        ) -> ASErr,
    >,
    #[doc = " Retrieves the group of a specific swatch in a swatch list.\nRequires an exact match with the swatch object; swatches for the same color and name\nare not considered equivalent.\n@param list The swatch list, or \\c NULL for the current document's swatch list.\n@param swatch The swatch object.\n@param containingSwatchGroup [out] A buffer in which to return the containing group object,\nor a \\c NULL object if the swatch is not in the list.\n@param groupIndex [out] Optional. A buffer in which to return the 0-based index position\nof this group within the list.\n@param swatchIndex [out] Optional. A buffer in which to return the 0-based index position\nof this swatch within the group."]
    pub LocateSwatch: ::std::option::Option<
        unsafe extern "C" fn(
            list: AISwatchListRef,
            swatch: AISwatchRef,
            containingSwatchGroup: *mut AISwatchGroupRef,
            groupIndex: *mut ai_int32,
            swatchIndex: *mut ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Moves a swatch from one group to another within the same list. Other index positions within\nboth groups are adjusted accordingly.\n@param fromGroup The group object that currently contains the swatch.\n@param fromIndex The 0-based index of the swatch in the current group.\n@param toGroup The destination group object.\n@param toIndex The 0-based index at which to insert the swatch in the destination group,\nor -1 to append it to the end of the group.\n@return \\c #kBadParameterErr if the source index is less than 0, or if either index is\ngreater than the number of swatches in its group, or if the two swatch groups are\nnot in the same swatch list.\n<br> \\c #kInvalidSwatchTypeForDest if the swatch is a type that\nis not allowed in the destination group."]
    pub ReorderSwatchBetweenGroups: ::std::option::Option<
        unsafe extern "C" fn(
            fromGroup: AISwatchGroupRef,
            fromIndex: ai_int32,
            toGroup: AISwatchGroupRef,
            toIndex: ai_int32,
        ) -> ASErr,
    >,
    #[doc = " Reports whether a swatch group is displayed in the open state (showing swatches)\nthe next time it is loaded into a palette that is in list view and shows color groups.\nThis status is saved on behalf of the Swatches palette, so that it can persist while the\ndocument is closed or inactive.\n\nThis preference does not guarantee that the swatches\nare visible, even if this swatch group is in the active document,\nbecause the Swatches palette might not show color groups, or might\nnot be in list view.\n(Note that this function returns a boolean value, not an error code.)\n@param swatchGroup The swatch group object.\n@return True if the swatch group should be open in list view."]
    pub WantsToBeOpenIfInListView:
        ::std::option::Option<unsafe extern "C" fn(swatchGroup: AISwatchGroupRef) -> ASBoolean>,
    #[doc = " Sets whether a swatch group is displayed in the open state (showing swatches)\nthe next time it is loaded into a palette that is in list view and shows color groups.\nThis status is saved on behalf of the Swatches palette, so that it can persist while the\ndocument is closed or inactive.\n\nIf a plug-in other than the Swatches palette changes this value,\nit does not, by itself, trigger an update to the Swatches palette.\nHowever, it the change is made at the same time as another change that does\ntrigger an update, such as adding a new swatch group or a new swatch,\nthe Swatches palette honors the setting when the swatch group\nis next displayed in list view.\n@param swatchGroup The swatch group object.\n@param whatItWants True to display the group in the open state, false to\ndisplay it in the closed state.\n@return \\c #kBadParameterErr if the no swatch group is supplied."]
    pub SetWantsToBeOpenIfInListView: ::std::option::Option<
        unsafe extern "C" fn(swatchGroup: AISwatchGroupRef, whatItWants: ASBoolean) -> ASErr,
    >,
    pub FilterSwatchGroup: ::std::option::Option<
        unsafe extern "C" fn(
            swatchGroup: AISwatchGroupRef,
            swatchType: ai_int32,
            filteredGroup: *mut std_vector,
        ) -> ASErr,
    >,
}
#[doc = " The new stroke width for a \\c #kAIPaintStyleSetStrokeWidthSelector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIStrokeWidthMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The stroke width in points."]
    pub newStrokeWidth: f32,
}
#[doc = " Data for \\c #kAIUpdatePathStyleNotifier"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIUpdatePathStyleNotifyData {
    #[doc = " Path style to update."]
    pub pathStyle: AIPathStyle,
    #[doc = " Path style map. The map indicates which fields of an \\c #AIPathStyle\nare specified by a partial style. A path style can contain unknown or mixed\nattributes, which are indicated by a value of false for that attribute in the map."]
    pub pathStyleMap: AIPathStyleMap,
}
#[doc = " Behavior options for Color Editor. See  \\c #AIPaintStyleSuite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorEditorOptions {
    #[doc = " When true, colors are converted to the document color space for\ndisplay in the color indicator. This gamut limits them to the\ndocument color space. Default is true."]
    pub showSampleInDocCs: AIBoolean,
    #[doc = " When true, Lab is allowed as a color model in the Color Editor.\nDefault is false."]
    pub allowLabColorModel: AIBoolean,
    #[doc = " When true, a square representing the current color is drawn to\nthe left of the color sliders. When false, the color indicator\nis hidden. Default is true."]
    pub showColorIndicator: AIBoolean,
    #[doc = " When true, the web-safe and gamut indicators are drawn to the right of the color sliders.\nWhen false, they are drawn to the left of the color sliders. Default is false."]
    pub warningIndicatorsOnRight: AIBoolean,
    #[doc = " When true, global objects are verified against the current document's swatch list\nbefore they are displayed. When false, they are assumed to be valid. Default is true.\n\n\\li A Color Editor installed in a palette should always set this to true, because colors can\nbecome invalid asynchronously with palette updates.\n\n\\li A Color Editor in a modal dialog may wish to set this to false,\nespecially if it allows modification of tints on \\c #AIColor values\nfrom swatch libraries that have not yet been targeted to the current document."]
    pub verifyColors: AIBoolean,
}
#[doc = " Behavior options for opening the Color Picker using\n\\c #AIPaintStyleSuite::DisplayColorPickerWithOptions()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorPickerOptions {
    #[doc = " The swatch list to display in the swatch-list view of\nthe Color Picker. When \\c NULL, the current document's\nswatch list is used.\n\nWhen the Color Picker is displayed, the  swatch-list view\nis shown if the initial color exactly matches the color\nfrom a swatch in this list."]
    pub swatchList: AISwatchListRef,
}
pub const AIColorEditorColorSpace_kAIColorEditorColorUnknown: AIColorEditorColorSpace = 0;
pub const AIColorEditorColorSpace_kAIColorEditorColorGray: AIColorEditorColorSpace = 1;
pub const AIColorEditorColorSpace_kAIColorEditorColorRGB: AIColorEditorColorSpace = 2;
pub const AIColorEditorColorSpace_kAIColorEditorColorCMYK: AIColorEditorColorSpace = 3;
pub const AIColorEditorColorSpace_kAIColorEditorColorLab: AIColorEditorColorSpace = 4;
#[doc = " Internal"]
pub const AIColorEditorColorSpace_kAIColorEditorColorDummy: AIColorEditorColorSpace = 4294967295;
#[doc = " Possible colorspaces for specifying colors for a Color Editor"]
pub type AIColorEditorColorSpace = ::std::os::raw::c_uint;
#[doc = " Color specification for the Color Editor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIColorEditorColor {
    #[doc = " The colorspace"]
    pub space: AIColorEditorColorSpace,
    #[doc = " The color values. Which array members have values, and what\nthey mean, depends on the colorspace."]
    pub values: [AIReal; 4usize],
    #[doc = " Each member of this array that is true corresponds to a\nmember of the \\c values array with a meaningful value."]
    pub defined: [AIBoolean; 4usize],
}
pub const AIColorEditorReadOnlyOption_kAIColorEditorReadOnlyDefault: AIColorEditorReadOnlyOption =
    0;
#[doc = " Color Editor read-only flag. See \\c #AIPaintStyleSuite::SetColorEditorReadOnly()."]
pub type AIColorEditorReadOnlyOption = ::std::os::raw::c_uint;
pub const AIStrokeAlignmentType_kAIStrokeAlignmentCenter: AIStrokeAlignmentType = 0;
pub const AIStrokeAlignmentType_kAIStrokeAlignmentInside: AIStrokeAlignmentType = 1;
pub const AIStrokeAlignmentType_kAIStrokeAlignmentOutside: AIStrokeAlignmentType = 2;
#[doc = " Possible values for stroke alignment. See  \\c #AIPaintStyleSuite."]
pub type AIStrokeAlignmentType = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite provides functions to examine and operate on the Color and Gradient\npalettes, which display and modify the paint style of the current selection,\nand the Color Editor, which allows a user to choose and edit colors.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPaintStyleSuite and \\c #kAIPaintStyleSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPaintStyleSuite {
    #[doc = " Causes the Color palette to show the stroke color (not fill).\n(Note that this function does not return an error code.)"]
    pub SetStrokeActive: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Reports whether the Color palette shows the stroke color (not fill).\n(Note that this function returns a boolean value, not an error code.)\n@return True if stroke is active."]
    pub IsStrokeActive: ::std::option::Option<unsafe extern "C" fn() -> ASBoolean>,
    #[doc = " Causes the Color palette to show the fill color (not stroke).\n(Note that this function does not return an error code.)"]
    pub SetFillActive: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Reports whether the Color palette shows the fill color (not stroke).\n(Note that this function returns a boolean value, not an error code.)\n@return True if fill is active."]
    pub IsFillActive: ::std::option::Option<unsafe extern "C" fn() -> ASBoolean>,
    #[doc = " Sets the fill and stroke states of the current selection to those\nof the default style (usually white for fill and solid\n1-point black for stroke).\n(Note that this function does not return an error code.)"]
    pub SetDefaultFillStroke: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Retrieves the index position of the selected stop the current gradient.\n(Note that this function returns a numeric value, not an error code.)\n@return The 0-based position index, or -1 if a gradient stop is not\ncurrently being edited."]
    pub GetActiveGradientStopIndex:
        ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    #[doc = " Retrieves the gradient currently shown in the Gradient palette.\n@param color [out] A buffer in which to return the gradient."]
    pub GetCurrentGradient:
        ::std::option::Option<unsafe extern "C" fn(color: *mut AIColor) -> ASErr>,
    #[doc = " Retrieves the fill, stroke, or currently active gradient stop\ncolor currently shown in the Color palette.\n@param color [out] A buffer in which to return the color."]
    pub GetCurrentColor: ::std::option::Option<unsafe extern "C" fn(color: *mut AIColor) -> ASErr>,
    #[doc = " Invokes the Gradient palette."]
    pub ShowGradientDialog: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Invokes the Color palette."]
    pub ShowColorDialog: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " If caching is not active, applies a color to the selection, or to the\nactive gradient stop.\n\nIf caching is active--that is, between a call to \\c #BeginActiveColor()\nand a call to \\c #EndActiveColor() --applies the color to proxies (such as the\ncolor previews in the Tools palette) rather than to the selection or gradient stop.\n(The eyedropper tool uses this during mouse-drag.)\n@param color The new color.\n@param useGradientStop True to replace the color in the\ncurrently active gradient stop only, false to replace the color\nin the entire selection."]
    pub SetActiveColor: ::std::option::Option<
        unsafe extern "C" fn(color: *mut AIColor, useGradientStop: ASBoolean) -> ASErr,
    >,
    #[doc = " Starts caching for color application to proxies.\n@see \\c #SetActiveColor(), \\c #SetAIColor()"]
    pub BeginActiveColor: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Finishes caching for color application to proxies.\n@see \\c #SetActiveColor(), \\c #SetAIColor()"]
    pub EndActiveColor: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Reports whether the current color in the Color palette is for a stroke or fill.\n(Note that this function returns a boolean value, not an error code.)\n@return True if the color is for a stroke, false if it is for a fill."]
    pub IsCurrentColorStroke: ::std::option::Option<unsafe extern "C" fn() -> ASBoolean>,
    #[doc = " If caching is not active, applies a stroke or fill color to the current selection,\nusing a partial color specification.\n\nIf caching is active--that is, between a call to \\c #BeginActiveColor()\nand a call to \\c #EndActiveColor() --applies the color to proxies (such as the\ncolor previews in the Tools palette) rather than to the selection.\n@param color The color structure containing new color component values.\n@param colorMap A color map that specifies which members of the color structure\ncontain valid values.\n@param isStroke True to set the current stroke color, false to set the fill color."]
    pub SetAIColor: ::std::option::Option<
        unsafe extern "C" fn(
            color: *mut AIColor,
            colorMap: *mut AIColorMap,
            isStroke: ASBoolean,
        ) -> ASErr,
    >,
    #[doc = "\tShows a gradient in the Gradient palette.\n@param color The gradient."]
    pub SetCurrentGradient:
        ::std::option::Option<unsafe extern "C" fn(color: *mut AIColor) -> ASErr>,
    #[doc = "\tShows a color in the Color palette.\n@param color The color."]
    pub SetCurrentColor: ::std::option::Option<unsafe extern "C" fn(color: *mut AIColor) -> ASErr>,
    #[doc = " Shows the Color palette if it is hidden, hides the Color palette if it is shown."]
    pub ToggleColorDialog: ::std::option::Option<unsafe extern "C" fn() -> ASErr>,
    #[doc = " Exchanges the fill and stroke colors for the current selection.\n(Note that this function does not return an error code.)"]
    pub SwapFillStroke: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Invokes the color-chooser dialog and reports the chosen color.\n(Note that this function returns a boolean value, not an error code.)\n@param currentColor specifies the initial color the picker will display.\nWhen the function returns currentColor will become the color the user picked.\n@return True if the user clicked OK, false of the user clicked Cancel."]
    pub DisplayColorPicker:
        ::std::option::Option<unsafe extern "C" fn(currentColor: *mut AIColor) -> ASBoolean>,
    #[doc = " Invokes the Color Picker dialog with options and reports the chosen color.\n(Note that this function returns a boolean value, not an error code.)\n@param currentColor [in/out] On input, the initial color to display.\nOn output, the color the user selected.\n@param options Options for initial display. The Color Picker opens in\nthe swatch-list view if the initial color exactly matches the color\nin a swatch from the \\c #AIColorPickerOptions::swatchList.\n@return True if the user clicked OK in the Color Picker, false if the user clicked Cancel."]
    pub DisplayColorPickerWithOptions: ::std::option::Option<
        unsafe extern "C" fn(
            currentColor: *mut AIColor,
            options: *const AIColorPickerOptions,
        ) -> ASBoolean,
    >,
    #[doc = " Changes the stroke alignment for an art object.\n@param art [in] The art handle.\n@param strokeAlignment [in] The new alignment type, a constant in \\c #AIStrokeAlignmentType.\n@return \\c #kNoErr if successful, error code otherwise."]
    pub SetStrokeAlignment: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, strokeAlignment: ai_uint32) -> AIErr,
    >,
    #[doc = " Changes the stroke alignment for the currently selected art object or objects.\n@param strokeAlignment [in] The new alignment type, a constant in \\c #AIStrokeAlignmentType.\n@return \\c #kNoErr if successful, error code otherwise."]
    pub SetStrokeAlignmentOnSelection:
        ::std::option::Option<unsafe extern "C" fn(strokeAlignment: ai_uint32) -> AIErr>,
    #[doc = " Retrieves the stroke alignment for the currently selected art object or objects.\n(Note that this function returns a numeric value, not an error code.)\n@return The stroke alignment type of the current selection, a constant in \\c #AIStrokeAlignmentType.\nIf there is no selection or selected art objects have different states,\treturns  \\c #kAIStrokeAlignmentCenter."]
    pub GetStrokeAlignmentFromSelection: ::std::option::Option<unsafe extern "C" fn() -> ai_uint32>,
}
#[doc = " focus changed to fill or stroke"]
pub const AIArtStyleFocusValue_kAIFocusOnFillStroke: AIArtStyleFocusValue = 0;
#[doc = " focus changed to object"]
pub const AIArtStyleFocusValue_kAIFocusOnObject: AIArtStyleFocusValue = 1;
#[doc = " focus changed to object"]
pub const AIArtStyleFocusValue_kAIDummyFocus: AIArtStyleFocusValue = 16777215;
#[doc = " Focus types, sent in notify data for \\c #kAIArtStyleFocusChangedNotifier."]
pub type AIArtStyleFocusValue = ::std::os::raw::c_uint;
#[doc = " Style contains only one fill and one stroke and can have transparency\napplied only at the object level."]
pub const AIArtStyleType_kAIArtStyleSimple: AIArtStyleType = 1;
#[doc = " Style can contain multiple fills and strokes, can have different\ntransparency applied to each fill or stroke as well as to the object as a\nwhole, and can contain Live Effects."]
pub const AIArtStyleType_kAIArtStyleActive: AIArtStyleType = 2;
#[doc = " Art style types"]
pub type AIArtStyleType = ::std::os::raw::c_uint;
#[doc = " Return type for \\c #AIArtStyleSuite::ExamineStyle().\nSee \\c #AIArtStyleHasAttrsBits for values."]
pub type AIArtStyleHasAttrs = ai_uint32;
#[doc = " null value"]
pub const AIArtStyleHasAttrsBits_kStyleHasNothing: AIArtStyleHasAttrsBits = 0;
#[doc = " Style has fill"]
pub const AIArtStyleHasAttrsBits_kStyleHasFill: AIArtStyleHasAttrsBits = 1;
#[doc = " Style has stroke"]
pub const AIArtStyleHasAttrsBits_kStyleHasStroke: AIArtStyleHasAttrsBits = 2;
#[doc = " Style has patterns"]
pub const AIArtStyleHasAttrsBits_kStyleHasPatterns: AIArtStyleHasAttrsBits = 4;
#[doc = " Style has custom colors"]
pub const AIArtStyleHasAttrsBits_kStyleHasCustomColors: AIArtStyleHasAttrsBits = 8;
#[doc = " Style has gradients on Fill"]
pub const AIArtStyleHasAttrsBits_kStyleHasFillGradients: AIArtStyleHasAttrsBits = 16;
#[doc = " Style has radial gradients on Fill"]
pub const AIArtStyleHasAttrsBits_kStyleHasRadialGradientsOnFill: AIArtStyleHasAttrsBits = 32;
#[doc = " Style has transparency"]
pub const AIArtStyleHasAttrsBits_kStyleHasTransparency: AIArtStyleHasAttrsBits = 64;
#[doc = " Style has brushes"]
pub const AIArtStyleHasAttrsBits_kStyleHasBrushes: AIArtStyleHasAttrsBits = 128;
#[doc = " Style has gradients on Stroke"]
pub const AIArtStyleHasAttrsBits_kStyleHasStrokeGradients: AIArtStyleHasAttrsBits = 256;
#[doc = " Style has radial gradients on Stoke"]
pub const AIArtStyleHasAttrsBits_kStyleHasRadialGradientsOnStroke: AIArtStyleHasAttrsBits = 512;
#[doc = " Style has effects.\nTransparency does not count as an effect, but brushes do.\nIf a style reports that it has no transparency or effects, but the\ntype is \\c #kAIArtStyleActive, it has either multiple fills or strokes,\nor a stroke that is below the fill."]
pub const AIArtStyleHasAttrsBits_kStyleHasEffects: AIArtStyleHasAttrsBits = 65536;
#[doc = " Style has scalable effects"]
pub const AIArtStyleHasAttrsBits_kStyleHasScalableEffects: AIArtStyleHasAttrsBits = 131072;
#[doc = "\tPass to \\c #AIArtStyleSuite::ExamineStyle() to check for all possible attributes."]
pub const AIArtStyleHasAttrsBits_kStyleCheckForAll: AIArtStyleHasAttrsBits = 4294967295;
#[doc = " Bit flag value for style properties.\nA logical OR of these is returned by \\c #AIArtStyleSuite::ExamineStyle()."]
pub type AIArtStyleHasAttrsBits = ::std::os::raw::c_uint;
#[doc = " Gradient information for \\c #AIArtStyleSuite::NewStyle() and\n\\c #AIArtStyleSuite::GetPaintAttributes()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtStylePaintData {
    #[doc = " The gradient origin, relative to the bounding box\nof the object to which the style would be applied."]
    pub fillRelativeGradientOrigin: AIRealPoint,
    #[doc = " The gradient length, in points."]
    pub fillRelativeGradientLength: AIReal,
    #[doc = " The gradient aspect ratio, for radial gradients"]
    pub fillGradientAspectRatio: AIReal,
    #[doc = " The stroke gradient origin, relative to the bounding box\nof the object to which the style would be applied."]
    pub strokeRelativeGradientOrigin: AIRealPoint,
    #[doc = " The stroke gradient length, in points."]
    pub strokeRelativeGradientLength: AIReal,
    #[doc = " The stroke gradient aspect ratio, for radial gradients"]
    pub strokeGradientAspectRatio: AIReal,
}
#[doc = "\t@ingroup Suites\nThe functions in the Art Style suite are used to access and modify\nart styles on artwork in Illustrator documents.\n\nIn AI8, Illustrator introduced the concept of plug-in groups, where the art\nthat was actually printed (result art) was separate from the art that the\nuser edited (edit art).\tThis concept was extended in AI9 with the introduction\nof art styles. Now, any art object in the document (including groups and\ntext objects) can optionally have \"styled art\" attached to it. It is this\n\"styled art\" that gets printed, not the original \"source art\".\n\nThe art style applied to an art object controls how styled\nart is generated. A plug-in should not directly modify styled art itself,\nwhich can be regenerated at any time, but should instead work with the art styles.\n\nExport plug-ins should export the styled art, if any, applied to an object,\nrather than the original source art.\n\nIn the UI, the art style applied to an Illustrator art object is known as the\nobject's \\e appearance, and is manipulated through the Appearance\npalette. Appearances can also be saved and reused on other objects through the\nGraphic Styles palette.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArtStyleSuite and \\c #kAIArtStyleVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtStyleSuite {
    #[doc = " Retrieves the styled art for an art object.\nThe objects that comprise the styled art cannot themselves have\nstyled art.\n@param art The art object.\n@param styleArt [out] A buffer in which to return the styled art object, or\nthe original art object if there is no special style applied.\nReturns \\c NULL in case of error; for example, if a Live Effect failed\nto execute because of memory constraints."]
    pub GetStyledArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, styledArt: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the art style associated with an art object.\n@param art The art object.\n@param artStyle [out] A buffer in which to return the art style reference, or\n\\c NULL if no art style is applied. Null art styles are common\nfor objects of type \\c kGroupArt, \\c kPlacedArt, and \\c kPluginArt."]
    pub GetArtStyle: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, artStyle: *mut AIArtStyleHandle) -> AIErr,
    >,
    #[doc = " Retrieves the art style currently displayed in the Appearance palette.\n@param artStyle [out] A buffer in which to return the art style reference.\n@param mixedState [out] A buffer in which to return true if the Appearance\npalette shows \"Mixed\". In this case, the returned art style\nis a simple style which is an attempt to gather the common attributes\nof the art styles attached to the currently selected objects in the\ncurrent document."]
    pub GetCurrentArtStyle: ::std::option::Option<
        unsafe extern "C" fn(artStyle: *mut AIArtStyleHandle, mixedState: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves an art style by its unique name from the current document.\n@param artStyle [out] A buffer in which to return the art style reference.\n@param name The unique name.\n@param searchAllStyles When true, search all styles in the current document,\nincluding anonymous styles.\nWhen false, search only named styles (those shown in the Graphic Styles\npalette).\n@see \\c #GetArtStyleByNameFromDocument()"]
    pub GetArtStyleByName: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: *mut AIArtStyleHandle,
            name: *const ai_UnicodeString,
            searchAllStyles: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of art styles currently listed in the Graphic Styles palette.\nUse with \\c #GetNthNamedArtStyle() to iterate through art styles in the current document.\n@param count [out] A buffer in which to return the number of styles.\n@see \\c #CountNamedArtStylesFromDocument()"]
    pub CountNamedArtStyles:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a named art style by index. Use with \\c #CountNamedArtStyles()\nto iterate through art styles that are currently shown in the Graphic Styles palette.\n@param n The position index, in the range <code> [0..numStyles-1]</code>.\n@param artStyle [out] A buffer in which to return the art style reference.\n@see \\c #GetNthNamedArtStyleFromDocument()"]
    pub GetNthNamedArtStyle: ::std::option::Option<
        unsafe extern "C" fn(n: ai_int32, artStyle: *mut AIArtStyleHandle) -> AIErr,
    >,
    #[doc = " Applies an art style to an art object.\n@param art The art object.\n@param artStyle The art style, or \\c NULL to remove any art style\ncurrently associated with the art object.\n@return \\c #kStyleNotInCurrentDocument if the given art style is not in\nthe current document."]
    pub SetArtStyle: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, artStyle: AIArtStyleHandle) -> AIErr,
    >,
    #[doc = " Applies an art style to the currently targeted objects on the artboard. This\nis the same clicking the style in the Graphic Styles palette.\n@param artStyle The art style.\n@return \\c #kStyleNotInCurrentDocument if the given art style is not in the\ncurrent document."]
    pub SetCurrentArtStyle:
        ::std::option::Option<unsafe extern "C" fn(artStyle: AIArtStyleHandle) -> AIErr>,
    #[doc = "\tReports whether an art style is anonymous. Named art styles appear in the\nGraphic Styles palette.\n(Note that the function returns a boolean value, not an error code.)\n\n@param artStyle The art style object.\n@return True if the style is anonymous; false if it is named."]
    pub IsArtStyleAnonymous:
        ::std::option::Option<unsafe extern "C" fn(artStyle: AIArtStyleHandle) -> AIBoolean>,
    #[doc = " Retrieves the unique name of an art style.\n@param artStyle The art style.\n@param name [out] A buffer in which to return the name.\n@param isAnonymous [out] A buffer in  which to return the output as true if the style is anonymous,\nor false if it is named (shown in the Graphic Styles palette)."]
    pub GetArtStyleName: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            name: *mut ai_UnicodeString,
            isAnonymous: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the unique name of a named art style; that is, one that is shown\nin the Graphic Styles palette. Anonymous styles cannot be renamed. You can use\n\\c #AddNamedStyle() to convert an anonymous style to a named style.\n@param artStyle The art style. This must be a named art style\n@param name The new name. Style names are limited to 64 characters\n(including the terminating \\c NULL character). Empty (\"\") names are not allowed.\n@return \\c #kStyleNotInCurrentDocument if the given art style is not in\nthe current document.<br>\\c #kNameInUseErr if another art style already exists\nwith the given name."]
    pub SetArtStyleName: ::std::option::Option<
        unsafe extern "C" fn(artStyle: AIArtStyleHandle, name: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the paint information for an art style.\n\n@param artStyle The art style.\n@param aiPathStyle [out] A buffer in which to return an \\c #AIPathStyle structure\nthat contains information about the fill, stroke and the even-odd fill rule.\n@param paintData [out] A buffer in which to return an \\c #AIArtStylePaintData structure\nthat contains the gradient vector and origin relative to the object's bounding box."]
    pub GetPaintAttributes: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            aiPathStyle: *mut AIPathStyle,
            paintData: *mut AIArtStylePaintData,
        ) -> AIErr,
    >,
    #[doc = " Creates a new art style.\n@param aiPathStyle An \\c #AIPathStyle structure that contains information about\nthe fill, stroke and the even-odd fill rule.\n@param paintData An \\c #AIArtStylePaintData structure that contains the\ngradient vector and origin relative to the object's bounding box. Can be \\c NULL.\n@param blendDict A dictionary that contains the transparency information. Can be \\c NULL.\n@param newStyle [out] A buffer in which to return the new art style reference."]
    pub NewStyle: ::std::option::Option<
        unsafe extern "C" fn(
            aiPathStyle: *mut AIPathStyle,
            paintData: *mut AIArtStylePaintData,
            blendDict: AIDictionaryRef,
            newStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Converts an anonymous style to a named style, which is shown in the Graphic Styles palette.\n@param artStyle The anonymous art style.\n@param name The new name. Style names are limited to 64 characters\n(including the terminating \\c NULL character). Empty (\"\") names are not allowed.\n@param uniquify When true, the function appends a numeric string to make the name unique, if\nit is already in use. When false, if the name is in use, the function fails.\n@param namedStyle [out] A buffer in which to return the new art style reference.\n@return \\c #kNameInUseErr if the name is already in use and \\c uniquify is false."]
    pub AddNamedStyle: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            name: *const ai_UnicodeString,
            uniquify: AIBoolean,
            namedStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Converts a named style, which is shown in the Graphic Styles palette, to an anonymous style, which is not.\nRemoves the named style from the palette.\n@param namedStyle The named art style.\n@param anonStyle [out] A buffer in which to return the new art style reference.\n@return \\c #kStyleNotInCurrentDocument if the art style is not in the current document."]
    pub RemoveNamedStyle: ::std::option::Option<
        unsafe extern "C" fn(
            namedStyle: AIArtStyleHandle,
            anonStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates an anonymous copy of a named art style (one shown in the Graphics Styles palette).\nThe named style remains in the palette.\n@param namedStyle The named style. (If this is an anonymous style, it is copied to \\c anonStyle.)\n@param anonStyle [out] A buffer in which to return the new art style reference."]
    pub CreateAnonymousStyle: ::std::option::Option<
        unsafe extern "C" fn(
            namedStyle: AIArtStyleHandle,
            anonStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Redefines a named art style to have the same characteristics as another style.\n@param namedStyle The named style to redefine.\n@param dstStyle The style to copy attributes from.\n@return The error \\c #kStyleNotInCurrentDocument if \\c namedStyle is not in the current document."]
    pub RedefineNamedStyle: ::std::option::Option<
        unsafe extern "C" fn(namedStyle: AIArtStyleHandle, dstStyle: AIArtStyleHandle) -> AIErr,
    >,
    #[doc = " Moves a named art style to a position in the Graphic Styles palette.\n@param namedStyle The named art style.\n@param index The new position index. Use -1 to move the art style to the end\nof the list."]
    pub MoveNamedStyle: ::std::option::Option<
        unsafe extern "C" fn(namedStyle: AIArtStyleHandle, index: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a named art style by its unique name from a specified document. Searches\nonly named styles (those that are shown in the Graphic Styles palette when\nthe specified document is current).\n@param artStyle [out] A buffer in which to return the art style reference.\n@param name The unique name.\n@param document The document.\n@see \\c #GetArtStyleByName()"]
    pub GetArtStyleByNameFromDocument: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: *mut AIArtStyleHandle,
            name: *const ai_UnicodeString,
            document: AIDocumentHandle,
        ) -> AIErr,
    >,
    #[doc = " Gets the number of named art styles in a specified document (those shown\nin the Graphic Styles palette when that document is current).\nUse with \\c #GetNthNamedArtStyleFromDocument() to iterate through art styles\nin a particular document.\n@param count [out] A buffer in which to return the number of styles\n@param document The document.\n@see \\c #CountNamedArtStyles()"]
    pub CountNamedArtStylesFromDocument: ::std::option::Option<
        unsafe extern "C" fn(count: *mut ai_int32, document: AIDocumentHandle) -> AIErr,
    >,
    #[doc = " Retrieves a named art style by index for a specified document.\nUse with \\c #CountNamedArtStylesFromDocument() to iterate through art styles\nthat are shown in the Graphic Styles palette when that document is current.\n@param n The position index, in the range <code> [0..numStyles-1]</code>.\n@param artStyle [out] A buffer in which to return the art style reference.\n@param document The document.\n@see \\c #GetNthNamedArtStyle()"]
    pub GetNthNamedArtStyleFromDocument: ::std::option::Option<
        unsafe extern "C" fn(
            n: ai_int32,
            artStyle: *mut AIArtStyleHandle,
            document: AIDocumentHandle,
        ) -> AIErr,
    >,
    #[doc = " Tests equivalence between two art styles.\n@param artStyle1 The first art style.\n@param artStyle2 The second art style.\n@param result [out] A buffer in which to return the output as true if the styles are equivalent.\n@note A false result does not guarantee that the two styles are not equivalent."]
    pub Equiv: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle1: AIArtStyleHandle,
            artStyle2: AIArtStyleHandle,
            result: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sorts the named art styles in the current document alphabetically. The order\nis reflected in the Graphic Styles palette."]
    pub SortNamedStyles: ::std::option::Option<unsafe extern "C" fn() -> AIErr>,
    #[doc = " Retrieves the default art style of the current document, which is always\nlisted first in the Graphic Styles palette.\n@param artStyle [out] A buffer in which to return the art style reference."]
    pub GetDefaultArtStyle:
        ::std::option::Option<unsafe extern "C" fn(artStyle: *mut AIArtStyleHandle) -> AIErr>,
    #[doc = " Retrieves the name of the default art style of the current document, which is always\nlisted first in the Graphic Styles palette.\n@param name [out] A buffer in which to return the name."]
    pub GetDefaultArtStyleName:
        ::std::option::Option<unsafe extern "C" fn(name: *mut ai_UnicodeString) -> AIErr>,
    #[doc = " Reports whether an art style exists in the current document.\n(Note that the function returns a boolean value, not an error code.)\n@param artStyle The art style.\n@return True if the art style is in the current document."]
    pub ValidateArtStyle:
        ::std::option::Option<unsafe extern "C" fn(artStyle: AIArtStyleHandle) -> AIBoolean>,
    #[doc = " Expands the style of an art object, replacing the art object with the art\nthat would be returned by \\c #GetStyledArt(). Transfers opacity masks,\nURLs, tags, and so on from the input art to the flattened art.\n@param art The art object. Upon return, this reference is no longer valid.\n@note This function is maintained for compatibility with older plug-ins,\nbut is superseded by \\c #GetFlattenedArt()"]
    pub FlattenStyle: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Retrieves the type of an art style.\n@param artStyle The art style.\n@param type [out] A buffer in which to return the type; a \\c #AIArtStyleType value."]
    pub GetArtStyleType: ::std::option::Option<
        unsafe extern "C" fn(artStyle: AIArtStyleHandle, type_: *mut ai_int16) -> AIErr,
    >,
    #[doc = " Reports whether an art style contains all the pieces it needs in order\nto execute. (Note that this function returns a boolean value, not an error code.)\n@param artStyle The art style.\n@return True if the style can be successfully applied.\n<br>False if the style contains an effect provided by a plug-in that\ncannot be found in the Plug-Ins folder."]
    pub CanExecute:
        ::std::option::Option<unsafe extern "C" fn(artStyle: AIArtStyleHandle) -> AIBoolean>,
    #[doc = " Returns the scale factor for an art object's style. (Note that the function returns a\nnumeric value, not an error code.) <br>\nThe option \"Scale Strokes & Effects\" allows you to scale the stroke weight\nand effects attached to an art object.The scale factor is stored with the\nart object, and applied after the style is applied. For example, if the style attached\nto an object has a stroke with a weight of 2 pt, and the object's scale factor is 2.5,\nthe visual stroke weight is 5 pt.\n\n@note \\c #GetPaintAttributes() gets the unscaled parameter values,as do functions from the\n\\c #AIArtStyleParserSuite.\n<br> However, the \\c #AIPathStyleSuite calls return the scaled stroke weights\nattached to the objects.\n\n@param art The art object.\n@return The scale factor.\n@see \\c #SetArtStyleScaleFactor() <br> \\c #ResetArtStyleScaleFactor()"]
    pub GetArtStyleScaleFactor:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIReal>,
    #[doc = " Sets the scale factor for an art object's style. The scale factor is stored with the\nart object, and applied after the style is applied.\n@param art The art object.\n@param scaleFactor The new scale factor.\n@see \\c #GetArtStyleScaleFactor() <br> \\c #ResetArtStyleScaleFactor()"]
    pub SetArtStyleScaleFactor:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, scaleFactor: AIReal) -> AIErr>,
    #[doc = " Applies a new style to an art object that is scaled by the object's current scale factor,\nand resets the scale factor for the object to 1.\n@param art The art object.\n@see \\c #GetArtStyleScaleFactor() <br> \\c #ResetArtStyleScaleFactor()"]
    pub ResetArtStyleScaleFactor:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Transforms the art style of an object.\n@param art The art object.\n@param matrix A pointer to the transformation matrix.\n@param lineScale The scale factor to apply to the line-drawing style values\nspecified in the art object�s current style.\n@param flags Bit flags that control how the transformation is performed.\nA logical OR of \\c #AITransformArtOptions values.\nIf the \\c kTransformObjects flag is on, it is assumed that the art object itself\nhas also been transformed by the same matrix, and that any transformation of the points,\ndescendant art, and so on, have already been performed. This allows gradient vectors and\nother style attributes that are dependent upon object bounds to be adjusted immediately,\nrather than deferred until artwork synchronization."]
    pub TransformObjectArtStyle: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            matrix: *mut AIRealMatrix,
            lineScale: AIReal,
            flags: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Examines an art style for specific attributes, and returns the ones found.\n(Note that the function returns an attribute structure, not an error code.)\n@param artStyle The art style.\n@param checkFor A logical OR of \\c #AIArtStyleHasAttrsBits values,\nspecifying which attributes to check for. Pass \\c #kStyleCheckForAll\nto check all attributes.\n@return A logical OR of \\c #AIArtStyleHasAttrsBits values for those attributes found in the style."]
    pub ExamineStyle: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            checkFor: AIArtStyleHasAttrs,
        ) -> AIArtStyleHasAttrs,
    >,
    #[doc = " Retrieves the art style that will be used for new art created by a tool, based on\napplication preferences.\n@param artStyle [out] A buffer in which to return the style reference."]
    pub GetToolArtStyle:
        ::std::option::Option<unsafe extern "C" fn(artStyle: *mut AIArtStyleHandle) -> AIErr>,
    #[doc = " Expands the style of an art object, replacing the art object with the art\nthat would be returned by \\c #GetStyledArt(). Transfers opacity masks,\nURLs, tags, and so on from the input art to the flattened art.\n@param art The art object. Upon return, this reference is no longer valid,\nunless no flattening was needed.\n@param flattenedArt [out] A buffer in which to return the flattened art object."]
    pub GetFlattenedArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, flattenedArt: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Reports whether an art object has a style that would be equivalent to a null style.\nThis is the same as verifying that the style has no fill, no stroke,\nno effects, and default transparency attributes. (Note that the function returns a\nboolean value, not an error code.)\n@param art The art object.\n@return True if the art's style is effectively null."]
    pub HasEffectiveNullStyle:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Retrieves the map for the path style of an art style, as retrieved\nby \\c #GetPaintAttributes(). The map indicates which fields of an \\c #AIPathStyle\nare specified by a partial style. A path style can contain unknown or mixed\nattributes (indicated by a value of false for that attribute in the map) only\nwhen it is associated with a graph object, not when it is associated with an art object.\n@param artStyle The art style.\n@param aiPathStyleMap [out] A buffer in which to return the path style map."]
    pub GetPaintMap: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            aiPathStyleMap: *mut AIPathStyleMap,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIMask {
    _unused: [u8; 0],
}
#[doc = " An opaque reference to a mask. There is a one-to-one correspondence between\nobjects and masks."]
pub type AIMaskRef = *mut _AIMask;
#[doc = " The various blending modes that can be used to composite an object. These\nmodes correspond to the ones in Photoshop. See #AIBlendingModeValues."]
pub type AIBlendingMode = ai_int32;
pub const AIBlendingModeValues_kAINormalBlendingMode: AIBlendingModeValues = 0;
pub const AIBlendingModeValues_kAIMultiplyBlendingMode: AIBlendingModeValues = 1;
pub const AIBlendingModeValues_kAIScreenBlendingMode: AIBlendingModeValues = 2;
pub const AIBlendingModeValues_kAIOverlayBlendingMode: AIBlendingModeValues = 3;
pub const AIBlendingModeValues_kAISoftLightBlendingMode: AIBlendingModeValues = 4;
pub const AIBlendingModeValues_kAIHardLightBlendingMode: AIBlendingModeValues = 5;
pub const AIBlendingModeValues_kAIColorDodgeBlendingMode: AIBlendingModeValues = 6;
pub const AIBlendingModeValues_kAIColorBurnBlendingMode: AIBlendingModeValues = 7;
pub const AIBlendingModeValues_kAIDarkenBlendingMode: AIBlendingModeValues = 8;
pub const AIBlendingModeValues_kAILightenBlendingMode: AIBlendingModeValues = 9;
pub const AIBlendingModeValues_kAIDifferenceBlendingMode: AIBlendingModeValues = 10;
pub const AIBlendingModeValues_kAIExclusionBlendingMode: AIBlendingModeValues = 11;
pub const AIBlendingModeValues_kAIHueBlendingMode: AIBlendingModeValues = 12;
pub const AIBlendingModeValues_kAISaturationBlendingMode: AIBlendingModeValues = 13;
pub const AIBlendingModeValues_kAIColorBlendingMode: AIBlendingModeValues = 14;
pub const AIBlendingModeValues_kAILuminosityBlendingMode: AIBlendingModeValues = 15;
pub const AIBlendingModeValues_kAINumBlendingModes: AIBlendingModeValues = 16;
#[doc = " Values for \\c #AIBlendingMode"]
pub type AIBlendingModeValues = ::std::os::raw::c_uint;
pub const AIKnockout_kAIKnockoutUnknown: AIKnockout = -1;
#[doc = " No knockout"]
pub const AIKnockout_kAIKnockoutOff: AIKnockout = 0;
#[doc = " Knockout"]
pub const AIKnockout_kAIKnockoutOn: AIKnockout = 1;
#[doc = " Use parent's knockout value"]
pub const AIKnockout_kAIKnockoutInherit: AIKnockout = 2;
#[doc = " Knockout tri-state"]
pub type AIKnockout = ::std::os::raw::c_int;
#[doc = " @ingroup Suites\nThis suite provides function for working with \\e blend \\e styles.\nWhen an art object overlaps other art, it is composited with what\nwas drawn before it, using a blend style that is a part of the\nobject's art style. Fills and strokes can have their own\ncompositing attributes.\n\nSee the PDF language specification for details of the transparency\nmodes used by Illustrator.\n\n@see \\c #AIMaskSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIBlendStyleSuite and \\c #kAIBlendStyleVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBlendStyleSuite {
    #[doc = " Retrieves the current blending mode of an art object, which\napplies to the object as a whole.\n(Note that this function returns a constant value, not an error code.)\n@param\tart The art object.\n@return The mode constant, one of the \\c #AIBlendingModeValues."]
    pub GetBlendingMode:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBlendingMode>,
    #[doc = " Sets the blending mode of an art object, which\napplies to the object as a whole.\n@param\tart The art object.\n@param mode The new mode constant, one of the \\c #AIBlendingModeValues."]
    pub SetBlendingMode: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, mode: AIBlendingMode) -> AIErr,
    >,
    #[doc = " Retrieves the current opacity value applied by the style to an art object.\n(Note that this function returns a numeric value, not an error code.)\n@param\tart The art object.\n@return The opacity value, in the range [0..1] where 0 is completely\ntransparent and 1 is completely opaque."]
    pub GetOpacity: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIReal>,
    #[doc = " Sets the opacity value applied by the style to an art object.\n@param\tart The art object.\n@param opacity The new opacity value, in the range [0..1] where 0 is completely\ntransparent and 1 is completely opaque."]
    pub SetOpacity:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, opacity: AIReal) -> AIErr>,
    #[doc = " Reports whether any blending modes used in the rendering of the object\ncontents are isolated from what has already been drawn. This does\nnot affect the blending mode used for compositing the entire object\ninto its backdrop.\n(Note that this function returns a boolean value, not an error code.)\n@param\tart The art object.\n@return\tTrue if isolation is on."]
    pub GetIsolated: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Sets whether any blending modes used in the rendering of the object\ncontents are isolated from what has already been drawn. This does\nnot affect the blending mode used for compositing the entire object\ninto its backdrop.\n@param\tart The art object.\n@param isolated True to turn isolation on, false to turn it off."]
    pub SetIsolated:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, isolated: AIBoolean) -> AIErr>,
    #[doc = " Retrieves the current knockout state of an art object. If the state is\n\\c #kAIKnockoutInherit, the on/off state is inherited from the object�s parent,\nand you can use \\c #GetInheritedKnockout() to retrieve it.\n(Note that this function returns a constant value, not an error code.)\n@param\tart The art object.\n@return The knockout state constant, one of the \\c #AIKnockout values."]
    pub GetKnockout: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIKnockout>,
    #[doc = " Retrieves the inherited knockout state (on or off) of an art object.\n(Note that this function returns a constant value, not an error code.)\n@param\tart The art object.\n@return The knockout state constant, \\c #kAIKnockoutOff or \\c #kAIKnockoutOn."]
    pub GetInheritedKnockout:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIKnockout>,
    #[doc = " Sets the knockout state of an art object. If the state is\n\\c #kAIKnockoutInherit, the on/off state is inherited from\nthe object�s parent.\n@param\tart The art object.\n@param knockout The new knockout state: on, off, or inherited,"]
    pub SetKnockout: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, knockout: AIKnockout) -> AIErr,
    >,
    #[doc = " Reports whether opacity and mask define the knockout shape for\nan art object.\n(Note that this function returns a boolean value, not an error code.)\n@param\tart The art object.\n@return\tTrue if opacity and mask define the knockout shape."]
    pub GetAlphaIsShape: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIBoolean>,
    #[doc = " Sets whether opacity and mask define the knockout shape for\nan art object.\n@param\tart The art object.\n@param alphaIsShape True if opacity and mask define the knockout shape,\nfalse if they do not."]
    pub SetAlphaIsShape: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, alphaIsShape: AIBoolean) -> AIErr,
    >,
    #[doc = " Copies the compositing attributes that are applied globally by the\nstyle of one art object to another art object.\n@param source The source art object.\n@param destination The destination art object."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(source: AIArtHandle, destination: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the dictionary that contains compositing attributes that\nare applied globally by the style of an art object.\nThis convenience function has the same effect as retrieving an\nart object�s art style and getting attributes individually\nusing \\c #AIBlendStyleSuite::GetStyleAttrs().\n\nThe keys for the compositing attributes are:\n\\verbatim\n#kAIBlendModeKey\n#kAIBlendOpacityKey\n#kAIBlendIsolatedKey\n#kAIBlendKnockoutKey\n#kAIBlendAlphaIsShapeKey\n\\endverbatim\n@param art The art object.\n@param attrs [in, out] The dictionary in which to return the attributes.\n@see \\c #AIDictionarySuite"]
    pub GetArtAttrs: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, attrs: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Sets the compositing attributes applied globally to an art object,\nusing a dictionary. This convenience function has the same\neffect as retrieving an art object�s art style and setting\nattributes individually using \\c #AIBlendStyleSuite::SetStyleAttrs().\n@param art The art object.\n@param attrs The dictionary containing the attributes.\nYou can specify a subset of the keys in order to modify a\nsubset of the compositing attributes.\n@see \\c #GetArtAttrs() for keys."]
    pub SetArtAttrs: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, attrs: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Retrieves the dictionary that contains globally-applied compositing attributes\nfrom an art style.\n@param style The art style object.\n@param attrs [in, out] The dictionary in which to return the attributes.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub GetStyleAttrs: ::std::option::Option<
        unsafe extern "C" fn(style: AIArtStyleHandle, attrs: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Modifies the compositing attributes of an art style that are applied globally\nto an art object, using a dictionary, and creates a new style with\nthe modifications.\n@param style The source art style object. This object is not modified.\n@param attrs The dictionary containing the attributes.\nYou can specify a subset of the keys in order to modify a\nsubset of the compositing attributes.\n@param newStyle [out] A buffer in which to return a new style object\ncontaining the modifications."]
    pub SetStyleAttrs: ::std::option::Option<
        unsafe extern "C" fn(
            style: AIArtStyleHandle,
            attrs: AIDictionaryRef,
            newStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the common compositing attributes for the current selection in the\ncurrent document. Retrieves only the common attributes; for\nexample, if two objects are selected with different opacities, the\nopacity entry is not present in the returned dictionary.\n@param styleAttrs [in, out] The dictionary in which to return the common attributes\napplied to objects as a whole. Can be \\c NULL if not needed.\n@param fillAttrs [in, out] The dictionary in which to return the common attributes\napplied to the focal fills.\tCan be \\c NULL if not needed.\n@param strokeAttrs [in, out] The dictionary in which to return the common attributes\napplied to the focal strokes. Can be \\c NULL if not needed.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub GetCurrentTransparency: ::std::option::Option<
        unsafe extern "C" fn(
            styleAttrs: AIDictionaryRef,
            fillAttrs: AIDictionaryRef,
            strokeAttrs: AIDictionaryRef,
        ) -> AIErr,
    >,
    #[doc = " Sets compositing attributes for the current selection in the\ncurrent document.The dictionaries can specify a subset of\nkeys in order to modify a subset of the compositing attributes.\n@param styleAttrs The dictionary containing the attributes\napplied to objects as a whole. Can be \\c NULL if not needed.\n@param fillAttrs The dictionary containing attributes\napplied to the focal fills.\tCan be \\c NULL if not needed.\n@param strokeAttrs The dictionary containing attributes\napplied to the focal strokes. Can be \\c NULL if not needed.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub SetCurrentTransparency: ::std::option::Option<
        unsafe extern "C" fn(
            styleAttrs: AIDictionaryRef,
            fillAttrs: AIDictionaryRef,
            strokeAttrs: AIDictionaryRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves dictionary containing the compositing attributes for\nthe focal fill of an art style.\n@param artStyle The art style object.\n@param attrs [in, out] The dictionary in which to return the attributes.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub GetFocalFillAttrs: ::std::option::Option<
        unsafe extern "C" fn(artStyle: AIArtStyleHandle, attrs: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Retrieves dictionary containing the compositing attributes for\nthe focal stroke of an art style.\n@param artStyle The art style object.\n@param attrs [in, out] The dictionary in which to return the attributes.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub GetFocalStrokeAttrs: ::std::option::Option<
        unsafe extern "C" fn(artStyle: AIArtStyleHandle, attrs: AIDictionaryRef) -> AIErr,
    >,
    #[doc = " Modifies the compositing attributes for the focal fill of an art style\nusing a dictionary, and creates a new style with the modifications.\n@param artStyle The source art style object. Not modified.\n@param attrs The dictionary containing the attributes.\n@param newStyle [out] A buffer in which to return a new style object\ncontaining the modifications.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub SetFocalFillAttrs: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            attrs: AIDictionaryRef,
            newStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Modifies the compositing attributes for the focal stroke of an art style\nusing a dictionary, and creates a new style with the modifications.\n@param artStyle The source art style object. Not modified.\n@param attrs The dictionary containing the attributes.\n@param newStyle [out] A buffer in which to return a new style object\ncontaining the modifications.\n@see \\c #GetArtAttrs() for keys, \\c #AIDictionarySuite"]
    pub SetFocalStrokeAttrs: ::std::option::Option<
        unsafe extern "C" fn(
            artStyle: AIArtStyleHandle,
            attrs: AIDictionaryRef,
            newStyle: *mut AIArtStyleHandle,
        ) -> AIErr,
    >,
    #[doc = " Reports whether an art object contains any artwork with\nnon-normal blending that is not isolated at the level of the object.\n(Note that this function returns a boolean value, not an error code.)\n@param\tart The art object.\n@return\tTrue if the object does contain artwork with non-isolated blending."]
    pub ContainsNonIsolatedBlending:
        ::std::option::Option<unsafe extern "C" fn(object: AIArtHandle) -> AIBoolean>,
    #[doc = " Reports the isolation state of the page group, which contains all the layers in the\ncurrent document.\n(Note that this function returns a boolean value, not an error code.)\n@return\tTrue if the contents of the page is to be drawn in an isolated\ntransparency group."]
    pub GetDocumentIsolated: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Sets the isolation state of the page group, which contains all the layers in the\ncurrent document.\n@param isolated True to turn isolation on, false to turn it off."]
    pub SetDocumentIsolated:
        ::std::option::Option<unsafe extern "C" fn(isolated: AIBoolean) -> AIErr>,
    #[doc = " Reports the knockout state of the page group, which contains all the layers in the\ncurrent document.\n(Note that this function returns a boolean value, not an error code.)\n@return\tTrue if knockout is on for the page group, false if it is off."]
    pub GetDocumentKnockout: ::std::option::Option<unsafe extern "C" fn() -> AIBoolean>,
    #[doc = " Sets the knockout state of the page group, which contains all the layers in the\ncurrent document.\n@param knockout True to turn knockout on, false to turn it off."]
    pub SetDocumentKnockout:
        ::std::option::Option<unsafe extern "C" fn(knockout: AIBoolean) -> AIErr>,
}
#[doc = " @ingroup Suites\nThis suite provides functions to access the opacity mask that\ncan be associated with an art object. Opacity values from the\nmask are combined with the object's own opacity when compositing it.\n\nMask objects are reference counted.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIMaskSuite and \\c #kAIMaskVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIMaskSuite {
    #[doc = " Increments the reference count for a mask.\n(Note that this function returns an integer value, not an error code.)\n@param mask The mask object.\n@return The new reference count for the mask."]
    pub AddRef: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> ai_int32>,
    #[doc = " Decrements the reference count for a mask, and, when\nthe count reaches 0, frees the associated memory.\n(Note that this function returns an integer value, not an error code.)\n@param mask The mask object.\n@return The new reference count for the mask."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> ai_int32>,
    #[doc = " Retrieves the mask associated with an art object, if any.\n@param object The art object.\n@param mask [out] A buffer in which to return the mask object."]
    pub GetMask: ::std::option::Option<
        unsafe extern "C" fn(object: AIArtHandle, mask: *mut AIMaskRef) -> AIErr,
    >,
    #[doc = " Creates a mask for an art object if it does not already have one.\nThe art of the newly created mask is an empty group object.\nRetrieve the new mask with \\c #GetMask().\n@param object The art object."]
    pub CreateMask: ::std::option::Option<unsafe extern "C" fn(object: AIArtHandle) -> AIErr>,
    #[doc = " Deletes the mask association between an art object and its mask,\nand decrements the reference count of the mask. If the reference\ncount is then 0, also deletes the mask object.\n@param object The art object."]
    pub DeleteMask: ::std::option::Option<unsafe extern "C" fn(object: AIArtHandle) -> AIErr>,
    #[doc = " Reports the link state of a mask. When a mask is linked, certain actions\non the associated art object, such as rotation, are automatically applied\nto the mask as well.\n(Note that this function returns a boolean value, not an error code.)\n@param mask The mask object.\n@return True if the mask is linked."]
    pub GetLinked: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIBoolean>,
    #[doc = " Sets the link state of a mask. When a mask is linked, certain actions\non the associated art object, such as rotation, are automatically applied\nto the mask as well.\n@param mask The mask object.\n@param linked True to turn linking on, false to turn it off."]
    pub SetLinked:
        ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef, linked: AIBoolean) -> AIErr>,
    #[doc = " Reports the disabled state of a mask. When a mask is disabled,\nit is ignored when rendering the associated art object.\n(Note that this function returns a boolean value, not an error code.)\n@param mask The mask object.\n@return True if the mask is disabled."]
    pub GetDisabled: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIBoolean>,
    #[doc = " Sets the disabled state of a mask. When a mask is disabled,\nit is ignored when rendering the associated art object.\n@param mask The mask object.\n@param disabled True to disable the mask, false to enable it."]
    pub SetDisabled:
        ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef, disabled: AIBoolean) -> AIErr>,
    #[doc = " Reports the inverted state of a mask. When a mask is inverted,\nthe opacity is inverted before being applied to the associated art.\n(Note that this function returns a boolean value, not an error code.)\n@param mask The mask object.\n@return True if the mask is inverted."]
    pub GetInverted: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIBoolean>,
    #[doc = " Sets the inverted state of a mask. When a mask is inverted,\nthe opacity is inverted before being applied to the associated art.\n@param mask The mask object.\n@param inverted True to invert the mask, false to turn inversion off."]
    pub SetInverted:
        ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef, inverted: AIBoolean) -> AIErr>,
    #[doc = " Copies a mask and its link status from one art object to another.\n@param source The source art object.\n@param destination The destination art object."]
    pub Copy: ::std::option::Option<
        unsafe extern "C" fn(source: AIArtHandle, destination: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the art object that comprises an opacity mask, if any.\n(Note that this function returns an object value, not an error code.)\n@param mask The mask object.\n@return The art object, or \\c NULL if there is no mask art."]
    pub GetArt: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIArtHandle>,
    #[doc = " Reports whether the art object that comprises an opacity mask is\ncurrently being edited.\n(Note that this function returns a boolean value, not an error code.)\n@param mask The mask object.\n@return True if the mask art is being edited."]
    pub IsEditingArt: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIBoolean>,
    #[doc = " Turns editing on or off for the art object associated with a mask.\nEditing mask art causes a new layer to be created\nat the top of the current layer list containing the mask art. When\nediting is terminated the layer is deleted.\n@param mask The mask object.\n@param isedit True to turn editing on, false to turn it off.\n@see \\c #AILayerListSuite"]
    pub SetEditingArt:
        ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef, isedit: AIBoolean) -> AIErr>,
    #[doc = " Retrieves the masked art object associated with a group art object\nthat is the mask art for another art object.\n@param mask The group art object.\n@param [out] A buffer in which to return the masked art object,\nor \\c  NULL if the input art object is not used as a mask."]
    pub GetMaskedArt: ::std::option::Option<
        unsafe extern "C" fn(mask: AIArtHandle, masked: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Reports the clipping state of a mask.\n(Note that this function returns a boolean value, not an error code.)\n@param mask The mask object.\n@return True if the art associated with the mask is clipped."]
    pub GetClipping: ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef) -> AIBoolean>,
    #[doc = " Sets the clipping state of a mask. When clipping is true, the\nopacity value outside the mask art is 0%, thus clipping out\neverything outside the mask art.When clipping is false, the\nvalue outside is 100%, thus revealing everything outside the\nboundary of the mask art.\n@param mask The mask object.\n@param clipping True to turn clipping on, false to turn it off."]
    pub SetClipping:
        ::std::option::Option<unsafe extern "C" fn(mask: AIMaskRef, clipping: AIBoolean) -> AIErr>,
}
#[doc = " If on, updates are triggered by edits to non-descendant objects\nthat overlap the bounds of the editable art. This is intended for objects\nwith lens-like effects (distorting what they move over), or\navoidance behavior (moving away from what moves over them)."]
pub const AIPluginGroupOptions_kPluginGroupWantsOverlapUpdateOption: AIPluginGroupOptions = 2;
#[doc = " If on, when the entire plug-in group is translated as a whole, the\nresult group is transformed as well, and no update message is sent."]
pub const AIPluginGroupOptions_kPluginGroupWantsAutoTranslateOption: AIPluginGroupOptions = 4;
#[doc = " If on, when the entire plug-in group is scaled uniformly, the\nresult group is transformed as well, and no update message is sent."]
pub const AIPluginGroupOptions_kPluginGroupWantsAutoUScaleOption: AIPluginGroupOptions = 8;
#[doc = " If on, when the entire plug-in group is transformed as a whole by any matrix,\nthe result group is transformed as well, and no update message is sent.\nThe notify-edits message is sent to let the plug-in know what has been done;\nA zero return from the automatically-handled operation types is treated\nlike a \\c #kDontCarePluginGroupReply return, so you need not register for\nthe notify-edits message if you do not need to respond to it."]
pub const AIPluginGroupOptions_kPluginGroupWantsAutoTransformOption: AIPluginGroupOptions = 16;
#[doc = " If on, hit testing by other tools does fill hit testing on the edit group.\n(The plug-in's own tool controls its own hit testing.) By default,\nthe edit group is only outline-hit, because objects in the edit group\nare not previewed. Use this options if you copy the edit group contents\tinto the\nresult group and then add things, making it appear that the edit\ngroup paths are previewed. This allows direct selection of individual editable\npaths with a fill click.\n\nWhen on, if there are some edit group objects whose fills or strokes are\n\\e not copied into the result group, you must check style change notifications\nto turn off any fill or stroke paint that the user has given to those objects.\nOtherwise, hits can occur on elements you have not painted.\nSee also \\c #kPluginGroupForceFillHitOnClosedPaths."]
pub const AIPluginGroupOptions_kPluginGroupDoEditFillHitOption: AIPluginGroupOptions = 32;
#[doc = " If off (the default), when a user edit removes all objects from the edit group,\nthe whole plug-in group object is deleted (analogous to the behavior of non-layer groups).\nIf on, the plug-in group remains in the artwork\tafter its edit group has been emptied.\nUse for objects that build their result art based entirely on private data that requires\nno edit art, or that behave like layers in that they can maintain the drawing insertion\nfocus while empty. For implementing layer-like plugin groups, see also the flags\n#kPluginGroupDoNotTarget and #kPluginGroupDoNotSmartTarget."]
pub const AIPluginGroupOptions_kPluginGroupKeepWhenEmptyOption: AIPluginGroupOptions = 64;
#[doc = " If on, the objects in the result group behave like fill of the\nobjects in the edit group. You could use this, for example, to\nimplement ink hatching. Setting this flag informs other plug-ins\nof your plug-in group's behavior. For example, an Expand Fill filter\ncould expand plug-in groups if this flag is on, or a Fill Color could\nrefuse to assign a pattern or gradient fill to the edit group objects,\nknowing that the result group is acting as the fill. (Assigning solid color\nshould be permitted, since fill-like plug-in groups often colorize their fills.)\nDefault is off."]
pub const AIPluginGroupOptions_kPluginGroupIsFillLike: AIPluginGroupOptions = 128;
#[doc = " If on, the objects in the result group behave like stroke of the\nobjects in the edit group. You could use this, for example, for brushes.\nSetting this flag informs other plug-ins of your plug-in group's behavior.\nFor example, an Expand Stroke filter could expand plug-in groups if this\nflag is on, or the Stroke palette could ignore stroke attributes,\nknowing that the result group is acting as the stroke. Default is off.\n\nIf both this and \\c #kPluginGroupIsFillLike are off, the result group objects\nare treated as related to the edit group in some way other than fill or stroke\neffect. An example is path interpolation blends."]
pub const AIPluginGroupOptions_kPluginGroupIsStrokeLike: AIPluginGroupOptions = 256;
#[doc = "\tIf on, the plug-in group object can never be targeted.\nIllustrator always recurses into the contents of the edit group\nto find targeted objects, regardless of whether the plug-in\tgroup object\nis fully selected. This flag prevents users from targeting the\nplug-in group and applying styles, transparency or effects to that level,\neven via the Layers or Appearance panels.\nAlso, if this flag and #kPluginGroupKeepWhenEmptyOption are both on,\nthen the plugin group will act very much like a layer, in that commands\nsuch as Group, Cut,\tDelete, Copy and copy-drag will operate upon the contents\nof the edit group, somewhat as if it were only partially selected, rather\nthan the entire plugin group. See also #kPluginGroupDoNotSmartTarget."]
pub const AIPluginGroupOptions_kPluginGroupDoNotTarget: AIPluginGroupOptions = 512;
#[doc = "\tIf on, selecting any piece inside the edit group automatically targets\nthe plug-in group level. This targeting behavior is similar to that of\ncompound paths. Fill/stroke changes apply to the plug-in group level,\nand the \"Contents\" field is not shown in the Appearance palette.\nThe Compound Shapes plug-in group uses this option.\nUsers can still target the objects inside the edit group\nindividually in the Layers palette."]
pub const AIPluginGroupOptions_kPluginGroupAlwaysSmartTarget: AIPluginGroupOptions = 1024;
#[doc = "\tIf on, the plug-in group is not targeted when fully selected. Users must\ntarget the plug-in group through the Layers panel or the Appearance panel.\nAlso, if this flag and #kPluginGroupKeepWhenEmptyOption are both on,\nthen the plugin group will act very much like a layer, in that commands\nsuch as Group, Cut,\tDelete, Copy and copy-drag will operate upon the contents\nof the edit group, somewhat as if it were only partially selected, rather\nthan the entire plugin group. See also #kPluginGroupDoNotTarget.\nDo not set both this option and \\c #kPluginGroupAlwaysSmartTarget for the\nsame plug-in group."]
pub const AIPluginGroupOptions_kPluginGroupDoNotSmartTarget: AIPluginGroupOptions = 2048;
#[doc = "\tIf on, plug-in objects of this plug-in group can be clipping objects.\nThe result art of a clipping object is used as a clip, if its type\nmakes this possible."]
pub const AIPluginGroupOptions_kPluginGroupCanBeClipping: AIPluginGroupOptions = 4096;
#[doc = "\tIf on, the Layers palette always shows the contents of the edit group."]
pub const AIPluginGroupOptions_kPluginGroupAlwaysShowContents: AIPluginGroupOptions = 8192;
#[doc = "\tIf on, the Layers palette queries the plug-in group with the\n\\c #kSelectorAICanShowContents message to ask if it may expand\nthe plug-in group. The plug-in group should reply with \\c #kRefusePluginGroupReply\nif it is \\e not okay to expand."]
pub const AIPluginGroupOptions_kPluginGroupAskToShowContents: AIPluginGroupOptions = 16384;
#[doc = " Together with \\c #kPluginGroupBlendAsPluginGroup, defines how plug-in groups\nother than blends act when they appear inside a blend. This one is tested first.\n\nIf on, and the selection includes any other plug-in group with this flag on,\nthe Make Blend command is disabled. Also, fully selected plug-in groups with\nthis option on do not respond to clicks of the Blend tool (although you can\nstill create blends INSIDE of them.)\n\nIf the selection contains no plug-in groups with this flag on, then plug-in groups\nthat are blended to anything other than another plug-in group of the same class\nwith the \\c #kPluginGroupBlendAsPluginGroup flag on are treated as if they\nwere their result group. The interpolated objects are ordinary groups."]
pub const AIPluginGroupOptions_kPluginGroupDisableBlends: AIPluginGroupOptions = 32768;
#[doc = " Together with \\c #kPluginGroupDisableBlends, defines how plug-in groups\nother than blends act when they appear inside a blend.\n\\c #kPluginGroupDisableBlends is tested first.\n\nIf the blend includes two adjacent plug-in groups of the same plug-in class,\nand this option on for that class, then the interpolated objects\nare also of the same plug-in class. The contents of the edit groups of\nthe two plug-in objects are blended as if they were ordinary groups. The plug-in\ncan then interpolate the plug-in group data and dictionary contents;\nsee \\c #kSelectorAIInterpolateData. Finally the interpolated plug-in groups are\nsent the \\c #kSelectorAIUpdateArt message."]
pub const AIPluginGroupOptions_kPluginGroupBlendAsPluginGroup: AIPluginGroupOptions = 65536;
#[doc = " If on, the plug-in group restricts which types of objects can be inserted\ninto its edit group, and should handle the \\c #kSelectorAIDisallowsArtTypeQuery\nmessage. This differs from the check you do for a \\c #kBeforeOperationTime\n\\c #kSelectorAINotifyEdits response, in that such a check passes in\na specific prospective-contents object to a specific plug-in group, and checks\nwhether that object can be inserted. The \\c #AIPluginArtTypeMessageData does not\nhave a specific art object, only an art type. You can use it, for example, to\ndisable tools  or commands that might otherwise create a new object of that type,\nor to provide cancel feedback on mouse over."]
pub const AIPluginGroupOptions_kPluginGroupRestrictsArtTypes: AIPluginGroupOptions = 131072;
#[doc = " Provides a lighter-weight, less flexible version of customized fill hit testing.\n\nIf on, the plug-in group is treated as if it supplied fill paint on closed paths,\nso that selection tools select those paths in the edit group when clicking\nin their interiors, even if they have no fill paint of their own and no ancestor art style supplies\nfill paint.\n\nSee also  \\c #kPluginGroupForceFillHitOnAllPaths (the same, but for all paths)\n\nEdit fill hit testing is done only after outline testing fails to hit anything in\nthe whole edit group, so front contents do not obscure outlines of back contents. It is also done\nonly if something is hit in the result group, so that paths that are unfilled and that do not\noverlap any filled region are not selected.\n\nIf on, this option takes precedence over \\c #kPluginGroupDoEditFillHitOption, meaning that\nthe plug-in group has private data that it uses to supply fills (rather than edit objects\nbeing copied into the result group).\n\nThis option is not the best choice if the plug-in group supplies private fills\non only some parts of the edit group, or if the fill geometry is transformed. In that case,\ncustom hit testing allows more customization, but takes longer."]
pub const AIPluginGroupOptions_kPluginGroupForceFillHitOnClosedPaths: AIPluginGroupOptions = 262144;
#[doc = " Provides a lighter-weight, less flexible version of customized fill hit testing.\n\nIf on, the plug-in group is treated as if it supplied fill paint on all paths,\nso that selection tools select those paths in the edit group when clicking\nin their interiors, even if they have no fill paint of their own and no ancestor art style supplies\nfill paint.\n\nSee  \\c #kPluginGroupForceFillHitOnClosedPaths for additional details."]
pub const AIPluginGroupOptions_kPluginGroupForceFillHitOnAllPaths: AIPluginGroupOptions = 524288;
#[doc = " If on, paint styles applied to content of this plug-in group should not be obtained or set\nby accessing the art styles of objects in the edit group, but instead by asking the plug-in group to\nget or set the paint styles attached to objects that it considers selected. The plug-in\nreceives the \\c #kSelectorAICollectPaintStyles message when Illustrator would normally\niterate the art styles attached to children of the edit group, and receives the\n\\c #kSelectorAIApplyPaintStyles message when Illustrator would normally set the art\nstyles attached to children of the edit group.\n\nSee also \\c #AIPluginGroupCollectPaintStylesData, \\c #AIPluginGroupApplyPaintStylesData\n\nUse if art styles attached to selected objects in the edit group do not reflect what the user\nsees as the selected styles. (The contents of the edit group are not previewed, so the styles\nin the result group are what the user sees, and they may not correspond\tdirectly to the styles used\nin the edit group.) Also useful for plug-in groups that manage selection state in a way that does\nnot map directly onto object selection within the edit group.\n\nThis flag is not compatible with any of the target flags (\\c #kPluginGroupDoNotTarget,\n\\c #kPluginGroupAlwaysSmartTarget, \\c #kPluginGroupDoNotSmartTarget)."]
pub const AIPluginGroupOptions_kPluginGroupManagesPaintStyles: AIPluginGroupOptions = 1048576;
#[doc = " If on, the plugin group allows at least some grouping operations to be performed\ninside of it. Grouping operations include Group, Ungroup, Make Compound, Make Clip,\nand their corresponding Release operations, plus Expand Appearance and Expand,\nsince they typically convert a leaf object into a group. If off, no grouping\noperations are attempted and no #kCheckOperationTime message is sent.\nThe reason there is a flag rather than just using a #kCheckOperationTime message\nbefore the edit, as is done for most kinds of edits, is that until CS 6, grouping\noperations were unilaterally disallowed inside all plugin groups. Since the default\nfor no response to a kCheckOperationTime message is to assume that the operation\nIS allowed, in order not to alter the runtime environment for legacy plugins we\nmust default to sending no message and not attempting the operation."]
pub const AIPluginGroupOptions_kPluginGroupPermitsGroupCmds: AIPluginGroupOptions = 2097152;
#[doc = " Options for \\c #AIPluginGroupSuite::AddAIPluginGroup().\nOptions affect how operations on a plug-in group affect the\nresult group, and whether the notifications are\tsent after an operation.\nNotifications include \\c #kSelectorAIUpdateArt \"AI Update\" and\n\\c #kTransformOperationCode \"AI Notify Edits\".\n(Options cannot be changed after the class is defined.)"]
pub type AIPluginGroupOptions = ::std::os::raw::c_uint;
#[doc = " For the \\c #kSelectorAINotifyEdits and \\c #kSelectorAIInterpolateData\nmessages, an operation time that indicates the\nrelationship of the notification to the stage of the operation.\nAn \\c #AIPluginGroupMessage::AIOperationTime value.\nThe times are:\n<br> \\c\t#kCheckOperationTime\n<br> \\c #kBeforeOperationTime\n<br> \\c #kAfterOperationTime\n<br> \\c #kDuringOperationTime\n\n@note You must not dispose of or reorder any artwork objects during a\n\\c #kCheckOperationTime or \\c #kBeforeOperationTime notification.\nAny editing must wait until \\c #kAfterOperationTime."]
pub type AIOperationTime = *const ::std::os::raw::c_char;
#[doc = " For \\c #kSelectorAINotifyEdits, an \\c #AIPluginGroupMessage::code\nvalue that indicates the type of editing operation being performed.\n\nThese code values refer to the entire plug-in group object:\n<br> \\c #kReadOperationCode\n<br> \\c #kWriteOperationCode\n<br> \\c #kAttachOperationCode\n<br> \\c #kExpandOperationCode\n\nFor these code values, the editing parameters,\n\\c #AIPluginGroupMessage::preEditArt and \\c #AIPluginGroupMessage::postEditArt\nindicate the edit group or member that has been or will be edited:\n<br> \\c #kOrderingOperationCode\n<br> \\c #kTransformOperationCode\n<br> \\c #kGeometryOperationCode\n<br> \\c #kTopologyOperationCode\n<br> \\c #kDeleteOperationCode\n<br> \\c #kAttributeOperationCode\n<br> \\c #kStyleOperationCode\n<br> \\c #kChangeOperationCode\n\nThe editing parameters are valid only during \\c #kCheckOperationTime and\n\\c #kBeforeOperationTime, where one notify-edits message is sent for\neach top-level affected or selected descendant of the plug-in object.\nFor example, if an entire group is selected but its parent is not fully selected,\nthat group is passed as the \\c preEditArt, but not its children.\n\nFor some codes, additional subcodes indicate which of several operations of\nthe given type is occurring. Subcodes are \\c #AIErr (four-byte \\c char) values,\nthat can be used in debugging as well as allowing switch statements."]
pub type AIOperationCode = *const ::std::os::raw::c_char;
#[doc = " Something in the edit group has been modified by plug-in calls, and\nIllustrator is about to pop the context. There will have been no\n\\c #kBeforeOperationTime notification. Handler must not modify anything other\nthan the plug-in object itself (because it is called in a loop that\nis processing the artwork tree)."]
pub const AIChangeOperationSubcodes_kPluginSyncArtOpCode: AIChangeOperationSubcodes = 1347179847;
#[doc = " Subcode values for \\c #kChangeOperationCode (only at \\c #kAfterOperationTime)"]
pub type AIChangeOperationSubcodes = ::std::os::raw::c_uint;
pub const AIOrderingOperationSubcodes_kSendToBackOpCode: AIOrderingOperationSubcodes = 1111573323;
pub const AIOrderingOperationSubcodes_kSendToFrontOpCode: AIOrderingOperationSubcodes = 1179799124;
pub const AIOrderingOperationSubcodes_kSendBackwardOpCode: AIOrderingOperationSubcodes = 1146050382;
pub const AIOrderingOperationSubcodes_kSendForwardOpCode: AIOrderingOperationSubcodes = 1431328580;
pub const AIOrderingOperationSubcodes_kReverseGroupOpCode: AIOrderingOperationSubcodes = 1381388883;
#[doc = " The \\c #AIPluginGroupMessage::preEditArt is in the plug-in group,\nand is being moved to another location which is also inside the plug-in group.\nSee \\c #AIPluginGroupMessage::insertionOrder and \\c #AIPluginGroupMessage::destinationArt\nfor the destination of the move.\nUsed only if the movement is not equivalent to one of the more specific commands above."]
pub const AIOrderingOperationSubcodes_kSendInternalOpCode: AIOrderingOperationSubcodes = 1397313108;
#[doc = " The \\c #AIPluginGroupMessage::preEditArt is in the plug-in group, and is about\nto be reordered to a location outside the plug-in group.\nSee \\c #AIPluginGroupMessage::insertionOrder and \\c #AIPluginGroupMessage::destinationArt\nfor the destination of the move.\nThis is a chance to remove any private dictionary entries from the \\c preEditArt.)"]
pub const AIOrderingOperationSubcodes_kReorderOutCode: AIOrderingOperationSubcodes = 1297502036;
#[doc = " The \\c #AIPluginGroupMessage::preEditArt is outside the plug-in group, and is\nabout to be reordered to a location inside the plug-in group,\nSee \\c #AIPluginGroupMessage::insertionOrder and \\c #AIPluginGroupMessage::destinationArt\nfor the destination of the move.\n(Typically handled in the same way as a \\c #kPasteIntoOpCode for \\c #kTopologyOperationCode.)"]
pub const AIOrderingOperationSubcodes_kReorderIntoOpCode: AIOrderingOperationSubcodes = 1297500494;
#[doc = " Subcode values for \\c #kOrderingOperationCode"]
pub type AIOrderingOperationSubcodes = ::std::os::raw::c_uint;
pub const AITransformOperationSubcodes_kTranslationOpCode: AITransformOperationSubcodes =
    1297045061;
pub const AITransformOperationSubcodes_kRotationOpCode: AITransformOperationSubcodes = 1380930625;
pub const AITransformOperationSubcodes_kUniformScaleOpCode: AITransformOperationSubcodes =
    1431520065;
pub const AITransformOperationSubcodes_kNonUniformScaleOpCode: AITransformOperationSubcodes =
    1314079553;
pub const AITransformOperationSubcodes_kShearOpCode: AITransformOperationSubcodes = 1397245266;
pub const AITransformOperationSubcodes_kReflectionOpCode: AITransformOperationSubcodes = 1380271692;
pub const AITransformOperationSubcodes_kMixedTransformOpCode: AITransformOperationSubcodes =
    1297368653;
#[doc = " Subcode values for \\c #kTransformOperationCode"]
pub type AITransformOperationSubcodes = ::std::os::raw::c_uint;
pub const AIGeometryOperationSubcodes_kMiscPathChangeOpCode: AIGeometryOperationSubcodes =
    1195724621;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kMovePointsOpCode: AIGeometryOperationSubcodes = 1297110099;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kAdjustControlsOpCode: AIGeometryOperationSubcodes =
    1094994499;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kAddPointsOpCode: AIGeometryOperationSubcodes = 726684755;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kRemovePointsOpCode: AIGeometryOperationSubcodes = 760239187;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kReverseSegmentsOpCode: AIGeometryOperationSubcodes =
    1381388883;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kOpenCloseOpCode: AIGeometryOperationSubcodes = 1330660172;
#[doc = " Unused"]
pub const AIGeometryOperationSubcodes_kSwapSymbolsOpCode: AIGeometryOperationSubcodes = 1398231885;
#[doc = " Subcode values for \\c #kGeometryOperationCode"]
pub type AIGeometryOperationSubcodes = ::std::os::raw::c_uint;
#[doc = " One path is replaced by two."]
pub const AITopologyOperationSubcodes_kScissorOpCode: AITopologyOperationSubcodes = 1396918618;
#[doc = " The \\c #AIPluginGroupMessage::postEditArt (or its children if it is a group)\nwill be inserted into the edit art below \\c #AIPluginGroupMessage::preEditArt\n(which is the same as \\c #AIPluginGroupMessage::destinationArt.)"]
pub const AITopologyOperationSubcodes_kPasteBelowOpCode: AITopologyOperationSubcodes = 1346520396;
#[doc = " The \\c #AIPluginGroupMessage::postEditArt (or its children if it is a group)\nwill be inserted above \\c #AIPluginGroupMessage::preEditArt\n(which is the same as \\c #AIPluginGroupMessage::destinationArt.)"]
pub const AITopologyOperationSubcodes_kPasteIntoOpCode: AITopologyOperationSubcodes = 1346981460;
#[doc = " The \\c #AIPluginGroupMessage::postEditArt (or its children if it is a group)\nwill be inserted below \\c #AIPluginGroupMessage::preEditArt\n(which is the same as \\c #AIPluginGroupMessage::destinationArt.)"]
pub const AITopologyOperationSubcodes_kPasteAboveOpCode: AITopologyOperationSubcodes = 1346454102;
#[doc = " The \\c #AIPluginGroupMessage::postEditArt is a transformed copy of \\c preEditArt.\nTypically it will be inserted above \\c #AIPluginGroupMessage::preEditArt.\nCheck \\c #AIPluginGroupMessage::destinationArt and \\c #AIPluginGroupMessage::insertionOrder\nfor the insertion location."]
pub const AITopologyOperationSubcodes_kTransformCopyOpCode: AITopologyOperationSubcodes =
    1413697360;
#[doc = " The \\c #AIPluginGroupMessage::preEditArt will be changed into a type path."]
pub const AITopologyOperationSubcodes_kTypePathChangeOpCode: AITopologyOperationSubcodes =
    1415136072;
#[doc = " Unused"]
pub const AITopologyOperationSubcodes_kReplaceOneOpCode: AITopologyOperationSubcodes = 1380274225;
#[doc = " Unused"]
pub const AITopologyOperationSubcodes_kReplaceByManyOpCode: AITopologyOperationSubcodes =
    1380274253;
#[doc = " The \\c #AIPluginGroupMessage::postEditArt is a non-transformed copy of \\c preEditArt,\nwhich will be inserted in the art edit group or a descendant.\nCheck \\c #AIPluginGroupMessage::destinationArt and\n\\c #AIPluginGroupMessage::insertionOrder for the insertion location."]
pub const AITopologyOperationSubcodes_kDuplicateInsideOpCode: AITopologyOperationSubcodes =
    1146441833;
#[doc = " Sent only at \\c #kAfterOperationTime. The \\c #AIPluginGroupMessage::postEditArt\nis a copy of \\c preEditArt which was moved outside the plug-in group.\nAllows you to remove any private tags or dictionary entries\nfrom the \\c postEditArt."]
pub const AITopologyOperationSubcodes_kDuplicateOutsideOpCode: AITopologyOperationSubcodes =
    1146441839;
#[doc = " The selected objects inside the plugin group are to be combined into a\ngroup, compound path, or clipping group. The \\c #AIPluginGroupMessage::preEditArt\nis the first encountered selected component of the plugin group, which determines\nwhere the new group will be placed in the stacking order. At \\c #kCheckOperationTime\nand \\c #kBeforeOperationTime the \\c #AIPluginGroupMessage::postEditArt is an\nempty art object of the type that is going to be created. The plugin can call\n\\c #AIArtSuite::GetArtType() to determine whether a group or compound path is being\ncreated, and can call \\c #AIGroupSuite::GetGroupClipped() when the type is \\c #kGroupArt\nto determine when a clipping group is being created. The \\c postEditArt at pre-edit\ntime is not necessarily the same \\c AIArtHandle that is created,\nand is definitely not in the art tree; it has a null parent.\nIf this message is sent at \\c #kAfterOperationTime, the \\c postEditArt is the\nresulting group or compound path art.\nThis operation code is sent only if the \\c #kPluginGroupPermitsGroupCmds option\nis set. If that option is off, no group operations are attempted."]
pub const AITopologyOperationSubcodes_kMakeGroupOpCode: AITopologyOperationSubcodes = 1196578128;
#[doc = " The \\c #AIPluginGroupMessage::preEditArt will be ungrouped or released.\nIf it is a nested plugin group, it will be replaced by its edit art group.\nThis operation code is sent only if the #kPluginGroupPermitsGroupCmds option\nis set. If that option is off, no release group operations are attempted."]
pub const AITopologyOperationSubcodes_kReleaseGroupOpCode: AITopologyOperationSubcodes = 1431193424;
#[doc = " If non-null, the \\c #AIPluginGroupMessage::preEditArt will be expanded into a group\nthat expands all or part of the appearance. If it is a nested plugin group, it will\nbe expanded into its result group. If it is an object with an active art style,\nit will be replaced by the styled art. If it has a basic appearance, either the\nfills or strokes or both will be expanded. If the \\c preEditArt is null or is the\nplugin group itself, then the plugin group is partially selected and is about to be\nexamined by one of the Expand commands. This gives the plugin group a chance to return\n\\c #kRefusePluginGroupReply to skip examination of the contents, if the plugin group\ndisallows all expansions inside (but allows \\c #kMakeGroupOpCode and/or \\c #kReleaseGroupOpCode.)\nNo attempt is made to inform the plugin group of the details of the operation,\nas there are too many variations, and the main intent is to ask whether the expansion\nis allowed at all.\nThis operation code is sent only if the \\c #kPluginGroupPermitsGroupCmds option\nis set. If that option is off, no expansion operations are attempted inside the\nplugin group.\nSee also \\c #kExpandOperationCode for notifications of the expansion of the entire\nplugin group."]
pub const AITopologyOperationSubcodes_kExpandInsideOpCode: AITopologyOperationSubcodes = 1165520969;
#[doc = " Subcode values for \\c #kTopologyOperationCode  These are sent\nat \\c #kBeforeOperationTime, and provide additional information\nabout what type of change is about to occur. Your handler can update\nprivate data, but must not make any changes to the edit group."]
pub type AITopologyOperationSubcodes = ::std::os::raw::c_uint;
pub const AIStyleOperationSubcodes_kPathStyleOpCode: AIStyleOperationSubcodes = 1346458696;
#[doc = " Unused"]
pub const AIStyleOperationSubcodes_kTextStyleOpCode: AIStyleOperationSubcodes = 1096041812;
#[doc = " Unused"]
pub const AIStyleOperationSubcodes_kArtStyleOpCode: AIStyleOperationSubcodes = 1095914579;
#[doc = " Subcode values for \\c #kStyleOperationCode"]
pub type AIStyleOperationSubcodes = ::std::os::raw::c_uint;
pub const AIAttributeOperationSubcodes_kHideOpCode: AIAttributeOperationSubcodes = 1212761157;
pub const AIAttributeOperationSubcodes_kShowOpCode: AIAttributeOperationSubcodes = 1397247831;
pub const AIAttributeOperationSubcodes_kLockOpCode: AIAttributeOperationSubcodes = 1280262987;
pub const AIAttributeOperationSubcodes_kUnlockOpCode: AIAttributeOperationSubcodes = 1431194699;
pub const AIAttributeOperationSubcodes_kSetNameOpCode: AIAttributeOperationSubcodes = 1312902469;
#[doc = " Subcode values for \\c #kAttributeOperationCode\nBy default, a c #kNoErr return (usually meaning the notification was not handled)\nfor the Name subcode does not mark the plugin group dirty, because it is not\nexpected to change the contents of the result group for a typical plugin group.\nThis is in contrast to most edit notifications, which mark the plugin group\ndirty unless it receives a \\c #kDontCarePluginGroupReply from a \\c #kBeforeOperationTime\nnotification or a \\c #kMarkValidPluginGroupReply from a \\c #kAfterOperationTime notification.\nSince there is no reply that tells the plugin group to invalidate itself on these\nnotifications, if a rebuild is wanted on a change of name the plugin group\nshould call \\c #AIPluginGroupSuite::MarkPluginArtDirty() while handling the message."]
pub type AIAttributeOperationSubcodes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AIClassOpaque {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to a plug-in group, never dereferenced.\nAccess with \\c #AIPluginGroupSuite."]
pub type AIPluginGroupHandle = *mut _t_AIClassOpaque;
#[doc = " Developer-defined data for \\c #AIInterruptProc callback."]
pub type AIInterruptData = *mut ::std::os::raw::c_void;
#[doc = " Callback function prototype for \\c #AIPluginGroupMessage::proc.\nAn update or interpolate handler that will take a long time can\ncall this function any number of times, to give time back to the\ncore for other processing (such as preview and other event handling).\nWhen it returns an error, your handler should stop processing and\nreturn the error. It will get a chance again later to update.\n@param art The art object.\n@param data Developer-defined data to pass through.\n@return An error to halt processing of the update or interpolate notification."]
pub type AIInterruptProc =
    ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, data: AIInterruptData) -> ASErr>;
#[doc = " \\c #AIPluginGroupMessage::style value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union StyleUnion {
    #[doc = " The path style. If partial, the  \\c #AIPluginGroupMessage::styleMap\nindicates which fields are valid."]
    pub path_s: *mut AIPathStyle,
    #[doc = " Unused"]
    pub art_s: AIArtStyleHandle,
}
#[doc = " \\c #AIPluginGroupMessage::styleMap value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union StyleMapUnion {
    #[doc = " A style map that indicates which fields are valid in\na partial \\c #AIPluginGroupMessage::style value."]
    pub path_s_map: *mut AIPathStyleMap,
}
#[doc = " Sent with the \\c #kSelectorAINotifyEdits, \\c #kSelectorAIUpdateArt,\n\\c #kSelectorAICanShowContents and \\c #kSelectorAIInterpolateData notifications.\n\nThe \\c #kSelectorAINotifyEdits notifies of edits in the edit group. In this case the \\c time\nand \\c code members provide more information about the stage of the editing\noperation and the operation being performed. Additional members provide information\nabout what is being edited, how it is being edited and the replacement art that will\nbe the edited result.<br>\nProcess this information and return one of these error codes to control how the operation\nproceeds:\n<br> \\c #kRefusePluginGroupReply\n<br> \\c #kWantsAfterMsgPluginGroupReply\n<br> \\c #kMarkValidPluginGroupReply\n<br> \\c #kDontCarePluginGroupReply\n<br> \\c #kDestroyPluginGroupReply\n\nThe \\c #kSelectorAIUpdateArt message is sent to request that the plug-in group manager\nrebuild the result group in response to edits in the edit group. In this case the\nonly the \\c proc and \\c data fields are used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIPluginGroupMessage {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group object."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object."]
    pub art: AIArtHandle,
    #[doc = " For \\c #kSelectorAINotifyEdits and \\c #kSelectorAIInterpolateData\nmessages, the stage of the operation (check if allowed, before, during, after)."]
    pub time: AIOperationTime,
    #[doc = " For \\c #kSelectorAINotifyEdits, the specific operation being performed."]
    pub code: AIOperationCode,
    #[doc = " For \\c #kSelectorAINotifyEdits, the descendant of the edit art group that\nis\tabout to be edited."]
    pub preEditArt: AIArtHandle,
    #[doc = " For \\c #kSelectorAINotifyEdits, the object what will be in the edit group when the\noperation completes. For edits that change attributes but keep the same art object\n(such as most style operations), the same as \\c preEditArt. At \\c #kBeforeOperationTime,\nthe attributes have not yet been modified.\nIf not the same as \\c preEditArt, the object is not in the edit art group until\n\\c #kAfterOperationTime. Transformation, geometry changes or attribute changes\nhave already been performed on the object, but is has not yet been inserted into the artwork.\n\n@note You must not dispose of or reorder any artwork objects during a\n\\c #kCheckOperationTime or \\c #kBeforeOperationTime notification.\nAny editing must wait until \\c #kAfterOperationTime."]
    pub postEditArt: AIArtHandle,
    #[doc = " For some operation codes, a subcodes that further describes\nthe operation being performed. See \\c #AIOperationCode.\nSubcodes are four-byte chars like \\c AIErr, that facilitate debugging\nwhile still allowing switch statements."]
    pub subCode: AIErr,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kTransformOperationCode\nor \\c subCode is \\c #kTransformCopyOpCode.\nThe matrix used for the transformation."]
    pub matrix: AIRealMatrix,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kStyleOperationCode.\nThe style that was modified."]
    pub style: StyleUnion,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kStyleOperationCode.\nIndicates which  fields of \\c style are valid, if it is a partial style.\nIf \\c NULL, all style fields are valid."]
    pub styleMap: StyleMapUnion,
    #[doc = " For \\c #kSelectorAIUpdateArt and \\c #kSelectorAIInterpolateData,\nA callback that allows you to interrupt lengthy processing."]
    pub proc_: AIInterruptProc,
    #[doc = " For \\c #kSelectorAIUpdateArt and \\c #kSelectorAIInterpolateData.\nDeveloper-defined data to pass through to the \\c proc callback."]
    pub data: AIInterruptData,
    #[doc = " For \\c #kSelectorAIInterpolateData.\n<br>At \\c #kBeforeOperationTime or \\c #kAfterOperationTime,\nthe number of steps in the blend.\n<br> At \\c #kDuringOperationTime, the number of this step (first step is 1)."]
    pub steps: ::std::os::raw::c_int,
    #[doc = " For \\c #kSelectorAIInterpolateData.\n<br> The distance of this interpolation between the source and destination\nof the blend. [0..1], where 0 is the source (\\c preEditArt) and 1 is\nthe destination (\\c postEditArt)."]
    pub t: AIReal,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kGeometryOperationCode\nand \\c subCode is \\c #kSwapSymbolsOpCode. In this case, \\c art is a symbol\ninstance in the edit group, and this is the replacement symbol.\n(If your plug-in group uses symbols in its art dictionary, see also\n\\c #kSelectorAIReplaceSymbol.)"]
    pub toSymbol: AIPatternHandle,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kTransformOperationCode or\n\\c subCode is \\c #kTransformCopyOpCode. Transformation options,\na logical OR of \\c #AITransformArtOptions."]
    pub transformFlags: ai_int32,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kTransformOperationCode or\n\\c subCode is \\c #kTransformCopyOpCode.\nIf \\c transformFlags contains \\c #kScaleLines, the factor by which the strokes\nare scaled."]
    pub transformLineScale: AIReal,
    #[doc = " For reordering, duplicating, and pasting operations, the preposition object in the paint\norder, for relative placement of the new object. See \\c #AIArtSuite::NewArt."]
    pub destinationArt: AIArtHandle,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied for reordering, duplicating and\npasting operations. The paint-order placement of the new object,\nrelative to the \\c destinationArt object. Cannot be \\c #kPlaceAboveAll\nor \\c #kPlaceBelowAll (because the object must go inside a plug-in group).\nNever \\c #kPlaceDefault (it is translated into a more specific\npaint order before notification)."]
    pub insertionOrder: AIPaintOrder,
    #[doc = " For \\c #kSelectorAINotifyEdits, supplied if \\c code is \\c #kReadOperationCode\n\\c #kWriteOperationCode. The version of the Illustrator file\nbeing read from or written to. For other operations, the value is 0."]
    pub aiVersion: AIVersion,
    #[doc = "For \\c #kSelectorAIPluginArtDocScaleChange, supplied if there is a change in the document scale,\nthe corresponding plugin can make changes according to the relative scale"]
    pub relativeScaleFactor: AIReal,
}
#[doc = " Data for the \\c #kSelectorAIReplaceSymbol notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIReplaceSymbolMessageData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object."]
    pub art: AIArtHandle,
    #[doc = " A symbol to be replaced, referenced by the plug-in group\nin its dictionary, or \\c NULL to replace all used symbols."]
    pub targetSymbol: AIPatternHandle,
    #[doc = " The replacement symbol."]
    pub replacementSymbol: AIPatternHandle,
}
#[doc = " Data for the \\c #kSelectorAIDisallowsArtTypeQuery notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginArtTypeMessageData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group for which insertion is requested."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The \\c #AIArtType of art potentially inserted into the group."]
    pub artType: ::std::os::raw::c_short,
}
#[doc = " A callback that you must supply with the \\c #AIPluginGroupCustomHitTestData::CustomHitData,\nthat casts the void* data to the appropriate type and disposes of it properly."]
pub type AICustomHitDataDeleteFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Data for the \\c #kSelectorAIPerformCustomHitTest notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginGroupCustomHitTestData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object that was hit."]
    pub art: AIArtHandle,
    #[doc = " The hit location coordinates."]
    pub location: AIRealPoint,
    pub CustomHitData: AIPluginGroupCustomHitTestData__bindgen_ty_1,
}
#[doc = " A structure in which to record custom hit information.\nAccess after the hit test with \\c #AIHitTestSuite::GetCustomHitData()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginGroupCustomHitTestData__bindgen_ty_1 {
    #[doc = " [in] The data that was provided to \\c #AIHitTestSuite::CustomHitTest()"]
    pub inData: *mut ::std::os::raw::c_void,
    #[doc = " [out] Developer-defined custom hit data. Your plug-in is reponsible for\nallocating and  cleaning up this heap-based data."]
    pub outData: *mut ::std::os::raw::c_void,
    #[doc = " [out] A callback function that properly deletes the\nreturned custom hit data. Required."]
    pub deleteFunc: AICustomHitDataDeleteFunc,
}
#[doc = " Prototype for the \\c #AIPluginGroupCollectPaintStylesData::artStyleCallback.\nCan examine, but not modify the art styles and art objects.\n@param artStyle The current art style.\n@param gradientContext \\c NULL if gradient vectors in the style are relative\nto the whole plug-in group. Otherwise, gradient vectors in the style are\nrelative to this art object.\n@param usage How the style is used (in fills or strokes), an \\c #AIPaintUsage value.\n@param callbackData\tDeveloper-defined data passed from the notification message."]
pub type AIProcessArtStyleFunc = ::std::option::Option<
    unsafe extern "C" fn(
        artStyle: AIArtStyleHandle,
        gradientContext: AIArtHandle,
        usage: ai_int32,
        callbackData: *mut ::std::os::raw::c_void,
    ) -> ASErr,
>;
#[doc = " Prototype for the \\c #AIPluginGroupCollectPaintStylesData::pathStyleCallback.\nCan examine, but not modify the path styles and art objects.\n@param pathStyle The current path style.\n@param psMap A style map that identifies the valid fields in a partial style.\nCan be \\c NULL.\n@param gradientContext \\c NULL if gradient vectors in the style are relative\nto the whole plug-in group. Otherwise, gradient vectors in the style are\nrelative to this art object.\n@param usage How the style is used (in fills or strokes), an \\c #AIPaintUsage value.\n@param callbackData\tDeveloper-defined data passed from the notification message."]
pub type AIProcessPathStyleFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pathStyle: *const AIPathStyle,
        psMap: *const AIPathStyleMap,
        gradientContext: AIArtHandle,
        usage: ai_int32,
        callbackData: *mut ::std::os::raw::c_void,
    ) -> ASErr,
>;
#[doc = " Data for the \\c #kSelectorAICollectPaintStyles notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginGroupCollectPaintStylesData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object whose style contents are being queried"]
    pub pluginArt: AIArtHandle,
    #[doc = " True to iterate only selected styles. (Currently always true.)"]
    pub selectedOnly: AIBoolean,
    #[doc = " Developer-defined data to pass through to the callbacks."]
    pub callbackData: *mut ::std::os::raw::c_void,
    #[doc = " A callback function that examines the art styles in the plug-in art."]
    pub artStyleCallback: AIProcessArtStyleFunc,
    #[doc = " A callback function that examines the path styles in the plug-in art."]
    pub pathStyleCallback: AIProcessPathStyleFunc,
}
#[doc = " Data for the \\c #kSelectorAIApplyPaintStyles message."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AIPluginGroupApplyPaintStylesData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object whose style contents are being modified"]
    pub pluginArt: AIArtHandle,
    #[doc = " When true, apply a transformation using \\c matrix, \\c transformFlags,\nand \\c transformLineScale, and ignore \\c pathStyle and \\c pathStyleMap.\n<br> When false, merge styles using \\c pathStyle and \\c pathStyleMap, and ignore\n\\c matrix, \\c transformFlags, and \\c transformLineScale."]
    pub applyStyleTransform: AIBoolean,
    #[doc = " Fill and stroke information to be merged into the current style."]
    pub pathStyle: AIPathStyle,
    #[doc = " A style map the indicates which fields are valid in a partial path style."]
    pub pathStyleMap: AIPathStyleMap,
    #[doc = " The transformation matrix."]
    pub matrix: AIRealMatrix,
    #[doc = "\tTransformation options, a logical OR of \\c #AITransformArtOptions.\n\\c #kTransformObjects and \\c #kTransformChildren are always off,\nand at least one of \\c #kTransformFillGradients, \\c #kTransformFillPatterns,\n\\c #kTransformStrokePatterns, \\c #kTransformStrokeGradients, or \\c #kScaleLines is on."]
    pub transformFlags: ai_int32,
    #[doc = " If the \\c #kScaleLines option is on, the factor by which to scale the strokes."]
    pub transformLineScale: AIReal,
}
#[doc = " Callback function prototype used to process colors from art style handles\ndirectly contained in the dictionary of a plug-in group. Passed to \\c #kSelectorAIAdjustColors\nin \\c #AIPluginGroupAdjustColorsData::adjustArtStyleCallback.\nAllows various concerned plug-ins to work with the contained styles:\n\n\\li The plug-in with art style handles in its dictionary can use this to find those art styles,\n\\li Another plug-in that implements the effects inside the art styles can use it to access their colors.\n\\li Another plug-in can provides the color-adjustment callback to do the actual color mapping.\n\nThis callback is not typically provided by a third-party plug-in, but is provided internally\nby the implementation of \\c #AIPathStyleSuite::AdjustObjectAIColors(), or by\n\\c #AIPluginGroupSuite::PluginArtAdjustColors(). A plug-in groups with art styles\nin its dictionary need only call this callback, not implement it.\n@param oldArtStyle The art style to be examined. It is not altered.\n@param newArtStyle [out] A buffer in which to return the art style after color adjustment.\nIf no colors are changed, contains the input style.\n@param userData A pointer to developer-defined data needed for the modification,\nacquired from the message data."]
pub type AIAdjustArtStyleFunc = ::std::option::Option<
    unsafe extern "C" fn(
        oldArtStyle: AIArtStyleHandle,
        newArtStyle: *mut AIArtStyleHandle,
        userData: *mut ::std::os::raw::c_void,
    ) -> AIErr,
>;
#[doc = " Data for the \\c #kSelectorAIAdjustColors notification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginGroupAdjustColorsData {
    #[doc = " The message data."]
    pub d: SPMessageData,
    #[doc = " The plug-in group."]
    pub entry: AIPluginGroupHandle,
    #[doc = " The plug-in group art object whose style contents are being modified."]
    pub pluginArt: AIArtHandle,
    #[doc = " When true, iterate only selected colors.In this case, the plug-in group\nwas at least partially selected in object selection mode."]
    pub selectedOnly: AIBoolean,
    #[doc = " When true, iterate colors used in fills."]
    pub adjustFills: AIBoolean,
    #[doc = " When true, iterate colors used in strokes."]
    pub adjustStrokes: AIBoolean,
    #[doc = " Developer-defined data to pass through to the callback.\nCan contain extra parameters needed by the color mapping."]
    pub callbackData: *mut ::std::os::raw::c_void,
    #[doc = " A developer-defined callback function that processes colors. Call on any colors\nthat are directly contained in the plug-in group's private data; that is, not contained\nwithin an \\c #AIArtStyleHandle, \\c #AIPatternHandle, or an \\c #AIArtHandle."]
    pub adjustColorCallback: AIAdjustColorFunc,
    #[doc = " [out] Set to true if the handler modified any colors."]
    pub modifiedSomething: AIBoolean,
    #[doc = " A developer-defined callback function to examine or modify colors contained\nin patterns, symbols, brush patterns or graph designs. Called on objects of these\ntypes that may contain meaningful colors and that are directly stored in the\nplug-in group's private data; that is, not contained within an\n\\c #AIArtStyleHandle, \\c #AIPatternHandle, or an \\c #AIArtHandle.\nFill patterns, for example, are usually stored in an \\c #AIColor, and\nbrush patterns are usually stored in an \\c #AIArtStyleHandle.\nYou will typically call this for symbol handles that are stored independently\nof symbol instances.\n\nThe function does not modify the input pattern. It returns a processed\nhandle of the same type, which the plug-in group should store if it is\ndifferent from the input handle."]
    pub adjustPatternHandleCallback: AIAdjustPatternHandleFunc,
    #[doc = " A developer-defined callback function to examine or modify colors contained\nin art styles, including the private parameters of Live Effects.\nCall on any art style handles that are directly stored in the plug-in group's\nprivate data; that is, not attached to any art object.\n\nThe function does not modify the input style. It returns a processed\nart style, which the plug-in group should store if it is\ndifferent from the input handle."]
    pub adjustArtStyleCallback: AIAdjustArtStyleFunc,
}
#[doc = " Descriptive information for a new plug-in group.\nSee \\c #AIPluginGroupSuite::AddAIPluginGroup()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIAddPluginGroupData {
    #[doc = " Major version number."]
    pub major: ai_int32,
    #[doc = " Minor version number."]
    pub minor: ai_int32,
    #[doc = " Localized descriptive string for error messages."]
    pub desc: *const ::std::os::raw::c_char,
}
#[doc = "\t@ingroup Suites\nThis suite provides functions for working with \\e plug-in \\e groups.\n\nA plug-in group organizes artwork that is acted upon by a particular plug-in.\nA plug-in group object is a container of plug-in group art objects.\nIt maintains two groups of art objects; one group that the user interacts\nwith (the \\e edit \\e group), and another group that your plug-in generates\n(the \\e result \\e group). Use the functions in this suite to create\nthese groups and to access their contents.\n\nRegister a plug-in group during startup to manage plug-in group art objects\nof a particular type, using \\c #AIPluginGroupSuite::AddAIPluginGroup().\nStore the returned plug-in group handle in \\c globals, to use in\ncreating plug-in group art objects. All plug-in group art objects\nmust associate themselves with a plug-in group by calling\n\\c #AIPluginGroupSuite::UseAIPluginGroup().\n\nA plug-in group art object is an art object with the type \\c #kPluginArt. The\nedit art group and result art group are art objects with the type\n\\c #kGroupArt, but they are not children of the plug-in group art object.\nAccess them with \\c #AIPluginGroupSuite::GetPluginArtEditArt() and\n\\c #AIPluginGroupSuite::GetPluginArtResultArt().\n\\li Members of the edit group are hidden, but are editable and selectable.\n\\li Members of the result group become visible, but are not selectable.\n\nYou can define and store arbitrary data with a plug-group art object, using\n\\c #AIPluginGroupSuite::SetPluginArtDataRange(),\n\\c #AIPluginGroupSuite::GetPluginArtDataRange(),\n\\c #AIPluginGroupSuite::SetPluginArtDataCount(),\nand  \\c #AIPluginGroupSuite::GetPluginArtDataCount().\n\nA plug-in that manages plug-in groups can receive these selectors,\nwith \\c #kCallerAIPluginGroup as the caller, accompanied by\nan \\c #AIPluginGroupMessage:\n<br> \\c #kSelectorAINotifyEdits\n<br> \\c #kSelectorAIUpdateArt\n<br> \\c #kSelectorAICanShowContents\n<br> \\c #kSelectorAIInterpolateData\n\nIt can also receive these selectors:\n<br> \\c #kSelectorAIReplaceSymbol (sends \\c #AIReplaceSymbolMessageData)\n<br> \\c #kSelectorAIDisallowsArtTypeQuery (sends \\c #AIPluginArtTypeMessageData)\n<br> \\c #kSelectorAIPerformCustomHitTest (sends \\c #AIPluginGroupCustomHitTestData)\n<br> \\c #kSelectorAICollectPaintStyles (sends \\c #AIPluginGroupCollectPaintStylesData)\n<br> \\c #kSelectorAIApplyPaintStyles (sends \\c #AIPluginGroupApplyPaintStylesData)\n<br> \\c #kSelectorAIAdjustColors (sends \\c #AIPluginGroupAdjustColorsData)\n\nThe Live Blend tool is an example of how plug-in groups are used.\nA live blend is created by drawing two objects, then clicking them\nseparately with the blend tool. After the second click, the tool draws\na series of intermediate objects between the original source and destination\nobjects to create a smooth blend between them. Only the source and destination\nobjects are selectable or editable. When you edit or move the source or\ndestination objects, the intermediate objects are regenerated. The document\ncontains only the original two objects in the art tree.\nIn this case, the source and destination art objects (as well as the spine\nwhich links the two objects) are children of the edit group, and the intermediate\nobjects (as well as a copy of the original source and destination objects) are\nchildren of the result group.\n\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIPluginGroupSuite and \\c #kAIPluginGroupVersion.\n\n@section Plug-in Group Example\n\nFirst, register the plug-in group:\n\n@code\nsAIPluginGroup->AddAIPluginGroup (\nmessage->d.self,\n\"My Plugin Group Plugin\",\n&pluginGroupData,\nkPluginGroupWantsAutoTransformOption,\n&g->myPluginGroupHandle\n);\n@endcode\n\nCreate the plug-in group art, typically in response to a menu item or a click\nin your dialog, then associate the plug-in group art with the plug-in group.\n\n@code\nsAIArt->NewArt( kPluginArt, kPlaceAboveAll, NULL, &pluginGroupArt );\nsAIPluginGroup->UseAIPluginGroup (pluginGroupArt, g->myPluginGroupHandle );\n@endcode\n\nThis activates the plug-in group art and allows you to access\nits edit and result groups.\n\nUpon activation, your plug-in starts to receive notifications.\nIn response to \\c #kSelectorAIUpdateArt or \\c #kSelectorAINotifyEdits\nnotifications, you must regenerate the objects in the result group\nThe update message is the easiest and most effective notifier to use.\nIt is sent whenever any of the edit-group objects are modified.\nIn your main loop, listen for the \\c #kCallerAIPluginGroup caller\nand \\c #kSelectorAIUpdateArt selector and respond by regenerating the\nresult-group objects according to the new state of the edit-group objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIPluginGroupSuite {
    #[doc = " Creates a plug-in group.\n@param self This plug-in.\n@param name A unique identifying name for the plug-in group.\nThis name is displayed in error messages, and differs\nfrom the \\e default name used in the Layers\nand Appearance palettes; see \\c #SetAIPluginGroupDefaultName().\n@param data The version and error-reporting information for the group.\n@param options Option flags that determine the behavior of members,\na logical OR of \\c #AIPluginGroupOptions. You cannot change these\nafter they are set.\n@param entry [out] A buffer in which to return the plug-in group object."]
    pub AddAIPluginGroup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: SPPluginRef,
            name: *const ::std::os::raw::c_char,
            data: *mut AIAddPluginGroupData,
            options: ai_int32,
            entry: *mut AIPluginGroupHandle,
        ) -> AIErr,
    >,
    #[doc = " Associates a plug-in group art object with a plug-in group, activating\nthe plug-in group and automatically creating the contained edit and\nresult groups. After calling this function, your plug-in starts to\nreceive plug-in group selectors.\n\nYou can only access the edit and result groups through this art object;\nsee \\c #GetPluginArtEditArt() and \\c #GetPluginArtResultArt().\n\nThe art object inherits the plug-in group's name and version attributes,\nwhich you can then access either through the group (\\c #GetAIPluginGroupName(),\nfor example) or the art object (\\c #GetPluginArtName()). The plug-in group\nname is used for error messages, and differs from the art object's name,\nused in the Layers and Appearance palettes; see \\c #GetAIPluginGroupDefaultName().\n\nYou can move the art object to a new plug-in group with \\c #SetPluginArtPluginGroup().\n@param art An art object of type \\c #kPluginArt, created with \\c #AIArtSuite::NewArt().\n@param entry The plug-in group object."]
    pub UseAIPluginGroup: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, entry: AIPluginGroupHandle) -> AIErr,
    >,
    #[doc = " Retrieves the name of a plug-in group. This name is displayed in error messages,\nand can differ from the display name (called the \\e default name) used in\nthe Layers and Appearance palettes; see \\c #GetAIPluginGroupDefaultName().\n@param entry The plug-in group object.\n@param name [out] A buffer in which to return the name."]
    pub GetAIPluginGroupName: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIPluginGroupHandle,
            name: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the version information of a plug-in group.\n@param entry The plug-in group object.\n@param major [out] A buffer in which to return the major version number.\n@param minor [out] A buffer in which to return the minor version number."]
    pub GetAIPluginGroupVersion: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIPluginGroupHandle,
            major: *mut ai_int32,
            minor: *mut ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the description of a plug-in group, a localized string that Illustrator\nuses for error reporting.\n@param entry The plug-in group object.\n@param desc [out] A buffer in which to return the description."]
    pub GetAIPluginGroupDescription: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIPluginGroupHandle,
            desc: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the option flags of a plug-in group.\n@param entry The plug-in group object.\n@param options [out] A buffer in which to return the options, a logical OR\nof \\c #AIPluginGroupOptions."]
    pub GetAIPluginGroupOptions: ::std::option::Option<
        unsafe extern "C" fn(entry: AIPluginGroupHandle, options: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves a reference to the plug-in that created a plug-in group.\nYou can pass this reference to functions in the \\c #AIPluginSuite.\n@param entry The plug-in group object.\n@param plugin [out] A buffer in which to return the plug-in object."]
    pub GetAIPluginGroupPlugin: ::std::option::Option<
        unsafe extern "C" fn(entry: AIPluginGroupHandle, plugin: *mut SPPluginRef) -> AIErr,
    >,
    #[doc = " Gets the number of currently registered plug-in group managers. Use with\n\\c #GetNthAIPluginGroup() to iterate through plug-in groups (which can belong\nto different plug-ins).\n@param count [out] A buffer in which to return the number of groups."]
    pub CountAIPluginGroups:
        ::std::option::Option<unsafe extern "C" fn(count: *mut ai_int32) -> AIErr>,
    #[doc = " Retrieves a reference to a plug-in group by position index in the current list\nof registered plug-in group managers. Use with \\c #CountAIPluginGroups to\niterate through plug-in groups (which can belong to different plug-ins).\n@param n The 0-based index position.\n@param entry [out] A buffer in which to return the plug-in group object."]
    pub GetNthAIPluginGroup: ::std::option::Option<
        unsafe extern "C" fn(index: ai_int32, entry: *mut AIPluginGroupHandle) -> AIErr,
    >,
    #[doc = " Retrieves the name of the plug-in group that manages a plug-in group art object.\n@param art The plug-in group art object.\n@param name [out] A buffer in which to return the plug-in group name."]
    pub GetPluginArtName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *mut *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = "  Sets the name of the plug-in group that manages a plug-in group art object.\n@param art The plug-in group art object.\n@param name The new unique identifying name for the plug-in group."]
    pub SetPluginArtName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *mut ::std::os::raw::c_char) -> AIErr,
    >,
    #[doc = " Retrieves the version information for the plug-in group that manages\na plug-in group art object.\n@param art The plug-in group art object.\n@param major [out] A buffer in which to return the major version number.\n@param minor [out] A buffer in which to return the minor version number."]
    pub GetPluginArtVersion: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, major: *mut ai_int32, minor: *mut ai_int32) -> AIErr,
    >,
    #[doc = " Sets the version information for the plug-in group that manages\na plug-in group art object.\n@param art The plug-in group art object.\n@param major The new major version number.\n@param minor The new minor version number."]
    pub SetPluginArtVersion: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, major: ai_int32, minor: ai_int32) -> AIErr,
    >,
    #[doc = " Retrieves the plug-in group that manages a plug-in group art object.\n@param art The plug-in group art object.\n@param entry [out] A buffer in which to return the plug-in group object."]
    pub GetPluginArtPluginGroup: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, entry: *mut AIPluginGroupHandle) -> AIErr,
    >,
    #[doc = " Sets the plug-in group that manages a plug-in group art object.\n@param art The plug-in group art object.\n@param entry The new plug-in group object."]
    pub SetPluginArtPluginGroup:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Retrieves the edit group art object from the plug-in group art object.\n@param art The plug-in group art object.\n@param editArt [out] A buffer in which to return the edit group art object.\n\n@note The edit group art object is \\e not a child of the\nthe plug-in group art object. You can access it with this function,\nand it can be returned by \\c #AIMatchingArtSuite::GetSelectedArt(), which\ncan also return the plug-in group art object itself. <br>\n\\c #AIMatchingArtSuite::GetSelectedArt() or \\c #AIMatchingArtSuite::GetMatchingArt()\ncan return objects in the edit group."]
    pub GetPluginArtEditArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, editArt: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Replaces the edit group of a plug-in group art object.\n@param art The plug-in group art object.\n@param editArt The new edit group object, an art object of type \\c #kGroupArt."]
    pub SetPluginArtEditArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, editArt: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the result group art object from the plug-in group art object.\n@param art The plug-in group art object.\n@param resultArt [out] A buffer in which to return the result group art object.\n\n@note The result group art object is \\e not a child of the\nthe plug-in group art object. You can access it only with this function."]
    pub GetPluginArtResultArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, resultArt: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Replaces the result group of a plug-in group art object.\n@param art The plug-in group art object.\n@param resultArt The new result group object, an art object of type \\c #kGroupArt."]
    pub SetPluginArtResultArt: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, resultArt: AIArtHandle) -> AIErr,
    >,
    #[doc = " Gets the size of the developer-defined data store for a plug-in group art object.\nStore data using \\c #SetPluginArtDataRange(), and access it with \\c #GetPluginArtDataRange().\nThe data is stored as a hexadecimal-encoded string of bytes.\n@param art The plug-in group art object.\n@param count [out] A buffer in which to return the number of bytes of data\nstored, or 0 if there is no data associated with the art object."]
    pub GetPluginArtDataCount:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, count: *mut usize) -> AIErr>,
    #[doc = " Sets the size of the developer-defined data store for a plug-in group art object.\nStore data using \\c #SetPluginArtDataRange(), and access it with \\c #GetPluginArtDataRange().\nThe data is stored as a hexadecimal-encoded string of bytes.\n@param art The plug-in group art object.\n@param count The number of bytes of data."]
    pub SetPluginArtDataCount:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, count: usize) -> AIErr>,
    #[doc = " Retrieves data from the developer-defined data store for a plug-in group art object.\nThe data is stored as a hexadecimal-encoded string of bytes.\n@param art The plug-in group art object.\n@param data [out] A buffer in which to return the data.\n@param index An offset into the data store at which to start reading.\n@param count A number of bytes to read from the data store."]
    pub GetPluginArtDataRange: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            data: *mut ::std::os::raw::c_void,
            index: usize,
            count: usize,
        ) -> AIErr,
    >,
    #[doc = " Writes data to the developer-defined data store for a plug-in group art object.\nThe data is stored as a hexadecimal-encoded string of bytes.\n@param art The plug-in group art object.\n@param data A pointer to the developer-defined data.\n@param index An offset into the data store at which to start writing.\n@param count A number of bytes to write to the data store."]
    pub SetPluginArtDataRange: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            data: *mut ::std::os::raw::c_void,
            index: usize,
            count: usize,
        ) -> AIErr,
    >,
    #[doc = " Marks a plug-in group art object as dirty, meaning that the contained art has\nbeen modified since the last update operation. This forces an update notification;\nsee \\c #kSelectorAIUpdateArt.\n\nIllustrator generally detects when a plug-in group object needs\nto have the result art rebuilt. It sends an update message when\nthe object is first created, and whenever the group's data or any object\nin the edit group has been edited (outside of the update message handler itself).\nYou might need to specifically mark the art as changed if objects have external\ndependencies; for instance, reference to a pattern or other global object,\nor an artwork attribute such as the page size. If you detect relevant changes\nthrough other notifications, you can trigger an update by calling this function.\n@param art The plug-in group art object.\n@see \\c #MarkPluginArtClean(), \\c #MarkPluginArtSilent()"]
    pub MarkPluginArtDirty: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Marks a plug-in group art object as clean, meaning that the contained art has\nnot been modified since the last update operation.\n\nA menu command or tool action typically modifies the edit art or the\nobject's data, then rebuilds the result art. The modifications trigger\na notify-edit message, and also mark the plug-in object dirty, causing\na redundant update if the result art has already been updated.\nUse this function in an external notification handler, after updating\nthe result group, to prevent the redundant update.\n\n@param art The plug-in group art object.\n@see \\c #MarkPluginArtDirty(), \\c #MarkPluginArtSilent()\n@note This function is intended for use within a GoMenu or AITool handler, or a notification\nfrom some other suite. When a handler for \\c #kSelectorAINotifyEdits\nreturns \\c #kNoErr, it marks the plug-in object as dirty (in need of\n\\c #kSelectorAIUpdateArt), even if the handler called this function. To prevent\nthis, the handler must return \\c #kMarkValidPluginGroupReply."]
    pub MarkPluginArtClean: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = " Reports whether a plug-in group art object is a clipping object. When it is,\nthe result group constructed by the plug-in group manager should\ncontain one or more paths that are set to clip.\n@param art The plug-in group art object.\n@param clipping [out] A buffer in which to return true if the object\nis a clipping object."]
    pub GetPluginArtClipping: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, clipping: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Sets the clipping state of a plug-in group art object.\n@param art The plug-in group art object.\n@param clipping True to make the object a clipping object, false to\nturn clipping off.\n@return \\c #kBadParameterErr if the associated group does not specify the option\n\\c #kPluginGroupCanBeClipping."]
    pub SetPluginArtClipping:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, clipping: AIBoolean) -> AIErr>,
    #[doc = " Retrieves the default name for a plug-in group, as returned by\n\\c #AIArtSuite::GetArtName(). This name is used in\nthe Layers and Appearance palettes, and can differ from the name\nassigned at creation, which is displayed in error messages;\nsee \\c #GetAIPluginGroupName().\n@param art The plug-in group object.\n@param name [out] A buffer in which to return the default name, or \\c NULL,\nin which case \\c #AIArtSuite::GetArtName() returns the description string."]
    pub GetAIPluginGroupDefaultName: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIPluginGroupHandle,
            name: *mut *mut ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Sets the default name for a plug-in group, as returned by\n\\c #AIArtSuite::GetArtName(). This name is used in\nthe Layers and Appearance palettes, and can differ from the name\nassigned at creation, which is displayed in error messages;\nsee \\c #GetAIPluginGroupName().\n@param entry The plug-in group object.\n@param name The new default name, or \\c NULL,  in which case \\c #AIArtSuite::GetArtName()\nreturns the description string."]
    pub SetAIPluginGroupDefaultName: ::std::option::Option<
        unsafe extern "C" fn(
            entry: AIPluginGroupHandle,
            name: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the earliest Illustrator version that this plug-in group supports.\n@param entry The plug-in group object.\n@param appVersion [out] A buffer in which to return the version constant.\n@see \\c #SetAIPluginGroupAppVersion()"]
    pub GetAIPluginGroupAppVersion: ::std::option::Option<
        unsafe extern "C" fn(entry: AIPluginGroupHandle, appVersion: *mut AIVersion) -> AIErr,
    >,
    #[doc = " Sets the earliest Illustrator version that this plug-in group supports.\nWhen Illustrator writes out this plug-in group, if writing to an earlier file\nformat, it writes out only the result group.\n\nIf not specifically set, the version default is 8.\tPlug-in groups are not supported in versions\nearlier than 8.\n@param entry The plug-in group object.\n@param appVersion The version constant."]
    pub SetAIPluginGroupAppVersion: ::std::option::Option<
        unsafe extern "C" fn(entry: AIPluginGroupHandle, appVersion: AIVersion) -> AIErr,
    >,
    #[doc = " Prevents subsequent modifications to the edit group from marking the object dirty (changed) and\ntriggering the update notification.\tDoes not prevent the marking of the result group.\nThe status is cleared when the context is popped.\n@param art The plug-in group art object.\n@see \\c #MarkPluginArtClean(), \\c #MarkPluginArtDirty()"]
    pub MarkPluginArtSilent: ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle) -> AIErr>,
    #[doc = "\t@deprecated As of AI13 (CS3), this function is deprecated in favor of\n\\c #AIPathStyleSuite::AdjustObjectAIColors(), a more powerful and flexible treatment\nof colors in global objects such as patterns, gradients, symbols, brushes, and\nLive Effects. Color filter plug-ins\tthat iterate the artwork contents themselves\nand only use this function for plug-in groups with that have the flag\n\\c #kPluginGroupManagesPaintStyles, should now use \\c #AIPathStyleSuite::AdjustObjectAIColors()\nto process the entire selection. In this case, the new function emulates\nthe previous behavior; it sends an c\\ #AIPluginGroupAdjustColorsData\nmessage in which both the pattern and style adjustment callbacks do nothing.\n\nModifies colors in all art managed by a plug-in group, by calling a developer-defined callback function.\n@param art The plug-in group art object.\n@param adjustColorCallback The developer-defined callback procedure.\n@param callbackData Optional developer-defined data to pass through to the callback.\n@param modifiedSomething [out] Optional, a buffer in which to return true if any\ncolors were modified.\n@param adjustFills True to modify colors in fill.\n@param adjustStrokes True to modify colors in strokes.\n@param selectionOnly True to modify colors only in selected objects.\n@return Any error reported by the callback function.\n@note This function s intended for the use of plug-ins \\e other \\e than\nthe one implementing the plug-in group."]
    pub PluginArtAdjustColors: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            adjustColorCallback: AIAdjustColorFunc,
            callbackData: *mut ::std::os::raw::c_void,
            modifiedSomething: *mut ASBoolean,
            adjustFills: AIBoolean,
            adjustStrokes: AIBoolean,
            selectionOnly: AIBoolean,
        ) -> AIErr,
    >,
}
pub const AIWorkspaceDefaultValue_kAIWSDefaultPreset: AIWorkspaceDefaultValue = 1;
pub const AIWorkspaceDefaultValue_kAIWSAICSPreset: AIWorkspaceDefaultValue = 2;
#[doc = " Not used"]
pub type AIWorkspaceDefaultValue = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIWorkspace {
    _unused: [u8; 0],
}
#[doc = "\tTypes\n\n/\n/** Opaque reference to a workspace. Access with \\c #AIWorkspaceSuite."]
pub type AIWorkspaceHandle = *mut _AIWorkspace;
#[doc = " Message sent with workspace selectors. See \\c #AIWorkspaceSuite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIWorkspaceMessage {
    #[doc = " Message data."]
    pub d: SPMessageData,
    #[doc = " The workspace receiving the message."]
    pub workspace: AIWorkspaceHandle,
    #[doc = " The name of the tab palette. If you install multiple palettes, compare to the\nsaved name to determine which one made the request."]
    pub dialogName: *const ::std::os::raw::c_char,
    #[doc = " True when \\c #kAIWSDefaultSelector message was sent because a palette\nwas not found in the current workspace, and an exception was raised. Your\nhandler can restore the palette layout to the default."]
    pub restore: AIBoolean,
    #[doc = " Not used."]
    pub flag: AIWorkspaceDefaultValue,
}
#[doc = " @ingroup Suites\nThis suite allows you to access \\e workspaces.\nA workspace is an object in which to store the screen layout of floating\ntabbed palettes, such as the Tool and Control palettes.\nThe workspace can store current size, visibility, physical location, docking information,\nand any other palette-specific options (such as the list view option in the brushes\npalette).\n\nThese functions retrieve and set values in the workspace object, according\nto the data type.\n\nThe workspace does not control persistence, which governs the behavior\nat startup. This is determined in the individual libraries (Brush, Graphic\nStyle, Swatch, and Symbol).\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIWorkspaceSuite and \\c #kAIWorkspaceVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIWorkspaceSuite {
    #[doc = " Retrieves an integer value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetIntegerValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_int,
        ) -> AIErr,
    >,
    #[doc = " Sets an integer value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetIntegerValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a real-number value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetRealValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = " Sets a real-number value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetRealValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIReal,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a boolean value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetBooleanValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets a boolean value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetBooleanValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a string value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetStringValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_char,
            length: ai_int32,
        ) -> AIErr,
    >,
    #[doc = " Sets a string value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetStringValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a point value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetPointValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Sets a point value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetPointValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIPoint,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a real-number point value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetRealPointValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Sets a real-number point value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetRealPointValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a rectangle value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetRectValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRect,
        ) -> AIErr,
    >,
    #[doc = " Sets a rectangle value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetRectValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIRect,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a real-number rectangle value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetRealRectValue: ::std::option::Option<
        unsafe extern "C" fn(
            collectioRef: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Sets a real-number rectangle value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetRealRectValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Retrieves a transformation matrix value from a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value [out] A buffer in which to return the value."]
    pub GetRealMatrixValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: *mut AIRealMatrix,
        ) -> AIErr,
    >,
    #[doc = " Sets a transformation matrix value for a workspace.\n@param workspace The workspace object.\n@param prefix The palette name, as returned by <code>sADMDialog->GetDialogName(fDialog)</code>.\n@param suffix A configuration item in the plug-in, such as \"ListView\" or \"ShowOption\".\n@param value The new value."]
    pub SetRealMatrixValue: ::std::option::Option<
        unsafe extern "C" fn(
            workspace: AIWorkspaceHandle,
            prefix: *const ::std::os::raw::c_char,
            suffix: *const ::std::os::raw::c_char,
            value: AIRealMatrix,
        ) -> AIErr,
    >,
}
#[repr(C)]
pub struct Plugin__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Plugin {
    pub vtable_: *const Plugin__bindgen_vtable,
    pub fPluginRef: SPPluginRef,
    pub fPluginName: [::std::os::raw::c_char; 256usize],
    pub fSuites: *mut Suites,
    pub fLockCount: ::std::os::raw::c_int,
    pub fPluginAccess: SPAccessRef,
    pub fLastError: ASErr,
    pub fErrorTimeout: ::std::os::raw::c_long,
    pub fSupressDuplicateErrors: ASBoolean,
    pub fLastErrorTime: time_t,
    pub fApplicationStartedNotifier: AINotifierHandle,
    pub fApplicationShutdownNotifer: AINotifierHandle,
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12DefaultErrorEP8SPPlugini"]
    pub fn Plugin_DefaultError(ref_: SPPluginRef, error: ASErr);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin11FilterErrorEi"]
    pub fn Plugin_FilterError(error: ASErr) -> ASBoolean;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin11IsReloadMsgEPcS0_"]
    pub fn Plugin_IsReloadMsg(
        caller: *mut ::std::os::raw::c_char,
        selector: *mut ::std::os::raw::c_char,
    ) -> ASBoolean;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6PluginC1EP8SPPlugin"]
    pub fn Plugin_Plugin(this: *mut Plugin, pluginRef: SPPluginRef);
}
impl Plugin {
    #[inline]
    pub unsafe fn DefaultError(ref_: SPPluginRef, error: ASErr) {
        Plugin_DefaultError(ref_, error)
    }
    #[inline]
    pub unsafe fn FilterError(error: ASErr) -> ASBoolean {
        Plugin_FilterError(error)
    }
    #[inline]
    pub unsafe fn IsReloadMsg(
        caller: *mut ::std::os::raw::c_char,
        selector: *mut ::std::os::raw::c_char,
    ) -> ASBoolean {
        Plugin_IsReloadMsg(caller, selector)
    }
    #[inline]
    pub unsafe fn new(pluginRef: SPPluginRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Plugin_Plugin(__bindgen_tmp.as_mut_ptr(), pluginRef);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6PluginD1Ev"]
    pub fn Plugin_Plugin_destructor(this: *mut Plugin);
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin11ReportErrorEiPcS0_Pv"]
    pub fn Plugin_ReportError(
        this: *mut ::std::os::raw::c_void,
        error: ASErr,
        caller: *mut ::std::os::raw::c_char,
        selector: *mut ::std::os::raw::c_char,
        message: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin10LockPluginEh"]
    pub fn Plugin_LockPlugin(this: *mut ::std::os::raw::c_void, lock: ASBoolean) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin13StartupPluginEP18SPInterfaceMessage"]
    pub fn Plugin_StartupPlugin(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPInterfaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin17PostStartupPluginEv"]
    pub fn Plugin_PostStartupPlugin(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin17PreShutdownPluginEv"]
    pub fn Plugin_PreShutdownPlugin(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin14ShutdownPluginEP18SPInterfaceMessage"]
    pub fn Plugin_ShutdownPlugin(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPInterfaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12UnloadPluginEP18SPInterfaceMessage"]
    pub fn Plugin_UnloadPlugin(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPInterfaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12ReloadPluginEP18SPInterfaceMessage"]
    pub fn Plugin_ReloadPlugin(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPInterfaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin15AcquirePropertyEP19SPPropertiesMessage"]
    pub fn Plugin_AcquireProperty(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPPropertiesMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin15ReleasePropertyEP19SPPropertiesMessage"]
    pub fn Plugin_ReleaseProperty(
        this: *mut ::std::os::raw::c_void,
        message: *mut SPPropertiesMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin13GetPluginNameEPcj"]
    pub fn Plugin_GetPluginName(
        this: *mut ::std::os::raw::c_void,
        name: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin5PurgeEv"]
    pub fn Plugin_Purge(this: *mut ::std::os::raw::c_void) -> ASBoolean;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin7MessageEPcS0_Pv"]
    pub fn Plugin_Message(
        this: *mut ::std::os::raw::c_void,
        caller: *mut ::std::os::raw::c_char,
        selector: *mut ::std::os::raw::c_char,
        message: *mut ::std::os::raw::c_void,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin9SetGlobalEPS_"]
    pub fn Plugin_SetGlobal(this: *mut ::std::os::raw::c_void, plugin: *mut Plugin) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin19AllocateSuiteTablesEv"]
    pub fn Plugin_AllocateSuiteTables(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin15FillSuiteTablesEv"]
    pub fn Plugin_FillSuiteTables(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16EmptySuiteTablesEv"]
    pub fn Plugin_EmptySuiteTables(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin21AcquireOptionalSuitesEv"]
    pub fn Plugin_AcquireOptionalSuites(this: *mut ::std::os::raw::c_void) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin6NotifyEP17AINotifierMessage"]
    pub fn Plugin_Notify(
        this: *mut ::std::os::raw::c_void,
        message: *mut AINotifierMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin8GoActionEP15DoActionMessage"]
    pub fn Plugin_GoAction(
        this: *mut ::std::os::raw::c_void,
        message: *mut DoActionMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin10GoMenuItemEP13AIMenuMessage"]
    pub fn Plugin_GoMenuItem(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIMenuMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin14UpdateMenuItemEP13AIMenuMessage"]
    pub fn Plugin_UpdateMenuItem(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIMenuMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin19GetFilterParametersEP15AIFilterMessage"]
    pub fn Plugin_GetFilterParameters(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIFilterMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin8GoFilterEP15AIFilterMessage"]
    pub fn Plugin_GoFilter(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIFilterMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin17PluginGroupNotifyEP20AIPluginGroupMessage"]
    pub fn Plugin_PluginGroupNotify(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIPluginGroupMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin17PluginGroupUpdateEP20AIPluginGroupMessage"]
    pub fn Plugin_PluginGroupUpdate(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIPluginGroupMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin23GetFileFormatParametersEP19AIFileFormatMessage"]
    pub fn Plugin_GetFileFormatParameters(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIFileFormatMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12GoFileFormatEP19AIFileFormatMessage"]
    pub fn Plugin_GoFileFormat(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIFileFormatMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin15CheckFileFormatEP19AIFileFormatMessage"]
    pub fn Plugin_CheckFileFormat(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIFileFormatMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16FileFormatUpdateEP25AIUpdateFileFormatMessage"]
    pub fn Plugin_FileFormatUpdate(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIUpdateFileFormatMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin23SetFileFormatParametersEP15DoActionMessage"]
    pub fn Plugin_SetFileFormatParameters(
        this: *mut ::std::os::raw::c_void,
        message: *mut DoActionMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin8EditToolEP13AIToolMessage"]
    pub fn Plugin_EditTool(this: *mut ::std::os::raw::c_void, message: *mut AIToolMessage)
        -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin15TrackToolCursorEP13AIToolMessage"]
    pub fn Plugin_TrackToolCursor(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin13ToolMouseDownEP13AIToolMessage"]
    pub fn Plugin_ToolMouseDown(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin13ToolMouseDragEP13AIToolMessage"]
    pub fn Plugin_ToolMouseDrag(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin11ToolMouseUpEP13AIToolMessage"]
    pub fn Plugin_ToolMouseUp(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin10SelectToolEP13AIToolMessage"]
    pub fn Plugin_SelectTool(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12DeselectToolEP13AIToolMessage"]
    pub fn Plugin_DeselectTool(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12ReselectToolEP13AIToolMessage"]
    pub fn Plugin_ReselectTool(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16DecreaseDiameterEP13AIToolMessage"]
    pub fn Plugin_DecreaseDiameter(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16IncreaseDiameterEP13AIToolMessage"]
    pub fn Plugin_IncreaseDiameter(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIToolMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin24EditLiveEffectParametersEP28AILiveEffectEditParamMessage"]
    pub fn Plugin_EditLiveEffectParameters(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectEditParamMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin12GoLiveEffectEP21AILiveEffectGoMessage"]
    pub fn Plugin_GoLiveEffect(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectGoMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin21LiveEffectInterpolateEP30AILiveEffectInterpParamMessage"]
    pub fn Plugin_LiveEffectInterpolate(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectInterpParamMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin22LiveEffectGetInputTypeEP28AILiveEffectInputTypeMessage"]
    pub fn Plugin_LiveEffectGetInputType(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectInputTypeMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin27LiveEffectConvertColorSpaceEP31AILiveEffectConvertColorMessage"]
    pub fn Plugin_LiveEffectConvertColorSpace(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectConvertColorMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin25LiveEffectScaleParametersEP29AILiveEffectScaleParamMessage"]
    pub fn Plugin_LiveEffectScaleParameters(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectScaleParamMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin22LiveEffectAdjustColorsEP31AILiveEffectAdjustColorsMessage"]
    pub fn Plugin_LiveEffectAdjustColors(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectAdjustColorsMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin21LiveEffectHandleMergeEP30AILiveEffectHandleMergeMessage"]
    pub fn Plugin_LiveEffectHandleMerge(
        this: *mut ::std::os::raw::c_void,
        message: *mut AILiveEffectHandleMergeMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin7GoTimerEP14AITimerMessage"]
    pub fn Plugin_GoTimer(this: *mut ::std::os::raw::c_void, message: *mut AITimerMessage)
        -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin11GoClipboardEP18AIClipboardMessage"]
    pub fn Plugin_GoClipboard(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIClipboardMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16CanCopyClipboardEP18AIClipboardMessage"]
    pub fn Plugin_CanCopyClipboard(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIClipboardMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin14CloneClipboardEP18AIClipboardMessage"]
    pub fn Plugin_CloneClipboard(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIClipboardMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16DisposeClipboardEP18AIClipboardMessage"]
    pub fn Plugin_DisposeClipboard(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIClipboardMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin14WorkspaceWriteEP18AIWorkspaceMessage"]
    pub fn Plugin_WorkspaceWrite(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIWorkspaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16WorkspaceRestoreEP18AIWorkspaceMessage"]
    pub fn Plugin_WorkspaceRestore(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIWorkspaceMessage,
    ) -> ASErr;
}
unsafe extern "C" {
    #[link_name = "\u{1}__ZN6Plugin16WorkspaceDefaultEP18AIWorkspaceMessage"]
    pub fn Plugin_WorkspaceDefault(
        this: *mut ::std::os::raw::c_void,
        message: *mut AIWorkspaceMessage,
    ) -> ASErr;
}
pub type AIControlBarPlatformWindow = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_AIControlBar {
    _unused: [u8; 0],
}
#[doc = "\tReference to a control-bar object."]
pub type AIControlBarRef = *mut _opaque_AIControlBar;
#[doc = " A developer-defined data object associated with a control bar."]
pub type AIControlBarUserData = *mut ::std::os::raw::c_void;
#[doc = " Prototype of a function to be called when the visibility of a Control Bar has changed.\n@param inControlBar\t\t\tThe control-bar object.\n@param isVisible\t\t\tThe new visibility state of the Control Bar, true if visible"]
pub type AIControlBarVisibilityChangedNotifyProc = ::std::option::Option<
    unsafe extern "C" fn(inControlBar: AIControlBarRef, isVisible: AIBoolean),
>;
#[doc = " Prototype of a function to be called when the size of a Control Bar has changed.\n@param inControlBar\t\t\tThe control-bar object."]
pub type AIControlBarSizeChangedNotifyProc =
    ::std::option::Option<unsafe extern "C" fn(inControlBar: AIControlBarRef)>;
#[doc = "\t@ingroup Suites\nThis suite provides functions for creating and managing control bars.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIControlBarSuite\tand \\c #kAIControlBarSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIControlBarSuite {
    #[doc = " Creates a new control-bar object\n@param inPluginRef\t\t\tThe plug-in that is creating the control bar.\n@param inControlBarSize\t\tSize of the new control bar.\n@param inMinWidth\t\t\tMinimum width of the new control bar.\n@param inMaxWidth\t\t\tMaximum width of the new control bar.\n@param inUserData\t\t\tDeveloper-defined data to be associated with the control bar.\n@param outControlBar\t\t[out] A buffer in which to return the new control-bar object."]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            inPluginRef: SPPluginRef,
            inControlBarSize: *const AISize,
            inMinWidth: AIReal,
            inMaxWidth: AIReal,
            inUserData: AIControlBarUserData,
            outControlBar: *mut AIControlBarRef,
        ) -> AIErr,
    >,
    #[doc = " Deletes a control bar object.\nThis must be called when the plug-in receives a shutdown notification, \\c #kAIApplicationShutdownNotifier.\n@param inControlBar\t\t\tThe control bar object."]
    pub Destroy:
        ::std::option::Option<unsafe extern "C" fn(inControlBar: AIControlBarRef) -> AIErr>,
    #[doc = " Retrieves developer-defined data associates with a control bar.\n@param inControlBar\t\t\tThe control Bar object.\n@param outUserData\t\t\t[out] A buffer in which to return the developer-defined data."]
    pub GetUserData: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            outUserData: *mut AIControlBarUserData,
        ) -> AIErr,
    >,
    #[doc = " Associates developer-defined data with a control bar, which can be used in developer-defined callbacks.\n@param inControlBar\t\t\tThe control bar object.\n@param inUserData\t\t\tThe developer-defined data."]
    pub SetUserData: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            inUserData: AIControlBarUserData,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the platform-specific window or view used for the control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param outControlBarPlatformWindow\t[out] A buffer in which to return the platform-specific window or view."]
    pub GetPlatformWindow: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            outControlBarPlatformWindow: *mut AIControlBarPlatformWindow,
        ) -> AIErr,
    >,
    #[doc = " Shows or hides a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param inShow\t\t\t\t\t\tTrue to make the control bar visible, false to hide it."]
    pub Show: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, inShow: AIBoolean) -> AIErr,
    >,
    #[doc = " Reports the current visibility state of a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param outIsShown\t\t\t\t\t[out] A buffer in which to return true if the control bar is visible, false otherwise."]
    pub IsShown: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, outIsShown: *mut AIBoolean) -> AIErr,
    >,
    #[doc = " Retrieves the current width of control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param outControlBarWidth\t\t\t[out] A buffer in which to return the width value in pixels."]
    pub GetWidth: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            outControlBarWidth: *mut AIReal,
        ) -> AIErr,
    >,
    #[doc = "  Sets the width of control bar.\tIf the width is out of allowed bounds, returns an error.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param inControlBarWidth\t\t\tThe new width value in pixels. Must be >= minWidth and <= maxWidth."]
    pub SetWidth: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, inControlBarWidth: AIReal) -> AIErr,
    >,
    #[doc = " Retrieves the current minimum width of a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param outMinWidth\t\t\t\t\t[out] A buffer in which to return the minimum width value in pixels."]
    pub GetMinimumWidth: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, outMinWidth: *mut AIReal) -> AIErr,
    >,
    #[doc = " Sets the minimum width of a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param inMinWidth\t\t\t\t\tThe new minimum width in pixels; must be > 0 and <= maxWidth."]
    pub SetMinimumWidth: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, inMinWidth: AIReal) -> AIErr,
    >,
    #[doc = " Retrieves the current maximum width of a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param outMaxWidth\t\t\t\t\t[out] A buffer in which to return the maximum width value in pixels."]
    pub GetMaximumWidth: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, outMaxWidth: *mut AIReal) -> AIErr,
    >,
    #[doc = " Sets the maximum width of a control bar.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param inMaxWidth\t\t\t\t\tThe new maximum width in pixels; must be >= minWidth."]
    pub SetMaximumWidth: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, inMaxWidth: AIReal) -> AIErr,
    >,
    #[doc = " Moves a control bar to a specific location. If the control bar is docked, does nothing.\n@param inControlBar\t\t\t\t\tThe control bar object.\n@param inPoint\t\t\t\t\t\tThe new position in global screen coordinates."]
    pub Move: ::std::option::Option<
        unsafe extern "C" fn(inControlBar: AIControlBarRef, inPoint: *const AIPoint) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to call when the visibility of a control bar has changed.\n@param inControlBar\t\t\t\t\t\tThe control bar object.\n@param inVisibilityChangedNotifyProc\tThe new callback procedure."]
    pub SetVisibilityChangedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            inVisibilityChangedNotifyProc: AIControlBarVisibilityChangedNotifyProc,
        ) -> AIErr,
    >,
    #[doc = " Sets a callback procedure to call when the size of a control bar has changed.\n@param inControlBar\t\t\t\t\t\tThe control bar object.\n@param inSizeChangedNotifyProc\t\t\tThe new callback procedure."]
    pub SetSizeChangedNotifyProc: ::std::option::Option<
        unsafe extern "C" fn(
            inControlBar: AIControlBarRef,
            inSizeChangedNotifyProc: AIControlBarSizeChangedNotifyProc,
        ) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite provides utilities for creating paths whose shapes\ndescribe a particular geometric figure. All of the utilities take parameters\nthat describe the geometric figure and return a new art object. The art object\nis created in the art tree at the current insertion point as returned by\n\\c #AIArtSuite::GetInsertionPoint().\n\n@note The shape suite is supplied by a plug-in, which the user can remove.\nClients of the shape suite should fail gracefully if it\tis not available.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIShapeConstructionSuite and \\c #kAIShapeConstructionVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIShapeConstructionSuite {
    #[doc = " Creates a path for a rectangle.\n@param fromPoint The upper left point.\n@param toPoint The lower right point.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object.\n@param size [out] A buffer in which to return a point giving the\nhorizontal and vertical size of the figure, in document points."]
    pub NewPointPointRect: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            toPoint: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            isConstrained: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
            size: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rectangle of a given size.\n@param fromPoint The upper left point.\n@param size A point whose components specify the horizontal and vertical\nsize of the figure,\tin document points.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object."]
    pub NewPointSizeRect: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            size: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval from two focus points.\n@param fromPoint The first focus point.\n@param toPoint The second focus point.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param isCircumscribed True to circumscribe the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object.\n@param size [out] A buffer in which to return a point giving the\nhorizontal and vertical size of the figure, in document points."]
    pub NewPointPointOval: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            toPoint: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            isConstrained: AIBoolean,
            isCircumscribed: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
            size: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval of a given size.\n@param fromPoint The source point.\n@param size A point whose components specify the horizontal and vertical\nsize of the figure, in document points.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object."]
    pub NewPointSizeOval: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            size: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rounded rectangle.\n@param fromPoint The upper left point.\n@param toPoint The lower right point.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object.\n@param size [out] A buffer in which to return a point giving the\nhorizontal and vertical size of the figure, in document points."]
    pub NewPointPointRoundedRect: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            toPoint: AIRealPoint,
            radius: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            isConstrained: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
            size: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rounded rectangle of a given size.\n@param fromPoint The upper left point.\n@param size A point whose components specify the horizontal and vertical\nsize of the figure, in document points.\n@param isCentered True to center the figure.\n@param isReversed True to reverse the figure.\n@param isConstrained True to constrain the figure.\n@param honorConstrainAngle True to constrain the angle.\n@param art [out] A buffer in which to return the new path object."]
    pub NewPointSizeRoundedRect: ::std::option::Option<
        unsafe extern "C" fn(
            fromPoint: AIRealPoint,
            size: AIRealPoint,
            radius: AIRealPoint,
            isCentered: AIBoolean,
            isReversed: AIBoolean,
            honorConstrainAngle: AIBoolean,
            art: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rectangle from page coordinates for the sides.\n@param top The X coordinate of the top.\n@param left The Y coordinate of the left edge.\n@param bottom The X coordinate of the bottom.\n@param right The Y coordinate of the right edge.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewRect: ::std::option::Option<
        unsafe extern "C" fn(
            top: AIReal,
            left: AIReal,
            bottom: AIReal,
            right: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rectangle of a given size, centered around a point.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param height The height in document points.\n@param width The width in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewCenteredRect: ::std::option::Option<
        unsafe extern "C" fn(
            centerX: AIReal,
            centerY: AIReal,
            height: AIReal,
            width: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rounded rectangle from page coordinates for the sides.\n@param top The X coordinate of the top.\n@param left The Y coordinate of the left edge.\n@param bottom The X coordinate of the bottom.\n@param right The Y coordinate of the right edge.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewRoundedRect: ::std::option::Option<
        unsafe extern "C" fn(
            top: AIReal,
            left: AIReal,
            bottom: AIReal,
            right: AIReal,
            horizRadius: AIReal,
            vertRadius: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a rounded rectangle of a given size, centered around a point.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param height The height in document points.\n@param width The width in document points.\n@param horizRadius The horizontal radius of the rounded corners, in document points.\n@param vertRadius The vertical radius of the rounded corners, in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewCenteredRoundedRect: ::std::option::Option<
        unsafe extern "C" fn(
            centerX: AIReal,
            centerY: AIReal,
            height: AIReal,
            width: AIReal,
            horizRadius: AIReal,
            vertRadius: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval inscribed within a rectangle,\nfrom page coordinates for the sides.\n@param top The X coordinate of the top.\n@param left The Y coordinate of the left edge.\n@param bottom The X coordinate of the bottom.\n@param right The Y coordinate of the right edge.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewInscribedOval: ::std::option::Option<
        unsafe extern "C" fn(
            top: AIReal,
            left: AIReal,
            bottom: AIReal,
            right: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval circumscribed around a rectangle,\nfrom page coordinates for the sides.\n@param top The X coordinate of the top.\n@param left The Y coordinate of the left edge.\n@param bottom The X coordinate of the bottom.\n@param right The Y coordinate of the right edge.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewCircumscribedOval: ::std::option::Option<
        unsafe extern "C" fn(
            top: AIReal,
            left: AIReal,
            bottom: AIReal,
            right: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval inscribed within a rectangle of a given size,\ncentered around a point.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param height The height in document points.\n@param width The width in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewInscribedCenteredOval: ::std::option::Option<
        unsafe extern "C" fn(
            centerX: AIReal,
            centerY: AIReal,
            height: AIReal,
            width: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an oval circumscribed around a rectangle of a given size,\ncentered around a point.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param height The height in document points.\n@param width The width in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewCircumscribedCenteredOval: ::std::option::Option<
        unsafe extern "C" fn(
            centerX: AIReal,
            centerY: AIReal,
            height: AIReal,
            width: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a regular polygon of a given radius,\ncentered around a point.\n@param numSides The number of sides.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param radius The radius, in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewRegularPolygon: ::std::option::Option<
        unsafe extern "C" fn(
            numSides: ai_uint16,
            centerX: AIReal,
            centerY: AIReal,
            radius: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a regular polygon with a given vertex point,\ncentered around a point.\n@param numsides The number of sides.\n@param center The center point.\n@param vertex The vertex point.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewRegularPolygonPoint: ::std::option::Option<
        unsafe extern "C" fn(
            numsides: ai_uint16,
            center: AIRealPoint,
            vertex: AIRealPoint,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an n-pointed star with a given radius,\ncentered around a point.\n@param numPoints The number of star points.\n@param centerX The X coordinate of the center.\n@param centerY The Y coordinate of the center.\n@param radius1 The first radius, in document points.\n@param radius2 The second radius, in document points.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewStar: ::std::option::Option<
        unsafe extern "C" fn(
            numPoints: ai_uint16,
            centerX: AIReal,
            centerY: AIReal,
            radius1: AIReal,
            radius2: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for an n-pointed star with a given vertex point and radius ratio,\ncentered around a point.\n@param numPoints The number of star points.\n@param center The center point.\n@param vertex The vertex point.\n@param radiusRation The radius ratio.\n@param reversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewStarPoint: ::std::option::Option<
        unsafe extern "C" fn(
            numPoints: ai_uint16,
            center: AIRealPoint,
            vertex: AIRealPoint,
            radiusRatio: AIReal,
            reversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for spiral around a point.\n@param firstArcCenter The center point for the first arc of the spiral.\n@param start The starting point.\n@param decayPercent The decay ration expressed as a percentage.\n@param numQuarterTurns The number of quarter turns.\n@param clockwiseFromOutside True to spiral clockwise.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewSpiral: ::std::option::Option<
        unsafe extern "C" fn(
            firstArcCenter: AIRealPoint,
            start: AIRealPoint,
            decayPercent: AIReal,
            numQuarterTurns: ai_int16,
            clockwiseFromOutside: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for elliptical pie around a point.\n@param center The center point for the ellipse of which this pie is a part of.\n@param width The width of the ellipse of which this pie is a part of.\n@param height The height of the ellipse of which this pie is a part of.\n@param rotationAngle The rotation angle of the ellipse of which this pie is a part of.\n@param startAngle absolute start angle of the pie.\n@param endAngle absolute end angle of the pie.\n@param isReversed True to reverse the figure.\n@param newArt [out] A buffer in which to return the new path object."]
    pub NewEllipticalPie: ::std::option::Option<
        unsafe extern "C" fn(
            center: AIRealPoint,
            width: AIReal,
            height: AIReal,
            rotationAngle: AIReal,
            startAngle: AIReal,
            endAngle: AIReal,
            isReversed: AIBoolean,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a line.\n@param startPoint The starting point of line.\n@param endPoint The end point of line.\n@param art [out] A buffer in which to return the new path object."]
    pub NewLinePoint: ::std::option::Option<
        unsafe extern "C" fn(
            startPoint: *const AIRealPoint,
            endPoint: *const AIRealPoint,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
    #[doc = " Creates a path for a line.\n@param center The coordinate of the center of line (Mid point of line).\n@param length of line in document points.\n@param rotationAngle absolute rotation angle of the line.\n@param art [out] A buffer in which to return the new path object."]
    pub NewLine: ::std::option::Option<
        unsafe extern "C" fn(
            center: *const AIRealPoint,
            length: AIReal,
            rotationAngle: AIReal,
            newArt: *mut AIArtHandle,
        ) -> AIErr,
    >,
}
#[doc = " Marks the end of an object enumeration."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeNull: AIGeometryOrganizationType = 0;
#[doc = " A path object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizePath: AIGeometryOrganizationType = 1;
#[doc = " A group object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeGroup: AIGeometryOrganizationType = 2;
#[doc = " A compound object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeCompound: AIGeometryOrganizationType = 3;
#[doc = " A placed object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizePlaced: AIGeometryOrganizationType = 4;
#[doc = " A raster object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeRaster: AIGeometryOrganizationType = 5;
#[doc = " A text frame object.\n(As of AI11 the text organization callbacks are called for each text frame.)"]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeText: AIGeometryOrganizationType = 6;
#[doc = " A text path object.\n(As of AI11 this is called if the text frame has a confining path--that is,\nit is area text or text on a path)."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeTextPath: AIGeometryOrganizationType = 7;
#[doc = " A text line object.\n(Obsolete, not invoked by AI11 or later.)"]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeTextLine: AIGeometryOrganizationType = 8;
#[doc = " A clipping group object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeClipGroup: AIGeometryOrganizationType = 9;
#[doc = " A mask object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeMask: AIGeometryOrganizationType = 10;
#[doc = " A mesh object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeMesh: AIGeometryOrganizationType = 11;
#[doc = " A symbol object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeSymbol: AIGeometryOrganizationType = 12;
#[doc = " A foreign object.\n@note AI11 and later."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeForeignObject: AIGeometryOrganizationType =
    13;
#[doc = " A legacy text object.\n@note AI11 and later."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeLegacyText: AIGeometryOrganizationType = 14;
#[doc = " A chart object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeChart: AIGeometryOrganizationType = 15;
#[doc = " A Plugin Art Object.\n@note AI19.2 and later"]
pub const AIGeometryOrganizationType_kAIGeometryOrganizePluginArt: AIGeometryOrganizationType = 16;
#[doc = " A Graph Object."]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeGraph: AIGeometryOrganizationType = 17;
#[doc = " A repeat object"]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeRepeat: AIGeometryOrganizationType = 18;
#[doc = " Internal"]
pub const AIGeometryOrganizationType_kAIGeometryOrganizeDummy: AIGeometryOrganizationType =
    4294967295;
#[doc = " Types of art objects that can be enumerated to \\c #AIGeometryOrganizationProcs.\nThese correspond to \\c #AIArtType values for objects.\nSee \\c #AIGeometrySuite"]
pub type AIGeometryOrganizationType = ::std::os::raw::c_uint;
#[doc = " Developer-defined data for geometry callbacks.\nSee \\c #AIGeometrySuite"]
pub type AIGeometryUserData = *mut ::std::os::raw::c_void;
#[doc = " Callback prototype for \\c #AIGeometryOrganizationProcs. Called before enumeration\nbegins for an object of an associated \\c #AIGeometryOrganizationType.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param object The art object to be enumerated.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryBeginProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, object: AIArtHandle) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryOrganizationProcs. Called after enumeration\nends or is halted by a 1 result for an object of an associated \\c #AIGeometryOrganizationType.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param object The art object that was enumerated.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryEndProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, object: AIArtHandle) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryConstructionProcs.\tCalled to describe paths\nand outlines within a shape.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param p The destination location of the move.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryMoveToProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, p: *mut AIRealPoint) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryConstructionProcs.\tCalled to describe each\npath or outline within an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param p The destination location of the line draw.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryLineToProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, p: *mut AIRealPoint) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryConstructionProcs. Called to describe each\npath or outline within an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param p1 The first curve point.\n@param p2 The second curve point.\n@param p3 The third curve point.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryCurveToProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        p1: *mut AIRealPoint,
        p2: *mut AIRealPoint,
        p3: *mut AIRealPoint,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryConstructionProcs.\tCalled to describe each\npath or outline within an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryClosePathProc =
    ::std::option::Option<unsafe extern "C" fn(userData: AIGeometryUserData) -> ai_int16>;
#[doc = " Callback prototype for \\c #AIGeometryPaintingProcs.\tCalled to describe the fill\nof an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryFillProc =
    ::std::option::Option<unsafe extern "C" fn(userData: AIGeometryUserData) -> ai_int16>;
#[doc = " Callback prototype for \\c #AIGeometryPaintingProcs.\tCalled to describe the strokes\nof an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryStrokeProc =
    ::std::option::Option<unsafe extern "C" fn(userData: AIGeometryUserData) -> ai_int16>;
#[doc = " Callback prototype for \\c #AIGeometryPaintingProcs. Called to describe the clipping\nof an element of the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryClipProc =
    ::std::option::Option<unsafe extern "C" fn(userData: AIGeometryUserData) -> ai_int16>;
#[doc = " Callback prototype for \\c #AIGeometryPaintingProcs.\tCalled when an outline\nwithin the  art tree being iterated is filled with an image.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param raster The image object.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryImageProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, raster: AIArtHandle) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryPaintingProcs. Called when an outline\nwithin the  art tree being iterated is filled with an image.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param raster The image mask object.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryImageMaskProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, raster: AIArtHandle) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param gray The grayscale value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetGrayProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, gray: AIReal) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param cyan The CMYK cyan value.\n@param magenta The CMYK magenta value.\n@param yellow The CMYK yellow value.\n@param black The CMYK black value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetCMYKColorProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        cyan: AIReal,
        magenta: AIReal,
        yellow: AIReal,
        black: AIReal,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param red The RGB red value.\n@param green The RGB green value.\n@param blue The RGB blue value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetRGBColorProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        red: AIReal,
        green: AIReal,
        blue: AIReal,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param alpha The alpha channel value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetAlphaProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, alpha: AIReal) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param customColor The custom color.\n@param tint The amount of the color, a percentage in the range [0..1].\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetCustomColorProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        customColor: AICustomColorHandle,
        tint: AIReal,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param gradient The gradient object.\n@param gradientOrigin The origin point.\n@param gradientAngle The angle.\n@param gradientLength The length.\n@param hiliteAngle The highlight angle.\n@param hiliteLength\tThe highlight length.\n@param matrix The transformation matrix.\n@return 0 for enumeration to continue, 1 to halt enumeration.\n@see \\c #AIGradientStyle"]
pub type AIGeometrySetGradientColorProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        gradient: AIGradientHandle,
        gradientOrigin: *mut AIRealPoint,
        gradientAngle: AIReal,
        gradientLength: AIReal,
        hiliteAngle: AIReal,
        hiliteLength: AIReal,
        matrix: *mut AIRealMatrix,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the fill and\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param pattern The pattern object.\n@param shiftDistance Pattern style value.\n@param shiftAngle Pattern style value.\n@param scale  Pattern style value.\n@param rotateAngle Pattern style value.\n@param reflect Pattern style value.\n@param reflectAngle\tPattern style value.\n@param shearAngle Pattern style value.\n@param shearAxis Pattern style value.\n@return 0 for enumeration to continue, 1 to halt enumeration.\n@see \\c #AIPatternStyle"]
pub type AIGeometrySetPatternColorProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        pattern: AIPatternHandle,
        shiftDistance: AIReal,
        shiftAngle: AIReal,
        scale: *mut AIRealPoint,
        rotateAngle: AIReal,
        reflect: AIBoolean,
        reflectAngle: AIReal,
        shearAngle: AIReal,
        shearAxis: AIReal,
        matrix: *mut AIRealMatrix,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called when an outline\nwithin the art tree being iterated is filled with an image.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param alpha The alpha channel value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometryImageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        raster: AIArtHandle,
        artSlice: *mut AISlice,
        workTile: *mut AITile,
        workSlice: *mut AISlice,
    ) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param lineWidth The line width value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetLineWidthProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, lineWidth: AIReal) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param lineCap The line cap value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetLineCapProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, lineCap: AILineCap) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param lineJoin The line join value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetLineJoinProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, lineJoin: AILineJoin) -> ai_int16,
>;
#[doc = " Callback prototype for \\c #AIGeometryStateProcs. Called for the\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param miterLimit The miter limit value.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetMiterLimitProc = ::std::option::Option<
    unsafe extern "C" fn(userData: AIGeometryUserData, miterLimit: AIReal) -> ai_int16,
>;
#[doc = "Callback prototype for \\c #AIGeometryStateProcs.\tCalled for the\nstroke of each element within the art tree being iterated.\nSee \\c #AIGeometrySuite\n@param userData Developer-defined data.\n@param offset The dash offset value.\n@param length The number of dash values.\n@param array The array of dash values.\n@return 0 for enumeration to continue, 1 to halt enumeration."]
pub type AIGeometrySetDashProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: AIGeometryUserData,
        offset: AIReal,
        length: ai_int16,
        array: *mut AIReal,
    ) -> ai_int16,
>;
#[doc = " Passed as a pointer to a list of organization types\nwith associated begin/end procedures.\nThe list is terminated by an entry with an organization type of 0.\nSee \\c #AIGeometrySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGeometryOrganizationProcs {
    #[doc = " The type of object to which these procedures apply."]
    pub type_: AIGeometryOrganizationType,
    #[doc = " Procedure called before enumerating an object of this type."]
    pub begin: AIGeometryBeginProc,
    #[doc = " Procedure called after enumerating an object of this type."]
    pub end: AIGeometryEndProc,
}
#[doc = " Callbacks that get information about how paths are constructed.\nCalled for leaf objects.\nSee \\c #AIGeometrySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGeometryConstructionProcs {
    pub moveTo: AIGeometryMoveToProc,
    pub lineTo: AIGeometryLineToProc,
    pub curveTo: AIGeometryCurveToProc,
    pub closePath: AIGeometryClosePathProc,
}
#[doc = " Callbacks that get information about how objects are painted.\nCalled for leaf objects. The interior region of a fill or clip can\nbe determined using either the non-zero winding or even-odd rules\n(see the PDF reference manual for a definition). The eofill and\neoclip call backs indicate even-odd while the others indicate non-\nzero winding.\nSee \\c #AIGeometrySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGeometryPaintingProcs {
    pub fill: AIGeometryFillProc,
    pub eofill: AIGeometryFillProc,
    pub stroke: AIGeometryStrokeProc,
    pub clip: AIGeometryClipProc,
    pub eoclip: AIGeometryClipProc,
    pub image: AIGeometryImageProc,
    pub imageMask: AIGeometryImageMaskProc,
}
#[doc = " Callbacks that get information about painting options.\nCalled for leaf objects.\nSee \\c #AIGeometrySuite"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGeometryStateProcs {
    pub setWhiteColor: AIGeometrySetGrayProc,
    pub setBlackColor: AIGeometrySetGrayProc,
    pub setGrayColor: AIGeometrySetGrayProc,
    pub setCMYKColor: AIGeometrySetCMYKColorProc,
    pub setRGBColor: AIGeometrySetRGBColorProc,
    pub setAlpha: AIGeometrySetAlphaProc,
    pub setCustomColor: AIGeometrySetCustomColorProc,
    pub setGradientColor: AIGeometrySetGradientColorProc,
    pub setPatternColor: AIGeometrySetPatternColorProc,
    pub setLineWidth: AIGeometrySetLineWidthProc,
    pub setLineCap: AIGeometrySetLineCapProc,
    pub setLineJoin: AIGeometrySetLineJoinProc,
    pub setMiterLimit: AIGeometrySetMiterLimitProc,
    pub setDash: AIGeometrySetDashProc,
}
#[doc = " @ingroup Suites\nThis suite provides an iteration mechanism for collecting information about\nthe art objects in the various kinds of\tartwork trees.\nIt allows you to define a set of callback procedures to work with\nvarious aspects of artwork, including the placement, style, and color attributes.\nThe \\c #GeometryIterate() function enumerates the contents of an artwork\nsubtree to a set of callback functions that receive various kinds\nof information about each object. You need supply only the callbacks of interest\nto your plug-in.\n\nAll of the object information passed to the callbacks is public information that\ncan be accessed directly through SDK functions. You can also define and pass\narbitrary data to the callbacks, to use together with the object data.\n\nAll callbacks should return 0 to continue processing the next\nartwork element, or nonzero to halt processing. This allows you to prune\nthe traversal of the artwork tree.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIGeometrySuite and \\c #kAIGeometryVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIGeometrySuite {
    #[doc = " Supplies information to developer-defined callback procedures,\ncalling the procedures iteratively for each member of an artwork tree whose\nroot is a specified art object.\n@param art The root art object.\n@param organizationProcs For each object in the tree, calls the start and the end procedure\nassociated the type before and after enumerating the object.\n@param constructionProcs Contains pointers to callbacks that receive a geometric\ndescription of each leaf art object.\n@param paintingProcs Contains pointers to callbacks that receive information\nabout how each leaf object is painted.\n@param stateProcs Contains pointers to callbacks that receive additional parameters\nto the painting operations.\n@param userData Developer-defined data to be passed to callbacks.\n@param skipArtTypes A logical OR of \\c #AIArtUserAttr values for art objects to skip during iteration.\nAs an example, pass  kArtHidden | kArtLocked to skip hidden and locked arts\nPass 0 to skip no arts."]
    pub GeometryIterate: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            organizationProcs: *mut AIGeometryOrganizationProcs,
            constructionProcs: *mut AIGeometryConstructionProcs,
            paintingProcs: *mut AIGeometryPaintingProcs,
            stateProcs: *mut AIGeometryStateProcs,
            userData: AIGeometryUserData,
            skipArtTypes: ai_int32,
        ) -> AIErr,
    >,
}
#[doc = " Transform object geometry"]
pub const AITransformArtOptions_kTransformObjects: AITransformArtOptions = 1;
#[doc = " Apply the transform to gradient fills"]
pub const AITransformArtOptions_kTransformFillGradients: AITransformArtOptions = 2;
#[doc = " Apply the transform to pattern fills"]
pub const AITransformArtOptions_kTransformFillPatterns: AITransformArtOptions = 4;
#[doc = " Apply the transform to pattern strokes"]
pub const AITransformArtOptions_kTransformStrokePatterns: AITransformArtOptions = 8;
#[doc = " Scale the stroke weights by the linescale factor"]
pub const AITransformArtOptions_kScaleLines: AITransformArtOptions = 16;
#[doc = " Transform any opacity masks attached to the objects\nif they are set as linked."]
pub const AITransformArtOptions_kTransformLinkedMasks: AITransformArtOptions = 32;
#[doc = " Apply the transformation recursively."]
pub const AITransformArtOptions_kTransformChildren: AITransformArtOptions = 64;
#[doc = " Apply the transformation only to selected segments of path objects."]
pub const AITransformArtOptions_kTransformSelectionOnly: AITransformArtOptions = 128;
#[doc = " Notify parent plug-in groups of the transformation. Affects performance\nif \\c #AITransformArtSuite::TransformArt() is called during a mouse drag loop."]
pub const AITransformArtOptions_kTransformNotifyPluginGroups: AITransformArtOptions = 256;
#[doc = " Internal use only."]
pub const AITransformArtOptions_kTransformForPerspectivePlugin: AITransformArtOptions = 512;
#[doc = " Apply the transform to gradient stroke."]
pub const AITransformArtOptions_kTransformStrokeGradients: AITransformArtOptions = 1024;
#[doc = " Preserve corners during transformations while maintaining radii values"]
pub const AITransformArtOptions_kPreserveCornersMaintainingRadii: AITransformArtOptions = 2048;
#[doc = " Preserve corners during transformations while scaling radii values"]
pub const AITransformArtOptions_kPreserveCornersScalingRadii: AITransformArtOptions = 4096;
#[doc = " Scale the text wrap offsets by the linescale factor"]
pub const AITransformArtOptions_kScaleTextWrapOffset: AITransformArtOptions = 8192;
#[doc = " Transform all aspects of the art style"]
pub const AITransformArtOptions_kTransformEntireArtStyle: AITransformArtOptions = 1054;
#[doc = " Transform all aspects of the art style that are not affected by transformation preferences."]
pub const AITransformArtOptions_kTransformBasicArtStyle: AITransformArtOptions = 1026;
#[doc = " Options that control the behavior of \\c #AITransformArtSuite::TransformArt()"]
pub type AITransformArtOptions = ::std::os::raw::c_uint;
#[doc = " @ingroup Suites\nThis suite provides a function that transforms an art object of any\ntype by a given transformation matrix, making special transformation routines\nfor the different art types unnecessary.\n\n\\li Text art, raster art, and placed art objects have associated\ntransformation matrices. Functions such as \\c #AIRasterSuite::GetRasterMatrix()\nin the related suites provide access to the matrices.\n\\c #TransformArt() does not use the associated matrix, but instead uses\na matrix that you pass to the function.\n\\li Path art objects are simple collections of connected line segments, and\ndo not have an associated transformation matrix. For these, you must use\nthe \\c #TransformArt() function.\n\nAcquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAITransformArtSuite and \\c #kAITransformArtSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AITransformArtSuite {
    #[doc = " Transforms an art object by a given transformation matrix.\n@param art The art object.\n@param matrix The transformation matrix.\n@param lineScale The scale factor to apply if the object has a stroke\nand the \\c #kScaleLines option is set.  Expressed as a percentage\nin the range [0..1], where 1 is 100%, meaning no scaling. Calculate the\nappropriate linescale as a function of the horizontal and vertical scale\nfactors of the matrix: <code>lineScale = sqrt(Sx) * sqrt(Sy)</code>.\nAlso, if the object is a text wrap, and \\c #kScaleTextWrapOffset\noption is set, ,the lineScale is applied to the text wrap offset as well.\n@param flags Behavior options, a logical OR of \\c #AITransformArtOptions constants.\n@note This function does not do a \"deep\" transform; that is, it does not\nautomatically traverse into the members of group or compound art objects.\nIf you wish to do this, you must traverse the artwork tree and call the\nfunction on the member art objects."]
    pub TransformArt: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            matrix: *mut AIRealMatrix,
            lineScale: AIReal,
            flags: ai_int32,
        ) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _t_AINamePool {
    _unused: [u8; 0],
}
#[doc = "A pool of unique names that can be associated with objects such\nas identifiers. Each document has its own set of name pools.\nA name pool can impose syntactic constraints on the contained names.\n@see \\c #AIUIDSuite, \\c #AIUIDPoolSuite"]
pub type AINamePoolRef = *mut _t_AINamePool;
#[doc = " @ingroup Suites\nThese functions allow you to create, query, and\tmanage\nname pools. An identifier (UID) is unique within a given pool, and\nhas a name which is also unique within that pool; see \\c #AINamePoolRef.\nEach UID can be stored in only one container, and only once within that container.\n\n@see \\c #AIUIDSuite, \\c #AIUIDREFSuite, \\c #AIUIDUtilsSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUIDPoolSuite and \\c #kAIUIDPoolVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUIDPoolSuite {
    #[doc = " Increments the reference count for a UID name pool.\nWhen you create a pool, the initial count is 1.\nUse \\c #Release() to decrement the count.\n(Note that this function returns a numeric value, not an error code.)\n@param pool The UID name pool reference.\n@return The current reference count."]
    pub AddRef:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut ::std::os::raw::c_void) -> ai_int32>,
    #[doc = " Decrements the reference count for a UID name pool, and\nfrees the memory when the reference count is 0.\nWhen you create a pool, the initial count is 1.\nUse \\c #AddRef() to increment the count.\n(Note that this function returns a numeric value, not an error code.)\n@param pool The UID name pool reference.\n@return The current reference count."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(pool: *mut ::std::os::raw::c_void) -> ai_int32>,
    #[doc = " Retrieves a UID name pool by its name. Currently there is only one\npool, for XML unique ID names. This pool is returned regardless\nof the name supplied.\n@param name Ignored.\n@param pool [out] A buffer in which to return the pool reference."]
    pub GetPool: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            pool: *mut AINamePoolRef,
        ) -> AIErr,
    >,
    #[doc = " Creates a new unique identifier with a name from the name pool. The new\nUID has an initial reference count of 1.\n@param pool The UID name pool.\n@param name Optional. A name that conforms to the syntax\nimposed by the pool, and that is not currently in use.\nIf not specified, the function creates a unique name.\n@param uid [out] A buffer in which to return the UID object."]
    pub NewUID: ::std::option::Option<
        unsafe extern "C" fn(
            pool: AINamePoolRef,
            name: *const ai_UnicodeString,
            uid: *mut AIUIDRef,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the UIDRef from its name.\n@param pool The UID name pool.\n@param name The UID name.\n@param uid [out] A buffer in which to return the UID object,\nor \\c NULL if there is none."]
    pub GetUID: ::std::option::Option<
        unsafe extern "C" fn(
            pool: AINamePoolRef,
            name: *const ai_UnicodeString,
            uid: *mut AIUIDRef,
        ) -> AIErr,
    >,
    #[doc = " Creates a new reference to a unique identifier with a name from the name pool.\nThe new UID reference has an initial reference count of 1.\n@param pool The UID name pool.\n@param name Optional.  A name that conforms to the syntax\nimposed by the pool, and that is not currently in use.\nIf not specified, the function creates a unique name.\n@param uidref [out] A buffer in which to return the UID reference object."]
    pub NewUIDREF: ::std::option::Option<
        unsafe extern "C" fn(
            pool: AINamePoolRef,
            name: *const ai_UnicodeString,
            uidref: *mut AIUIDREFRef,
        ) -> AIErr,
    >,
    #[doc = " Creates a new unique identifier with a unique name generated from a base name.\n@param pool The UID name pool.\n@param name Optional. A base name that conforms to the syntax\nimposed by the pool. If not specified, or if in use, the function\ncreates a unique name.\n@param uid [out] A buffer in which to return the UID object."]
    pub NewUIDFromBase: ::std::option::Option<
        unsafe extern "C" fn(
            pool: AINamePoolRef,
            base: *const ai_UnicodeString,
            uid: *mut AIUIDRef,
        ) -> AIErr,
    >,
}
#[doc = "\t@ingroup Suites\nThis suite allows you to access and manage unique identifiers.\nA unique identifier (UID) is an object that can be stored in\na dictionary or an array. A unique identifier cannot occur\nin more than one container, or more than once in a container.\n\nGiven a unique ID, you can find its container. For example,\nunique IDs are typically found in the dictionary of an art object.\nGiven such an ID, you can  access the associated art object.\nAn art object name is itself stored as a specially encoded\nunique ID in the associated art object dictionary.\n\n@see \\c #AIUIDPoolSuite, \\c #AIUIDREFSuite, \\c #AIUIDUtilsSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUIDSuite and \\c #kAIUIDVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUIDSuite {
    #[doc = " Increments the reference count for a unique identifier.\nWhen you create a UID, the initial count is 1.\nUse \\c #Release() to decrement the count.\n(Note that this function returns a numeric value, not an error code.)\n@param uid The UID object.\n@return The current reference count."]
    pub AddRef:
        ::std::option::Option<unsafe extern "C" fn(uid: *mut ::std::os::raw::c_void) -> ai_int32>,
    #[doc = " Decrements the reference count for a unique identifier, and\nfrees the memory when the reference count is 0.\nWhen you create a UID, the initial count is 1.\nUse \\c #AddRef() to increment the count.\n(Note that this function returns a numeric value, not an error code.)\n@param uid The UID object.\n@return The current reference count."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(uid: *mut ::std::os::raw::c_void) -> ai_int32>,
    #[doc = " Reports whether a unique identifier is currently stored within\nsome container.\tA UID cannot occur in more than one\ncontainer, or more than once in a container.\n(Note that this function returns a boolean value, not an error code.)\n@param uid The UID object.\n@return True if the UID is contained in a dictionary or array."]
    pub IsInUse: ::std::option::Option<unsafe extern "C" fn(uid: AIUIDRef) -> AIBoolean>,
    #[doc = " Retrieves the UID name pool to which a unique identifier's name belongs.\n(Note that this function does not return an error code.)\n@param uid The UID object.\n@param pool [out] A buffer in which to return the UID name pool, or\n\\c NULL\tif the UID is not valid."]
    pub GetPool:
        ::std::option::Option<unsafe extern "C" fn(uid: AIUIDRef, pool: *mut AINamePoolRef)>,
    #[doc = " Retrieves the name of a unique identifier as a Unicode string.\n@param uid The UID object.\n@param name [out] A buffer in which to return the name."]
    pub GetName: ::std::option::Option<
        unsafe extern "C" fn(uid: AIUIDRef, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the dictionary or array that contains\ta unique identifier.\n(Note that this function returns an object value, not an error code.)\n@param uid The UID object.\n@return The entry object, or a \\c NULL reference if the UID is\nnot stored in a container.\n@see \\c #AIEntrySuite"]
    pub GetContainer: ::std::option::Option<unsafe extern "C" fn(uid: AIUIDRef) -> AIEntryRef>,
    #[doc = " Creates a new reference to a unique identifier.\nThe new UID reference has an initial reference count of 1.\n@param uid The UID object.\n@param ruidref [out] A buffer in which to return the UID reference object."]
    pub NewUIDREF: ::std::option::Option<
        unsafe extern "C" fn(uid: AIUIDRef, ruidref: *mut AIUIDREFRef) -> AIErr,
    >,
}
#[doc = " @ingroup Suites\nThis suite allows you to access and manage references to unique identifiers.\nThe \\c #AIEntrySuite provides methods to convert between \\c #AIEntryRef\nand \\c #AIUIDRef.\n\nUse a UID to tag an object with a unique identifier, then use a UID reference\nto make a reference to that object. For example, if your plug-in creates art\nobjects and you want to attach a unique identifier to an object, first create\na UID and put it in the art object�s dictionary. You can then store\na reference to the object in the document dictionary using an \\c #AIUIDRef.\n\n@see \\c #AIUIDPoolSuite, \\c #AIUIDSuite, \\c #AIUIDUtilsSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUIDREFSuite and \\c #kAIUIDREFVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUIDREFSuite {
    #[doc = " Increments the reference count for a UID reference.\nWhen you create an \\c #AIUIDRef, the initial count is 1.\nUse \\c #Release() to decrement the count.\n(Note that this function returns a numeric value, not an error code.)\n@param uidref The UID reference object.\n@return The current reference count."]
    pub AddRef: ::std::option::Option<
        unsafe extern "C" fn(uidref: *mut ::std::os::raw::c_void) -> ai_int32,
    >,
    #[doc = " Decrements the reference count for a UID reference, and\nfrees the memory when the reference count is 0.\nWhen you create an \\c #AIUIDRef, the initial count is 1.\nUse \\c #AddRef() to increment the count.\n(Note that this function returns a numeric value, not an error code.)\n@param uidref The UID reference object.\n@return The current reference count."]
    pub Release: ::std::option::Option<
        unsafe extern "C" fn(uidref: *mut ::std::os::raw::c_void) -> ai_int32,
    >,
    #[doc = " Reports whether a UID reference is currently stored within some container.\nA UID cannot occur in more than one container, or more than once in a container.\n(Note that this function returns a boolean value, not an error code.)\n@param uidref The UID reference object.\n@return True if the UID reference is contained in a dictionary or array."]
    pub IsInUse: ::std::option::Option<unsafe extern "C" fn(uidref: AIUIDREFRef) -> AIBoolean>,
    #[doc = " Retrieves the UID name pool to which a UID reference's name belongs.\n(Note that this function does not return an error code.)\n@param uidref The UID reference object.\n@param pool [out] A buffer in which to return the UID name pool, or\n\\c NULL\tif the UID reference is not valid."]
    pub GetPool:
        ::std::option::Option<unsafe extern "C" fn(uidref: AIUIDREFRef, pool: *mut AINamePoolRef)>,
    #[doc = " Retrieves the name of a UID reference as a Unicode string\n@param uidref The UID reference object.\n@param name [out] A buffer in which to return the name."]
    pub GetName: ::std::option::Option<
        unsafe extern "C" fn(uidref: AIUIDREFRef, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = "  Retrieves the dictionary or array that contains a UID reference.\n(Note that this function returns an object value, not an error code.)\n@param uidref The UID reference object.\n@return The entry object, or a \\c NULL reference if the UID reference\nis not stored in a container.\n@see \\c #AIEntrySuite"]
    pub GetContainer:
        ::std::option::Option<unsafe extern "C" fn(uidref: AIUIDREFRef) -> AIEntryRef>,
    #[doc = " Retrieves the unique identifier referred to by a  UID reference.\n(Note that this function does not return an error code.)\n@param uidref The UID reference object.\n@param uid [out] A buffer in which to return the UID object,\nor \\c NULL if there is none."]
    pub GetUID:
        ::std::option::Option<unsafe extern "C" fn(uidref: AIUIDREFRef, uid: *mut AIUIDRef)>,
}
#[doc = " @ingroup Suites\nThis suite allows you to query and manage the unique identifiers for art objects.\n@see \\c #AIUIDPoolSuite, \\c #AIUIDSuite, \\c #AIUIDREFSuite\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUIDUtilsSuite and \\c #kAIUIDUtilsVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUIDUtilsSuite {
    #[doc = " Retrieves the unique identifier for an art object.\n@param art The art object.\n@param create True to assign a generated UID if the object has\nnone.\n@param uid [out] A buffer in which to return the found UID object,\nor a generated UID if none is found and \\c create is true."]
    pub GetArtUID: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, create: AIBoolean, uid: *mut AIUIDRef) -> AIErr,
    >,
    #[doc = " Sets the unique identifier of an art object, replacing its current UID, if any.\n@param art The art object.\n@param uid The new UID object,"]
    pub SetArtUID:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, uid: AIUIDRef) -> AIErr>,
    #[doc = " Transfers the unique identifier of an art object to another art object,\nsetting the UID\tof the source art to \\c NULL.\n@param srcart The source art object.\n@param dstart The destination art object."]
    pub TransferArtUID: ::std::option::Option<
        unsafe extern "C" fn(srcart: AIArtHandle, dstart: AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the UID reference for an art object, or assigns a new UID\nand creates the reference if needed.\n@param art The art object.\n@param uidref [out] A buffer in which to return the UID reference object."]
    pub NewArtUIDREF: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, uidref: *mut AIUIDREFRef) -> AIErr,
    >,
    #[doc = " Retrieves the art object referenced by a UID reference.\nIf the UID reference is associated with a text story (a sequence of\nlinked text frames), retrieves the first frame of the story.\n@param uidref The UID reference object,\n@param art [out] A buffer in which to return the art object."]
    pub GetReferencedArt: ::std::option::Option<
        unsafe extern "C" fn(uidref: AIUIDREFRef, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the UID name of an art object.\n@param art The art object.\n@param name [out] A buffer in which to return the name string, or\nthe empty string if no UID is assigned."]
    pub GetArtUIDName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Sets the UID name of an art object.\n@param art The art object.\n@param name The new name string.\n@return The \\c #kUIDNotUnique error if the named UID is already in use."]
    pub SetArtUIDName: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the name or XML identifier of an art object, depending on the setting of\nthe user preference \"Identify Object by: Object Name/XML ID\".\nIf the preference allows a user to enter arbitrary names,\nthey are internally translated to valid, unique, XML IDs. This\nfunction translates back to the name that was entered.\n@param art The art object.\n@param name [out] A buffer in which to return the name string.\n@param isDefaultName [out] A buffer in which to return the output as true if the\nart object has no name or UID, and the returned string is the default name."]
    pub GetArtNameOrUID: ::std::option::Option<
        unsafe extern "C" fn(
            art: AIArtHandle,
            name: *mut ai_UnicodeString,
            isDefaultName: *mut ASBoolean,
        ) -> AIErr,
    >,
    #[doc = " Sets the name or XML identifier of an art object, depending on the setting of\nthe user preference \"Identify Object by: Object Name/XML ID\".\n@param art The art object.\n@param name The newly named string. If the preference allows a user\nto enter arbitrary names, this can be any string, which is\ntranslated internally to a valid, unique, XML ID. Otherwise, it\nmust conform to XML ID syntax.\n"]
    pub SetArtNameOrUID: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, name: *const ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Creates a new UID reference based on an existing UID reference, by appending\na numeric suffix to make the name unique.\n@param base The base UID reference object.\n@param uid  [out] A buffer in which to return the new UID reference."]
    pub MakeUIDFromBase:
        ::std::option::Option<unsafe extern "C" fn(base: AIUIDRef, uid: *mut AIUIDRef) -> AIErr>,
    #[doc = " Creates a new name from a base name, by appending a numeric suffix to\nmake the name unique.\n@param base The base name string.\n@param name [out] A buffer in which to return the new name string."]
    pub MakeUniqueNameFromBase: ::std::option::Option<
        unsafe extern "C" fn(base: *const ai_UnicodeString, name: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the UID reference for the story associated with an art object.\n@param art The art object, of type \\c #AIArtType::kTextFrameArt.\n@param create True to generate and assign a new UID if the story has none.\n@param ruid\t[out] A buffer in which to return the UID reference object."]
    pub GetStoryUID: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, create: AIBoolean, ruid: *mut AIUIDRef) -> AIErr,
    >,
    #[doc = " Sets the UID reference for the story associated with an art object.\n@param art The art object, of type \\c #AIArtType::kTextFrameArt.\n@param ruid\tThe new UID reference object."]
    pub SetStoryUID:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, uid: AIUIDRef) -> AIErr>,
    #[doc = " Transfers the unique identifier from the story associated with a text art object\nto the story of another text art object. The UID of the source story is set to \\c NULL.\n@param srcart The source art object, of type \\c #AIArtType::kTextFrameArt.\n@param dstart The destination art object, of type \\c #AIArtType::kTextFrameArt."]
    pub TransferStoryUID: ::std::option::Option<
        unsafe extern "C" fn(srcart: AIArtHandle, dstart: AIArtHandle) -> AIErr,
    >,
    #[doc = " Creates a new UID reference for the story associated with an art object.\nPass this reference to \\c #GetReferencedArt() to retrieve the first\nframe of the story (regardless of which frame was used to create the\nreference).\n@param art The art object, of type \\c #AIArtType::kTextFrameArt.\n@param ruid\tThe new UID reference object."]
    pub NewStoryUIDREF: ::std::option::Option<
        unsafe extern "C" fn(art: AIArtHandle, uidref: *mut AIUIDREFRef) -> AIErr,
    >,
    #[doc = " Transfers the unique identifier from the story associated with a text art object\nto another art object of any type. The UID of the source story is set to \\c NULL.\n@param frame The source art object, of type \\c #AIArtType::kTextFrameArt.\n@param art The destination art object, of any type."]
    pub TransferStoryUIDToArt:
        ::std::option::Option<unsafe extern "C" fn(frame: AIArtHandle, art: AIArtHandle) -> AIErr>,
    #[doc = " Transfers the unique identifier from an art object of any type to the story associated\nwith a text art object. The UID of the source art object is set to \\c NULL.\n@param art The source art object, of any type.\n@param frame The destination art object, of type \\c #AIArtType::kTextFrameArt."]
    pub TransferArtUIDToStory:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, frame: AIArtHandle) -> AIErr>,
    #[doc = " Retrieves the source object from which an object being dragged and transformed was derived.\n@param target The unique identifier (UID) for the object being dragged.\n@param equiv [out] A buffer in which to return the UID of the source object for\nthe transformation, if found.\n@return \\c #kUIDNotFound error if the source object UID is not found in the current context."]
    pub FindEquivUID: ::std::option::Option<
        unsafe extern "C" fn(target: AIUIDRef, equiv: *mut AIUIDRef) -> AIErr,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAIArtboardProperties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAIArtboardList {
    _unused: [u8; 0],
}
#[doc = "\t@ingroup Suites\nThis suite provides utilities that allow you to create and manipulate\nArtboards in a document. A document is associated with an \\c ArtboardList object\nthat contains multiple \\c Artboard objects, each of which is associated with and\n\\c ArtboardProperties object.\n@note It is recommended that you use the wrapper class, \\c #ai::ArtboardProperties and \\c #ai::ArtboardList\nrather than calling these functions directly.\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIArtboardSuite and \\c #kAIArtboardSuiteVersion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIArtboardSuite {
    #[doc = " Initializes an artboard properties object with default values.\n@param artboard The artboard properties object."]
    pub Init:
        ::std::option::Option<unsafe extern "C" fn(artboard: *mut ai_ArtboardProperties) -> AIErr>,
    #[doc = " Duplicates an artboard object.\n@param artboard The artboard properties object to clone.\n@param newArtboard [out] A buffer in which to return the new artboard properties object."]
    pub CloneArtboard: ::std::option::Option<
        unsafe extern "C" fn(
            artboard: *mut ai_ArtboardProperties,
            newArtboard: *const ai_ArtboardProperties,
        ) -> AIErr,
    >,
    #[doc = "Disposes of an artboard properties object.\n@param artboard The artboard properties object."]
    pub Dispose: ::std::option::Option<
        unsafe extern "C" fn(properties: *mut ai_ArtboardProperties) -> AIErr,
    >,
    #[doc = " Retrieves the position and bounds of an artboard.\n@param properties The artboard properties object.\n@param bounds [out] A rectangle object in which to return the position and bounds of the artboard."]
    pub GetPosition: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            bounds: *mut AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Modifies the position and bounds of an artboard.\nCall \\c #AIArtboardSuite::Update() with this object to make the change.\n@param properties The artboard properties object.\n@param bounds The new position and bounds."]
    pub SetPosition: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *mut ai_ArtboardProperties,
            bounds: *const AIRealRect,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the pixel aspect ratio of the artboard ruler.\n@param properties The artboard properties object.\n@param par [out] A buffer in which to return the pixel aspect ratio."]
    pub GetPAR: ::std::option::Option<
        unsafe extern "C" fn(properties: *const ai_ArtboardProperties, par: *mut AIReal) -> AIErr,
    >,
    #[doc = " Modifies the pixel aspect ratio of the artboard ruler.\nCall \\c #AIArtboardSuite::Update() with this object to make the change.\n@param properties The artboard properties object.\n@param  par The new pixel aspect ratio."]
    pub SetPAR: ::std::option::Option<
        unsafe extern "C" fn(properties: *mut ai_ArtboardProperties, par: AIReal) -> AIErr,
    >,
    pub GetName: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            name: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    pub SetName: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *mut ai_ArtboardProperties,
            name: *const ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Reports whether a particular type of artboard annotation is currently shown.\n@param properties The artboard properties object.\n@param  type The annotation type.\n@param\tshow A buffer in which to return true if the type is shown, false if it is hidden."]
    pub GetShowDisplayMark: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            type_: ai_ArtboardProperties_DisplayMarkType,
            show: *mut AIBoolean,
        ) -> AIErr,
    >,
    pub SetShowDisplayMark: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *mut ai_ArtboardProperties,
            type_: ai_ArtboardProperties_DisplayMarkType,
            show: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the artboard list of the current document.\n@param artboardList [out] A buffer in which to return the artboard list object."]
    pub GetArtboardList:
        ::std::option::Option<unsafe extern "C" fn(artboardList: *mut ai_ArtboardList) -> AIErr>,
    #[doc = " Releases an artboard list object.\n@param artboardList The artboard list object."]
    pub ReleaseArtboardList:
        ::std::option::Option<unsafe extern "C" fn(artboardList: *mut ai_ArtboardList) -> AIErr>,
    #[doc = " Adds a new artboard to the current document and reports its index position in the artboard list.\n@param artboardList The artboard list object.\n@param newArtboard The new artboard's properties object.\n@param index [out] A buffer in which to return the 0-based index position of the new artboard.\n@return  The error \\c #kAIExceededMaxArtboardLimitErr if list size exceeds the application-defined limit."]
    pub AddNew: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            newArtboard: *mut ai_ArtboardProperties,
            index: *mut ai_ArtboardID,
        ) -> AIErr,
    >,
    #[doc = " Deletes an artboard from an artboard list, and makes the next one in the list active.\nThe last artboard cannot be deleted.\n@param artboardList The artboard list object.\n@param index The 0-based index position of the artboard to delete from the list.\n@return The error \\c #kAICantDeleteLastArtboardErr if you attempt to delete the last artboard."]
    pub Delete: ::std::option::Option<
        unsafe extern "C" fn(artboardList: *mut ai_ArtboardList, index: ai_ArtboardID) -> AIErr,
    >,
    #[doc = " Retrieves the number of artboards defined in an artboard list.\n@param artboardList The artboard list object.\n@param count [out] A buffer in which to return the number of artboards."]
    pub GetCount: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *const ai_ArtboardList,
            count: *mut ai_ArtboardID,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the index position of the active artboard in the document's list.\n@param artboardList The artboard list object.\n@param index [out] A buffer in which to return the 0-based index of the active artboard, or\n-1 if there are no artboards in the current document."]
    pub GetActive: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *const ai_ArtboardList,
            index: *mut ai_ArtboardID,
        ) -> AIErr,
    >,
    #[doc = " Makes a specific artboard active, and makes it current in the iteration order.\n@param artboardList The artboard list object.\n@param index The 0-based index position of the artboard in the list."]
    pub SetActive: ::std::option::Option<
        unsafe extern "C" fn(artboardList: *mut ai_ArtboardList, index: ai_ArtboardID) -> AIErr,
    >,
    #[doc = " Updates the properties of an artboard. Use with \\c #GetCount() and \\c #GetArtboardProperties()\nto modify the artboard without changing which artboard is active in the document.\n@param artboardList The artboard list object.\n@param index The 0-based index position of the artboard in the document list.\n@param properties The object containing the new artboard properties."]
    pub Update: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            index: ai_ArtboardID,
            properties: *const ai_ArtboardProperties,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the properties of an artboard from an artboard list.\nUse with \\c #GetCount() and \\c #Update() to modify an artboard without\nchanging which artboard is active in the document.\n@param artboardList The artboard list object.\n@param index The 0-based index position of the artboard in the list.\n@param properties [out]\tA buffer in which to return\tthe artboard properties object.\nOn error, returns an invalid object"]
    pub GetArtboardProperties: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            index: ai_ArtboardID,
            properties: *mut ai_ArtboardProperties,
        ) -> AIErr,
    >,
    #[doc = " Retrieves the ruler origin of an artboard, relative to left-bottom corner.\n@param properties The artboard properties object.\n@param rulerOrigin [out] A buffer in which to return ruler origin."]
    pub GetRulerOrigin: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            rulerOrigin: *mut AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Sets the ruler origin of the artboard, relative to left-bottom corner.\n@param properties The artboard properties object.\n@param rulerOrigin The new ruler origin."]
    pub SetRulerOrigin: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *mut ai_ArtboardProperties,
            rulerOrigin: *const AIRealPoint,
        ) -> AIErr,
    >,
    #[doc = " Inserts a new Artboard at the specified location.\n@param artboardList The ArtboardList object.\n@param artboard The new artboard's properties.\n@param index 0-based index position of the new artboard.\n@return The error \\c #kAIExceededMaxArtboardLimitErr if maximum number of allowed artboards is exceeded.\nNote : It will override the UUID in artboardProperties. In case you want to preserve the UUID in artboard properties use \\c #InsertUsingArtboardPropertiesUUID()"]
    pub Insert: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboard: *mut ai_ArtboardProperties,
            index: *mut ai_ArtboardID,
        ) -> AIErr,
    >,
    #[doc = " Reports whether an artboard's current name is application-generated. When this is the case,\nand the user chooses to export art as JPEG, and to save artboards as separate files, the files\nare distinguished only by number, rather than the full generated name; for example, myArt-01.jpg.\nWhen an artboard name has been explicitly set, that name is used in the exported JPEG filename.\n\n@param properties The artboard properties object.\n@param isDefault A buffer in which to return true if the name is generated, false\nif it has been explicitly set."]
    pub IsDefaultName: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            isDefault: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Internal. Do not use."]
    pub SetIsDefaultName: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *mut ai_ArtboardProperties,
            isDefault: *const AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Query artboard selection\n@param properties\t\tThe artboard properties object.\n@param isSelected [out]\tA buffer in which to return the selection"]
    pub IsSelected: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            isSelected: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Select one artboard\n@param artboardList\t\tThe ArtboardList object.\n@param artboardID\t\tThe artboard to select.\n@param exclusively\t\tif true, clear existing selection first."]
    pub SelectArtboard: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboardID: ai_ArtboardID,
            exclusively: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Select multiple artboards\n@param artboardList\t\tThe ArtboardList object.\n@param artboardIDs\t\tThe artboards to select.\n@param exclusively\t\tif true, clear existing selection first."]
    pub SelectArtboards: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboardIDs: *const ai_AutoBuffer<ai_ArtboardID, ::std::os::raw::c_ulong>,
            exclusively: AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Select all artboards\n@param artboardList\t\tThe ArtboardList object."]
    pub SelectAllArtboards:
        ::std::option::Option<unsafe extern "C" fn(artboardList: *mut ai_ArtboardList) -> AIErr>,
    #[doc = " Delete set of artboards\n@param artboardList\t\tThe ArtboardList object.\n@param artboardIDs\t\tThe artboards to delete."]
    pub DeleteArtboards: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboardIDs: *const ai_AutoBuffer<ai_ArtboardID, ::std::os::raw::c_ulong>,
        ) -> AIErr,
    >,
    #[doc = " Deselect an artboard\n@param artboardList\t\tThe ArtboardList object.\n@param artboardID\t\tThe artboard to de-select."]
    pub DeselectArtboard: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboardID: ai_ArtboardID,
        ) -> AIErr,
    >,
    #[doc = " Deselect all artboards\n@param artboardList\t\tThe ArtboardList object."]
    pub DeselectAllArtboards:
        ::std::option::Option<unsafe extern "C" fn(artboardList: *mut ai_ArtboardList) -> AIErr>,
    pub AreAnyArtboardsOverlapping: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            isOverlapping: *mut AIBoolean,
        ) -> AIErr,
    >,
    #[doc = " Retrieves Artboard UUID as Unicode String\n@param properties       The artboard properties to retrieve from.\n@param uuid             The uuid to fetch."]
    pub GetUUIDAsString: ::std::option::Option<
        unsafe extern "C" fn(
            properties: *const ai_ArtboardProperties,
            uuid: *mut ai_UnicodeString,
        ) -> AIErr,
    >,
    #[doc = " Inserts a new Artboard at the specified location using the UUID in artboard properties.\n@param artboardList The ArtboardList object.\n@param artboard The new artboard's properties.\n@param index 0-based index position of the new artboard.\n@return The error \\c #kAIExceededMaxArtboardLimitErr if maximum number of allowed artboards is exceeded."]
    pub InsertUsingArtboardPropertiesUUID: ::std::option::Option<
        unsafe extern "C" fn(
            artboardList: *mut ai_ArtboardList,
            artboard: *mut ai_ArtboardProperties,
            index: *mut ai_ArtboardID,
        ) -> AIErr,
    >,
}
#[doc = "\tSuite\n\n/\n/** @ingroup Suites\nThis suite is in an experimental state, it is not completely production-ready.\nThese functions allow you to interact with the UUID and associated art\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAIUUIDSuite and \\c #kAIUUIDVersion.\n@see \\c #ai::uuid"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIUUIDSuite {
    #[doc = " Retrieves the art object associated with the UUID, if the art\nis in-scope.\n@param _uuid [in] const reference of UUID of art object.\n@param art [out] A buffer in which to return the output as the valid art object,\nor a null pointer if the art object has been deleted or\nmoved out of scope.\nThis API may fail to provide the correct ArtHandle, if an object's dictionary is acquired\nbut not released after use. (It is not recommended to acquire and hold the dictionary reference\nfor future use)"]
    pub GetArtHandle: ::std::option::Option<
        unsafe extern "C" fn(_uuid: *const ai_uuid, art: *mut AIArtHandle) -> AIErr,
    >,
    #[doc = " Retrieves the UUID associated with the art.\n@param art [in] The art object.\n@param _uuid [out] Reference variable to return the UUID of the art object."]
    pub GetArtUUID:
        ::std::option::Option<unsafe extern "C" fn(art: AIArtHandle, _uuid: *mut ai_uuid) -> AIErr>,
    #[doc = " Retrieves the UnicodeString representation of the UUID.\n@param _uuid [in] Const reference of the UUID from which UnicodeString need to be created.\n@param uStr [out] Reference variable in which to return the UnicodeString representation\nof UUID."]
    pub UUIDToString: ::std::option::Option<
        unsafe extern "C" fn(_uuid: *const ai_uuid, uStr: *mut ai_UnicodeString) -> AIErr,
    >,
    #[doc = " Retrieves the UUID object by creating it from the UnicodeString.\n@param uStr [in] UnicodeString from which the UUID needs to be created.\n@param _uuid [out] Reference variable in which to return the UUID object created from the\nUnicodeString."]
    pub StringToUUID: ::std::option::Option<
        unsafe extern "C" fn(uStr: *const ai_UnicodeString, _uuid: *mut ai_uuid) -> AIErr,
    >,
    #[doc = " Generates new unique UUID.\n@param _uuid [out] Reference variable in which the new generated uuid object is returned*"]
    pub GenerateNewUUID: ::std::option::Option<unsafe extern "C" fn(_uuid: *mut ai_uuid) -> AIErr>,
}
pub const AIDecimalPrecisionType_kValue: AIDecimalPrecisionType = 0;
pub const AIDecimalPrecisionType_kDimension: AIDecimalPrecisionType = 1;
pub const AIDecimalPrecisionType_kType: AIDecimalPrecisionType = 2;
pub const AIDecimalPrecisionType_kScale: AIDecimalPrecisionType = 3;
pub const AIDecimalPrecisionType_kArtboardSize: AIDecimalPrecisionType = 4;
pub const AIDecimalPrecisionType_kPercentage: AIDecimalPrecisionType = 5;
pub const AIDecimalPrecisionType_kColor: AIDecimalPrecisionType = 6;
pub const AIDecimalPrecisionType_kAngle: AIDecimalPrecisionType = 7;
pub const AIDecimalPrecisionType_kResolution: AIDecimalPrecisionType = 8;
pub const AIDecimalPrecisionType_kStroke: AIDecimalPrecisionType = 9;
#[doc = "\t@ingroup Suites\nThis suite provides utilities that allow you to get the Limits .\n\n\\li Acquire this suite using \\c #SPBasicSuite::AcquireSuite() with the constants\n\\c #kAILimitsSuite and \\c #kAILimitsSuiteVersion."]
pub type AIDecimalPrecisionType = ai_uint16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILimitsSuite {
    #[doc = " Retrieves the size of the canvas.\n(Note that this function returns a constant value, not an error code.)\n@return The canvas size (assuming square canvas)"]
    pub GetCanvasSize: ::std::option::Option<unsafe extern "C" fn() -> ai_int32>,
    #[doc = " Returns the default large canvas scaling, compared to the regular canvas size.\n(Note that this function returns a constant value, not an error code.)"]
    pub GetLargeCanvasScale: ::std::option::Option<unsafe extern "C" fn() -> AIReal>,
    pub GetDecimalPrecision:
        ::std::option::Option<unsafe extern "C" fn(type_: AIDecimalPrecisionType) -> ai_int32>,
    pub GetMinTransformDimensionValue: ::std::option::Option<unsafe extern "C" fn() -> AIReal>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPPlugin {
    _unused: [u8; 0],
}
#[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPSuiteList {
    pub _address: u8,
}
#[doc = " For \\c #kSPAdaptersAcquireSuiteHostSelector and \\c #kSPAdaptersReleaseSuiteHostSelector.\nNo longer used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPSuite {
    pub _address: u8,
}
pub type self_type = ai_UnicodeString_const_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AIDictionary {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilePathImpl {
    pub _address: u8,
}
